<html><title>Programa&ccedil;&atilde;o din&acirc;mica</title><body>&#10;<p><b>Programa&ccedil;&atilde;o din&acirc;mica</b> &eacute; um m&eacute;todo para a constru&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmos</a> para a resolu&ccedil;&atilde;o de problemas computacionais, em especial os de <a href="http://en.wikipedia.org/wiki/Otimiza%C3%A7%C3%A3o_combinat%C3%B3ria" id="w">otimiza&ccedil;&atilde;o combinat&oacute;ria</a>. <sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup>Ela &eacute; aplic&aacute;vel a problemas nos quais a solu&ccedil;&atilde;o &oacute;tima pode ser computada a partir da solu&ccedil;&atilde;o &oacute;tima previamente calculada e memorizada &shy; de forma a evitar rec&aacute;lculo &shy; de outros subproblemas que, sobrepostos, comp&otilde;em o problema original.</p>&#10;<p>O que um problema de otimiza&ccedil;&atilde;o deve ter para que a <b>programa&ccedil;&atilde;o din&acirc;mica</b> seja aplic&aacute;vel s&atilde;o duas principais caracter&iacute;sticas: subestrutura &oacute;tima e superposi&ccedil;&atilde;o de subproblemas. Um problema apresenta uma subestrutura &oacute;tima quando uma solu&ccedil;&atilde;o &oacute;tima para o problema cont&eacute;m em seu interior solu&ccedil;&otilde;es &oacute;timas para subproblemas. A superposi&ccedil;&atilde;o de subproblemas acontece quando um algoritmo recursivo reexamina o mesmo problema muitas vezes.</p>&#10;<a id="Exemplo_Sequ%C3%AAncia_de_Fibonacci" name="Exemplo_Sequ%C3%AAncia_de_Fibonacci"></a><h2> Exemplo Sequ&ecirc;ncia de Fibonacci</h2>&#10;<p>Como exemplo simples de programa&ccedil;&atilde;o din&acirc;mica, com alguma frequ&ecirc;ncia, alguns textos, utilizam a determina&ccedil;&atilde;o da <a href="http://en.wikipedia.org/wiki/Sequ%C3%AAncia_de_Fibonacci" id="w">Sequ&ecirc;ncia de Fibonacci</a>, quando implementada de forma recursiva. Isso porque quando a forma recursiva &eacute; implementada sem maiores cuidados, sem memoriza&ccedil;&atilde;o, o seu c&aacute;lculo de tempo cresce exponencialmente.</p>&#10;<p>Observe que, a rigor, esse caso n&atilde;o &eacute; um problema de programa&ccedil;&atilde;o din&acirc;mica, visto que o c&aacute;lculo do n&shy;&eacute;simo n&uacute;mero de Fibonacci cresce linearmente, e n&atilde;o exponencialmente. Por&eacute;m, este exemplo ainda assim &eacute; utilizado devido &agrave; sua simplicidade.</p>&#10;<p><span class="math">F(n)=\left\lbrace&#10;\begin{matrix}&#10;1 & \text{se } n\leq 1 \\&#10;F(n&shy;1) + F(n&shy;2) & \text{caso contr&aacute;rio} \end{matrix}&#10;\right\rbrace</span></p>&#10;<p>Quando implementada de forma recursiva &#34&semi;ing&ecirc;nua&#34&semi; (<i>na&iuml;ve</i>), sem memoriza&ccedil;&atilde;o, a dupla chamada a F na segunda linha causa a necessidade da repeti&ccedil;&atilde;o de c&aacute;lculos, que cresce exponencialmente.</p>&#10;<a id="Exemplo_Multiplica%C3%A7%C3%A3o_de_Cadeia_de_Matrizes_%3Cref%3E%7B%7Bcitar_livro%7D%7D%3C/ref%3E" name="Exemplo_Multiplica%C3%A7%C3%A3o_de_Cadeia_de_Matrizes_%3Cref%3E%7B%7Bcitar_livro%7D%7D%3C/ref%3E"></a><h2> Exemplo Multiplica&ccedil;&atilde;o de Cadeia de Matrizes &#60&semi;ref&#62&semi; &#60&semi;/ref&#62&semi;</h2>&#10;&#10;<p>Imaginemos o processo de multiplica&ccedil;&atilde;o de <span class="math">n</span> <a href="http://en.wikipedia.org/wiki/Matriz" id="w">matrizes</a> <span class="math">M = M_1 \times M_2 \times \ldots \times M_n</span> com <a href="http://en.wikipedia.org/wiki/Dimens%C3%B5es" id="w">dimens&otilde;es</a> <span class="math">m_0 \times m_1, m_1 \times m_2, \dotsc , m_{n&shy;1} \times m_n</span>, respectivamente. O problema em ess&ecirc;ncia &eacute; trivial, pois se multiplicarmos sequencialmente as matrizes obteremos facilmente o resultado esperado. </p>&#10;<p>&Eacute; interessante lembrar que a multiplica&ccedil;&atilde;o de matrizes n&atilde;o &eacute; comutativa (em geral, <span class="math">A \times B \neq B \times A</span>), mas associativa, o que significa que <span class="math">A \times (B \times C) = (A \times B) \times C</span>.</p>&#10;<p>O maior desafio que reside neste problema &eacute;, ent&atilde;o, otimizar o desempenho do programa que o resolve, ou seja, aproveitar&shy;se da propriedade associativa para encontrar a ordem &oacute;tima de se realizar a multiplica&ccedil;&atilde;o das matrizes, de modo que o n&uacute;mero de multiplica&ccedil;&otilde;es escalares seja m&iacute;nimo.</p>&#10;<p>Podemos observar que, em geral, multiplicar uma matriz <span class="math">m \times n</span> por uma matriz <span class="math">n \times p</span> exige <span class="math">m \times n \times p</span> opera&ccedil;&otilde;es de multiplica&ccedil;&atilde;o. As matrizes s&atilde;o multiplicadas aos pares.</p>&#10;<a id="Problema" name="Problema"></a><h3> Problema </h3>&#10;&#10;<p>Multiplicar <span class="math">M = M_1 \times M_2 \times M_3 \times M_4</span>  com dimens&otilde;es <span class="math">200 \times 2</span>, <span class="math">2 \times 30</span>, <span class="math">30 \times 20</span> e <span class="math">20 \times 5</span>, respectivamente. Quantas multiplica&ccedil;&otilde;es s&atilde;o realizadas nessa sequ&ecirc;ncia?</p>&#10;<p>Vamos exemplificar algumas maneiras de realizarmos esta opera&ccedil;&atilde;o:</p>&#10;<p><center>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table border="1">&#10;<tr>&#10;<td><b>Organiza&ccedil;&atilde;o dos par&ecirc;nteses</b> </td>&#10;<td><b>Computa&ccedil;&atilde;o do custo</b> </td>&#10;<td><b>Custo</b></td></tr>&#10;<tr>&#10;<td><span class="math">M_1 \times ((M_2 \times M_3) \times M_4)</span> </td>&#10;<td><span class="math">2 \times 30 \times 20 + 2 \times 20 \times 5 + 200 \times 2 \times 5</span> </td>&#10;<td><span class="math">3.400</span></td></tr>&#10;<tr>&#10;<td><span class="math">(M_1 \times (M_2 \times M_3)) \times M_4</span> </td>&#10;<td><span class="math">2 \times 30 \times 20 + 200 \times 2 \times 20 + 200 \times 20 \times 5</span> </td>&#10;<td><span class="math">29.200</span></td></tr>&#10;<tr>&#10;<td><span class="math">(M_1 \times M_2) \times (M_3 \times M_4)</span> </td>&#10;<td><span class="math">200 \times 2 \times 30 + 30 \times 20 \times 5 + 200 \times 30 \times 5</span> </td>&#10;<td><span class="math">45.000</span></td></tr></table></div>&#10;</center></p>&#10;<p>Como podemos observar, a ordem da multiplica&ccedil;&atilde;o faz uma grande diferen&ccedil;a no tempo de execu&ccedil;&atilde;o final. </p>&#10;<a id="Solu%C3%A7%C3%A3o" name="Solu%C3%A7%C3%A3o"></a><h4> Solu&ccedil;&atilde;o </h4>&#10;&#10;<p>Para resolver este problema, tudo que precisamos &eacute; saber qual o melhor &iacute;ndice <span class="math">k</span> tal que <span class="math">M = (M_1 \times M_2 \times \ldots \times M_k) \times (M_{k+1} \times M_{k+2} \times \ldots \times M_n)</span> onde <span class="math">k</span> varia de 1 at&eacute; (n&minus;1). </p>&#10;<p>Note que esse problema foi decomposto em dois subproblemas. Mais precisamente defina <span class="math">C(i, j)</span> como o n&uacute;mero m&iacute;nimo de multiplica&ccedil;&otilde;es (ou o custo m&iacute;nimo) para realizar o produto  <span class="math">M_i \times M_{i+1} \times \ldots \times M_j</span>.</p> &#10;<p>Portanto,&#10;</p><dl><dd><span class="math">C(i, j) = min \left\lbrace C(i,k) + C(k+1, j) + m_{i&shy;1} m_k m_j\right\rbrace</span>,</dd></dl>&#10;<p>onde <span class="math">k</span> varia de 1 at&eacute; (j &shy;1), fornece o custo m&iacute;nimo de multiplica&ccedil;&otilde;es. Da&iacute;, note que:</p>&#10;&#10;&#10;<ul>&#10;<li><span class="math">C(i, k) = M_{i} \times M_{i+1} \times \ldots \times M_{k}</span> &eacute; o n&uacute;mero m&iacute;nimo de opera&ccedil;&otilde;es para realizar de <span class="math">i</span> at&eacute; <span class="math">k</span>&semi;</li>&#10;<li><span class="math">C(k+1, j) = M_{k+1} \times M_{k+2} \times \ldots \times M_{j}</span> &eacute; o n&uacute;mero m&iacute;nimo de opera&ccedil;&otilde;es para realizar de <span class="math">(k+1)</span> at&eacute; <span class="math">j</span>&semi;</li>&#10;<li><span class="math">m_{i&shy;1}m_{k}m_{j}</span> &eacute; o n&uacute;mero m&iacute;nimo de opera&ccedil;&otilde;es para realizar esse produto.</li></ul>&#10;&#10;<p>Esta express&atilde;o constitui uma recorr&ecirc;ncia t&iacute;pica do m&eacute;todo de programa&ccedil;&atilde;o din&acirc;mica.  Ela sugere um <a href="http://en.wikipedia.org/wiki/Algoritmo_recursivo" id="w">algoritmo recursivo</a>, mas, uma implementa&ccedil;&atilde;o <i>&ldquo;bottom up&rdquo;</i> (de baixo para cima) &eacute; mais eficiente. Um algoritmo nesta f&oacute;rmula tem os seguintes passos iterativos: </p>&#10;&#10;<ol>&#10;<li>Os <span class="math">C(i,i)</span> s&atilde;o calculados para <span class="math">1 \leq i \leq n</span>. Claramente, <span class="math">C(i,i) = 0</span>&semi;</li>&#10;<li>Os <span class="math">C(i,i+1)</span> s&atilde;o calculados para <span class="math">1 \leq i \leq n&shy;1</span>&semi; </li>&#10;<li>Os <span class="math">C(i,i+2)</span> s&atilde;o calculados para <span class="math">1 \leq i \leq n&shy;2</span>&semi; e assim por diante</li></ol>&#10;<p>Assim, vamos aplicar o algoritmo acima para resolver o exemplo dado anteriormente. Observe que devemos calcular o custo m&iacute;nimo na ordem crescente da diferen&ccedil;a entre <span class="math">i</span> e <span class="math">j</span> . Ent&atilde;o, no primeiro passo iterativo, a diferen&ccedil;a entre <span class="math">i</span> e <span class="math">j</span> &eacute; zero, pois, <span class="math">i = j</span>, o que implica:</p>&#10;<dl><dd><span class="math">C(1,1) = C(2,2) = C(3,3) = C(4,4) = 0</span>.</dd></dl>&#10;<p>No segundo passo, temos <i>i &shy; j = 1</i>, logo, </p>&#10;<dl><dd><span class="math">C(1,2) = M_{1} \times M_{2} = 12000</span></dd></dl><dl><dd><span class="math">C(2,3) = M_{2} \times M_{3} = 1200</span></dd></dl><dl><dd><span class="math">C(3,4) = M_{3} \times M_{4} = 3000</span></dd></dl>&#10;<p>No terceiro passo, <i>j &shy; i = 2</i> e com isso, o <span class="math">k</span> varia de 1 a 2. Utilizando a f&oacute;rmula recursiva:</p>&#10;<dl><dd><span class="math">C(1,3) = min(C(1,1) + C(2, 3) + m_{0}m_{1}m_{3}&semi;</span> <span class="math">C(1,2) + C(3,3) + m_{0}m_{2}m_{3}) = min(9200&semi; 132000)</span></dd></dl>&#10;<p>Para  <span class="math">k</span> variando de 2 a 3 temos:</p>&#10;<dl><dd><span class="math">C(2,4) = min(C(2,2) + C(3, 4) + m_{1}m_{2}m_{4}&semi; C(2,3) + C(4,4) + m_{1}m_{3}m_{4}) = min (3300&semi; 1400)</span></dd></dl>&#10;<p>No &uacute;ltimo passo, <i>j &minus; i = 3</i> e com isso, o <span class="math">k = 1, 2, 3</span>. </p>&#10;<dl><dd><span class="math">C(1,4) = min (C(1,1) + C(2, 4) + m_{0}m_{1}m_{4}&semi; C(1,2) + C(3,4)  + m_{0}m_{2}m_{4}&semi; C(1,3) + C(4,4) + m_{0}m_{3}m_{4}) = min(3400&semi; 45000&semi; 29200)</span></dd></dl>&#10;<p>Por fim, a solu&ccedil;&atilde;o &oacute;tima: </p>&#10;<dl><dd><span class="math">M = (M_{1} \times ((M_{2} \times M_{3}) \times M_{4}) \to 3.400</span> opera&ccedil;&otilde;es.</dd></dl>&#10;<a id="Conclus%C3%A3o" name="Conclus%C3%A3o"></a><h4> Conclus&atilde;o </h4>&#10;&#10;<p>Tentar todas as ordens poss&iacute;veis de multiplica&ccedil;&otilde;es para avaliar o produto de <span class="math">n</span> matrizes &eacute; um processo ordem exponencial em <span class="math">n</span>.</p>&#10;<p>Usando programa&ccedil;&atilde;o din&acirc;mica &eacute; poss&iacute;vel resolver este problema na ordem polinimial, ou seja <span class="math">O(n^3)</span> .</p>&#10;<a id="Implementa%C3%A7%C3%A3o_em_Java" name="Implementa%C3%A7%C3%A3o_em_Java"></a><h3> Implementa&ccedil;&atilde;o em Java </h3>&#10;<p />&#10;&#10;<a id="Refer%C3%AAncias_Bibliograficas" name="Refer%C3%AAncias_Bibliograficas"></a><h2> Refer&ecirc;ncias Bibliograficas </h2>&#10;<p /><ol class="references">&#10;<li id="_note&shy;1"><b><a href="#_ref&shy;1" title="">&uarr&semi;</a></b>  </li></ol><a id="Links_externos" name="Links_externos"></a><h2>Links externos</h2>&#10;&#10;<ul>&#10;<li>Implementa&ccedil;&atilde;o dos <a href="http://en.wikipedia.org/wiki/Algoritmos" id="w">Algoritmos</a> em <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_din%C3%A2mica" id="w">Programa&ccedil;&atilde;o din&acirc;mica</a> na <a href="http://en.wikipedia.org/wiki/Plataforma_Java" id="w">Plataforma Java</a>.<a class="externallink" href="http://www.github.com/FilomenaAlves/projetoMatrizes" rel="nofollow" title="http://www.github.com/FilomenaAlves/projetoMatrizes">github</a></li></ul>&#10;<a id="Veja_tamb%C3%A9m" name="Veja_tamb%C3%A9m"></a><h2> Veja tamb&eacute;m  </h2>&#10;&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Problema_da_mochila" id="w">Problema da Mochila</a></li>&#10;<li><a class="externallink" href="http://en.wikipedia.org/wiki/Matrix_chain_multiplication" rel="nofollow" title="http://en.wikipedia.org/wiki/Matrix_chain_multiplication">Matrix Chain Multiplication</a></li>&#10;<li><a class="externallink" href="http://en.wikipedia.org/wiki/Dynamic_programming" rel="nofollow" title="http://en.wikipedia.org/wiki/Dynamic_programming">Dynamic Programming</a></li>&#10;<li><a class="externallink" href="http://en.wikipedia.org/wiki/Greedy_algorithm" rel="nofollow" title="http://en.wikipedia.org/wiki/Greedy_algorithm">Greedy Algorithm</a></li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos_de_otimiza%C3%A7%C3%A3o" id="w">Categoria:Algoritmos de otimiza&ccedil;&atilde;o</a></p></body></html>