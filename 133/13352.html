<html><title>Linguagem de programa&ccedil;&atilde;o</title><body>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:DeCSS.PNG%7Cthumb%7C300px%7CTrecho_de_programa_na_linguagem_de_programa%C3%A7%C3%A3o_%5B%5BC_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">C]].</a></p>&#10;<p>Uma <b>linguagem de programa&ccedil;&atilde;o</b> &eacute; um m&eacute;todo padronizado para comunicar <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_de_m%C3%A1quina" id="w">instru&ccedil;&otilde;es</a> para um <a href="http://en.wikipedia.org/wiki/Computador" id="w">computador</a>.<sup id="_ref&shy;dershem_a" class="reference"><a href="#_note&shy;dershem" title="">[1]</a></sup> &Eacute; um conjunto de <a href="http://en.wikipedia.org/wiki/Sintaxe" id="w">regras sint&aacute;ticas</a> e sem&acirc;nticas usadas para definir um <a href="http://en.wikipedia.org/wiki/Programa_de_computador" id="w">programa de computador</a>.<sup id="_ref&shy;fischer_a" class="reference"><a href="#_note&shy;fischer" title="">[2]</a></sup><sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup> Permite que um programador especifique precisamente sobre quais dados um computador vai atuar, como estes dados ser&atilde;o armazenados ou transmitidos e quais a&ccedil;&otilde;es devem ser tomadas sob v&aacute;rias circunst&acirc;ncias. Linguagens de programa&ccedil;&atilde;o podem ser usadas para expressar <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmos</a> com precis&atilde;o.</p>&#10;<p>O conjunto de palavras (<i>lexemas</i> classificados em <i>tokens</i>), compostos de acordo com essas regras, constituem o <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_fonte" id="w">c&oacute;digo fonte</a> de um <a href="http://en.wikipedia.org/wiki/Software" id="w">software</a>.<sup id="_ref&shy;aho_a" class="reference"><a href="#_note&shy;aho" title="">[4]</a></sup> Esse c&oacute;digo fonte &eacute; depois traduzido para <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_de_m%C3%A1quina" id="w">c&oacute;digo de m&aacute;quina</a>, que &eacute; executado pelo <a href="http://en.wikipedia.org/wiki/Processador" id="w">processador</a>.<sup id="_ref&shy;aho_b" class="reference"><a href="#_note&shy;aho" title="">[4]</a></sup></p>&#10;<p>Uma das principais metas das linguagens de programa&ccedil;&atilde;o &eacute; permitir que programadores tenham uma maior produtividade, permitindo expressar suas inten&ccedil;&otilde;es mais facilmente do que quando comparado com a linguagem que um computador entende nativamente (c&oacute;digo de m&aacute;quina).<sup id="_ref&shy;melo_a" class="reference"><a href="#_note&shy;melo" title="">[5]</a></sup> Assim, linguagens de programa&ccedil;&atilde;o s&atilde;o projetadas para adotar uma sintaxe de n&iacute;vel mais alto, que pode ser mais facilmente entendida por programadores humanos. Linguagens de programa&ccedil;&atilde;o s&atilde;o ferramentas importantes para que <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_de_computadores" id="w">programadores</a> e <a href="http://en.wikipedia.org/wiki/Engenharia_de_software" id="w">engenheiros de software</a> possam escrever programas mais organizados e com maior rapidez.</p>&#10;<p>Linguagens de programa&ccedil;&atilde;o tamb&eacute;m tornam os programas menos dependentes de computadores ou ambientes computacionais espec&iacute;ficos (propriedade chamada de portabilidade<sup id="_ref&shy;van_a" class="reference"><a href="#_note&shy;van" title="">[6]</a></sup>). Isto acontece porque programas escritos em linguagens de programa&ccedil;&atilde;o s&atilde;o traduzidos para o c&oacute;digo de m&aacute;quina do computador no qual ser&aacute; executado em vez de ser diretamente executado. Uma meta ambiciosa do <a href="http://en.wikipedia.org/wiki/Fortran" id="w">Fortran</a>, uma das primeiras linguagens de programa&ccedil;&atilde;o, era esta independ&ecirc;ncia da m&aacute;quina onde seria executada.<sup id="_ref&shy;7" class="reference"><a href="#_note&shy;7" title="">[7]</a></sup><sup id="_ref&shy;ieee_a" class="reference"><a href="#_note&shy;ieee" title="">[8]</a></sup></p>&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2> Hist&oacute;ria </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Ada_Lovelace_portrait.jpg%7Cthumb%7Cleft" id="w">[[Ada Lovelace]] em [[1840]].</a>&#10;<a href="http://en.wikipedia.org/wiki/Imagem:Grace_Hopper.jpg%7Cthumb" id="w">[[Grace Hopper]] em [[1984]].</a>&#10;O primeiro trabalho de linguagem de programa&ccedil;&atilde;o foi criado por <a href="http://en.wikipedia.org/wiki/Ada_Lovelace" id="w">Ada Lovelace</a>, grande amiga de <a href="http://en.wikipedia.org/wiki/Charles_Babbage" id="w">Charles Babbage</a>.<sup id="_ref&shy;ada_a" class="reference"><a href="#_note&shy;ada" title="">[9]</a></sup> O projeto da primeira calculadora mec&acirc;nica program&aacute;vel foi idealizado por <a href="http://en.wikipedia.org/wiki/Charles_Babbage" id="w">Charles Babbage</a><sup id="_ref&shy;breton_a" class="reference"><a href="#_note&shy;breton" title="">[10]</a></sup> que, ap&oacute;s gastar fortunas e um longo tempo, n&atilde;o conseguiu concretizar o projeto.<sup id="_ref&shy;gonick_a" class="reference"><a href="#_note&shy;gonick" title="">[11]</a></sup> A linguagem de programa&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/ADA" id="w">ADA</a> foi batizada em homenagem a esta primeira programadora.<sup id="_ref&shy;smith_a" class="reference"><a href="#_note&shy;smith" title="">[12]</a></sup></p>&#10;<p>Uma das primeiras linguagens de programa&ccedil;&atilde;o para computadores foi provavelmente <a href="http://en.wikipedia.org/wiki/Plankalk%C3%BCl" id="w">Plankalk&uuml;l</a>, criada por <a href="http://en.wikipedia.org/wiki/Konrad_Zuse" id="w">Konrad Zuse</a> na <a href="http://en.wikipedia.org/wiki/Alemanha_Nazista" id="w">Alemanha Nazista</a>,<sup id="_ref&shy;zuse_a" class="reference"><a href="#_note&shy;zuse" title="">[13]</a></sup> mas que teve pouco ou nenhum impacto no futuro das linguagens de programa&ccedil;&atilde;o.</p>&#10;<p>O primeiro compilador foi escrito por <a href="http://en.wikipedia.org/wiki/Grace_Hopper" id="w">Grace Hopper</a>,<sup id="_ref&shy;14" class="reference"><a href="#_note&shy;14" title="">[14]</a></sup> em 1952, para a linguagem de programa&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/Sistema_A&shy;0" id="w">A&shy;0</a>.<sup id="_ref&shy;wexel_a" class="reference"><a href="#_note&shy;wexel" title="">[15]</a></sup> A primeira linguagem de programa&ccedil;&atilde;o de alto n&iacute;vel amplamente usada foi <a href="http://en.wikipedia.org/wiki/Fortran" id="w">Fortran</a>, criada em 1954.<sup id="_ref&shy;hctc_a" class="reference"><a href="#_note&shy;hctc" title="">[16]</a></sup><sup id="_ref&shy;wexel_b" class="reference"><a href="#_note&shy;wexel" title="">[15]</a></sup> Em 1957 foi criada <a href="http://en.wikipedia.org/wiki/B&shy;0" id="w">B&shy;0</a>, sucessora da A&shy;0, que daria origem a <a href="http://en.wikipedia.org/wiki/Flow&shy;Matic" id="w">Flow&shy;Matic</a> (1958), antecessor imediato de <a href="http://en.wikipedia.org/wiki/COBOL" id="w">COBOL</a>, de 1959.<sup id="_ref&shy;cobol_a" class="reference"><a href="#_note&shy;cobol" title="">[17]</a></sup> O COBOL foi uma linguagem de ampla aceita&ccedil;&atilde;o para uso comercial.<sup id="_ref&shy;cobol_b" class="reference"><a href="#_note&shy;cobol" title="">[17]</a></sup> A linguagem <a href="http://en.wikipedia.org/wiki/ALGOL" id="w">ALGOL</a> foi criada em 1958&shy;1960<sup id="_ref&shy;algol_a" class="reference"><a href="#_note&shy;algol" title="">[18]</a></sup> O ALGOL&shy;60 teve grande influ&ecirc;ncia no projeto de muitas linguagens posteriores.<sup id="_ref&shy;algol2_a" class="reference"><a href="#_note&shy;algol2" title="">[19]</a></sup></p>&#10;<p>A linguagem <a href="http://en.wikipedia.org/wiki/Lisp" id="w">Lisp</a> foi criada em <a href="http://en.wikipedia.org/wiki/1958" id="w">1958</a> e se tornou amplamente utilizada na pesquisa na &aacute;rea de <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">ci&ecirc;ncia da computa&ccedil;&atilde;o</a> mais proeminentemente na &aacute;rea de <a href="http://en.wikipedia.org/wiki/Intelig%C3%AAncia_Artificial" id="w">Intelig&ecirc;ncia Artificial</a>.<sup id="_ref&shy;pratt_a" class="reference"><a href="#_note&shy;pratt" title="">[20]</a></sup> Outra linguagem relacionada ao campo da IA que surge em 1972 &eacute; a linguagem <a href="http://en.wikipedia.org/wiki/Prolog" id="w">Prolog</a>, uma linguagem do paradigma l&oacute;gico.<sup id="_ref&shy;prolog_a" class="reference"><a href="#_note&shy;prolog" title="">[21]</a></sup></p>&#10;<p>A <a href="http://en.wikipedia.org/wiki/Orienta%C3%A7%C3%A3o_a_objetos" id="w">orienta&ccedil;&atilde;o a objetos</a> &eacute; outro marco importante na hist&oacute;ria das linguagens de programa&ccedil;&atilde;o. A linguagem <a href="http://en.wikipedia.org/wiki/Simula_67" id="w">Simula 67</a> introduz o conceito de classes.<sup id="_ref&shy;horowitz_a" class="reference"><a href="#_note&shy;horowitz" title="">[22]</a></sup> A linguagem <a href="http://en.wikipedia.org/wiki/Smalltalk" id="w">Smalltalk</a><sup id="_ref&shy;goldberg_a" class="reference"><a href="#_note&shy;goldberg" title="">[23]</a></sup><sup id="_ref&shy;lewis_a" class="reference"><a href="#_note&shy;lewis" title="">[24]</a></sup>  expande o conceito de classes e se torna a primeira linguagem de programa&ccedil;&atilde;o que oferecia suporte completo &agrave; programa&ccedil;&atilde;o orientada a objetos.<sup id="_ref&shy;sebesta_a" class="reference"><a href="#_note&shy;sebesta" title="">[25]</a></sup> A linguagem <a href="http://en.wikipedia.org/wiki/C%2B%2B" id="w">C++</a> (originalmente conhecida como C com classes) populariza a orienta&ccedil;&atilde;o a objetos.<sup id="_ref&shy;schildt_a" class="reference"><a href="#_note&shy;schildt" title="">[26]</a></sup></p>&#10;<p>Diversas linguagens de programa&ccedil;&atilde;o surgiram desde ent&atilde;o. Entre estas incluem&shy;se <a href="http://en.wikipedia.org/wiki/C%E2%99%AF" id="w">C&#9839;</a>,<sup id="_ref&shy;liberty_a" class="reference"><a href="#_note&shy;liberty" title="">[27]</a></sup>  <a href="http://en.wikipedia.org/wiki/VB.NET" id="w">VB.NET</a>, <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_Java" id="w">Java</a>, <a href="http://en.wikipedia.org/wiki/Object_Pascal" id="w">Object Pascal</a>, <a href="http://en.wikipedia.org/wiki/Objective&shy;C" id="w">Objective&shy;C</a>, <a href="http://en.wikipedia.org/wiki/PHP" id="w">PHP</a>, <a href="http://en.wikipedia.org/wiki/Python" id="w">Python</a>,<sup id="_ref&shy;Lutz_a" class="reference"><a href="#_note&shy;Lutz" title="">[28]</a></sup> <a href="http://en.wikipedia.org/wiki/SuperCollider" id="w">SuperCollider</a>, <a href="http://en.wikipedia.org/wiki/D_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">linguagem D</a> <sup id="_ref&shy;29" class="reference"><a href="#_note&shy;29" title="">[29]</a></sup>e <a href="http://en.wikipedia.org/wiki/Ruby_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Ruby</a>.<sup id="_ref&shy;thomas_a" class="reference"><a href="#_note&shy;thomas" title="">[30]</a></sup><sup id="_ref&shy;31" class="reference"><a href="#_note&shy;31" title="">[31]</a></sup></p>&#10;<a id="Interpreta%C3%A7%C3%A3o_e_compila%C3%A7%C3%A3o" name="Interpreta%C3%A7%C3%A3o_e_compila%C3%A7%C3%A3o"></a><h2> Interpreta&ccedil;&atilde;o e compila&ccedil;&atilde;o </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Nt&shy;compilador.png%7Cthumb%7Cesquerda%7C100px" id="w">O processo da compila&ccedil;&atilde;o.</a>&#10;Uma linguagem de programa&ccedil;&atilde;o pode ser convertida, ou traduzida, em c&oacute;digo de m&aacute;quina por <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compila&ccedil;&atilde;o</a> ou interpretada por um processo denominado <a href="http://en.wikipedia.org/wiki/Interpretadores" id="w">interpreta&ccedil;&atilde;o</a>. Em ambas ocorre a <b>tradu&ccedil;&atilde;o</b> do c&oacute;digo fonte para c&oacute;digo de m&aacute;quina.<sup id="_ref&shy;32" class="reference"><a href="#_note&shy;32" title="">[32]</a></sup></p>&#10;<p>Se o m&eacute;todo utilizado traduz todo o texto do programa (tamb&eacute;m chamado de c&oacute;digo), para s&oacute; depois executar<sup id="_ref&shy;33" class="reference"><a href="#_note&shy;33" title="">[33]</a></sup> o programa, ent&atilde;o diz&shy;se que o programa foi compilado e que o mecanismo utilizado para a tradu&ccedil;&atilde;o &eacute; um compilador (que por sua vez nada mais &eacute; do que um programa).<sup id="_ref&shy;principles_a" class="reference"><a href="#_note&shy;principles" title="">[34]</a></sup> A vers&atilde;o compilada do programa tipicamente &eacute; armazenada, de forma que o programa pode ser executado um n&uacute;mero indefinido de vezes sem que seja necess&aacute;ria nova compila&ccedil;&atilde;o, o que compensa o tempo gasto na compila&ccedil;&atilde;o. Isso acontece com linguagens como <a href="http://en.wikipedia.org/wiki/Pascal_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Pascal</a><sup id="_ref&shy;pacitti_a" class="reference"><a href="#_note&shy;pacitti" title="">[35]</a></sup> e <a href="http://en.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">C</a>. </p>&#10;<p>Se o texto do programa &eacute; executado &agrave; medida que vai sendo traduzido, como em <a href="http://en.wikipedia.org/wiki/JavaScript" id="w">JavaScript</a>, <a href="http://en.wikipedia.org/wiki/BASIC" id="w">BASIC</a>, <a href="http://en.wikipedia.org/wiki/Python" id="w">Python</a> ou <a href="http://en.wikipedia.org/wiki/Perl" id="w">Perl</a>, num processo de tradu&ccedil;&atilde;o de trechos seguidos de sua execu&ccedil;&atilde;o imediata, ent&atilde;o diz&shy;se que o programa foi interpretado e que o mecanismo utilizado para a tradu&ccedil;&atilde;o &eacute; um interpretador. Programas interpretados s&atilde;o geralmente mais lentos do que os compilados, mas s&atilde;o tamb&eacute;m geralmente mais flex&iacute;veis, j&aacute; que podem interagir com o ambiente mais facilmente.<sup id="_ref&shy;scott_a" class="reference"><a href="#_note&shy;scott" title="">[36]</a></sup></p>&#10;<p>Embora haja essa distin&ccedil;&atilde;o entre <a href="http://en.wikipedia.org/wiki/Linguagem_interpretada" id="w">linguagens interpretadas</a> e <a href="http://en.wikipedia.org/wiki/Linguagem_compilada" id="w">compiladas</a>, as coisas nem sempre s&atilde;o t&atilde;o simples. H&aacute; linguagens compiladas para um c&oacute;digo de m&aacute;quina de uma m&aacute;quina virtual (sendo esta <i><a href="http://en.wikipedia.org/wiki/M%C3%A1quina_virtual" id="w">m&aacute;quina virtual</a></i> apenas mais um software, que emula a m&aacute;quina virtual sendo executado em uma m&aacute;quina real), como <a href="http://en.wikipedia.org/wiki/Java_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Java</a><sup id="_ref&shy;java2_a" class="reference"><a href="#_note&shy;java2" title="">[37]</a></sup>  (compila para a <a href="http://en.wikipedia.org/wiki/Plataforma_Java" id="w">plataforma Java</a><sup id="_ref&shy;jit_a" class="reference"><a href="#_note&shy;jit" title="">[38]</a></sup>) e <a href="http://en.wikipedia.org/wiki/C%E2%99%AF" id="w">C&#9839;</a> (compila para a <a href="http://en.wikipedia.org/wiki/Common_Language_Infrastructure" id="w">plataforma CLI</a><sup id="_ref&shy;msil_a" class="reference"><a href="#_note&shy;msil" title="">[39]</a></sup>). E tamb&eacute;m h&aacute; outras formas de interpretar em que os <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_fonte" id="w">c&oacute;digos fontes</a>, ao inv&eacute;s de serem interpretados linha&shy;a&shy;linha, t&ecirc;m blocos &#34&semi;compilados&#34&semi; para a mem&oacute;ria, de acordo com as necessidades, o que aumenta a performance dos programas quando os mesmos m&oacute;dulos s&atilde;o chamados v&aacute;rias vezes, t&eacute;cnica esta conhecida como <a href="http://en.wikipedia.org/wiki/JIT" id="w">JIT</a>.</p>&#10;<p>Como exemplo, podemos citar a linguagem Java. Nela, um compilador traduz o c&oacute;digo java para o c&oacute;digo intermedi&aacute;rio (e port&aacute;vel) da JVM. As JVMs originais interpretavam esse c&oacute;digo, de acordo com o c&oacute;digo de m&aacute;quina do computador hospedeiro, por&eacute;m atualmente elas compilam, segundo a t&eacute;cnica <a href="http://en.wikipedia.org/wiki/JIT" id="w">JIT</a> o c&oacute;digo JVM para c&oacute;digo hospedeiro.</p>&#10;<p>A tradu&ccedil;&atilde;o &eacute; tipicamente feita em v&aacute;rias fases, sendo as mais comuns a <a href="http://en.wikipedia.org/wiki/An%C3%A1lise_l%C3%A9xica" id="w">an&aacute;lise l&eacute;xica</a>, a <a href="http://en.wikipedia.org/wiki/An%C3%A1lise_sint%C3%A1tica" id="w">an&aacute;lise sint&aacute;tica</a> (ou <i><a href="http://en.wikipedia.org/wiki/Parser" id="w">parsing</a></i>), a <a href="http://en.wikipedia.org/wiki/Gera%C3%A7%C3%A3o_de_c%C3%B3digo" id="w">gera&ccedil;&atilde;o de c&oacute;digo</a> e a <a href="http://en.wikipedia.org/wiki/Otimiza%C3%A7%C3%A3o" id="w">otimiza&ccedil;&atilde;o</a>.<sup id="_ref&shy;holmes_a" class="reference"><a href="#_note&shy;holmes" title="">[40]</a></sup> Em compiladores tamb&eacute;m &eacute; comum a gera&ccedil;&atilde;o de c&oacute;digo intermedi&aacute;rio.<sup id="_ref&shy;41" class="reference"><a href="#_note&shy;41" title="">[41]</a></sup></p>&#10;<a id="Conceitos" name="Conceitos"></a><h2> Conceitos </h2>&#10;<a id="Programa%C3%A7%C3%A3o_estruturada" name="Programa%C3%A7%C3%A3o_estruturada"></a><h3> Programa&ccedil;&atilde;o estruturada </h3>&#10;<p>Programa&ccedil;&atilde;o estruturada &eacute; uma forma de programa&ccedil;&atilde;o de computadores que preconiza que todos os programas poss&iacute;veis podem ser reduzidos a apenas tr&ecirc;s estruturas: sequ&ecirc;ncia, decis&atilde;o e repeti&ccedil;&atilde;o.<sup id="_ref&shy;structured_a" class="reference"><a href="#_note&shy;structured" title="">[42]</a></sup> Um dos primeiros a preconizar a programa&ccedil;&atilde;o estruturada foi <a href="http://en.wikipedia.org/wiki/Haskell_Curry" id="w">Haskell B. Curry</a><sup id="_ref&shy;selected_a" class="reference"><a href="#_note&shy;selected" title="">[43]</a></sup><sup id="_ref&shy;44" class="reference"><a href="#_note&shy;44" title="">[44]</a></sup> Tendo, na pr&aacute;tica, sido transformada na Programa&ccedil;&atilde;o modular, a Programa&ccedil;&atilde;o estruturada orienta os programadores para a cria&ccedil;&atilde;o de estruturas simples em seus programas, usando as sub&shy;rotinas e as fun&ccedil;&otilde;es. Foi a forma dominante na cria&ccedil;&atilde;o de software entre a programa&ccedil;&atilde;o linear e a programa&ccedil;&atilde;o orientada por objetos.<sup id="_ref&shy;tucker_a" class="reference"><a href="#_note&shy;tucker" title="">[45]</a></sup> Apesar de ter sido sucedida pela programa&ccedil;&atilde;o orientada por objetos, pode&shy;se dizer que a programa&ccedil;&atilde;o estruturada ainda &eacute; marcantemente influente, uma vez que grande parte das pessoas ainda aprendem programa&ccedil;&atilde;o atrav&eacute;s dela. Por&eacute;m, a orienta&ccedil;&atilde;o a objetos superou o uso das linguagens estruturadas no mercado.<sup id="_ref&shy;tiobe_a" class="reference"><a href="#_note&shy;tiobe" title="">[46]</a></sup></p>&#10;<a id="Programa%C3%A7%C3%A3o_modular" name="Programa%C3%A7%C3%A3o_modular"></a><h3> Programa&ccedil;&atilde;o modular </h3>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Niklaus_Wirth%2C_UrGU.jpg%7Cthumb%7C200px%7Cright" id="w">[[Niklaus Wirth]] em [[2005]]. Criador da linguagem [[Pascal]] entre outras.</a>&#10;Programa&ccedil;&atilde;o modular &eacute; uma forma de programa&ccedil;&atilde;o no qual o desenvolvimento das rotinas de programa&ccedil;&atilde;o &eacute; feito atrav&eacute;s de m&oacute;dulos, que s&atilde;o interligados entre si atrav&eacute;s de uma interface comum.<sup id="_ref&shy;guezzi_a" class="reference"><a href="#_note&shy;guezzi" title="">[47]</a></sup> Foi apresentado originalmente pela Information &#38&semi; Systems Institute, Inc. no National Symposium on Modular Programming em 1968, com a lideran&ccedil;a de Larry Constantine. Exemplos de linguagens que orientaram seu projeto para este aspecto est&atilde;o as linguagens <a href="http://en.wikipedia.org/wiki/Modula&shy;2" id="w">Modula&shy;2</a>,<sup id="_ref&shy;modula2_a" class="reference"><a href="#_note&shy;modula2" title="">[48]</a></sup><sup id="_ref&shy;silva_a" class="reference"><a href="#_note&shy;silva" title="">[49]</a></sup> desenvolvida por <a href="http://en.wikipedia.org/wiki/Niklaus_Wirth" id="w">Niklaus Wirth</a> e a <a href="http://en.wikipedia.org/wiki/Modula&shy;3" id="w">Modula&shy;3</a>.<sup id="_ref&shy;modula3_a" class="reference"><a href="#_note&shy;modula3" title="">[50]</a></sup>.</p>&#10;<a id="Programa%C3%A7%C3%A3o_orientada_a_objetos" name="Programa%C3%A7%C3%A3o_orientada_a_objetos"></a><h3> Programa&ccedil;&atilde;o orientada a objetos </h3>&#10;<p><a href="http://en.wikipedia.org/wiki/Orienta%C3%A7%C3%A3o_a_objetos" id="w">Orienta&ccedil;&atilde;o a objetos</a>, tamb&eacute;m conhecida como <b>Programa&ccedil;&atilde;o Orientada a Objetos</b> (POO), ou ainda em ingl&ecirc;s <i>Object&shy;Oriented Programming</i> (OOP) &eacute; um <a href="http://en.wikipedia.org/wiki/Paradigma_de_programa%C3%A7%C3%A3o" id="w">paradigma de an&aacute;lise, projeto e programa&ccedil;&atilde;o</a> de sistemas de software baseado na composi&ccedil;&atilde;o e intera&ccedil;&atilde;o entre diversas unidades de software chamadas de <a href="http://en.wikipedia.org/wiki/Objeto_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">objetos</a>. O extensivo uso de objetos, particularmente em conjun&ccedil;&atilde;o com o mecanismo de <a href="http://en.wikipedia.org/wiki/Heran%C3%A7a_(programa%C3%A7%C3%A3o)" id="w">heran&ccedil;a</a>, caracteriza o estilo de programa&ccedil;&atilde;o orientada a objetos.<sup id="_ref&shy;friedman_a" class="reference"><a href="#_note&shy;friedman" title="">[51]</a></sup> Em alguns contextos, prefere&shy;se usar <a href="http://en.wikipedia.org/wiki/UML" id="w">modelagem orientada ao objeto</a> (UML), em vez de programa&ccedil;&atilde;o. De fato, o paradigma &#34&semi;orienta&ccedil;&atilde;o a objetos&#34&semi; tem bases conceituais e origem no campo de estudo da cogni&ccedil;&atilde;o, que influenciou a &aacute;rea de inteligencia artificial e da ling&uuml;&iacute;stica no campo da abstra&ccedil;&atilde;o de conceitos do mundo real. Na qualidade de m&eacute;todo de modelagem, &eacute; tida como a melhor estrat&eacute;gia, e mais natural, para se eliminar o &#34&semi;gap sem&acirc;ntico&#34&semi;, dificuldade recorrente no processo de modelar o mundo real, no dom&iacute;nio do problema, em um conjunto de componentes de software que seja o mais fiel na sua representa&ccedil;&atilde;o deste dom&iacute;nio. Facilitaria a comunica&ccedil;&atilde;o do profissional modelador e do usu&aacute;rio da &aacute;rea alvo, na medida em que a correla&ccedil;&atilde;o da simbologia e conceitos abstratos do mundo real e da ferramenta de modelagem (conceitos, terminologia, s&iacute;mbolos, grafismo e estrat&eacute;gias) fosse a mais &oacute;bvia, natural e exata poss&iacute;vel. A an&aacute;lise e projeto orientados a objetos tem como meta identificar o melhor conjunto de objetos para descrever um sistema de software.<sup id="_ref&shy;sommerville_a" class="reference"><a href="#_note&shy;sommerville" title="">[52]</a></sup> O funcionamento deste sistema se d&aacute; atrav&eacute;s do relacionamento e troca de <a href="http://en.wikipedia.org/wiki/Mensagem_(programa%C3%A7%C3%A3o)" id="w">mensagens</a> entre estes objetos. Na programa&ccedil;&atilde;o orientada a objetos, implementa&shy;se um conjunto de <a href="http://en.wikipedia.org/wiki/Classe_(programa%C3%A7%C3%A3o)" id="w">classes</a> que definem os objetos presentes no sistema de software. Cada classe determina o comportamento (definido nos <a href="http://en.wikipedia.org/wiki/M%C3%A9todo_(programa%C3%A7%C3%A3o)" id="w">m&eacute;todos</a>) e estados poss&iacute;veis (<a href="http://en.wikipedia.org/wiki/Atributo_(programa%C3%A7%C3%A3o)" id="w">atributos</a>) de seus objetos, assim como o relacionamento com outros objetos.<sup id="_ref&shy;guezzi_b" class="reference"><a href="#_note&shy;guezzi" title="">[47]</a></sup></p>&#10;<a id="Programa%C3%A7%C3%A3o_linear" name="Programa%C3%A7%C3%A3o_linear"></a><h3> Programa&ccedil;&atilde;o linear </h3>&#10;<p>Em matem&aacute;tica, problemas de Programa&ccedil;&atilde;o Linear s&atilde;o problemas de otimiza&ccedil;&atilde;o nos quais a fun&ccedil;&atilde;o objetivo e as restri&ccedil;&otilde;es s&atilde;o todas lineares.<sup id="_ref&shy;bregalda_a" class="reference"><a href="#_note&shy;bregalda" title="">[53]</a></sup> Programa&ccedil;&atilde;o Linear &eacute; uma importante &aacute;rea da otimiza&ccedil;&atilde;o por v&aacute;rias raz&otilde;es. Muitos problemas pr&aacute;ticos em pesquisa operacional podem ser expressos como problemas de programa&ccedil;&atilde;o linear. Certos casos especiais de programa&ccedil;&atilde;o linear, tais como problemas de <i>network flow</i> e problemas de <i>multicommodity flow</i> s&atilde;o considerados importantes o suficiente para que se tenha gerado muita pesquisa em algoritmos especializados para suas solu&ccedil;&otilde;es. V&aacute;rios algoritmos para outros tipos de problemas de otimiza&ccedil;&atilde;o funcionam resolvendo problemas de PL como sub&shy;problemas. Historicamente, id&eacute;ias da programa&ccedil;&atilde;o linear inspiraram muitos dos conceitos centrais de teoria da otimiza&ccedil;&atilde;o, tais como dualidade, decomposi&ccedil;&atilde;o, e a import&acirc;ncia da convexidade e suas generaliza&ccedil;&otilde;es.</p>&#10;<a id="Classifica%C3%A7%C3%A3o" name="Classifica%C3%A7%C3%A3o"></a><h2> Classifica&ccedil;&atilde;o </h2>&#10;<p>As linguagens de programa&ccedil;&atilde;o podem ser classificadas e sub&shy;classificadas de v&aacute;rias formas.</p>&#10;<a id="Classifica%C3%A7%C3%A3o_da_''ACM''" name="Classifica%C3%A7%C3%A3o_da_''ACM''"></a><h3> Classifica&ccedil;&atilde;o da &#39&semi;&#39&semi;ACM&#39&semi;&#39&semi; </h3>&#10;<p>A <a href="http://en.wikipedia.org/wiki/Association_for_Computing_Machinery" id="w">ACM</a> mant&eacute;m um sistema de classifica&ccedil;&atilde;o<sup id="_ref&shy;54" class="reference"><a href="#_note&shy;54" title="">[54]</a></sup> com os seguintes sub&shy;itens:</p>&#10;&#10;<ul>&#10;<li>Linguagens aplicativas, ou de aplica&ccedil;&atilde;o</li>&#10;<li>Linguagens <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_concorrente" id="w">concorrentes</a>, <a href="http://en.wikipedia.org/wiki/Computa%C3%A7%C3%A3o_distribu%C3%ADda" id="w">distribu&iacute;das</a> e <a href="http://en.wikipedia.org/wiki/Computa%C3%A7%C3%A3o_paralela" id="w">paralelas</a></li>&#10;<li>Linguagens de fluxo de dados</li>&#10;<li>Linguagens de projeto</li>&#10;<li>Linguagens extens&iacute;veis</li>&#10;<li>Linguagens de <a href="http://en.wikipedia.org/wiki/Assembly" id="w">montagem</a> e de <a href="http://en.wikipedia.org/wiki/Macro" id="w">macro</a></li>&#10;<li>Linguagens de microprograma&ccedil;&atilde;o</li>&#10;<li>Linguagens n&atilde;o determin&iacute;sticas</li>&#10;<li>Linguagens n&atilde;o procedurais</li>&#10;<li>Linguagens <a href="http://en.wikipedia.org/wiki/Orienta%C3%A7%C3%A3o_a_objetos" id="w">orientadas a objeto</a></li>&#10;<li>Linguagens de aplica&ccedil;&atilde;o especializada</li>&#10;<li>Linguagens de alt&iacute;ssimo n&iacute;vel<sup id="_ref&shy;55" class="reference"><a href="#_note&shy;55" title="">[55]</a></sup></li></ul>&#10;<a id="Quanto_ao_paradigma" name="Quanto_ao_paradigma"></a><h3> Quanto ao paradigma </h3>&#10;<p> &#10;Diferentes linguagens de programa&ccedil;&atilde;o podem ser agrupadas segundo o paradigma que seguem para abordar a sua sintaxe e sem&acirc;ntica. Os paradigmas se dividem em dois grandes grupos: <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_imperativa" id="w">imperativo</a> e <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_declarativa" id="w">declarativo</a>.<sup id="_ref&shy;appleby_a" class="reference"><a href="#_note&shy;appleby" title="">[56]</a></sup> </p>&#10;<a id="Paradigmas_Imperativos" name="Paradigmas_Imperativos"></a><h4> Paradigmas Imperativos </h4>&#10;<p>Os paradigmas imperativos s&atilde;o aqueles que facilitam a computa&ccedil;&atilde;o por meio de mudan&ccedil;as de estado.<sup id="_ref&shy;appleby_b" class="reference"><a href="#_note&shy;appleby" title="">[56]</a></sup> Se dividem em:</p>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_procedural" id="w">O paradigma procedural</a>. Neste paradigma, os programas s&atilde;o executados atrav&eacute;s de chamadas sucessivas a procedimentos separados. Exemplos de linguagens deste paradigma s&atilde;o o <a href="http://en.wikipedia.org/wiki/Fortran" id="w">Fortran</a> e o <a href="http://en.wikipedia.org/wiki/BASIC" id="w">BASIC</a>.</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_estruturada" id="w">O paradigma de estruturas de blocos</a>.<sup id="_ref&shy;appleby_c" class="reference"><a href="#_note&shy;appleby" title="">[56]</a></sup> A caracter&iacute;stica marcante deste paradigma s&atilde;o os escopos aninhados. Exemplos de linguagens deste paradigma s&atilde;o o <a href="http://en.wikipedia.org/wiki/Algol_60" id="w">Algol 60</a>, <a href="http://en.wikipedia.org/wiki/Pascal_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Pascal</a><sup id="_ref&shy;pacitti_b" class="reference"><a href="#_note&shy;pacitti" title="">[35]</a></sup> e <a href="http://en.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">C</a>.</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Orienta%C3%A7%C3%A3o_a_objetos" id="w">O paradigma de orienta&ccedil;&atilde;o a objetos</a>. Este paradigma descreve linguagens que suportam a intera&ccedil;&atilde;o entre objetos. Exemplos de linguagens deste paradigma s&atilde;o <a href="http://en.wikipedia.org/wiki/C%2B%2B" id="w">C++</a>,<sup id="_ref&shy;schildt_b" class="reference"><a href="#_note&shy;schildt" title="">[26]</a></sup>, <a href="http://en.wikipedia.org/wiki/D_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">linguagem D</a>,<sup id="_ref&shy;57" class="reference"><a href="#_note&shy;57" title="">[57]</a></sup> <a href="http://en.wikipedia.org/wiki/Java_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Java</a>, <a href="http://en.wikipedia.org/wiki/Python" id="w">Python</a><sup id="_ref&shy;Lutz_b" class="reference"><a href="#_note&shy;Lutz" title="">[28]</a></sup> e <a href="http://en.wikipedia.org/wiki/Ruby_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Ruby</a>.<sup id="_ref&shy;thomas_b" class="reference"><a href="#_note&shy;thomas" title="">[30]</a></sup></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Computa%C3%A7%C3%A3o_distribu%C3%ADda" id="w">O paradigma da computa&ccedil;&atilde;o distribu&iacute;da</a>. Este paradigma suporta que mais de uma rotina possa executar independentemente.<sup id="_ref&shy;watt_a" class="reference"><a href="#_note&shy;watt" title="">[58]</a></sup> Um exemplos de linguagem deste paradigma &eacute; a linguagem <a href="http://en.wikipedia.org/wiki/Ada_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Ada</a>.</li></ul>&#10;<a id="Paradigmas_Declarativos" name="Paradigmas_Declarativos"></a><h4> Paradigmas Declarativos </h4>&#10;<p>Os paradigmas declarativos s&atilde;o aqueles nos quais um programa especifica uma rela&ccedil;&atilde;o ou fun&ccedil;&atilde;o.<sup id="_ref&shy;appleby_d" class="reference"><a href="#_note&shy;appleby" title="">[56]</a></sup> Se dividem em:</p>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagem_funcional" id="w">O paradigma funcional</a>. Linguagens deste paradigma n&atilde;o incluem qualquer provis&atilde;o para atribui&ccedil;&atilde;o ou dados mut&aacute;veis <sup id="_ref&shy;abelson_a" class="reference"><a href="#_note&shy;abelson" title="">[59]</a></sup> Na programa&ccedil;&atilde;o funcional, o mapeamento entre os valores de entrada e sa&iacute;da s&atilde;o alcan&ccedil;ados mais diretamente. Um programa &eacute; uma fun&ccedil;&atilde;o (ou grupo de fun&ccedil;&otilde;es), tipicamente constitu&iacute;da de outras fun&ccedil;&otilde;es mais simples.<sup id="_ref&shy;watt2_a" class="reference"><a href="#_note&shy;watt2" title="">[60]</a></sup> Exemplos de linguagens deste paradigma s&atilde;o as linguagens <a href="http://en.wikipedia.org/wiki/Lisp" id="w">Lisp</a><sup id="_ref&shy;manual_a" class="reference"><a href="#_note&shy;manual" title="">[61]</a></sup>, <a href="http://en.wikipedia.org/wiki/Scheme" id="w">Scheme</a><sup id="_ref&shy;62" class="reference"><a href="#_note&shy;62" title="">[62]</a></sup> e <a href="http://en.wikipedia.org/wiki/Haskell_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Haskell</a><sup id="_ref&shy;haskell_a" class="reference"><a href="#_note&shy;haskell" title="">[63]</a></sup></li></ul>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_l%C3%B3gica" id="w">O paradigma da programa&ccedil;&atilde;o l&oacute;gica</a>. Este paradigma se baseia na no&ccedil;&atilde;o de que um programa implementa uma rela&ccedil;&atilde;o ao inv&eacute;s de um mapeamento.<sup id="_ref&shy;watt3_a" class="reference"><a href="#_note&shy;watt3" title="">[64]</a></sup> Exemplos de linguagens deste paradigma s&atilde;o o <a href="http://en.wikipedia.org/wiki/Prolog" id="w">Prolog</a><sup id="_ref&shy;bratko_a" class="reference"><a href="#_note&shy;bratko" title="">[65]</a></sup> e a linguagem <a href="http://en.wikipedia.org/wiki/G%C3%B6del_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">G&ouml;del</a>.<sup id="_ref&shy;godel_a" class="reference"><a href="#_note&shy;godel" title="">[66]</a></sup></li></ul>&#10;<a id="Quanto_a_estrutura_de_tipos" name="Quanto_a_estrutura_de_tipos"></a><h3> Quanto a estrutura de tipos </h3>&#10;&#10;<ul>&#10;<li>Fracamente tipada, como <a href="http://en.wikipedia.org/wiki/PHP" id="w">PHP</a> e <a href="http://en.wikipedia.org/wiki/Smalltalk" id="w">Smalltalk</a>, onde o tipo da vari&aacute;vel muda dinamicamente conforme a situa&ccedil;&atilde;o.</li>&#10;<li>Fortemente tipada, como <a href="http://en.wikipedia.org/wiki/Java_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Java</a> e <a href="http://en.wikipedia.org/wiki/Ruby_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Ruby</a>, onde o tipo da vari&aacute;vel, uma vez atribu&iacute;do, se mant&eacute;m o mesmo at&eacute; ser descartada da mem&oacute;ria.<sup id="_ref&shy;finkel_a" class="reference"><a href="#_note&shy;finkel" title="">[67]</a></sup></li>&#10;<li>Dinamicamente tipada, como <a href="http://en.wikipedia.org/wiki/SNOBOL_4" id="w">SNOBOL</a>, <a href="http://en.wikipedia.org/wiki/APL" id="w">APL</a>, <a href="http://en.wikipedia.org/wiki/Awk" id="w">Awk</a>, <a href="http://en.wikipedia.org/wiki/Perl" id="w">Perl</a>, <a href="http://en.wikipedia.org/wiki/Python" id="w">Python</a> e <a href="http://en.wikipedia.org/wiki/Ruby_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Ruby</a>, onde o tipo da vari&aacute;vel &eacute; definido em tempo de execu&ccedil;&atilde;o.<sup id="_ref&shy;finkel_b" class="reference"><a href="#_note&shy;finkel" title="">[67]</a></sup></li>&#10;<li>Estaticamente tipada, como <a href="http://en.wikipedia.org/wiki/Java_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Java</a> e <a href="http://en.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">C</a>, onde o tipo da vari&aacute;vel &eacute; definido em tempo de compila&ccedil;&atilde;o.<sup id="_ref&shy;jazayeri_a" class="reference"><a href="#_note&shy;jazayeri" title="">[68]</a></sup></li></ul>&#10;<a id="Quanto_ao_grau_de_abstra%C3%A7%C3%A3o" name="Quanto_ao_grau_de_abstra%C3%A7%C3%A3o"></a><h3> Quanto ao grau de abstra&ccedil;&atilde;o </h3>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_baixo_n%C3%ADvel" id="w">Linguagem de programa&ccedil;&atilde;o de baixo n&iacute;vel</a>, cujos simbolos s&atilde;o uma representa&ccedil;&atilde;o direta do c&oacute;digo de m&aacute;quina que ser&aacute; gerado, onde cada comando da linguagem equivale a um &#34&semi;opcode&#34&semi; do processador, como <a href="http://en.wikipedia.org/wiki/Assembly" id="w">Assembly</a>.<sup id="_ref&shy;ravisethi_a" class="reference"><a href="#_note&shy;ravisethi" title="">[69]</a></sup></li>&#10;<li>Linguagem de programa&ccedil;&atilde;o de m&eacute;dio n&iacute;vel,<sup id="_ref&shy;70" class="reference"><a href="#_note&shy;70" title="">[70]</a></sup>  que possui s&iacute;mbolos que podem ser convertidos diretamente para c&oacute;digo de m&aacute;quina (goto, express&otilde;es matem&aacute;ticas, atribui&ccedil;&atilde;o de vari&aacute;veis), mas tamb&eacute;m s&iacute;mbolos complexos que s&atilde;o convertidos por um compilador. Exemplo: <a href="http://en.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">C</a>, <a href="http://en.wikipedia.org/wiki/C%2B%2B" id="w">C++</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_alto_n%C3%ADvel" id="w">Linguagem de programa&ccedil;&atilde;o de alto n&iacute;vel</a>, composta de s&iacute;mbolos mais complexos, intelig&iacute;vel pelo ser humano e n&atilde;o&shy;execut&aacute;vel diretamente pela m&aacute;quina, no n&iacute;vel da especifica&ccedil;&atilde;o de algoritmos, como <a href="http://en.wikipedia.org/wiki/Pascal" id="w">Pascal</a>,<sup id="_ref&shy;pacitti_c" class="reference"><a href="#_note&shy;pacitti" title="">[35]</a></sup> <a href="http://en.wikipedia.org/wiki/Fortran" id="w">Fortran</a>, <a href="http://en.wikipedia.org/wiki/ALGOL" id="w">ALGOL</a>,<a href="http://en.wikipedia.org/wiki/Java_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Java</a> e <a href="http://en.wikipedia.org/wiki/SQL" id="w">SQL</a>.<sup id="_ref&shy;ravisethi_b" class="reference"><a href="#_note&shy;ravisethi" title="">[69]</a></sup></li></ul>&#10;<a id="Quanto_%C3%A0_gera%C3%A7%C3%A3o" name="Quanto_%C3%A0_gera%C3%A7%C3%A3o"></a><h3> Quanto &agrave; gera&ccedil;&atilde;o </h3>&#10;<p>A classifica&ccedil;&atilde;o das linguagens de programa&ccedil;&atilde;o em gera&ccedil;&otilde;es &eacute; uma quest&atilde;o que apresenta diverg&ecirc;ncias de autor para autor. Segundo Maclennan,<sup id="_ref&shy;maclennan_a" class="reference"><a href="#_note&shy;maclennan" title="">[71]</a></sup> as linguagens se dividem em cinco gera&ccedil;&otilde;es com as seguintes caracter&iacute;sticas:</p>&#10;&#10;<ul>&#10;<li>Primeira gera&ccedil;&atilde;o &shy; S&atilde;o linguagens onde suas estruturas de controle s&atilde;o aparentemente orientadas a m&aacute;quina. As instru&ccedil;&otilde;es condicionais n&atilde;o s&atilde;o <a href="http://en.wikipedia.org/wiki/Sub&shy;rotina_aninhada" id="w">aninhadas</a> e dependem fortemente de instru&ccedil;&otilde;es de desvio incondicional como o <a href="http://en.wikipedia.org/wiki/Goto_(programa%C3%A7%C3%A3o)" id="w">GOTO</a>. Uma linguagem t&iacute;pica desta gera&ccedil;&atilde;o &eacute; a linguagem <a href="http://en.wikipedia.org/wiki/Fortran" id="w">Fortran</a>.<sup id="_ref&shy;maclennan_b" class="reference"><a href="#_note&shy;maclennan" title="">[71]</a></sup></li></ul>&#10;&#10;<ul>&#10;<li>Segunda gera&ccedil;&atilde;o &shy; S&atilde;o linguagens onde as estruturas de controle s&atilde;o estruturadas de forma a minimizar ou dispensar o uso de instru&ccedil;&otilde;es GOTO. A segunda gera&ccedil;&atilde;o elaborou melhor e generalizou diversas estruturas de controle das linguagens de primeira gera&ccedil;&atilde;o. Uma das grandes contribui&ccedil;&otilde;es desta gera&ccedil;&atilde;o foi suas estruturas de nomes, que eram hierarquicamente aninhadas. Isto permitiu melhor controle de espa&ccedil;os de nomes e uma eficiente aloca&ccedil;&atilde;o din&acirc;mica de mem&oacute;ria. Uma linguagem t&iacute;pica desta gera&ccedil;&atilde;o &eacute; o <a href="http://en.wikipedia.org/wiki/Algol_60" id="w">Algol 60</a>.<sup id="_ref&shy;maclennan_c" class="reference"><a href="#_note&shy;maclennan" title="">[71]</a></sup></li></ul>&#10;&#10;<ul>&#10;<li>Terceira gera&ccedil;&atilde;o &shy; S&atilde;o linguagens que d&atilde;o &ecirc;nfase a simplicidade e efici&ecirc;ncia. Uma linguagem t&iacute;pica desta gera&ccedil;&atilde;o &eacute; a linguagem <a href="http://en.wikipedia.org/wiki/Pascal_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Pascal</a>.<sup id="_ref&shy;pacitti_d" class="reference"><a href="#_note&shy;pacitti" title="">[35]</a></sup> As estruturas de dados desta gera&ccedil;&atilde;o mostram um deslocamento da m&aacute;quina para a aplica&ccedil;&atilde;o. As estruturas de controle s&atilde;o mais simples e eficientes.<sup id="_ref&shy;maclennan_d" class="reference"><a href="#_note&shy;maclennan" title="">[71]</a></sup> </li></ul>&#10;&#10;<ul>&#10;<li>Quarta gera&ccedil;&atilde;o &shy; Esta gera&ccedil;&atilde;o &eacute; essencialmente o sin&ocirc;nimo para linguagens com abstra&ccedil;&atilde;o de dados. A maioria das linguagens desta gera&ccedil;&atilde;o focam na modulariza&ccedil;&atilde;o e no encapsulamento. Uma linguagem t&iacute;pica desta gera&ccedil;&atilde;o &eacute; a linguagem <a href="http://en.wikipedia.org/wiki/Ada_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Ada</a>.<sup id="_ref&shy;maclennan_e" class="reference"><a href="#_note&shy;maclennan" title="">[71]</a></sup> </li></ul>&#10;&#10;<ul>&#10;<li>Quinta gera&ccedil;&atilde;o &shy; Nesta gera&ccedil;&atilde;o, Maclennan agrupa diversos paradigmas como a orienta&ccedil;&atilde;o a objeto e o paradigma funcional, paradigma l&oacute;gico.<sup id="_ref&shy;maclennan_f" class="reference"><a href="#_note&shy;maclennan" title="">[71]</a></sup> </li></ul>&#10;<p>Henri Bal e Dick Grune, j&aacute; apresentam uma classifica&ccedil;&atilde;o em gera&ccedil;&otilde;es de forma diferente, enfatizando mais o aspecto da aplica&ccedil;&atilde;o. S&atilde;o elencadas 6 gera&ccedil;&otilde;es.<sup id="_ref&shy;bal_a" class="reference"><a href="#_note&shy;bal" title="">[72]</a></sup> </p>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_primeira_gera%C3%A7%C3%A3o" id="w">Primeira gera&ccedil;&atilde;o</a> &shy; <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_de_m%C3%A1quina" id="w">linguagem de m&aacute;quina</a>.</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_segunda_gera%C3%A7%C3%A3o" id="w">Segunda gera&ccedil;&atilde;o</a> &shy; <a href="http://en.wikipedia.org/wiki/Assembly" id="w">linguagens de montagem</a> (<i>assembly</i>).</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_terceira_gera%C3%A7%C3%A3o" id="w">Terceira gera&ccedil;&atilde;o</a> &shy; Linguagens procedurais. </li>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_quarta_gera%C3%A7%C3%A3o" id="w">Quarta gera&ccedil;&atilde;o</a> &shy; <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_quarta_gera%C3%A7%C3%A3o" id="w">Linguagens aplicativas</a>.</li>&#10;<li>Quinta gera&ccedil;&atilde;o &shy; Linguagens voltadas a <a href="http://en.wikipedia.org/wiki/Intelig%C3%AAncia_artificial" id="w">Intelig&ecirc;ncia artificial</a> como as linguagens l&oacute;gicas (<a href="http://en.wikipedia.org/wiki/Prolog" id="w">Prolog</a>) e as linguagens funcionais (<a href="http://en.wikipedia.org/wiki/Lisp" id="w">Lisp</a>).</li>&#10;<li>Sexta gera&ccedil;&atilde;o &shy; <a href="http://en.wikipedia.org/wiki/Rede_neural" id="w">Redes neurais</a>.</li></ul>&#10;<p>Doris Apleby e Julius J. VandeKopple dividem as linguagens em quatro gera&ccedil;&otilde;es que coincidem com as quatro primeiras gera&ccedil;&otilde;es elencadas por Henri Bal e Dick Grune.<sup id="_ref&shy;appleby_e" class="reference"><a href="#_note&shy;appleby" title="">[56]</a></sup></p>&#10;<a id="Lista_de_linguagens" name="Lista_de_linguagens"></a><h2> Lista de linguagens </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Programming_language_textbooks.jpg%7Cthumb%7Cdireita%7C200px" id="w">Livros sobre diversas linguagens de programa&ccedil;&atilde;o</a>&#10;Existem <a href="http://en.wikipedia.org/wiki/Anexo:Lista_de_linguagens_de_programa%C3%A7%C3%A3o" id="w">v&aacute;rias linguagens de programa&ccedil;&atilde;o</a>&semi; de acordo com o <a href="http://en.wikipedia.org/wiki/&Iacute;ndice_Tiobe" id="w">&Iacute;ndice Tiobe</a>, as 20 mais populares s&atilde;o:<sup id="_ref&shy;tiobe_b" class="reference"><a href="#_note&shy;tiobe" title="">[46]</a></sup></p>&#10;<p> &#10;</p>&#10;<ol>&#10;<li><a href="http://en.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">C</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Java_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Java</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Objective&shy;C" id="w">Objective&shy;C</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/C%2B%2B" id="w">C++</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/PHP" id="w">PHP</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/C%E2%99%AF" id="w">C&#9839;</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Visual_Basic" id="w">Visual Basic</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Python" id="w">Python</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Perl" id="w">Perl</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/JavaScript" id="w">JavaScript</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Ruby_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Ruby</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Visual_Basic_.NET" id="w">Visual Basic .NET</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Transact&shy;SQL" id="w">Transact&shy;SQL</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Lisp" id="w">Lisp</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Pascal_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Pascal</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Bash" id="w">Bash</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/PL/SQL" id="w">PL/SQL</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Embarcadero_Delphi" id="w">Delphi</a> / <a href="http://en.wikipedia.org/wiki/Object_Pascal" id="w">Object Pascal</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Ada_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Ada</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/MATLAB" id="w">MATLAB</a></li></ol>&#10;<p> </p>&#10;<a id="Notas" name="Notas"></a><h2> Notas </h2>&#10;<p /><ol class="references">&#10;<li id="_note&shy;1"><b><a href="#_ref&shy;1" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;2"><b><a href="#_ref&shy;2" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;3"><b><a href="#_ref&shy;3" title="">&uarr&semi;</a></b> Edsger Dijkstra em seu livro <i>A Discipline of Programming</i> assim define as linguagens de programa&ccedil;&atilde;o: &#34&semi;Eu vejo uma linguagem de programa&ccedil;&atilde;o principalmente como um ve&iacute;culo para a descri&ccedil;&atilde;o (potencialmente muito sofisticada) de mecanismos abstratos&#34&semi;  </li><li id="_note&shy;aho">&uarr&semi; <a href="#_ref&shy;aho_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;aho_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;5"><b><a href="#_ref&shy;5" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;6"><b><a href="#_ref&shy;6" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;7"><b><a href="#_ref&shy;7" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;8"><b><a href="#_ref&shy;8" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;9"><b><a href="#_ref&shy;9" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;10"><b><a href="#_ref&shy;10" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;11"><b><a href="#_ref&shy;11" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;12"><b><a href="#_ref&shy;12" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;13"><b><a href="#_ref&shy;13" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;14"><b><a href="#_ref&shy;14" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;wexel">&uarr&semi; <a href="#_ref&shy;wexel_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;wexel_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;16"><b><a href="#_ref&shy;16" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;cobol">&uarr&semi; <a href="#_ref&shy;cobol_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;cobol_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;18"><b><a href="#_ref&shy;18" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;19"><b><a href="#_ref&shy;19" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;20"><b><a href="#_ref&shy;20" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;21"><b><a href="#_ref&shy;21" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;22"><b><a href="#_ref&shy;22" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;23"><b><a href="#_ref&shy;23" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;24"><b><a href="#_ref&shy;24" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;25"><b><a href="#_ref&shy;25" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;schildt">&uarr&semi; <a href="#_ref&shy;schildt_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;schildt_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;27"><b><a href="#_ref&shy;27" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;Lutz">&uarr&semi; <a href="#_ref&shy;Lutz_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;Lutz_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;29"><b><a href="#_ref&shy;29" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;thomas">&uarr&semi; <a href="#_ref&shy;thomas_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;thomas_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;31"><b><a href="#_ref&shy;31" title="">&uarr&semi;</a></b> Para um mapa abrangente da hist&oacute;ria das linguagens de programa&ccedil;&atilde;o ver:  </li><li id="_note&shy;32"><b><a href="#_ref&shy;32" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;33"><b><a href="#_ref&shy;33" title="">&uarr&semi;</a></b> ou rodar, como se diz no jarg&atilde;o da computa&ccedil;&atilde;o</li><li id="_note&shy;34"><b><a href="#_ref&shy;34" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;pacitti">&uarr&semi; <a href="#_ref&shy;pacitti_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;pacitti_b" title=""><sup><i><b>b</b></i></sup></a> <a href="#_ref&shy;pacitti_c" title=""><sup><i><b>c</b></i></sup></a> <a href="#_ref&shy;pacitti_d" title=""><sup><i><b>d</b></i></sup></a>  </li><li id="_note&shy;36"><b><a href="#_ref&shy;36" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;37"><b><a href="#_ref&shy;37" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;38"><b><a href="#_ref&shy;38" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;39"><b><a href="#_ref&shy;39" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;40"><b><a href="#_ref&shy;40" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;41"><b><a href="#_ref&shy;41" title="">&uarr&semi;</a></b> Veja tamb&eacute;m <a href="http://en.wikipedia.org/wiki/Compilador" id="w">Compilador</a>.</li><li id="_note&shy;42"><b><a href="#_ref&shy;42" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;43"><b><a href="#_ref&shy;43" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;44"><b><a href="#_ref&shy;44" title="">&uarr&semi;</a></b> Cita&ccedil;&atilde;o de Knuth do memorando de Curry: &#34&semi;O primeiro passo no planejamento do programa &eacute; o de analisar a computa&ccedil;&atilde;o em certas partes principais, chamadas aqui de divis&otilde;es, de modo que o programa possa ser sintetizado a partir delas. As partes principais devem ser tais que, ou pelo menos algumas delas, s&atilde;o c&aacute;lculos independentes em si pr&oacute;prios, ou modifica&ccedil;&otilde;es desses c&aacute;lculos.&#34&semi; em:  </li><li id="_note&shy;45"><b><a href="#_ref&shy;45" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;tiobe">&uarr&semi; <a href="#_ref&shy;tiobe_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;tiobe_b" title=""><sup><i><b>b</b></i></sup></a> </li><li id="_note&shy;guezzi">&uarr&semi; <a href="#_ref&shy;guezzi_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;guezzi_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;48"><b><a href="#_ref&shy;48" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;49"><b><a href="#_ref&shy;49" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;50"><b><a href="#_ref&shy;50" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;51"><b><a href="#_ref&shy;51" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;52"><b><a href="#_ref&shy;52" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;53"><b><a href="#_ref&shy;53" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;54"><b><a href="#_ref&shy;54" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;55"><b><a href="#_ref&shy;55" title="">&uarr&semi;</a></b> Sussman et al. menciona que as linguagens de alt&iacute;ssimo n&iacute;vel s&atilde;o programadas em termos de senten&ccedil;as declarativas. Em:  </li><li id="_note&shy;appleby">&uarr&semi; <a href="#_ref&shy;appleby_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;appleby_b" title=""><sup><i><b>b</b></i></sup></a> <a href="#_ref&shy;appleby_c" title=""><sup><i><b>c</b></i></sup></a> <a href="#_ref&shy;appleby_d" title=""><sup><i><b>d</b></i></sup></a> <a href="#_ref&shy;appleby_e" title=""><sup><i><b>e</b></i></sup></a>  </li><li id="_note&shy;57"><b><a href="#_ref&shy;57" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;58"><b><a href="#_ref&shy;58" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;59"><b><a href="#_ref&shy;59" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;60"><b><a href="#_ref&shy;60" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;61"><b><a href="#_ref&shy;61" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;62"><b><a href="#_ref&shy;62" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;63"><b><a href="#_ref&shy;63" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;64"><b><a href="#_ref&shy;64" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;65"><b><a href="#_ref&shy;65" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;66"><b><a href="#_ref&shy;66" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;finkel">&uarr&semi; <a href="#_ref&shy;finkel_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;finkel_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;68"><b><a href="#_ref&shy;68" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;ravisethi">&uarr&semi; <a href="#_ref&shy;ravisethi_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;ravisethi_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;70"><b><a href="#_ref&shy;70" title="">&uarr&semi;</a></b> Muitos autores classificam as linguagens quanto ao grau de abstra&ccedil;&atilde;o em apenas dois: alto e baixo. Alguns autores como Dennis Ritchie e Kenneth Thompson classificam algumas linguagens como <a href="http://en.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">C</a> e <a href="http://en.wikipedia.org/wiki/Linguagem_de_Programa%C3%A7%C3%A3o_Combinada" id="w">CPL</a> tanto como baixo n&iacute;vel como alto n&iacute;vel como em:  </li><li id="_note&shy;maclennan">&uarr&semi; <a href="#_ref&shy;maclennan_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;maclennan_b" title=""><sup><i><b>b</b></i></sup></a> <a href="#_ref&shy;maclennan_c" title=""><sup><i><b>c</b></i></sup></a> <a href="#_ref&shy;maclennan_d" title=""><sup><i><b>d</b></i></sup></a> <a href="#_ref&shy;maclennan_e" title=""><sup><i><b>e</b></i></sup></a> <a href="#_ref&shy;maclennan_f" title=""><sup><i><b>f</b></i></sup></a>  </li><li id="_note&shy;72"><b><a href="#_ref&shy;72" title="">&uarr&semi;</a></b>  </li></ol><a id="Bibliografia" name="Bibliografia"></a><h2> Bibliografia </h2>&#10;&#10;<ul>&#10;<li> </li></ul>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Anexo:Lista_de_linguagens_de_programa%C3%A7%C3%A3o" id="w">Anexo:Lista de linguagens de programa&ccedil;&atilde;o</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagem_compilada" id="w">Linguagem compilada</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagem_de_script" id="w">Linguagem de script</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagem_interpretada" id="w">Linguagem interpretada</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Paradigma_de_programa%C3%A7%C3%A3o" id="w">Paradigma de programa&ccedil;&atilde;o</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_de_computadores" id="w">Programa&ccedil;&atilde;o de computadores</a></li></ul>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o" id="w"> </a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:T%C3%B3picos_em_linguagens_de_programa%C3%A7%C3%A3o" id="w">Categoria:T&oacute;picos em linguagens de programa&ccedil;&atilde;o</a></p>&#10;<p> &#10; </p></body></html>