<html><title>MD5</title><body>&#10;<p>O <b>MD5</b> (Message&shy;Digest algorithm 5) &eacute; um <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmo</a> de <i><a href="http://en.wikipedia.org/wiki/Hash" id="w">hash</a></i> de 128 <a href="http://en.wikipedia.org/wiki/Bit" id="w">bits</a> unidirecional desenvolvido pela <a href="http://en.wikipedia.org/wiki/RSA_Data_Security%2C_Inc." id="w">RSA Data Security, Inc.</a>, descrito na RFC 1321, e muito utilizado por <a href="http://en.wikipedia.org/wiki/Software" id="w">softwares</a> com <a href="http://en.wikipedia.org/wiki/Protocolo" id="w">protocolo</a> <a href="http://en.wikipedia.org/wiki/P2P" id="w">ponto&shy;a&shy;ponto</a> (<a href="http://en.wikipedia.org/wiki/P2P" id="w">P2P</a>, ou <i> <a href="http://en.wikipedia.org/wiki/P2P" id="w">Peer&shy;to&shy;Peer</a></i>, em ingl&ecirc;s) na verifica&ccedil;&atilde;o de integridade de arquivos e <i>logins</i>.</p>&#10;<p>Foi desenvolvido em <a href="http://en.wikipedia.org/wiki/1991" id="w">1991</a> por <a href="http://en.wikipedia.org/wiki/Ronald_Rivest" id="w">Ronald Rivest</a> para suceder ao <a href="http://en.wikipedia.org/wiki/MD4" id="w">MD4</a> que tinha alguns problemas de seguran&ccedil;a. Por ser um <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmo</a> unidirecional, uma <i><a href="http://en.wikipedia.org/wiki/Hash" id="w">hash</a></i> md5 n&atilde;o pode ser transformada novamente no texto que lhe deu origem. O m&eacute;todo de verifica&ccedil;&atilde;o &eacute;, ent&atilde;o, feito pela compara&ccedil;&atilde;o das duas <i>hash</i> (uma da mensagem original confi&aacute;vel e outra da mensagem recebida). O MD5 tamb&eacute;m &eacute; usado para verificar a integridade de um arquivo atrav&eacute;s, por exemplo, do programa <a href="http://en.wikipedia.org/wiki/Md5sum" id="w">md5sum</a>, que cria a <i><a href="http://en.wikipedia.org/wiki/Hash" id="w">hash</a></i> de um arquivo. Isto pode&shy;se tornar muito &uacute;til para <i><a href="http://en.wikipedia.org/wiki/Download" id="w">downloads</a></i> de arquivos grandes, para programas <a href="http://en.wikipedia.org/wiki/P2P" id="w">P2P</a> que constroem o arquivo atrav&eacute;s de peda&ccedil;os e est&atilde;o sujeitos a corrup&ccedil;&atilde;o dos mesmos. Como autentica&ccedil;&atilde;o de <i>login</i> &eacute; utilizada em v&aacute;rios <a href="http://en.wikipedia.org/wiki/Sistema_operacional" id="w">sistemas operacionais</a> <a href="http://en.wikipedia.org/wiki/Unix" id="w">unix</a> e em muitos <i>sites</i> com autentifica&ccedil;&atilde;o.</p>&#10;<p>Em 2008, Ronald Rivest e outros, publicaram uma nova vers&atilde;o do algoritmo o <a href="http://en.wikipedia.org/wiki/MD6" id="w">MD6</a> com hash de tamanhos 224, 256, 384 ou 512 bits. O algoritmo MD6 iria participar do concurso para ser o novo algoritmo <a href="http://en.wikipedia.org/wiki/SHA&shy;3" id="w">SHA&shy;3</a><sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup><sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup>, por&eacute;m logo depois removeu&shy;o do concurso por consider&aacute;&shy;lo muito lento, anunciando que os computadores de hoje s&atilde;o muito lentos para usar o MD6.</p>&#10;<a id="Vulnerabilidade" name="Vulnerabilidade"></a><h2> Vulnerabilidade </h2>&#10;<p>Como o MD5 faz apenas uma passagem sobre os dados, se dois prefixos com o mesmo hash forem constru&iacute;dos, um sufixo comum pode ser adicionado a ambos para tornar uma colis&atilde;o mais prov&aacute;vel. Deste modo &eacute; poss&iacute;vel que duas strings diferentes produzam o mesmo hash.&#10;O que n&atilde;o garante que a partir de uma senha criptografada espec&iacute;fica consiga&shy;se a senha original, mas permite uma possibilidade de decifrar algumas senhas a partir de um conjunto grande de senhas criptografadas.</p>&#10;<a id="Pseudoc%C3%B3digo" name="Pseudoc%C3%B3digo"></a><h2> Pseudoc&oacute;digo </h2>&#10;<p>Segue&shy;se um <a href="http://en.wikipedia.org/wiki/Pseudoc%C3%B3digo" id="w">pseudoc&oacute;digo</a> para o algoritmo MD5</p> &#10;<pre><span style="color:green&semi;">//<i>Definir r como o seguinte</i></span>&#10;<b>var</b> <i>int</i>[64] r, k&#10;r[ 0..15] := {7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22} &#10;r[16..31] := {5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20}&#10;r[32..47] := {4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23}&#10;r[48..63] := {6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21}&#10; &#10;<span style="color:green&semi;">//<i>Utilizar a parte inteira dos senos de inteiros como constantes:</i></span>&#10;<b>for</b> i <b>from</b> 0 <b>to</b> 63&#10;    k[i] := floor(abs(sin(i + 1)) &times; 2^32)&#10; &#10;<span style="color:green&semi;">//<i>Iniciar as vari&aacute;veis:</i></span>&#10;<b>var</b> <i>int</i> h0 := 0x67452301&#10;<b>var</b> <i>int</i> h1 := 0xEFCDAB89&#10;<b>var</b> <i>int</i> h2 := 0x98BADCFE&#10;<b>var</b> <i>int</i> h3 := 0x10325476&#10; &#10;<span style="color:green&semi;">//<i>Pre&shy;processamento:</i></span>&#10;<b>append</b> &#34&semi;1&#34&semi; bit <b>to</b> message&#10;<b>append</b> &#34&semi;0&#34&semi; bits <b>until</b> message length in bits &equiv; 448 (mod 512)&#10;<b>append</b> bit length of message <b>as</b> <i>64&shy;bit little&shy;endian integer</i> <b>to</b> message&#10; &#10;<span style="color:green&semi;">//<i>Processar a mensagem em peda&ccedil;os sucessivos de 512&shy;bits:</i></span>&#10;<b>for each</b> <i>512&shy;bit</i> chunk <b>of</b> message&#10;    break chunk into sixteen 32&shy;bit little&shy;endian words w(i), 0 &le; i &le; 15&#10; &#10;    <span style="color:green&semi;">//<i>Inicializar o valor do hash para este peda&ccedil;o:</i></span>&#10;    <b>var</b> <i>int</i> a := h0&#10;    <b>var</b> <i>int</i> b := h1&#10;    <b>var</b> <i>int</i> c := h2&#10;    <b>var</b> <i>int</i> d := h3&#10; &#10;    <span style="color:green&semi;">//<i>Loop principal:</i></span>&#10;    <b>for</b> i <b>from</b> 0 <b>to</b> 63&#10;        <b>if</b> 0 &le; i &le; 15 <b>then</b>&#10;            f := (b <b>and</b> c) <b>or</b> ((<b>not</b> b) <b>and</b> d)&#10;            g := i&#10;        <b>else if</b> 16 &le; i &le; 31&#10;            f := (d <b>and</b> b) <b>or</b> ((<b>not</b> d) <b>and</b> c)&#10;            g := (5&times;i + 1) <b>mod</b> 16&#10;        <b>else if</b> 32 &le; i &le; 47&#10;            f := b <b>xor</b> c <b>xor</b> d&#10;            g := (3&times;i + 5) <b>mod</b> 16&#10;        <b>else if</b> 48 &le; i &le; 63&#10;            f := c <b>xor</b> (b <b>or</b> (<b>not</b> d))&#10;            g := (7&times;i) <b>mod</b> 16&#10;  &#10;        temp := d&#10;        d := c&#10;        c := b&#10;        b := ((a + f + k[i] + w(g)) <b>leftrotate</b> r[i]) + b&#10;        a := temp&#10; &#10;    <span style="color:green&semi;">//<i>Adicionar este peda&ccedil;o do hash ao resultado:</i></span>&#10;    h0 := h0 + a&#10;    h1 := h1 + b &#10;    h2 := h2 + c&#10;    h3 := h3 + d&#10; &#10;<b>var</b> <i>int</i> digest := h0 <b>append</b> h1 <b>append</b> h2 <b>append</b> h3 //<i>(expressed as little&shy;endian)</i>&#10;</pre>&#10;<p><i>Nota: Ao inv&eacute;s da formula&ccedil;&atilde;o do RFC 1321 acima exibida, considera&shy;se mais eficiente a seguinte implementa&ccedil;&atilde;o:</i>&#10;(0  &le; i &le; 15): f := d <b>xor</b> (b <b>and</b> (c <b>xor</b> d))&#10;(16 &le; i &le; 31): f := c <b>xor</b> (d <b>and</b> (b <b>xor</b> c))</p>&#10;<a id="Hashes_MD5" name="Hashes_MD5"></a><h2> Hashes MD5 </h2>&#10;<p>Os <a href="http://en.wikipedia.org/wiki/Hash" id="w">hashes</a> MD5 de 128&shy;bit (16&shy;byte) s&atilde;o normalmente representados por uma sequ&ecirc;ncia de 32 caracteres hexadecimais. O seguinte mostra uma string <a href="http://en.wikipedia.org/wiki/ASCII" id="w">ASCII</a> com 43&shy;bytes e o hash correspondente:</p>&#10;<pre> MD5(&#34&semi;The quick brown fox jumps over the lazy dog&#34&semi;) &#10;  = 9e107d9d372bb6826bd81d3542a419d6&#10;</pre>&#10;<p>Mesmo uma pequena altera&ccedil;&atilde;o na mensagem vai criar um hash completamente diferente, ex. ao mudar <tt>d</tt> para <tt>c</tt>:</p>&#10;<pre> MD5(&#34&semi;The quick brown fox jumps over the lazy <b><i>c</i></b>og&#34&semi;) &#10;  = 1055d3e698d289f2af8663725127bd4b&#10;</pre>&#10;<p>O Hash de uma string vazia &eacute;:</p>&#10;<pre> MD5(&#34&semi;&#34&semi;) &#10;  = d41d8cd98f00b204e9800998ecf8427e&#10;&#10;</pre><a id="Salgar_(Salting)" name="Salgar_(Salting)"></a><h2>Salgar (Salting)</h2>&#10;<p>Para aumentar a seguran&ccedil;a em alguns sistemas, usa&shy;se a t&aacute;tica de adicionar um texto fixo no texto original a ser criptografado. Deste modo se o sal for &#34&semi;wiki&#34&semi; e a senha for &#34&semi;1234&#34&semi;, a pseudo&shy;senha poder&aacute; ser &#34&semi;wiki1234&#34&semi; e assim mesmo que algu&eacute;m tenha o MD5 de 1234 por ser uma senha comum ele n&atilde;o ter&aacute; de wiki1234. Por&eacute;m caso o &#34&semi;sal&#34&semi; seja simples como no exemplo e houver o MD5 de &#34&semi;wiki1234&#34&semi; &eacute; poss&iacute;vel descobrir o sal e deste modo decriptografar as senhas mais comuns. Por este motivo geralmente o &#34&semi;sal&#34&semi; &eacute; algo complexo.</p>&#10;<a id="%7B%7BVer_tamb%C3%A9m%7D%7D" name="%7B%7BVer_tamb%C3%A9m%7D%7D"></a><h2>   </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Criptografia" id="w">Criptografia</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/MD2" id="w">MD2</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/MD4" id="w">MD4</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/SHA" id="w">SHA</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Hash" id="w">Hash</a></li></ul>&#10;<a id="%7B%7BLiga%C3%A7%C3%B5es_externas%7D%7D" name="%7B%7BLiga%C3%A7%C3%B5es_externas%7D%7D"></a><h2>   </h2>&#10;&#10;<ul>&#10;<li>RFC 1321</li>&#10;<li><a class="externallink" href="http://pascal.sources.ru/crypt/md5asm32.htm" rel="nofollow" title="http://pascal.sources.ru/crypt/md5asm32.htm">Pascal Implementation</a></li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos_de_criptografia" id="w">Categoria:Algoritmos de criptografia</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Criptografia" id="w">Categoria:Criptografia</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Detec%C3%A7%C3%A3o_e_corre%C3%A7%C3%A3o_de_erros" id="w">Categoria:Detec&ccedil;&atilde;o e corre&ccedil;&atilde;o de erros</a></p></body></html>