<html><title>Kerberos</title><body>&#10;<p> &#10;<b>Kerberos</b> &eacute; o nome de um <a href="http://en.wikipedia.org/wiki/Protocolo_de_rede" id="w">Protocolo de rede</a>, que permite comunica&ccedil;&otilde;es individuais seguras e identificadas, em uma rede insegura. Para isso o <a href="http://en.wikipedia.org/wiki/Massachusetts_Institute_of_Technology" id="w">Massachusetts Institute of Technology</a> (MIT) disponibiliza um pacote de aplicativos que implementam esse protocolo. O protocolo Kerberos previne <a href="http://en.wikipedia.org/wiki/Eavesdropping" id="w">Eavesdropping</a> e <a href="http://en.wikipedia.org/wiki/Replay_attack" id="w">Replay attack</a>, e ainda garante a integridade dos dados. Seus projetistas inicialmente o modelaram na arquitetura cliente&shy;servidor, e &eacute; poss&iacute;vel a autentica&ccedil;&atilde;o mutua entre o cliente e o servidor, permitindo assim que ambos se autentiquem.</p>&#10;<p>Kerberos utiliza <a href="http://en.wikipedia.org/wiki/Criptografia_sim%C3%A9trica" id="w">Criptografia sim&eacute;trica</a> e necessita de um <a href="http://en.wikipedia.org/wiki/En:trusted_third_party" id="w">sistema de confian&ccedil;a tripla</a>.</p>&#10;<a id="Hist%C3%B3ria_e_Desenvolvimento" name="Hist%C3%B3ria_e_Desenvolvimento"></a><h2> Hist&oacute;ria e Desenvolvimento </h2>&#10;<p>Kerberos &eacute; um protocolo de autentica&ccedil;&atilde;o do <a href="http://en.wikipedia.org/wiki/Projeto_Athena" id="w">Projeto Athena</a>. Tem esse nome em alus&atilde;o ao C&atilde;o guarda de tr&ecirc;s cabe&ccedil;as (<a href="http://en.wikipedia.org/wiki/C%C3%A9rbero" id="w">C&eacute;rbero</a>) do deus <a href="http://en.wikipedia.org/wiki/Hades" id="w">Hades</a> da <a href="http://en.wikipedia.org/wiki/Mitologia_grega" id="w">Mitologia grega</a>. Diversas vers&otilde;es do protocolo j&aacute; existiram, as vers&otilde;es 1 at&eacute; a 3 foram utilizadas somente dentro da MIT.&#10;Steve Miller e Clifford Neuman, foram os principais projetistas da vers&atilde;o 4 do Kerberos, publicada nos anos 80, ainda com foco no Projeto Athena.</p>&#10;<p>A vers&atilde;o 5 foi projetada por John Kohl e Clifford Neuman e publicada em 1993 no RFC 1510 (Ficou obsoleto ao RFC 4120 de 2005), e teve como inten&ccedil;&atilde;o melhorar a seguran&ccedil;a e as limita&ccedil;&otilde;es relativas a vers&atilde;o 4.</p>&#10;<p>A <a href="http://en.wikipedia.org/wiki/Massachusetts_Institute_of_Technology" id="w">MIT</a> disponibilizou uma implementa&ccedil;&atilde;o livre sob licen&ccedil;a BSD.</p>&#10;<p>Autoridades <a href="http://en.wikipedia.org/wiki/Estados_Unidos" id="w">Norte&shy;americanas/Estadundenses</a> proibiram o uso do Kerberos, pois esse utiliza um algoritmo de criptografia com uma chave de 56&shy;bit, chamado <a href="http://en.wikipedia.org/wiki/DES" id="w">DES</a>. Eles consideraram que o protocolo prejudica a seguran&ccedil;a nacional, porque impede que mensagens interceptadas sejam entendidas (Assim como qualquer aplicativo que utilize criptografia com chave maior que 40&shy;bit). Uma implementa&ccedil;&atilde;o n&atilde;o americana do Kerberos, <a class="externallink" href="http://www.pdc.kth.se/kth&shy;krb/" rel="nofollow" title="http://www.pdc.kth.se/kth&shy;krb/">KTH&shy;KRB</a> foi desenvolvida pela <a href="http://en.wikipedia.org/wiki/Royal_Institute_of_Technology" id="w">Royal Institute of Technology</a> na <a href="http://en.wikipedia.org/wiki/Su%C3%A9cia" id="w">Su&eacute;cia</a>, tornando assim o sistema dispon&iacute;vel fora dos EUA, at&eacute; a mudan&ccedil;a da regulamenta&ccedil;&atilde;o de exporta&ccedil;&atilde;o de criptografias. A implementa&ccedil;&atilde;o Sueca &eacute; baseada em uma vers&atilde;o chamada eBones. eBones &eacute; baseado em um release da vers&atilde;o eBones da MIT (Retirado a criptografia e as chamadas a mesma) que por sua vez foi baseado na vers&atilde;o 4 do Kerberos atualiza&ccedil;&atilde;o 9. Esse Kerberos limitado &eacute; chamado hoje como eBones. Uma implementa&ccedil;&atilde;o chamada <a class="externallink" href="http://www.pdc.kth.se/heimdal/" rel="nofollow" title="http://www.pdc.kth.se/heimdal/">Heimdal</a>, foi feita basicamente, pelo mesmo grupo de pessoas e &eacute; baseada na vers&atilde;o 5 do Kerberos.</p>&#10;<p><a href="http://en.wikipedia.org/wiki/Windows_2000" id="w">Windows 2000</a>, <a href="http://en.wikipedia.org/wiki/Windows_XP" id="w">Windows XP</a> e o <a href="http://en.wikipedia.org/wiki/Windows_Server_2003" id="w">Windows Server 2003</a> utilizam uma variante do Kerberos, como seu m&eacute;todo de autentica&ccedil;&atilde;o padr&atilde;o. As adi&ccedil;&otilde;es feitas no conjunto de protocolos do Kerberos pela <a href="http://en.wikipedia.org/wiki/Microsoft" id="w">Microsoft</a> s&atilde;o documentadas no RFC 3244 chamado &ldquo;Microsoft Windows 2000 Kerberos change Password and Set Password Protocols&rdquo;. O <a href="http://en.wikipedia.org/wiki/Mac_OS_X" id="w">Mac OS X</a> da Apple tamb&eacute;m usa o Kerberos, tanto o cliente como o servidor.</p>&#10;<p>Em <a href="http://en.wikipedia.org/wiki/2005" id="w">2005</a>, o grupo chamado <a href="http://en.wikipedia.org/wiki/IETF" id="w">IETF</a> &ldquo;IETF Kerberos Workgroup&rdquo; atualizou as especifica&ccedil;&otilde;es<a class="externallink" href="http://www.ietf.org/html.charters/krb&shy;wg&shy;charter.html" rel="nofollow" title="http://www.ietf.org/html.charters/krb&shy;wg&shy;charter.html">Kerberos</a>. As atualiza&ccedil;&otilde;es incluem:&#10;</p>&#10;<ul>&#10;<li>&#34&semi;Encryption and Checksum Specifications&#34&semi; (RFC 3961),</li>&#10;<li>&#34&semi;<a href="http://en.wikipedia.org/wiki/AES" id="w">Advanced Encryption Standard</a> (AES) Encryption for Kerberos 5&#34&semi; (RFC 3962),</li>&#10;<li>Uma nova edi&ccedil;&atilde;o da especifica&ccedil;&atilde;o do Kerberos vers&atilde;o 5 &#34&semi;The Kerberos Network Authentication Service (V5)&#34&semi; (RFC 4120). Essa vers&atilde;o substitui o RFC 1510, tornando a especifica&ccedil;&atilde;o do protocolo mais transparente e o explicando de modo mais detalhado e limpo.</li>&#10;<li>Uma nova edi&ccedil;&atilde;o de especifica&ccedil;&atilde;o do <a href="http://en.wikipedia.org/wiki/En:Generic_Security_Services_Application_Program_Interface" id="w">GSS&shy;API</a> &#34&semi;The Kerberos Version 5 Generic Security Service Application Program Interface (GSS&shy;API) Mechanism: Version 2.&#34&semi; (RFC 4121).</li></ul>&#10;<a id="Descri%C3%A7%C3%A3o" name="Descri%C3%A7%C3%A3o"></a><h2> Descri&ccedil;&atilde;o </h2>&#10;<p>O Kerberos utiliza basicamente o protocolo <a href="http://en.wikipedia.org/wiki/En:Needham&shy;Schroeder" id="w">Needham&shy;Schroeder</a>. O <a href="http://en.wikipedia.org/wiki/En:trusted_third_party" id="w">sistema de confian&ccedil;a tripla</a> &eacute; chamado de <i>Centro de Distribui&ccedil;&atilde;o de Chaves</i> (CDC), que &eacute; composta por duas partes separadas: um Servidor de Autentica&ccedil;&atilde;o (SA) e Servidor de Concess&atilde;o de Ticket (SCT). O Kerberos trabalha baseado em Tickets, que identificam os usu&aacute;rios.</p>&#10;<p>O CDC mant&eacute;m um banco de dados de chaves secretas&semi; toda entidade de rede &ndash; tanto clientes como servidores &ndash; compartilham uma chave secreta&#9;que &eacute; apenas conhecido por eles mesmos e pelo CDC. O conhecimento da chave secreta pelo CDC &eacute; necess&aacute;rio para a identifica&ccedil;&atilde;o das entidades de rede. Para a comunica&ccedil;&atilde;o entre as entidades o CDC gera uma <a href="http://en.wikipedia.org/wiki/En:session_key" id="w">chave de sess&atilde;o</a> tempor&aacute;ria, que serve para garantir a privacidade das informa&ccedil;&otilde;es.</p>&#10;<a id="Utilizadores" name="Utilizadores"></a><h2> Utilizadores </h2>&#10;<p>Os seguintes softwares podem utilizar Kerberos para a autentica&ccedil;&atilde;o:&#10;</p>&#10;<ul>&#10;<li><a class="externallink" href="http://pt.wikipedia.org/wiki/AFS" rel="nofollow" title="http://pt.wikipedia.org/wiki/AFS">AFS</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Apache_HTTP_Server" id="w">Apache</a> (com o m&oacute;dulo <a class="externallink" href="http://modauthkerb.sourceforge.net/index.html" rel="nofollow" title="http://modauthkerb.sourceforge.net/index.html">mod_auth_kerb</a>)</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Apache_HTTP_Server" id="w">Apache 2</a> (usando libapache&shy;mod&shy;auth&shy;kerb)</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Postfix" id="w">Postfix</a> (usando GSSAPI)</li>&#10;<li>Roteadores e Switches Cisco utilizando <a href="http://en.wikipedia.org/wiki/En:Cisco_IOS" id="w">IOS</a></li>&#10;<li><a class="externallink" href="http://en.wikipedia.org/wiki/Coda_(file_system)" rel="nofollow" title="http://en.wikipedia.org/wiki/Coda_(file_system)">Coda File System</a></li>&#10;<li><a class="externallink" href="http://pt.wikipedia.org/wiki/Eudora" rel="nofollow" title="http://pt.wikipedia.org/wiki/Eudora">Eudora</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Mac_OS_X" id="w">Mac OS X</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Microsoft_Windows" id="w">Microsoft Windows</a> (2000 e posteriores) utiliza como protocolo de autentica&ccedil;&atilde;o padr&atilde;o</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Mulberry_(e&shy;mail_client)" id="w">Mulberry</a>, um cliente de e&shy;mail desenvolvido por Cyrusoft, Inc.</li>&#10;<li><a class="externallink" href="http://pt.wikipedia.org/wiki/Nfs" rel="nofollow" title="http://pt.wikipedia.org/wiki/Nfs">NFS</a> (Desde NFSv3)</li>&#10;<li><a href="http://en.wikipedia.org/wiki/OpenSSH" id="w">OpenSSH</a> (with Kerberos v5 or higher)</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Pluggable_Authentication_Modules" id="w">PAM</a> (com o m&oacute;dulo pam_krb5)</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Samba_(servidor)" id="w">Samba</a> Desde v3.x</li>&#10;<li><a href="http://en.wikipedia.org/wiki/SOCKS" id="w">SOCKS</a> (Desde SOCKS5)</li>&#10;<li><a class="externallink" href="http://en.wikipedia.org/wiki/Netatalk" rel="nofollow" title="http://en.wikipedia.org/wiki/Netatalk">Netatalk</a></li>&#10;<li>As implementa&ccedil;&otilde;es <a href="http://en.wikipedia.org/wiki/X_Window_System" id="w">X Window System</a></li>&#10;<li>Indire(c)tamente, qualquer software que possa utilizar o <a class="externallink" href="http://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer" rel="nofollow" title="http://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer">SASL</a> para autentica&ccedil;&atilde;o, como o <a href="http://en.wikipedia.org/wiki/OpenLDAP" id="w">OpenLDAP</a>, <a href="http://en.wikipedia.org/wiki/Dovecot_(software)" id="w">Dovecot</a> <a href="http://en.wikipedia.org/wiki/IMAP4" id="w">IMAP4</a> e servidores <a href="http://en.wikipedia.org/wiki/POP3" id="w">POP3</a>, Servidor de e&shy;mail <a href="http://en.wikipedia.org/wiki/Postfix_(software)" id="w">Postfix</a></li>&#10;<li>O su&iacute;te de aplicativos Kerberos j&aacute; vem com os clientes e servidores habilitados para <a class="externallink" href="http://en.wikipedia.org/wiki/Remote_Shell" rel="nofollow" title="http://en.wikipedia.org/wiki/Remote_Shell">rsh</a>, <a href="http://en.wikipedia.org/wiki/File_transfer_protocol" id="w">FTP</a>, e <a href="http://en.wikipedia.org/wiki/Telnet" id="w">Telnet</a></li>&#10;<li>Qualquer software baseado em Java (Desde 1.4.2) utilizando JAAS/JGSS pode utilizar o Kerberos para a sua seguran&ccedil;a, veja <a class="externallink" href="http://java.sun.com/javase/6/docs/technotes/guides/security/jgss/single&shy;signon.html" rel="nofollow" title="http://java.sun.com/javase/6/docs/technotes/guides/security/jgss/single&shy;signon.html">http://java.sun.com/javase/6/docs/technotes/guides/security/jgss/single&shy;signon.html</a></li></ul>&#10;<a id="O_Protocolo" name="O_Protocolo"></a><h2> O Protocolo </h2>&#10;<p>Qualquer um pode especificar o protocolo utilizando a <a href="http://en.wikipedia.org/wiki/En:security_protocol_notation" id="w">nota&ccedil;&atilde;o de protocolo de seguran&ccedil;a</a>, onde <a href="http://en.wikipedia.org/wiki/En:characters_in_cryptography" id="w">&#39&semi;&#39&semi;Alice&#39&semi;&#39&semi;</a> (<i>A</i>) se autentica com <a href="http://en.wikipedia.org/wiki/En:characters_in_cryptography" id="w">&#39&semi;&#39&semi;Bob&#39&semi;&#39&semi;</a> (<i>B</i>) utilizando um servidor <i>S</i>. Onde:&#10;</p>&#10;<ul>&#10;<li>K<sub>AS</sub> &eacute; uma chave pr&eacute;&shy;estabelecida somente conhecida por A e S&semi;</li>&#10;<li>Como tamb&eacute;m K<sub>BS</sub> &eacute; somente conhecido por B e S&semi;</li>&#10;<li>K<sub>AB</sub> &eacute; uma <a href="http://en.wikipedia.org/wiki/En:session_key" id="w">chave de sess&atilde;o</a> entre A e B, gerada a cada vez que o protocolo &eacute; utilizado&semi;</li>&#10;<li>T<sub>S</sub> e T<sub>A</sub> s&atilde;o <a href="http://en.wikipedia.org/wiki/Marca_temporal" id="w">marcas temporais</a> geradas por S e por A, respectivamente&semi;</li>&#10;<li>L &eacute; um &#39&semi;lifespan&#39&semi; definindo o tempo de vida da marca temporal.</li></ul>&#10;<p><span class="math">A \rightarrow S: A,B</span>&#10;</p><dl><dd>A pede para S iniciar um conex&atilde;o com B.</dd></dl>&#10;<p><span class="math">S \rightarrow A: \{T_S, L, K_{AB}, B, \{T_S, L, K_{AB}, A\}_{K_{BS}}\}_{K_{AS}}</span>&#10;</p><dl><dd>S gera uma chave K<sub>AB</sub> e envia para A junto com a marca temporal e com os dados encriptados por B.</dd></dl>&#10;<p><span class="math">A \rightarrow B: \{T_S, L, K_{AB}, A\}_{K_{BS}}, \{A, T_A\}_{K_{AB}}</span>&#10;</p><dl><dd>A passa a mensagem para o B, obt&eacute;m um novo TA e passa utilizando a chave de sess&atilde;o.</dd></dl>&#10;<p><span class="math">B \rightarrow A: \{T_A + 1\}_{K_{AB}}</span>&#10;</p><dl><dd>B confirma a recep&ccedil;&atilde;o da chave de sess&atilde;o retornando uma vers&atilde;o modificada da marca temporal do A.</dd></dl>&#10;<p>Percebemos que a <a href="http://en.wikipedia.org/wiki/Seguran%C3%A7a" id="w">seguran&ccedil;a</a> do protocolo se baseia em marcas temporais T e &ldquo;lifespans&rdquo; L como indicadores de qu&atilde;o recente &eacute; a comunica&ccedil;&atilde;o.&#10;E em rela&ccedil;&atilde;o &agrave; opera&ccedil;&atilde;o do Kerberos, &eacute; importante salientar que o servidor S &eacute; utilizado por ambos como o Servidor de Autentica&ccedil;&atilde;o (SA), e como Servidor de Concess&atilde;o de Ticket (SCT). Sendo <span class="math">\{T_S, L, K_{AB}, B, \{T_S, L, K_{AB}, A\}_{K_{BS}}\}_{K_{AS}}</span>, <span class="math">\{T_S, L, K_{AB}, A\}_{K_{BS}}</span> &eacute; o Ticket do cliente para o servidor, <span class="math">\{A, T_A\}_{K_{AB}}</span> &eacute; o autenticador, e <span class="math">\{T_A + 1\}_{K_{AB}}</span> confirma a veracidade da identifica&ccedil;&atilde;o de B e se o mesmo &eacute; reconhecido por A. Isso &eacute; necess&aacute;rio para uma autentica&ccedil;&atilde;o mutua.</p>&#10;<a id="Funcionamento_do_Kerberos" name="Funcionamento_do_Kerberos"></a><h2> Funcionamento do Kerberos </h2>&#10;<p>A seguir, &eacute; descrito fluxo simplificado do funcionamento do protocolo.</p>&#10;<p>As seguintes nomenclaturas ser&atilde;o usadas:&#10;</p>&#10;<ul>&#10;<li>SA = Servidor de Autentica&ccedil;&atilde;o</li>&#10;<li>SCT = Servidor de Concess&atilde;o de Ticket</li>&#10;<li>SS = Servidor de Servi&ccedil;o</li>&#10;<li>cliente = Aplica&ccedil;&atilde;o cliente do kerberos no sistema</li></ul>&#10;<p>Em uma senten&ccedil;a: o cliente se autentica no SA, ent&atilde;o demonstra para o SCT que est&aacute; autorizado a receber um Ticket para utilizar em um servi&ccedil;o (e o recebe), ent&atilde;o demonstra ao SS que ele est&aacute; aprovado para receber um servi&ccedil;o.</p>&#10;<p>Em mais detalhes:&#10;</p>&#10;<ol>&#10;<li>O usu&aacute;rio coloca o nome de usu&aacute;rio e a senha no cliente.</li>&#10;<li>O cliente aplica uma criptografia de via &uacute;nica (ou hash) na senha digitada, e isso se torna a chave secreta do cliente.</li>&#10;<li>O cliente envia uma solicita&ccedil;&atilde;o de servi&ccedil;o, atrav&eacute;s de uma mensagem em texto&shy;plano, ao SA. Exemplo de mensagem: &ldquo;O usu&aacute;rio XYZ gostaria de receber um servi&ccedil;o&rdquo;. Nota: Nem a chave secreta, nem a senha s&atilde;o enviadas ao SA.</li>&#10;<li>O SA verifica se o cliente est&aacute; em sua base de dados. Se estiver, ele manda as seguintes duas mensagens ao cliente:&#10;<ol>&#10;<li>Mensagem A: <i>Chave de sess&atilde;o Cliente/SCT</i> criptografada usando a chave secreta do usu&aacute;rio.</li>&#10;<li>Mensagem B: <i>Ticket de Concess&atilde;o</i> (Que inclui a ID do cliente, endere&ccedil;o de rede do cliente, validade do ticket e a <i>Chave de sess&atilde;o Cliente/SCT</i>) criptografado utilizando a chave secreta do SCT.</li></ol></li>&#10;<li>Somente ap&oacute;s o cliente receber a mensagem A e B, ele descriptografa a mensagem A e obt&eacute;m a <i>Chave de sess&atilde;o Cliente/SCT</i>. Essa chave de sess&atilde;o ser&aacute; utilizada em comunica&ccedil;&otilde;es futuras com o SCT. (Nota: O cliente n&atilde;o consegue descriptografar a mensagem B, pois essa &eacute; criptografada utilizando a chave secreta do SCT). A partir desse momento, o cliente tem informa&ccedil;&otilde;es o suficiente para se autenticar no SCT.</li>&#10;<li>Ap&oacute;s requisitar o servi&ccedil;o, o cliente envia as seguintes duas mensagens ao SCT:&#10;<ol>&#10;<li>Mensagem C: Composta pelo <i>Ticket de Concess&atilde;o</i> vinda da mensagem B e o ID do servi&ccedil;o requisitado.</li>&#10;<li>Mensagem D: O Autenticador (que &eacute; composto do ID do cliente e a marca temporal), criptografado utilizando a <i>Chave de sess&atilde;o Cliente/SCT</i>.</li></ol></li>&#10;<li>Ap&oacute;s receber as mensagens C e D, o SCT descriptografa a mensagem B com sua chave secreta e a mensagem D (O Autenticador) utilizando a <i>Chave de sess&atilde;o Cliente/SCT</i> da mensagem B, verifica se os dados das mensagens conferem com os dados de quem enviou os pacotes e, caso esteja tudo certo, envia as seguintes duas mensagens ao cliente:&#10;<ol>&#10;<li>Mensagem E: <i>Ticket Cliente&shy;para&shy;Servidor</i> (que inclui o ID do cliente, endere&ccedil;o de rede do cliente, per&iacute;odo v&aacute;lido, e uma <i>chave de sess&atilde;o Cliente/Servidor</i>) criptografado utilizando a chave secreta do servi&ccedil;o.</li>&#10;<li>Mensagem F: <i>Chave de sess&atilde;o Cliente/Servidor</i> criptografado utilizando a <i>chave de sess&atilde;o Cliente/SCT</i>.</li></ol></li>&#10;<li>Ap&oacute;s receber as mensagens E e F do SCT, o cliente tem informa&ccedil;&otilde;es suficiente para se autenticar no SS (Nota: O cliente n&atilde;o consegue descriptografar a mensagem E, pois essa &eacute; criptografada utilizando a chave secreta do SS). Assim, o cliente se conecta no SS e envia as seguintes mensagens:&#10;<ol>&#10;<li>Mensagem E do passo anterior (o <i>Ticket Cliente&shy;para&shy;servidor</i>, criptografado utilizando a chave secreta do servi&ccedil;o) .</li>&#10;<li>Mensagem G: Um novo Autenticador, que inclui o ID do cliente, uma marca temporal, criptografados com <i>chave de sess&atilde;o Cliente/Servidor</i></li></ol></li>&#10;<li>Ap&oacute;s receber as mensagens, SS descriptografa a mensagem E e, com o <i>Ticket Cliente&shy;para&shy;Servidor</i> que estava nesta, descriptografa a mensagem G. Novamente os dados das mensagens s&atilde;o comparados com os dados de quem as envia e, caso esteja tudo certo, uma mensagem de confirma&ccedil;&atilde;o, codificada com a <i>Chave de sess&atilde;o Cliente/Servidor</i>, &eacute; enviada ao cliente contendo a marca temporal recebida na mensagem G incrementada em uma unidade.</li>&#10;<li>O cliente descriptografa a confirma&ccedil;&atilde;o utilizando a chave compartilhada com o servidor e verifica se a marca temporal est&aacute; atualizado corretamente. Se tiver, o cliente pode confiar no servidor e come&ccedil;a a pedir servi&ccedil;os ao mesmo.</li>&#10;<li>O Servidor retorna os servi&ccedil;os solicitados pelo cliente.</li></ol>&#10;<a id="Limita%C3%A7%C3%B5es_do_Kerberos" name="Limita%C3%A7%C3%B5es_do_Kerberos"></a><h2> Limita&ccedil;&otilde;es do Kerberos </h2>&#10;<p>Ponto de falha &uacute;nico: &Eacute; necess&aacute;ria uma disponibilidade cont&iacute;nua do servidor central. Quando o servidor do Kerberos est&aacute; indispon&iacute;vel, ningu&eacute;m pode mais se autenticar na rede. Isso pode ser resolvido utilizando diversos servidores Kerberos.</p>&#10;<p>O Kerberos necessita que os rel&oacute;gios internos dos clientes estejam sincronizados com o dele. Os Tickets t&ecirc;m um tempo de vida, e se o rel&oacute;gio do cliente n&atilde;o estiver sincronizado com o do servidor, a autentica&ccedil;&atilde;o ir&aacute; falhar. Na configura&ccedil;&atilde;o padr&atilde;o, &eacute; necess&aacute;rio que os rel&oacute;gios dos clientes n&atilde;o tenham uma diferen&ccedil;a maior do que 10 minutos. Na pr&aacute;tica, servidores <a href="http://en.wikipedia.org/wiki/Network_Time_Protocol" id="w">NTP</a> s&atilde;o utilizados para manter os rel&oacute;gios do servidor e dos clientes sincronizados.</p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Protocolos_de_controle_de_acesso_a_computador" id="w">Categoria:Protocolos de controle de acesso a computador</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Protocolos_de_criptografia" id="w">Categoria:Protocolos de criptografia</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Criptografia" id="w">Categoria:Criptografia</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Protocolos_de_rede" id="w">Categoria:Protocolos de rede</a></p></body></html>