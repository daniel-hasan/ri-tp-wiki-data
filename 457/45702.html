<html><title>Thread (ci&ecirc;ncia da computa&ccedil;&atilde;o)</title><body>&#10;<p> &#10; &#10;<b>Linha ou Encadeamento de execu&ccedil;&atilde;o</b> ( ), &eacute; uma forma de um <a href="http://en.wikipedia.org/wiki/Processo_(inform%C3%A1tica)" id="w">processo</a> dividir a si mesmo em duas ou mais tarefas que podem ser executadas concorrencialmente. O suporte &agrave; <i>thread</i> &eacute; fornecido pelo pr&oacute;prio <a href="http://en.wikipedia.org/wiki/Sistema_operacional" id="w">sistema operacional</a>, no caso da linha de execu&ccedil;&atilde;o ao n&iacute;vel do n&uacute;cleo ( ), ou implementada atrav&eacute;s de uma biblioteca de uma determinada <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagem</a>, no caso de uma User&shy;Level Thread (ULT). </p>&#10;<p>Uma thread permite, por exemplo, que o usu&aacute;rio de um programa utilize uma funcionalidade do <a href="http://en.wikipedia.org/wiki/GUI" id="w">ambiente</a> enquanto outras linhas de execu&ccedil;&atilde;o realizam outros c&aacute;lculos e opera&ccedil;&otilde;es. </p>&#10;<p>Em <i>hardwares</i> equipados com uma &uacute;nica <a href="http://en.wikipedia.org/wiki/Unidade_central_de_processamento" id="w">CPU</a>, cada thread &eacute; processada de forma aparentemente simult&acirc;nea, pois a mudan&ccedil;a entre uma thread e outra &eacute; feita de forma t&atilde;o r&aacute;pida que para o utilizador, isso est&aacute; acontecendo paralelamente. Em <i>hardwares</i> com m&uacute;ltiplos CPUs ou multi&shy;cores, as threads s&atilde;o realizadas realmente de forma simult&acirc;nea.</p>&#10;<p>Os sistemas que suportam uma &uacute;nica thread (em real execu&ccedil;&atilde;o) s&atilde;o chamados de <i>monothread</i> enquanto que os sistemas que suportam m&uacute;ltiplas threads s&atilde;o chamados de <i><a href="http://en.wikipedia.org/wiki/Multithread" id="w">multithread</a></i>.</p>&#10;<a id="Exemplo" name="Exemplo"></a><h2> Exemplo </h2>&#10;<p>Um exemplo simples seria um <a href="http://en.wikipedia.org/wiki/Jogo_eletr%C3%B4nico" id="w">jogo</a>, que pode ser modelado com linhas de execu&ccedil;&atilde;o diferentes, sendo uma para desenho de imagem e outra para &aacute;udio. Neste caso, h&aacute; um thread para tratar rotinas de desenho e outro thread para tratar &aacute;udio&semi; No ponto de vista do usu&aacute;rio, a imagem &eacute; desenhada ao mesmo tempo em que o &aacute;udio &eacute; emitido pelos alto&shy;falantes&semi; Por&eacute;m, para sistemas com uma &uacute;nica CPU, cada linha de execu&ccedil;&atilde;o &eacute; processada por vez.</p>&#10;<a id="Particularidades" name="Particularidades"></a><h2> Particularidades </h2>&#10;&#10;<p>Cada thread tem o mesmo <a href="http://en.wikipedia.org/wiki/Contexto_de_software" id="w">contexto de software</a> e compartilha o mesmo espa&ccedil;o de mem&oacute;ria (endere&ccedil;ado a um mesmo processo&shy;pai), por&eacute;m o <a href="http://en.wikipedia.org/wiki/Contexto_de_hardware" id="w">contexto de hardware</a> &eacute; diferente. Sendo assim o <i><a href="http://en.wikipedia.org/wiki/Overhead" id="w">overhead</a></i> causado pelo escalonamento de uma thread &eacute; muito menor do que o escalonamento de processos. Entretanto, algumas linguagens (<a href="http://en.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">C</a>, por exemplo) n&atilde;o fornecem acesso protegido &agrave; mem&oacute;ria nativa (sua implementa&ccedil;&atilde;o fica a cargo do programador ou de uma biblioteca externa) devido ao compartilhamento do espa&ccedil;o de mem&oacute;ria.</p>&#10;<p>Um dos benef&iacute;cios do uso das threads adv&eacute;m do facto do processo poder ser dividido em v&aacute;rias threads&semi; quando uma thread est&aacute; &agrave; espera de determinado dispositivo de <a href="http://en.wikipedia.org/wiki/Entrada/sa%C3%ADda" id="w">entrada/sa&iacute;da</a> ou qualquer outro recurso do sistema, o processo como um todo n&atilde;o fica parado, pois quando uma thread entra no estado de &#39&semi;bloqueio&#39&semi;, uma outra thread aguarda na fila de prontos para executar.</p>&#10;<p>Uma thread possui um conjunto de comportamentos padr&atilde;o, normalmente encontrados em qualquer implementa&ccedil;&atilde;o ou sistema operativo. </p>&#10;<p>Uma thread pode:&#10;</p>&#10;<ul>&#10;<li>criar outra da mesma forma que um processo, atrav&eacute;s do m&eacute;todo <i>thread&shy;create</i>, onde a thread retorna um <a href="http://en.wikipedia.org/wiki/ID" id="w">ID</a> como primeiro argumento (resultado da fun&ccedil;&atilde;o de cria&ccedil;&atilde;o)&semi;</li>&#10;<li>esperar outra thread se sincronizar, atrav&eacute;s do m&eacute;todo <i>join</i>&semi; </li>&#10;<li>voluntariamente &#34&semi;desistir&#34&semi; da <a href="http://en.wikipedia.org/wiki/CPU" id="w">CPU</a> por n&atilde;o precisar mais do processamento proposto pela pr&oacute;pria ou por vontade do utilizador. Feito atrav&eacute;s do m&eacute;todo <i>thread&shy;yield</i>&semi;</li>&#10;<li>replicar&shy;se sem a necessidade de duplicar todo o processo, economizando assim mem&oacute;ria, processamento da CPU e aproveitando o contexto (vari&aacute;veis, descritores, dispositivos de I/O).</li></ul>&#10;<a id="Estados_de_uma_linha_de_execu%C3%A7%C3%A3o" name="Estados_de_uma_linha_de_execu%C3%A7%C3%A3o"></a><h2> Estados de uma linha de execu&ccedil;&atilde;o </h2>&#10;<p>Uma thread pode assumir os seguintes estados:&#10;</p>&#10;<ul>&#10;<li><i>Unstarted</i>: logo ap&oacute;s ser criada (antes do <i>Start()</i>)&semi;</li>&#10;<li><i>Running</i>: ap&oacute;s ser ativada (<i>Start()</i>) ou ap&oacute;s m&eacute;todo <i>Resume()</i>&semi;</li>&#10;<li><i>Suspended</i>: ap&oacute;s m&eacute;todo <i>Suspended()</i>&semi;</li>&#10;<li><i>Stopped</i>: ap&oacute;s m&eacute;todo <i>Abort()</i>.</li></ul>&#10;<a id="ULT_e_KLT" name="ULT_e_KLT"></a><h2> ULT e KLT </h2>&#10;<p>Usualmente as threads s&atilde;o divididas em duas categorias: thread ao n&iacute;vel do utilizador ( ), e thread ao n&iacute;vel do n&uacute;cleo ( ).</p>&#10;<dl><dt>Thread em modo usu&aacute;rio</dt></dl>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:Ult.jpg" id="w">Ficheiro:Ult.jpg</a></p>&#10;<dl><dt>Thread em modo kernel</dt></dl>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:Klt.jpg" id="w">Ficheiro:Klt.jpg</a></p>&#10;<p>As threads da primeira categoria (ULT) s&atilde;o suportadas pela aplica&ccedil;&atilde;o, sem conhecimento do n&uacute;cleo e geralmente s&atilde;o implementadas por pacotes de rotinas (c&oacute;digos para criar, terminar, escalonamento e armazenar contexto) fornecidas por uma determinada biblioteca de uma linguagem, como &eacute; o caso da <code>thread.h</code> (biblioteca padr&atilde;o da <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_C" id="w">linguagem C</a>). Estas threads suportam as mesmas opera&ccedil;&otilde;es que as threads KLT (criar, sincronizar, duplicar e abortar). Possuem como vantagens a possibilidade de implementa&ccedil;&atilde;o em sistemas operativos que n&atilde;o suportam nativamente este recurso, sendo geralmente mais r&aacute;pidas e eficientes pois dispensam o acesso ao <a href="http://en.wikipedia.org/wiki/N%C3%BAcleo_(inform%C3%A1tica)" id="w">n&uacute;cleo</a>. Evita assim mudan&ccedil;a no modo de acesso, e a estrutura de dados fica no espa&ccedil;o do utilizador, levando a uma significativa queda de <i>overhead</i>, al&eacute;m de poder escolher entre as diversas formas de escalonamento em que melhor se adequa.</p>&#10;<p>A gest&atilde;o da thread (KLT) n&atilde;o &eacute; realizada atrav&eacute;s do c&oacute;digo do pr&oacute;prio programa&semi; todo o processo &eacute; subsidiado pelo SO. Esse modelo tem a vantagem de permitir o suporte a <a href="http://en.wikipedia.org/wiki/Multiprocessamento" id="w">multiprocessamento</a> e o facto do bloqueio de uma linha de execu&ccedil;&atilde;o n&atilde;o acarretar bloqueio de todo processo, n&atilde;o obstante, temos a desvantagem de ter que mudar o tipo de acesso sempre que o escalonamento for necess&aacute;rio, aumentando assim o t&atilde;o temido <i>overhead</i>.</p>&#10;<p>H&aacute; quatro opera&ccedil;&otilde;es b&aacute;sicas na gest&atilde;o de threads: criar, terminar, thread join e thread yield.</p>&#10;<dl><dt>Criar (<i>thread creation</i>)</dt></dl>&#10;<p>Basicamente uma thread pode criar outra(s), sendo que depois essas mesmas threads s&atilde;o executas &#39&semi;simultaneamente&#39&semi;. A thread criadora &eacute; a thread&shy;m&atilde;e e a thread criada &eacute; a thread&shy;filho. Threads inclu&iacute;das na <i>fun&ccedil;&atilde;o main</i> quando executadas podem criar threads&shy;filho. No diagrama a seguir h&aacute; a thread A que executa inicialmente. Mais tarde &eacute; criada a thread B indicada no ponto amarelo. Depois de criadas, a thread A e thread B executam simultaneamente. Em seguida a thread A pode criar uma ou mais threads (por exemplo uma thread C). Depois de criada a thread C, h&aacute; tr&ecirc;s threads executando simultaneamente e todas disputam o uso da CPU. Entretanto, a thread que pode ser executada a qualquer momento n&atilde;o &eacute; de conhecimento da CPU.</p>&#10;<dl><dt>Terminar (<i>thread termination</i>)</dt></dl>&#10;<p>Para maioria dos casos, as threads n&atilde;o s&atilde;o criadas e executadas eternamente. Depois de terminado o seu objectivo, a thread termina. No facto, a thread que criou estas duas threads&shy;filho termina tamb&eacute;m, porque sua tarefa atribu&iacute;da se completa. Na matrix de multiplica&ccedil;&atilde;o (<i>matrix multiplication</i>), uma vez que o valor de C[i,j] &eacute; computado, a thread correspondente termina. Em geral quando a tarefa atribu&iacute;da a thread completa, a thread pode ser terminada.&#10;Al&eacute;m disso, se a thread&shy;m&atilde;e terminar, todas as threads filho terminam tamb&eacute;m. Porque isso &eacute; importante? &#10;Isso &eacute; importante porque as threads&shy;filho compartilham recursos com a thread&shy;m&atilde;e, incluindo vari&aacute;veis. Quando a thread&shy;m&atilde;e termina, todas as vari&aacute;veis s&atilde;o perdidas e a thread&shy;filho n&atilde;o poder&aacute; aceder aos recursos que a thread&shy;m&atilde;e possuia. Assim, se a thread&shy;m&atilde;e terminar mais cedo que a thread&shy;filho haver&aacute; um problema!&#10;Uma thread pode terminar das seguintes maneiras:</p>&#10;&#10;<ul>&#10;<li>Retornando da sua rotina mais externa, a thread criadora.</li>&#10;<li>Quando termina a rotina em que foi come&ccedil;ada. </li>&#10;<li>Chamando pthread_exit, fornecendo um estado de sa&iacute;da.</li>&#10;<li>Terminando atrav&eacute;s da fun&ccedil;&atilde;o pthread_cancel</li></ul>&#10;<dl><dt>Sincronizar(<i>Thread Join</i>)</dt></dl>&#10;<p>Imagine a seguinte situa&ccedil;&atilde;o:&#10;Voc&ecirc; est&aacute; estudando para uma prova. Ent&atilde;o voc&ecirc; pede o seu irm&atilde;o mais novo para comprar uma pizza. Neste caso voc&ecirc; &eacute; a thread principal e seu irm&atilde;o a thread&shy;filho. Uma vez que voc&ecirc; deu a ordem, voc&ecirc; e seu irm&atilde;o come&ccedil;am a &ldquo;executar uma tarefa&rdquo; simultaneamente. Agora h&aacute; dois casos a se considerar:&#10;Primeiro: Seu irm&atilde;o traz a pizza e termina enquanto voc&ecirc; estuda. Nesse caso voc&ecirc; pode parar de estudar e comer a pizza.&#10;Segundo: Voc&ecirc; acaba de estudar mais cedo e dorme e depois a pizza chegar&aacute;.</p>&#10;<p>A jun&ccedil;&atilde;o de threads (thread join) &eacute; destinada para resolver este problema. A thread pode executar o <i>thread join</i> e aguardar at&eacute; a outra thread terminar. No caso acima, voc&ecirc; &eacute; a thread principal (<i>thread main</i>) e deve executar o <i>thread join</i>aguardando o seu irm&atilde;o (thread&shy;filho) terminar.&#10;Em geral o <i>thread join</i> &eacute; utilizado para a thread&shy;m&atilde;e se sincronizar com uma das threads&shy;filho.</p>&#10;<dl><dt>Thread Yield (Rendimento da thread)</dt></dl>&#10;<p>Suponha que voc&ecirc; executa um certo n&uacute;mero de programas o tempo todo no computador. Isso &eacute; poss&iacute;vel devido a CPU escalonar pouco a pouco outros ciclos da CPU, assim outros programas podem ser executados. Isso pode ser um problema de pol&iacute;tica de planeamento do Sistema Operativo. Entretanto, quando escrevemos programas com m&uacute;ltiplas threads, temos que fazer correctamente para que algumas threads n&atilde;o ocupem a CPU eternamente, ou por um tempo muito longo sem abandon&aacute;&shy;lo. Sen&atilde;o terminar na situa&ccedil;&atilde;o acima quando uma ou duas threads executam enquanto outras simplesmente esperam para retornar. Liberamos espa&ccedil;o na mem&oacute;ria gra&ccedil;as a <i>thread yield</i>.&#10;Quando a thread executa o <i>thread yield</i>, a execu&ccedil;&atilde;o da thread &eacute; suspensa e a CPU passa para uma outra thread em execu&ccedil;&atilde;o. Essa thread aguardar&aacute; at&eacute; a CPU tornar&shy;se dispon&iacute;vel novamente.</p>&#10;<a id="Escalonamento" name="Escalonamento"></a><h2> Escalonamento </h2>&#10;<p>Da mesma forma que os processos sofrem escalonamento, as threads tamb&eacute;m t&ecirc;m a mesma necessidade. Quando v&aacute;rios processos s&atilde;o executados em uma CPU, eles d&atilde;o a impress&atilde;o que est&atilde;o sendo executados simultaneamente. Com as threads ocorre o mesmo, elas esperam at&eacute; serem executadas. Como esta altern&acirc;ncia &eacute; muito r&aacute;pida, h&aacute; impress&atilde;o de que todas as threads s&atilde;o executadas paralelamente.</p>&#10;<dl><dt>Linha de execu&ccedil;&atilde;o ao n&iacute;vel do usu&aacute;rio</dt></dl>&#10;<p>As ULT s&atilde;o escalonadas pelo programador, tendo a grande vantagem de cada processo usar um algoritmo de escalonamento que melhor se adapte a situa&ccedil;&atilde;o, o sistema operacional neste tipo de thread n&atilde;o faz o escalonamento, em geral ele n&atilde;o sabe que elas existem. Neste modo o programador &eacute; respons&aacute;vel por criar, executar, escalonar e destruir a thread. Um exemplo pr&aacute;tico de processo chamado P1 que cont&eacute;m tais threads: P1T1, P1T2 e P1T3, quando o sistema operacinal da a CPU para o processo P1 cabe a ele destinar qual thread ser&aacute; executada, caso esta thread use todo processo do quantum, o sistema operacional chamar&aacute; outro processo, e quando o processo P1 voltar a executar, P1T1 voltar&aacute; a ser executada e continuar&aacute; executando at&eacute; seu t&eacute;rmino ou interven&ccedil;&atilde;o de P1, este comportamento n&atilde;o afetar&aacute; outros processos pois o sistema continua escalonando os processos normalmente.</p>&#10;<dl><dt>Linha de execu&ccedil;&atilde;o ao n&iacute;vel do n&uacute;cleo</dt></dl>&#10;<p>As KLT s&atilde;o escalonadas diretamente pelo sistema operacional, comumente s&atilde;o mais lentas que as Threads ULT pois a cada chamada elas necessitam consultar o sistema, exigindo assim a mudan&ccedil;a total de contexto do processador, mem&oacute;ria e outros n&iacute;veis necess&aacute;rios para alternar um processo. Um exemplo pr&aacute;tico de processo chamado P2 que cont&eacute;m as threads P2T1, P2T2 e P2T3 e um processo chamado P3 que cont&eacute;m as threads P3T1, P3T2 E P3T3. O Sistema Operacional n&atilde;o entregar&aacute; a CPU ao processo e sim a uma thread deste processo, note agora que o sistema &eacute; respons&aacute;vel por escalonar as threads e este sistema tem que suportar threads, a cada interrup&ccedil;&atilde;o de thread &eacute; necess&aacute;rio mudar todo o contexto de CPU e mem&oacute;ria, por&eacute;m as threads s&atilde;o independentes dos processos, podendo ser executadas P3T2, P2T1, P2T2, P2T1, P3T1,P2T3,P3T3, ou seja a ordem em que o escalonador do sistema determinar. J&aacute; com as threads em modo usu&aacute;rio n&atilde;o se consegue ter a mesma independ&ecirc;ncia, pois quando passamos o controle ao processo, enquanto seu quantum for v&aacute;lido ele ir&aacute; decidir que thread ir&aacute; rodar. Um escalonamento t&iacute;pico do sistema &eacute; onde o escalonador sempre escolhe a thread de maior prioridade, que s&atilde;o divididas em duas classes: Real Time e Normal. Cada thread ganha uma prioridade ao ser criada que varia de 0 a 31(0 &eacute; a menor e 31 maior), processos com prioridade 0 a 15(Real Time) tem prioridade ajustada no tempo de execu&ccedil;&atilde;o como nos processos de E/S que tem a prioridade aumentada variando o perif&eacute;rico, processos com prioridade 16 a 31 s&atilde;o executados at&eacute; terminar e n&atilde;o tem prioridade alterada, mas somente uma thread recebe a prioridade zero que &eacute; a respons&aacute;vel por zerar p&aacute;ginas livres no sistema. Existe ainda uma outra classe chamada de <i>idle</i>, uma classe mais baixa ainda, s&oacute; &eacute; executada quando n&atilde;o existem threads aptas, threads dessa classe n&atilde;o interferem na performance.</p>&#10;<a id="Compara%C3%A7%C3%A3o_entre_linha_de_execu%C3%A7%C3%A3o_e_Processo" name="Compara%C3%A7%C3%A3o_entre_linha_de_execu%C3%A7%C3%A3o_e_Processo"></a><h2> Compara&ccedil;&atilde;o entre linha de execu&ccedil;&atilde;o e Processo </h2>&#10;<p>Um sistema baseado em linha de execu&ccedil;&atilde;o &eacute; diferente de um <a href="http://en.wikipedia.org/wiki/Sistema_operacional" id="w">sistema operacional</a> multi&shy;tarefa tradicional, em que processos s&atilde;o tipicamente independentes, carregam consider&aacute;vel estado da informa&ccedil;&atilde;o, tem <a href="http://en.wikipedia.org/wiki/Endere%C3%A7o_de_mem%C3%B3ria" id="w">endere&ccedil;o de mem&oacute;ria</a> separado e interagem somente atrav&eacute;s de mecanismos de <a href="http://en.wikipedia.org/wiki/Inter&shy;Process_Communication" id="w">inter&shy;processos de comunica&ccedil;&atilde;o</a>. As <i>threads</i>, por outro lado, compartilham o estado da informa&ccedil;&atilde;o de processos &uacute;nicos, e compartilham mem&oacute;ria e outros recursos diretamente.</p>&#10;<p>A troca de contexto atrav&eacute;s de linha de execu&ccedil;&atilde;o num mesmo processo &eacute; tipicamente mais r&aacute;pida que a troca de contexto entre processos diferentes. Sistemas como o <a href="http://en.wikipedia.org/wiki/Windows_NT" id="w">Windows NT</a> e o <a href="http://en.wikipedia.org/wiki/OS/2" id="w">OS/2</a> s&atilde;o feitos para ter linha de execu&ccedil;&atilde;o &#34&semi;baratas&#34&semi; e processos &#34&semi;caros&#34&semi;, enquanto em outros sistemas operacionais n&atilde;o h&aacute; grandes diferen&ccedil;as.</p>&#10;<p>O <i>multithreading</i> &eacute; um modelo de programa&ccedil;&atilde;o popular que permite a execu&ccedil;&atilde;o de m&uacute;ltiplas linha de execu&ccedil;&atilde;o dentro de um contexto simples, compartilhando recursos do processo, e capazes de executar de forma independente. O modelo de programa&ccedil;&atilde;o em linha de execu&ccedil;&atilde;o fornece ao desenvolvedor uma execu&ccedil;&atilde;o simult&acirc;nea. Entretanto, a aplica&ccedil;&atilde;o mais interessante da tecnologia ocorre quando ela &eacute; utilizada em um processo simples permitindo uma execu&ccedil;&atilde;o paralela em <a href="http://en.wikipedia.org/wiki/Multiprocessamento" id="w">sistemas multi&shy;processados</a>.</p>&#10;<p>Um sistema <i>multi&shy;threaded</i> possui um melhor desempenho que um sistema de computadores com m&uacute;ltiplas <a href="http://en.wikipedia.org/wiki/CPU" id="w">CPUs</a> e com m&uacute;ltiplos n&uacute;cleos, ou que um <i><a href="http://en.wikipedia.org/wiki/Cluster" id="w">cluster</a></i> de m&aacute;quinas. Isto acontece porque a linha de execu&ccedil;&atilde;o empresta a ela mesma uma execu&ccedil;&atilde;o simult&acirc;nea. Em alguns casos, o programador precisa ter cuidado em evitar condi&ccedil;&otilde;es de concorr&ecirc;ncia e outros comportamentos inesperados.</p>&#10;<p>Para um dado ser manipulado corretamente, as linhas de execu&ccedil;&atilde;o freq&uuml;entemente precisar&atilde;o ser sincronizadas, para que os dados sejam processados na ordem correta. As linha de execu&ccedil;&atilde;o podem tamb&eacute;m executar opera&ccedil;&otilde;es at&ocirc;micas (freq&uuml;entemente implementadas usando sem&aacute;foros) com intuito de prevenir que dados comuns sejam simultaneamente modificados ou lidos enquanto o processo esta sendo modificado.</p>&#10;<p>Os sistemas operacionais implementam as linhas de execu&ccedil;&atilde;o de duas formas: <i>multithreading</i> preemptiva ou <i>multithreading</i>cooperativa. A <i>multithreading</i> preemptiva &eacute; geralmente considerada uma implementa&ccedil;&atilde;o superior, porque permite ao sistema determinar quando uma troca de contexto pode acontecer. A <i>multithreading</i> cooperativa, por outro lado, confia nas <i>threads</i>para ceder o controle, o que pode ser um problema caso uma tarefa &ldquo;monopolize&rdquo; o uso da CPU ou se houver espera pela disponibilidade de um recurso. A desvantagem da <i>multithread</i> preemptiva &eacute; que o sistema pode fazer uma troca em um tempo inapropriado, causando uma invers&atilde;o de prioridade ou outros efeitos ruins que podem ser evitados por uma <i>multithreading</i>cooperativa.</p>&#10;<p>Em geral:&#10;</p>&#10;<ul>&#10;<li>Criar um processo pode ser caro em termos de tempo, mem&oacute;ria, e <i>sincroniza&ccedil;&atilde;o entre processos</i>.</li>&#10;<li>As linhas de execu&ccedil;&atilde;o podem ser criadas sem a replica&ccedil;&atilde;o do processo inteiro.</li>&#10;<li>O trabalho de criar uma linha de execu&ccedil;&atilde;o pode ser feito no espa&ccedil;o do usu&aacute;rio. </li>&#10;<li>Como as linhas de execu&ccedil;&atilde;o partilham o espa&ccedil;o de endere&ccedil;amento a comunica&ccedil;&atilde;o entre elas &eacute; mais r&aacute;pida.</li>&#10;<li>O tempo gasto para troca de linha de execu&ccedil;&atilde;o &eacute; menor, em parte por que n&atilde;o h&aacute; necessidade de troca de espa&ccedil;o de endere&ccedil;amento.</li></ul>&#10;<a id="Modelo_de_Gera%C3%A7%C3%A3o_de_Multithreads" name="Modelo_de_Gera%C3%A7%C3%A3o_de_Multithreads"></a><h2> Modelo de Gera&ccedil;&atilde;o de Multithreads </h2>&#10;&#10;<dl><dt>Modelo Muitos&shy;Para&shy;Um</dt></dl>&#10;<p>O modelo muitos&shy;para&shy;um mapeia muitos threads de n&iacute;vel de usu&aacute;rio para threads do kernel. O gerenciamento dos threads &eacute; realizado no espa&ccedil;o do usu&aacute;rio e assim &eacute; eficiente, mas o processo inteiro ficar&aacute; bloqueado. Al&eacute;m disso, como somente um thread pode acessar o kernel de cada vez, m&uacute;ltiplos threads s&atilde;o incapazes de executar em paralelo em multiprocessadores.<sup id="_ref&shy;Multithreads_a" class="reference"><a href="#_note&shy;Multithreads" title="">[1]</a></sup></p>&#10;<dl><dt>Modelo Um&shy;Para&shy;Um</dt></dl>&#10;<p>O modelo um&shy;para&shy;um mapeia cada thread de usu&aacute;rio para um thread de kernel, gera mais concorr&ecirc;ncia do que o modelo muitos&shy;para&shy;um. Permite a um outro thread ser executado, enquanto um thread realiza uma chamada de sistema de bloqueio, ele tamb&eacute;m permite que m&uacute;ltiplos threads executem em paralelo em multiprocessadores. A &uacute;nica desvantagem deste modelo &eacute; que a cria&ccedil;&atilde;o de um thread de usu&aacute;rio requer a cria&ccedil;&atilde;o do correspondente thread de kernel.<sup id="_ref&shy;Multithreads_b" class="reference"><a href="#_note&shy;Multithreads" title="">[1]</a></sup></p>&#10;<dl><dt>Modelo Muitos&shy;Para&shy;Muitos</dt></dl>&#10;<p>O modelo muitos&shy;para&shy;muitos multiplexa muitos threads de n&iacute;vel de usu&aacute;rio para um n&uacute;mero menor ou igual de threads de kernel. O n&uacute;mero de threads de kernel pode ser espec&iacute;fico tanto para uma aplica&ccedil;&atilde;o em particular quanto para uma m&aacute;quina em particular. Os desenvolvedores podem criar tantos threads de usu&aacute;rio quantos forem necess&aacute;rios, e os correspondentes threads de kernel podem executar em paralelo em um multiprocessador. Al&eacute;m disso, quando um thread realiza uma chamada de sistema de bloqueio, o kernel pode agendar um outro thread para execu&ccedil;&atilde;o.<sup id="_ref&shy;Multithreads_c" class="reference"><a href="#_note&shy;Multithreads" title="">[1]</a></sup></p>&#10;<a id="Cancelamento" name="Cancelamento"></a><h2> Cancelamento </h2>&#10;<p>O cancelamento de threads corresponde &agrave; tarefa de terminar um thread antes que se complete. Por exemplo, se m&uacute;ltiplos threads est&atilde;o pesquisando concorrentemente em um banco de dados e um thread retorna o resultado, os threads que ainda est&atilde;o sendo executados podem ser cancelados. Uma outra situa&ccedil;&atilde;o pode ocorrer quando um usu&aacute;rio pressionar um bot&atilde;o em um navegador da Web. Com frequ&ecirc;ncia, uma p&aacute;gina da Web &eacute; carregada em um thread separado. Quando um usu&aacute;rio pressionar o bot&atilde;o stop, o thread que estava carregando a p&aacute;gina &eacute; cancelado. Um thread que est&aacute; para ser cancelado &eacute; frequ&ecirc;ntemente denominado thread&shy;alvo.<sup id="_ref&shy;Multithreads_d" class="reference"><a href="#_note&shy;Multithreads" title="">[1]</a></sup></p> &#10;<a id="Exemplos" name="Exemplos"></a><h2> Exemplos </h2>&#10;<a id="%5B%5BJava_(linguagem_de_programa%C3%A7%C3%A3o)%7CJava%5D%5D" name="%5B%5BJava_(linguagem_de_programa%C3%A7%C3%A3o)%7CJava%5D%5D"></a><h3> [[Java (linguagem de programa&ccedil;&atilde;o)|Java]] </h3>&#10;<p /><pre class="code">&#10;<b><font color="#7F0055">import</font></b> java.io.*&semi;&#10;<b><font color="#7F0055">public</font></b> <b><font color="#7F0055">class</font></b> Example <b><font color="#7F0055">implements</font></b> Runnable&#10;{&#10;  <b><font color="#7F0055">static</font></b> Thread threadCalculate&semi; <font color="#3F7F5F">// Cria o thread.&#10;</font>  <b><font color="#7F0055">static</font></b> Thread threadListen&semi;&#10;  <b><font color="#7F0055">long</font></b> totalPrimesFound = 0&semi;&#10;    &#10;  <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">static</font></b> <b><font color="#7F0055">void</font></b> main (String[] args)&#10;  {&#10;      Example e = <b><font color="#7F0055">new</font></b> Example()&semi;&#10;      &#10;      threadCalculate = <b><font color="#7F0055">new</font></b> Thread(e)&semi;&#10;      threadListen = <b><font color="#7F0055">new</font></b> Thread(e)&semi;&#10;      &#10;      threadCalculate.start()&semi;&#10;      threadListen.start()&semi;&#10;  }&#10;  &#10;  <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> run()&#10;  {&#10;      Thread currentThread = Thread.currentThread()&semi;&#10;      &#10;      <b><font color="#7F0055">if</font></b> (currentThread == threadCalculate)&#10;          calculatePrimes()&semi;&#10;      <b><font color="#7F0055">else</font></b> <b><font color="#7F0055">if</font></b> (currentThread == threadListen)&#10;          listenForStop()&semi;&#10;  }&#10;  &#10;  <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> calculatePrimes()&#10;  {&#10;      <b><font color="#7F0055">int</font></b> n = 1&semi;&#10;     &#10;      <b><font color="#7F0055">while</font></b> (<b><font color="#7F0055">true</font></b>)&#10;      {&#10;          n++&semi;&#10;          <b><font color="#7F0055">boolean</font></b> isPrime = <b><font color="#7F0055">true</font></b>&semi;&#10;         &#10;          <b><font color="#7F0055">for</font></b> (<b><font color="#7F0055">int</font></b> i = 2&semi; i &#60&semi; n&semi; i++)&#10;              <b><font color="#7F0055">if</font></b> ((n / i) * i == n)&#10;              {&#10;                  isPrime = <b><font color="#7F0055">false</font></b>&semi;&#10;                  <b><font color="#7F0055">break</font></b>&semi;&#10;              }&#10;         &#10;          <b><font color="#7F0055">if</font></b> (isPrime)&#10;          {&#10;              totalPrimesFound++&semi;&#10;              System.out.println(n)&semi;&#10;          }&#10;      } &#10;  }&#10;  &#10;  <b><font color="#7F0055">private</font></b> <b><font color="#7F0055">void</font></b> listenForStop()&#10;  {&#10;      BufferedReader input = <b><font color="#7F0055">new</font></b> BufferedReader(<b><font color="#7F0055">new</font></b> InputStreamReader(System.in))&semi;&#10;      String line = <font color="#2A00FF">&#34&semi;&#34&semi;</font>&semi;&#10;      &#10;      <b><font color="#7F0055">while</font></b> (!line.equals(<font color="#2A00FF">&#34&semi;stop&#34&semi;</font>))&#10;      {&#10;          <b><font color="#7F0055">try</font></b>&#10;          {&#10;              line = input.readLine()&semi;&#10;          }&#10;          <b><font color="#7F0055">catch</font></b> (IOException exception) {}&#10;      }&#10;      &#10;      System.out.println(<font color="#2A00FF">&#34&semi;Found &#34&semi;</font> + totalPrimesFound +&#10;          <font color="#2A00FF">&#34&semi; prime numbers before you said stop&#34&semi;</font>)&semi;&#10;      System.exit(0)&semi;&#10;  }&#10;}&#10;</pre>&#10;&#10;<a id="%5B%5BJava_(linguagem_de_programa%C3%A7%C3%A3o)%7CJava%5D%5D%2C_exemplo_simples_em_portugu%C3%AAs" name="%5B%5BJava_(linguagem_de_programa%C3%A7%C3%A3o)%7CJava%5D%5D%2C_exemplo_simples_em_portugu%C3%AAs"></a><h3>[[Java (linguagem de programa&ccedil;&atilde;o)|Java]], exemplo simples em portugu&ecirc;s</h3>&#10;<p /><pre class="code">&#10;<b><font color="#7F0055">import</font></b> java.util.logging.Level&semi;&#10;<b><font color="#7F0055">import</font></b> java.util.logging.Logger&semi;&#10;&#10;<b><font color="#7F0055">class</font></b> Threaded <b><font color="#7F0055">extends</font></b> Thread {&#10;    &#10;    Synchronized1 base&semi;&#10;    &#10;    <b><font color="#7F0055">public</font></b> Threaded( Synchronized1 bse ) {&#10;        <b><font color="#7F0055">this</font></b>.base = bse&semi;&#10;    }&#10;    &#10;}&#10;&#10;<b><font color="#7F0055">public</font></b> <b><font color="#7F0055">class</font></b> Synchronized1 {&#10;&#10;    <b><font color="#7F0055">public</font></b> Synchronized1() {&#10;    }&#10;    &#10;    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> ini() {&#10;        <b><font color="#7F0055">new</font></b> Threaded( <b><font color="#7F0055">this</font></b> ) {&#10;            <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> run() {&#10;                <b><font color="#7F0055">while</font></b>( <b><font color="#7F0055">true</font></b> ) {&#10;                    <b><font color="#7F0055">synchronized</font></b>( base ) {&#10;                        System.out.print( <font color="#2A00FF">&#34&semi;Este &eacute; A, agora vai mostrar B.\n&#34&semi;</font> )&semi;&#10;                        <b><font color="#7F0055">try</font></b> {&#10;                        Thread.sleep(1000)&semi;&#10;                    } <b><font color="#7F0055">catch</font></b> (InterruptedException ex) {&#10;                        Logger.getLogger(Synchronized1.<b><font color="#7F0055">class</font></b>.getName()).log(Level.SEVERE, <b><font color="#7F0055">null</font></b>, ex)&semi;&#10;                    }&#10;                        <b><font color="#7F0055">try</font></b> {&#10;                            base.notify()&semi;&#10;                            base.wait()&semi;&#10;                        } <b><font color="#7F0055">catch</font></b> (InterruptedException ex) {&#10;                            Logger.getLogger(Synchronized1.<b><font color="#7F0055">class</font></b>.getName()).log(Level.SEVERE, <b><font color="#7F0055">null</font></b>, ex)&semi;&#10;                        }&#10;                    }&#10;                    &#10;                }&#10;            }&#10;        }.start()&semi;&#10;        &#10;        &#10;        <b><font color="#7F0055">new</font></b> Threaded( <b><font color="#7F0055">this</font></b> ) {&#10;            <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> run() {&#10;                <b><font color="#7F0055">while</font></b>( <b><font color="#7F0055">true</font></b> ) {&#10;                    <b><font color="#7F0055">synchronized</font></b>( base ) {&#10;                        System.out.print( <font color="#2A00FF">&#34&semi;Este &eacute; B, ent&atilde;o foi j&aacute; mostrado A.\n&#34&semi;</font> )&semi;&#10;                          <b><font color="#7F0055">try</font></b> {&#10;                        Thread.sleep(1000)&semi;&#10;                    } <b><font color="#7F0055">catch</font></b> (InterruptedException ex) {&#10;                        Logger.getLogger(Synchronized1.<b><font color="#7F0055">class</font></b>.getName()).log(Level.SEVERE, <b><font color="#7F0055">null</font></b>, ex)&semi;&#10;                    }&#10;                          <b><font color="#7F0055">try</font></b> {&#10;                            base.notify()&semi;&#10;                            base.wait()&semi;&#10;                        } <b><font color="#7F0055">catch</font></b> (InterruptedException ex) {&#10;                            Logger.getLogger(Synchronized1.<b><font color="#7F0055">class</font></b>.getName()).log(Level.SEVERE, <b><font color="#7F0055">null</font></b>, ex)&semi;&#10;                        }&#10;                    }&#10;                  &#10;                }&#10;            }&#10;        }.start()&semi;&#10;    }&#10;    &#10;    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">static</font></b> <b><font color="#7F0055">void</font></b> main(String[] args) {&#10;        <b><font color="#7F0055">new</font></b> Synchronized1().ini()&semi;&#10;    }&#10;}&#10;</pre>&#10;&#10;<a id="%5B%5BC_(linguagem_de_programa%C3%A7%C3%A3o)%7CC%5D%5D" name="%5B%5BC_(linguagem_de_programa%C3%A7%C3%A3o)%7CC%5D%5D"></a><h3> [[C (linguagem de programa&ccedil;&atilde;o)|C]] </h3>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table style="float:right&semi; margin:1em 1em 1em 1em&semi; width:25em&semi; border: 1px solid #a0a0a0&semi; padding: 10px&semi; background&shy;color: #F5F5F5&semi; text&shy;align:left&semi;">&#10;<tr style="text&shy;align:center&semi; font&shy;size:normal&semi;">&#10;<td><b>Notas</b></td></tr>&#10;<tr style="text&shy;align:left&semi; font&shy;size:8pt&semi; text&shy;align:justify&semi;">&#10;<td>Esta implementa&ccedil;&atilde;o depende do uso da biblioteca <a href="http://en.wikipedia.org/wiki/POSIX_Threads" id="w">POSIX Threads</a>.</td></tr></table></div>&#10;<p />&#10;&#10;<a id="%5B%5BC%2B%2B%5D%5D" name="%5B%5BC%2B%2B%5D%5D"></a><h3> [[C++]] </h3>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table style="float:right&semi; margin:1em 1em 1em 1em&semi; width:25em&semi; border: 1px solid #a0a0a0&semi; padding: 10px&semi; background&shy;color: #F5F5F5&semi; text&shy;align:left&semi;">&#10;<tr style="text&shy;align:center&semi; font&shy;size:normal&semi;">&#10;<td><b>Notas</b></td></tr>&#10;<tr style="text&shy;align:left&semi; font&shy;size:8pt&semi; text&shy;align:justify&semi;">&#10;<td>Esta implementa&ccedil;&atilde;o depende do uso da biblioteca <a href="http://en.wikipedia.org/wiki/Boost" id="w">Boost</a>.</td></tr></table></div>&#10;<p />&#10;&#10;<a id="%5B%5BRuby_(linguagem_de_programa%C3%A7%C3%A3o)%7CRuby%5D%5D" name="%5B%5BRuby_(linguagem_de_programa%C3%A7%C3%A3o)%7CRuby%5D%5D"></a><h3> [[Ruby (linguagem de programa&ccedil;&atilde;o)|Ruby]] </h3>&#10;<p />&#10;&#10;<a id="%5B%5BCodeGear_Delphi%7CDelphi%5D%5D" name="%5B%5BCodeGear_Delphi%7CDelphi%5D%5D"></a><h3> [[CodeGear Delphi|Delphi]] </h3>&#10;<p />&#10;&#10;<p> </p>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Tecnologia_dos_sistemas_operacionais" id="w">Categoria:Tecnologia dos sistemas operacionais</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Computa%C3%A7%C3%A3o_concorrente" id="w">Categoria:Computa&ccedil;&atilde;o concorrente</a></p></body></html>