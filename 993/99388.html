<html><title>VHDL</title><body>&#10;<p><b>VHDL</b> ou &#34&semi;<a href="http://en.wikipedia.org/wiki/VHSIC" id="w">&#39&semi;&#39&semi;&#39&semi;V&#39&semi;&#39&semi;&#39&semi;HSIC</a> <a href="http://en.wikipedia.org/wiki/Linguagem_de_Descri%C3%A7%C3%A3o_de_Hardware" id="w">&#39&semi;&#39&semi;&#39&semi;H&#39&semi;&#39&semi;&#39&semi;ardware &#39&semi;&#39&semi;&#39&semi;D&#39&semi;&#39&semi;&#39&semi;escription &#39&semi;&#39&semi;&#39&semi;L&#39&semi;&#39&semi;&#39&semi;anguage</a>&#34&semi; (Linguagem de descri&ccedil;&atilde;o de hardware VHSIC &#34&semi;<a href="http://en.wikipedia.org/wiki/VHSIC" id="w">&#39&semi;&#39&semi;&#39&semi;V&#39&semi;&#39&semi;&#39&semi;ery &#39&semi;&#39&semi;&#39&semi;H&#39&semi;&#39&semi;&#39&semi;igh &#39&semi;&#39&semi;&#39&semi;S&#39&semi;&#39&semi;&#39&semi;peed &#39&semi;&#39&semi;&#39&semi;I&#39&semi;&#39&semi;&#39&semi;ntegrated &#39&semi;&#39&semi;&#39&semi;C&#39&semi;&#39&semi;&#39&semi;ircuits</a>&#34&semi;) &eacute; uma linguagem usada para facilitar o design (projeto/concep&ccedil;&atilde;o) de circuitos digitais em CPLDs, <a href="http://en.wikipedia.org/wiki/FPGA" id="w">FPGAs</a> e <a href="http://en.wikipedia.org/wiki/ASIC" id="w">ASICs</a>.</p>&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2> Hist&oacute;ria </h2>&#10;<p>A linguagem VHDL foi originalmente desenvolvida sob o comando do <a href="http://en.wikipedia.org/wiki/Departamento_de_Defesa" id="w">Departamento de Defesa</a> dos <a href="http://en.wikipedia.org/wiki/Estados_Unidos" id="w">Estados Unidos</a> (<a href="http://en.wikipedia.org/wiki/DARPA" id="w">DARPA</a>), em meados da d&eacute;cada de 1980, para documentar o comportamento de <a href="http://en.wikipedia.org/wiki/ASIC" id="w">ASICs</a> que compunham os equipamentos vendidos &agrave;s <a href="http://en.wikipedia.org/wiki/For%C3%A7as_Armadas" id="w">For&ccedil;as Armadas</a> americanas. Isto quer dizer que a linguagem VHDL foi desenvolvida para substituir os complexos manuais que descreviam o funcionamento dos ASICs. At&eacute; aquele momento, a &uacute;nica metodologia largamente utilizada no projeto de circuitos era a cria&ccedil;&atilde;o atrav&eacute;s de <a href="http://en.wikipedia.org/wiki/Diagramas_esquem%C3%A1ticos" id="w">diagramas esquem&aacute;ticos</a>. O problema com esta metodologia &eacute; o fato de que desenho tem menor portabilidade, s&atilde;o mais complexos para compreens&atilde;o e s&atilde;o extremamente dependentes da ferramenta utilizada para produzi&shy;los.</p>&#10;<p>Uma vez que o projeto VHSIC era de alta prioridade militar e havia dezenas de fornecedores envolvidos, o <a href="http://en.wikipedia.org/wiki/DoD" id="w">DoD</a> estava preocupado principalmente com as quest&otilde;es de portabilidade, documenta&ccedil;&atilde;o e compreensibilidade dos projetos. Cada um destes fornecedores atuava desenvolvendo partes dos projetos ou mesmo fornecendo componentes que viriam a se encaixar em outros sistemas maiores. Desta forma o DoD optou por buscar desenvolver uma linguagem que servisse como base para troca de informa&ccedil;&otilde;es sobre estes componentes e projetos. Uma linguagem que, independente do formato original do circuito, pudesse servir como uma descri&ccedil;&atilde;o e documenta&ccedil;&atilde;o eficientes do circuito, possibilitando os mais diferentes fornecedores e participantes a entender o funcionamento das outras partes, padronizando a comunica&ccedil;&atilde;o.</p>&#10;<p>O desenvolvimento da VHDL serviu inicialmente aos prop&oacute;sitos de documenta&ccedil;&atilde;o do projeto VHSIC. Entretanto, nesta &eacute;poca buscava&shy;se uma linguagem que facilitasse o projeto de um circuito&semi; ou seja, a partir de uma descri&ccedil;&atilde;o textual, um algoritmo, desenvolver o circuito, sem necessidade de especificar explicitamente as liga&ccedil;&otilde;es entre componentes. A VHDL presta&shy;se adequadamente a tais prop&oacute;sitos, podendo ser utilizada para as tarefas de documenta&ccedil;&atilde;o, descri&ccedil;&atilde;o, <a href="http://en.wikipedia.org/wiki/S%C3%ADntese" id="w">s&iacute;ntese</a>, <a href="http://en.wikipedia.org/wiki/Simula%C3%A7%C3%A3o" id="w">simula&ccedil;&atilde;o</a>, teste, verifica&ccedil;&atilde;o formal e ainda compila&ccedil;&atilde;o de software, em alguns casos.</p>&#10;<p>Ap&oacute;s o sucesso inicial do uso da VHDL, a sua defini&ccedil;&atilde;o foi posta em dom&iacute;nio p&uacute;blico, o que levou a ser padronizada pelo <a href="http://en.wikipedia.org/wiki/Instituto_de_Engenheiros_Eletricistas_e_Eletr%C3%B4nicos" id="w">IEEE (Institute of Electrical and Electronic Engineers)</a> em 1987. O fato de ser padronizada e de dom&iacute;nio p&uacute;blico ampliou ainda mais a sua utiliza&ccedil;&atilde;o, novas altera&ccedil;&otilde;es foram propostas, como &eacute; natural num processo de aprimoramento e a linguagem sofreu uma revis&atilde;o e um novo padr&atilde;o mais atualizado foi lan&ccedil;ado em 1993. Pequenas altera&ccedil;&otilde;es foram feitas em 2000 e 2002. Em setembro de 2008 foi aprovado pelo REVCOM a mais recente vers&atilde;o, IEEE 1076&shy;2008.</p>&#10;<p>Existe tamb&eacute;m ramifica&ccedil;&otilde;es desse padr&atilde;o, a saber:&#10;</p>&#10;<ul>&#10;<li>IEEE 1076.1 VHDL anal&oacute;gica e de sinal misto </li>&#10;<li>IEEE 1076.1.1 VHDL&shy;AMS pacotes padr&atilde;o (stdpkgs) </li>&#10;<li>IEEE 1076.2 VHDL pacotes matem&aacute;ticos (math) </li>&#10;<li>IEEE 1076.3 VHDL pacotes sintetizado (vhdlsynth) </li>&#10;<li>IEEE 1076.3 VHDL pacotes sintetizado &shy; Ponto flutuante (fphdl) </li>&#10;<li>IEEE 1076.4 VHDL bibliotecas para ASIC: vital </li>&#10;<li>IEEE 1076.6 VHDL s&iacute;ntese de interoperabilidade</li>&#10;<li>IEEE 1164 VHDL pacote com multi valores l&oacute;gicos (std_logic_1164)</li></ul>&#10;<a id="Sintaxe" name="Sintaxe"></a><h2> Sintaxe </h2>&#10;<p>A linguagem VHDL n&atilde;o &eacute; case&shy;sensitive e tem uma sintaxe similar &agrave;s linguagens <a href="http://en.wikipedia.org/wiki/Pascal_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Pascal</a> e da linguagem <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_Ada" id="w">ADA</a>.</p>&#10;<a id="Estrutura" name="Estrutura"></a><h3> Estrutura </h3>&#10;<a id="Coment%C3%A1rios" name="Coment%C3%A1rios"></a><h4> Coment&aacute;rios </h4>&#10;<p>S&atilde;o iniciados com dois tra&ccedil;os &#34&semi;&shy;&shy;&#34&semi; e terminam no final da linha.</p>&#10;<a id="Entity" name="Entity"></a><h4> Entity </h4>&#10;<p>&Eacute; a parte principal do projeto, &eacute; a interface do Sistema que descreve as entradas e sa&iacute;das. Composta de duas partes: <i>parameters</i> e <i>connections</i>. <i>Parameters</i> refere&shy;se aos par&acirc;metros, exemplo largura de barramento, s&atilde;o declarados como <i>generics</i>. <i>Connections</i> por sua vez, refere&shy;se como ocorre a transfer&ecirc;ncia de informa&ccedil;&otilde;es, s&atilde;o declarados como <i>ports</i>.</p>&#10;<p>O nome de uma <i>entity</i> deve identificar o sistema, podendo usar letras e n&uacute;meros, porem deve iniciar por uma letra.</p>&#10;<p>Exemplo de <i>entity</i>:&#10;</p>&#10;<pre>&#10;entity ORGATE is&#10;   &hellip;&#10;end ORGATE&semi;&#10;</pre>&#10;&#10;<a id="Architecture" name="Architecture"></a><h4> Architecture </h4>&#10;<p>&Eacute; o corpo do sistema, onde s&atilde;o feitas as atribui&ccedil;&otilde;es, opera&ccedil;&otilde;es, compara&ccedil;&otilde;es, etc&hellip;</p>&#10;<p>Declarado como <i>architecture</i> nome <i>of</i> entidade <i>is</i>. Podem existir v&aacute;rias <i>architecture</i> para a mesma <i>entity</i>.</p>&#10;<p>Exemplo de <i>architecture</i>:&#10;</p>&#10;<pre>&#10;architecture RTL of ANDGATE is&#10;begin&#10;   &hellip;&#10;end RTL&semi;&#10;</pre>&#10;&#10;<a id="Process" name="Process"></a><h4> Process </h4>&#10;<p>Diretiva usada quando se quer fazer uma lista de opera&ccedil;&otilde;es a serem executadas. Implementada dentro de <i>architecture</i>. Possui forma estruturada.</p>&#10;<p>Exemplo de <i>process</i>:&#10;</p>&#10;<pre>&#10;atrib : process&#10; begin&#10;    A &lArr; X&semi;&#10;    B &lArr; Y&semi;&#10; end process atrib&semi;&#10;</pre>&#10;&#10;<a id="Package" name="Package"></a><h3> Package </h3>&#10;<p>Usado quando precisa&shy;se usar um comando que n&atilde;o existe nas bibliotecas padr&atilde;o. Deve ser definido antes do inicio da <i>entity</i>. Para usar a <i>package</i> &eacute; necess&aacute;rio usar duas declara&ccedil;&otilde;es: <i>library</i> <i>use</i>. O <i>package</i> mais conhecido &eacute; o STD_LOGIC_1164 da IEEE por conter a maioria dos comandos adicionais usados na linguagem.</p>&#10;<p>Exemplo de <i>package</i>:&#10;</p>&#10;<pre>&#10;library IEEE&semi;&#10;use IEEE.std_logic_1164.all&semi;&#10;</pre>&#10;&#10;<a id="Sinal" name="Sinal"></a><h3> Sinal </h3>&#10;<p>Transmite os dados internamente ou externamente ao sistema sendo que os sinais externos s&atilde;o definidos em <i>entity</i> e usam a diretiva <i>ports</i>, j&aacute; os sinais internos s&atilde;o definidos em <i>architecture</i> e usam a diretiva <i>signal</i>.</p>&#10;<p>Os sinais podem ser uma linha (<i>bit</i>) ou um barramento (<i>bit_vector</i>). No caso do <i>bit_vector</i> a ordem &eacute; de suma import&acirc;ncia, sendo que o primeiro sinal &eacute; o mais significativo e o &uacute;ltimo o menos significativo. Estes dois tipos de sinais s&atilde;o nativos da linguagem VHDL, no entanto pode&shy;se adicionar mais tipos, usando bibliotecas apropriadas. Com isso, teremos tipos como: &#39&semi;U&#39&semi; (N&atilde;o inicializado), &#39&semi;X&#39&semi; (For&ccedil;a 0 ou 1), &#39&semi;0&#39&semi; (For&ccedil;a 0), &#39&semi;1&#39&semi; (For&ccedil;a 1), &#39&semi;Z&#39&semi; (Alta Imped&acirc;ncia), &#39&semi;W&#39&semi; (0 ou 1 fraco), &#39&semi;&shy;&#39&semi; (N&atilde;o interessa).</p>&#10;<p>Em <i>ports</i> tem que especificar a dire&ccedil;&atilde;o do sinal: entrada(<i>in</i>), sa&iacute;da (<i>out</i>) ou bidirecional (<i>inout</i>). Em <i>signal</i> n&atilde;o precisa especificar a dire&ccedil;&atilde;o devido ao fato do sinal ser interno.</p>&#10;<p>Sendo assim, o exemplo a seguir define um <i>port</i> com dois vetores, sendo um vetor X (o bit10 &eacute; o sinal mais significativo e o bit0 o menos significativo) e um vetor Y(sendo o bit0 o sinal mais significativo e o bit5 o menos significativo).&#10;</p>&#10;<pre>&#10;port ( X : out bit_vector (10 downto 0)&semi;&#10;       Y : inout bit_vector (0 to 5))&semi;&#10;</pre>&#10;<p>J&aacute; nesse exemplo definimos <i>a</i> e <i>b</i> como <i>signal</i> e ambos sendo <i>bit</i>.&#10;</p>&#10;<pre>&#10;signal a, b : bit&semi;&#10;</pre>&#10;&#10;<a id="Constantes" name="Constantes"></a><h3> Constantes </h3>&#10;<p>Servem para aumentar a legibilidade do c&oacute;digo e facilitar a sua modifica&ccedil;&atilde;o.</p>&#10;<p />&#10;<pre>&#10;CONSTANT &#60&semi;nome_da_constante&#62&semi; : &#60&semi;tipo&#62&semi; := &#60&semi;valor&#62&semi;&semi;&#10;</pre>&#10;&#10;<p>Exemplo:</p>&#10;<p />&#10;<pre>&#10;CONSTANT PI : REAL := 3.14&semi;&#10;CONSTANT WIDTH : INTEGER := 8&semi;&#10;</pre>&#10;&#10;<a id="Vari%C3%A1veis" name="Vari%C3%A1veis"></a><h3> Vari&aacute;veis </h3>&#10;<p>Usadas apenas em processos e subprogramas (fun&ccedil;&otilde;es e procedimentos), as vari&aacute;veis usualmente n&atilde;o est&atilde;o dispon&iacute;veis para m&uacute;ltiplos componentes e processos. Todas as atribui&ccedil;&otilde;es de vari&aacute;veis tem efeito imediato.</p>&#10;<p />&#10;<pre>&#10;VARIABLE &#60&semi;nome_variavel&#62&semi; : &#60&semi;tipo&#62&semi; [:= &#60&semi;valor&#62&semi;]&semi;&#10;</pre>&#10;&#10;<p>Exemplo:</p>&#10;<p />&#10;<pre>&#10;VARIABLE opcode : BIT_VECTOR (3 DOWNTO 0) := &#34&semi;0000&#34&semi;&semi;&#10;VARIABLE freq : INTEGER&semi;&#10;</pre>&#10;&#10;<a id="Operadores_e_Express%C3%B5es" name="Operadores_e_Express%C3%B5es"></a><h3> Operadores e Express&otilde;es </h3>&#10;<a id="Operadores_L%C3%B3gicos" name="Operadores_L%C3%B3gicos"></a><h4> Operadores L&oacute;gicos </h4>&#10;<p>Os operadores <i>and</i>, <i>or</i>, <i>nand</i>, <i>nor</i>, <i>xor</i> e xnor exigem dois operandos, j&aacute; o operador <i>not</i> exige apenas um operando.</p>&#10;<a id="Deslocamento" name="Deslocamento"></a><h4> Deslocamento </h4>&#10;<p>Restrito a vetores. Exige dois operandos, um sendo o <i>array</i> e o outro um <i>integer</i>, que &eacute; o n&uacute;mero de posi&ccedil;&otilde;es a serem deslocadas.</p>&#10;<p>As opera&ccedil;&otilde;es podem ser:</p>&#10;<p>shift left logical (deslocamento l&oacute;gico a esquerda)&semi;</p>&#10;<p>shift right logical (deslocamento l&oacute;gico a direita)&semi;</p>&#10;<p>shift left arithmetic (deslocamento aritm&eacute;tico a esquerda)&semi;</p>&#10;<p>shift right arithmetic (deslocamento aritm&eacute;tico a direita)&semi;</p>&#10;<p>rotate left logical (rotacionamento l&oacute;gico a esquerda)&semi;</p>&#10;<p>rotate right logical (rotacionamento l&oacute;gico a direita).</p>&#10;<a id="Operadores_aritm%C3%A9ticos" name="Operadores_aritm%C3%A9ticos"></a><h4> Operadores aritm&eacute;ticos </h4>&#10;<p>+ &rarr; soma ou identidade&semi;</p>&#10;&shy; &rarr; subtra&ccedil;&atilde;o ou nega&ccedil;&atilde;o&semi;&#10;&#10;<p>* &rarr; multiplica&ccedil;&atilde;o&semi;</p>&#10;<p>/ &rarr; divis&atilde;o&semi;</p>&#10;<p><i>mod</i> &rarr; m&oacute;dulo&semi;</p>&#10;<p><i>rem</i> &rarr; resto da divis&atilde;o&semi;</p>&#10;<p><i>abs</i> &rarr; valor absoluto&semi;</p>&#10;<p>** &rarr; exponencia&ccedil;&atilde;o.</p>&#10;<a id="Atribui%C3%A7%C3%A3o_e_compara%C3%A7%C3%B5es" name="Atribui%C3%A7%C3%A3o_e_compara%C3%A7%C3%B5es"></a><h4> Atribui&ccedil;&atilde;o e compara&ccedil;&otilde;es </h4>&#10;<p>&#60&semi;= &rarr; atribui&ccedil;&atilde;o&semi;</p>&#10;<p>= &rarr; igual&semi;</p>&#10;<p>/= &rarr; diferente&semi;</p>&#10;<p>&#60&semi; &rarr; menor&semi;</p>&#10;<p>&#60&semi;= &rarr; menor ou igual&semi;</p>&#10;<p>&#62&semi; &rarr; maior&semi;</p>&#10;<p>&#62&semi;= &rarr; maior ou igual&semi;</p>&#10;<a id="After_e_Wait" name="After_e_Wait"></a><h4> After e Wait </h4>&#10;<p>After tem a finalidade de ativar o estado indicado depois de determinado tempo.</p>&#10;<p>Exemplo de <i>after</i>:&#10;</p>&#10;<pre>&#10;x &lArr; &#39&semi;1&#39&semi; after 3s, &#39&semi;0&#39&semi; after 5s, &#39&semi;1&#39&semi; after 7s, &#39&semi;0&#39&semi; after 8s&semi;&#10;</pre>&#10;<p>O resultado graficamente seria:</p>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:After1.jpg" id="w">Ficheiro:After1.jpg</a></p>&#10;<p>J&aacute; wait &#39&semi;segura&#39&semi; o processo por determinado tempo.</p>&#10;<p>Exemplo de <i>wait</i>:&#10;</p>&#10;<pre>&#10;x &lArr; &#39&semi;0&#39&semi;&semi;&#10;wait for 2s&semi;&#10;x &lArr; &#39&semi;1&#39&semi;&semi;&#10;wait for 3s&semi;&#10;x &lArr; &#39&semi;0&#39&semi;&semi;&#10;wait for 1s&semi;&#10;</pre>&#10;<p>O resultado graficamente seria:</p>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:Wait.jpg" id="w">Ficheiro:Wait.jpg</a></p>&#10;<a id="Constantes" name="Constantes"></a><h4> Constantes </h4>&#10;<a id="Generic" name="Generic"></a><h5> Generic </h5>&#10;<p>Declarado na <i>entity</i> para definir uma constante. Composto pelo nome da constante seguido de dois pontos, tipo de constante e valor da constante precedido de :=. Seu &acirc;mbito &eacute; global.</p>&#10;<p>Exemplo de <i>generic</i>:&#10;</p>&#10;<pre>&#10;generic (SIZE : integer := 5&semi;&#10;</pre>&#10;&#10;<a id="Constant" name="Constant"></a><h5> Constant </h5>&#10;<p>Tem a mesma fun&ccedil;&atilde;o que o comando <i>generic</i> porem <i>constant</i> &eacute; declarado na <i>architecture</i>. Seu &acirc;mbito &eacute; local.</p>&#10;<p>Exemplo de <i>constant</i>:&#10;</p>&#10;<pre>&#10;constant SIZE : integer := 5&semi;&#10;</pre>&#10;&#10;<a id="Controles_condicionais" name="Controles_condicionais"></a><h3> Controles condicionais </h3>&#10;<p>Existem cinco comandos condicionais: <i>if then</i>, <i>if then else</i>, <i>case</i>, <i>for loop</i>, <i>next</i>.</p>&#10;<a id="If_Then" name="If_Then"></a><h4> If Then </h4>&#10;<p>Ser&aacute; executado o que estiver dentro do bloco se a condi&ccedil;&atilde;o for verdadeira.</p>&#10;<p>Exemplo de <i>if then</i>:&#10;</p>&#10;<pre>&#10;cmp : process&#10; begin&#10;    if A /= B then&#10;       C &lArr; B&semi;&#10;    end if&semi;&#10; end process cmp&semi;&#10;</pre>&#10;&#10;<a id="If_Then_Else" name="If_Then_Else"></a><h4> If Then Else </h4>&#10;<p>Se a condi&ccedil;&atilde;o for verdadeira ser&aacute; executado o que estiver dentro de <i>then</i>, caso contr&aacute;rio ser&aacute; executado o que estiver dentro de <i>else</i>.</p>&#10;<p>Exemplo de <i>if then else</i>:&#10;</p>&#10;<pre>&#10;cmp : process&#10; begin&#10;    if A = B then&#10;       C &lArr; 0&semi;&#10;    else&#10;       C &lArr; 1&semi;&#10;    end if&semi;&#10; end process cmp&semi;&#10;</pre>&#10;&#10;<a id="Case" name="Case"></a><h4> Case </h4>&#10;<p>Quando o teste de condi&ccedil;&atilde;o de uma vari&aacute;vel poder assumir v&aacute;rios op&ccedil;&otilde;es, &eacute; recomendado o uso do <i>case</i>.</p>&#10;<p>Exemplo de <i>case</i>:&#10;</p>&#10;<pre>&#10;converte : process&#10; begin&#10;    case Bin is&#10;       when &#34&semi;0000&#34&semi; &rArr; Dec &lArr; 0&semi;&#10;       when &#34&semi;0001&#34&semi; &rArr; Dec &lArr; 1&semi;&#10;       when &#34&semi;0010&#34&semi; &rArr; Dec &lArr; 2&semi;&#10;       when &#34&semi;0011&#34&semi; &rArr; Dec &lArr; 3&semi;&#10;       when others &rArr; Dec &lArr; &shy;1&semi;&#10;    end case&semi;&#10; end process converte&semi;&#10;</pre>&#10;&#10;<a id="For_Loop" name="For_Loop"></a><h4> For Loop </h4>&#10;<p>Enquanto o contador estiver dentro da faixa especificada o loop &eacute; executado.</p>&#10;<p>Exemplo de <i>for loop</i>:&#10;</p>&#10;<pre>&#10;conta : process&#10; begin&#10;    for i in 5 downto 0 loop&#10;       Num &lArr; Num + 1&semi;&#10;    end loop&semi;&#10; end process conta&semi;&#10;</pre>&#10;&#10;<a id="Next" name="Next"></a><h4> Next </h4>&#10;<p>Quando se quer pular determinados comandos e ir diretamente para outro usa&shy;se o comando <i>next</i>.</p>&#10;<p>Exemplo de <i>next</i>:&#10;</p>&#10;<pre>&#10;soma : process&#10; begin&#10;    aux : for i in 3 downto 0 loop&#10;       Num &lArr; Num + X&semi;&#10;       if Num = 10 then&#10;          Num &lArr; 0&semi;&#10;          next alfa&semi;&#10;       end if&#10;    end loop aux&semi;&#10; end process soma&semi;&#10;</pre>&#10;&#10;<a id="Test_Bench" name="Test_Bench"></a><h2> Test Bench </h2>&#10;<p>Testa o projeto (no <i>Test Bench</i>, o projeto &eacute; chamado de <i>design</i> ou <i>Unit Under Test</i>) atrav&eacute;s de sinais ou est&iacute;mulos, monitorando suas respostas e com isso ter uma analise melhor do design. O <i>Test Bench</i> consiste em: um soquete para o UUT, um gerador de sinais e ferramentas para monitorar as suas respostas que por exemplo pode dizer se o circuito est&aacute; ou n&atilde;o funcionando corretamente e sob quais aspectos est&atilde;o ocorrendo os problemas. O <i>design</i> n&atilde;o geram circuitos, servindo apenas para a simula&ccedil;&atilde;o.</p>&#10;<a id="Exemplo_de_C%C3%B3digo_VHDL" name="Exemplo_de_C%C3%B3digo_VHDL"></a><h2> Exemplo de C&oacute;digo VHDL </h2>&#10;<p>C&oacute;digo de uma <a href="http://en.wikipedia.org/wiki/Porta_l%C3%B3gica" id="w">porta l&oacute;gica</a> E.</p>&#10;<p />&#10;<pre>&#10;&shy;&shy; importa std_logic da IEEE library&#10;library IEEE&semi;&#10;use IEEE.std_logic_1164.all&semi;&#10;&#10;&shy;&shy; Declara uma entidade&#10;entity ANDGATE is&#10;   port ( &#10;         IN1 : in std_logic&semi;&#10;         IN2 : in std_logic&semi;&#10;         OUT1: out std_logic)&semi;&#10;end ANDGATE&semi;&#10;architecture RTL of ANDGATE is&#10;&#10;begin&#10;&#10;  OUT1 &lArr; IN1 and IN2&semi;&#10;&#10;end RTL&semi;&#10;</pre>&#10;<hr/>&#10;<a id="O_Uso_da_VHDL_em_Projetos_de_Circuitos" name="O_Uso_da_VHDL_em_Projetos_de_Circuitos"></a><h2> O Uso da VHDL em Projetos de Circuitos </h2>&#10;<p>A VHDL, bem como outras linguagens seguem um fluxo de projeto bem definido, composto de sete etapas , como apresenta a Figura 1: Especifica&ccedil;&atilde;o de Requisitos, Modelamento, S&iacute;ntese de Alto N&iacute;vel, Mapeamento Tecnol&oacute;gico, Implementa&ccedil;&atilde;o e ou Fabrica&ccedil;&atilde;o, Testes e Simula&ccedil;&atilde;o. O tempo e o custo de cada etapa dentro de um projeto &eacute; bastante vari&aacute;vel, dependendo da tecnologia utilizada para implementar o sistema. </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:VHDL1.jpg" id="w">Ficheiro:VHDL1.jpg</a></p>&#10;<dl><dt>Figura 1</dt><dd>Ciclo de vida de um projeto</dd></dl>&#10;<p>Durante a etapa de Especifica&ccedil;&atilde;o de Requisitos, o projetista e o usu&aacute;rio (em muitos casos podem ser a mesma pessoa), fazem um estudo e levantam todos os requisitos e caracter&iacute;sticas do sistema e definem o seu funcionamento. Caracter&iacute;sticas tais como atraso m&aacute;ximo permitido para as sa&iacute;das, freq&uuml;&ecirc;ncia m&aacute;xima de opera&ccedil;&atilde;o, consumo de pot&ecirc;ncia, custo, temperatura de opera&ccedil;&atilde;o, tens&atilde;o de alimenta&ccedil;&atilde;o s&atilde;o relacionadas a fim de buscar projetar um circuito que atenda a estes requisitos, que podem ser desej&aacute;veis ou necess&aacute;rios. N&atilde;o &eacute; necess&aacute;rio especificar todas estas caracter&iacute;sticas, isso sempre depender&aacute; de cada projeto. Esta fase &eacute; de extrema import&acirc;ncia porque uma vez compreendido corretamente o funcionamento do sistema, evita&shy;se a ocorr&ecirc;ncia de erros futuros. A cada unidade de tempo avan&ccedil;ada no ciclo de projeto, maior o custo de corre&ccedil;&atilde;o de um erro e maior a dificuldade em encontr&aacute;&shy;lo. Ou seja, al&eacute;m do preju&iacute;zo ser maior, maior tamb&eacute;m a probabilidade de que o erro passe despercebido e seja inclu&iacute;do na produ&ccedil;&atilde;o do sistema.</p>&#10;<p>Na etapa de modelamento &eacute; que o projeto propriamente dito &eacute; iniciado. Baseado nas especifica&ccedil;&otilde;es da etapa inicial, o projetista ir&aacute; escrever os modelos que representam o circuito. &Eacute; de fundamental import&acirc;ncia que o projetista tenha j&aacute; um pr&eacute;vio conhecimento das ferramentas de software que utilizar&aacute; no projeto e da tecnologia que ir&aacute; utilizar, a fim de conduzir o modelamento a fim de obter os melhores resultados futuramente. Outras caracter&iacute;sticas importantes a serem inclu&iacute;das nos modelos s&atilde;o: sempre que poss&iacute;vel, de maneira a n&atilde;o afetar o desempenho e a portabilidade, escrever modelos que sigam o padr&atilde;o estabelecido na linguagem, e n&atilde;o as extens&otilde;es oferecidas pelos desenvolvedores das ferramentas de s&iacute;ntese&semi; seguir um padr&atilde;o de escrita de c&oacute;digo uniforme para todos os modelos do projeto&semi; documentar adequadamente os modelos, incluindo nome do autor, datas de manuten&ccedil;&atilde;o, e coment&aacute;rios e explica&ccedil;&otilde;es relevantes.</p>&#10;<p>A S&iacute;ntese de Alto N&iacute;vel est&aacute; para o hardware assim como a compila&ccedil;&atilde;o est&aacute; para o software. Na s&iacute;ntese, o modelo descrito ser&aacute; convertido para estruturas de dados representando as conex&otilde;es, blocos, componentes e portas l&oacute;gicas. Esta etapa &eacute; autom&aacute;tica e dependente da ferramenta de software utilizada. Em geral, certos cuidados podem ser tomados durante o modelamento a fim de direcionar o algoritmo da s&iacute;ntese para que obtenha os melhores resultados para o circuito. Durante a s&iacute;ntese s&atilde;o pr&eacute;&shy;avaliados os requisitos do sistema a fim de indicar se o circuitos ir&aacute; atend&ecirc;&shy;los adequadamente. Ap&oacute;s a s&iacute;ntese ainda n&atilde;o est&aacute; definido o circuito a ser implementado, a especifica&ccedil;&atilde;o intermedi&aacute;ria que &eacute; resultante &eacute; ainda bastante gen&eacute;rica e pode ser direcionada para uma de muitas possibilidades de tecnologias de implementa&ccedil;&atilde;o.</p>&#10;<p>Somente ap&oacute;s o Mapeamento Tecnol&oacute;gico &eacute; que o circuito j&aacute; est&aacute; definido dentro da tecnologia em que ser&aacute; implementado. Fazendo uma analogia com o software, essa etapa corresponderia &agrave; <a href="http://en.wikipedia.org/wiki/Gera%C3%A7%C3%A3o_de_c%C3%B3digo" id="w">gera&ccedil;&atilde;o de c&oacute;digo</a> execut&aacute;vel que ocorre ao final da compila&ccedil;&atilde;o de um c&oacute;digo fonte. S&oacute; &eacute; poss&iacute;vel entender essa etapa adequadamente conhecendo&shy;se as diferentes tecnologias dispon&iacute;veis no mercado, como full custom, gate array, FPGAs, entre outros. O projetista pouco consegue influir no mapeamento, especificando apenas os par&acirc;metros de otimiza&ccedil;&atilde;o desejados.&#10;A etapa de implementa&ccedil;&atilde;o/fabrica&ccedil;&atilde;o n&atilde;o h&aacute; muito que ser explicada, nesse momento s&atilde;o criados os primeiros prot&oacute;tipos, avaliadas as condi&ccedil;&otilde;es finais, detalhes de produ&ccedil;&atilde;o entre outros detalhes de implementa&ccedil;&atilde;o final. Em seguida &agrave; fabrica&ccedil;&atilde;o, os circuitos s&atilde;o testados para que possam ser entregues ao usu&aacute;rio com garantia de isen&ccedil;&atilde;o de falhas.</p>&#10;<p>A Simula&ccedil;&atilde;o &eacute; uma etapa auxiliar, mas de grande relev&acirc;ncia no ciclo de vida do projeto. Simular consiste em avaliar o comportamento do circuito e validar o modelo produzido at&eacute; aquele momento. Durante a simula&ccedil;&atilde;o, s&atilde;o apresentados amostras de entradas poss&iacute;veis ao modelo do circuito, e os valores das sa&iacute;das, mem&oacute;rias e n&oacute;s internos do circuito s&atilde;o analisados a fim de comparar com o esperado na especifica&ccedil;&atilde;o. A Simula&ccedil;&atilde;o gera uma realimenta&ccedil;&atilde;o para os processos de modelamento, s&iacute;ntese e mapeamento, evitando a propaga&ccedil;&atilde;o de erros para etapas posteriores. Muitos dos problemas encontrados na simula&ccedil;&atilde;o n&atilde;o est&atilde;o necessariamente ligados a erros no projeto, mas ao n&atilde;o preenchimento dos requisitos necess&aacute;rios, principalmente no que se refere aos tempos do circuito (atraso, setup/hold, freq&uuml;&ecirc;ncia de opera&ccedil;&atilde;o).</p>&#10;<p>Na simula&ccedil;&atilde;o, um recurso muito interessante a ser utilizado s&atilde;o os test benches j&aacute; comentados anteriormente.</p>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2>Liga&ccedil;&otilde;es externas</h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://www.dcc.ufrj.br/~gabriel/circlog/vhdl.pdf" rel="nofollow" title="http://www.dcc.ufrj.br/~gabriel/circlog/vhdl.pdf">Introdu&ccedil;&atilde;o ao VHDL pelo Prof. Gabriel P. Silva do DCC&shy;IM/UFRJ</a></li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_especifica%C3%A7%C3%A3o" id="w">Categoria:Linguagens de especifica&ccedil;&atilde;o</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Eletr%C3%B4nica_digital" id="w">Categoria:Eletr&ocirc;nica digital</a></p></body></html>