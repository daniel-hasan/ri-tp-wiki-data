<html><title>Quicksort</title><body>&#10;<p> &#10;O <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmo</a> <b>Quicksort</b> &eacute; um m&eacute;todo de ordena&ccedil;&atilde;o muito r&aacute;pido e eficiente, inventado por <a href="http://en.wikipedia.org/wiki/C.A.R._Hoare" id="w">C.A.R. Hoare</a> em 1960<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup>, quando visitou a <a href="http://en.wikipedia.org/wiki/Universidade_de_Moscovo" id="w">Universidade de Moscovo</a> como estudante. Naquela &eacute;poca, Hoare trabalhou em um projeto de <a href="http://en.wikipedia.org/wiki/Tradu%C3%A7%C3%A3o_de_m%C3%A1quina" id="w">tradu&ccedil;&atilde;o de m&aacute;quina</a> para o <a href="http://en.wikipedia.org/wiki/National_Physical_Laboratory%2C_UK" id="w">National Physical Laboratory</a>.&#10;Ele criou o <b>Quicksort<i> ao tentar traduzir um dicion&aacute;rio de ingl&ecirc;s para russo, ordenando as palavras, tendo como objetivo reduzir o problema original em subproblemas que possam ser resolvidos mais facil e rapidamente.&#10;Foi publicado em 1962 ap&oacute;s uma s&eacute;rie de refinamentos.<sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup></i></b></p>&#10;<p>O Quicksort &eacute; um algoritmo de <a href="http://en.wikipedia.org/wiki/Ordena%C3%A7%C3%A3o_por_compara%C3%A7%C3%A3o" id="w">ordena&ccedil;&atilde;o por compara&ccedil;&atilde;o</a> <a href="http://en.wikipedia.org/wiki/Ordena%C3%A7%C3%A3o_est%C3%A1vel" id="w">n&atilde;o&shy;est&aacute;vel</a>.</p>&#10;<a id="O_algoritmo" name="O_algoritmo"></a><h2> O algoritmo </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Quicksort_example_small.png%7Cthumb" id="w">Algumas etapas do algoritmo Quicksort.</a></p>&#10;<p>O Quicksort adota a estrat&eacute;gia de <a href="http://en.wikipedia.org/wiki/Divis%C3%A3o_e_conquista" id="w">divis&atilde;o e conquista</a>. A estrat&eacute;gia consiste em rearranjar as chaves de modo que as chaves &#34&semi;menores&#34&semi; precedam as chaves &#34&semi;maiores&#34&semi;. Em seguida o Quicksort ordena as duas sublistas de chaves menores e maiores recursivamente at&eacute; que a lista completa se encontre ordenada. <sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup>Os passos s&atilde;o:</p>&#10;&#10;<ol>&#10;<li>Escolha um elemento da lista, denominado <i>piv&ocirc;</i>&semi;</li>&#10;<li>Rearranje a lista de forma que todos os elementos anteriores ao piv&ocirc; sejam menores que ele, e todos os elementos posteriores ao piv&ocirc; sejam maiores que ele. Ao fim do processo o piv&ocirc; estar&aacute; em sua posi&ccedil;&atilde;o final e haver&aacute; duas sublistas n&atilde;o ordenadas. Essa opera&ccedil;&atilde;o &eacute; denominada <i>parti&ccedil;&atilde;o</i>&semi;</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Recursividade_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">Recursivamente</a> ordene a sublista dos elementos menores e a sublista dos elementos maiores&semi;</li></ol>&#10;<p>A base da recurs&atilde;o s&atilde;o as listas de tamanho zero ou um, que est&atilde;o sempre ordenadas. O processo &eacute; finito, pois a cada itera&ccedil;&atilde;o pelo menos um elemento &eacute; posto em sua posi&ccedil;&atilde;o final e n&atilde;o ser&aacute; mais manipulado na itera&ccedil;&atilde;o seguinte.</p>&#10;<a id="Complexidade" name="Complexidade"></a><h2> Complexidade </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Complexidade_(inform%C3%A1tica)" id="w">Complexidade de tempo</a>: &theta;(n lg<sub>2</sub> n) no <a href="http://en.wikipedia.org/wiki/Complexidade_melhor_caso" id="w">melhor caso</a> e <a href="http://en.wikipedia.org/wiki/Complexidade_caso_m%C3%A9dio" id="w">caso m&eacute;dio</a> e &theta;(n<sup>2</sup>) no <a href="http://en.wikipedia.org/wiki/Complexidade_pior_caso" id="w">pior caso</a>&semi;</li>&#10;<li>Complexidade de espa&ccedil;o: &theta;(lg<sub>2</sub> n) no melhor caso e no caso m&eacute;dio e &theta;(lg<sub>2</sub> n) no pior caso. R. Sedgewick desenvolveu uma vers&atilde;o do Quicksort com parti&ccedil;&atilde;o recurs&atilde;o de cauda que tem complexidade &theta;(n<sup>2</sup>) no pior caso.</li></ul>&#10;<a id="Implementa%C3%A7%C3%B5es" name="Implementa%C3%A7%C3%B5es"></a><h2> Implementa&ccedil;&otilde;es </h2>&#10;<a id="%5B%5BPseudoc%C3%B3digo%5D%5D" name="%5B%5BPseudoc%C3%B3digo%5D%5D"></a><h3> [[Pseudoc&oacute;digo]] </h3>&#10;<p />&#10;<pre>&#10;procedimento QuickSort(X[], IniVet, FimVet)&#10;var&#10;   i, j, pivo, aux&#10;in&iacute;cio&#10;   i &#60&semi;&shy; IniVet&#10;   j &#60&semi;&shy; FimVet&#10;   pivo &#60&semi;&shy; X[(IniVet + FimVet) div 2]&#10;      enquanto(i &#60&semi; j)&#10;       |      enquanto (X[i] &#60&semi; pivo) fa&ccedil;a&#10;       |        |   i &#60&semi;&shy; i + 1&#10;       |      fimEnquanto&#10;       |      enquanto (X[j] &#62&semi; pivo) fa&ccedil;a&#10;       |        |   j &#60&semi;&shy; j &shy; 1&#10;       |      fimEnquanto&#10;       |      se (i &#60&semi;= j) ent&atilde;o&#10;       |        |  aux  &#60&semi;&shy; X[i]&#10;       |        |   X[i] &#60&semi;&shy; X[j]&#10;       |        |   X[j] &#60&semi;&shy; aux&#10;       |        |   i &#60&semi;&shy; i + 1&#10;       |        |   j &#60&semi;&shy; j &shy; 1&#10;       |      fimSe&#10;       fimEnquanto&#10;       se (j &#62&semi; IniVet) ent&atilde;o&#10;          |   QuickSort(X, IniVet, j)&#10;       fimSe&#10;       se (i &#60&semi; FimVet) ent&atilde;o&#10;       |  QuickSort(X, i, FimVet)&#10;       fimse&#10;fimprocedimento&#10;&#10;</pre>&#10;&#10;<a id="%5B%5BPascal%5D%5D" name="%5B%5BPascal%5D%5D"></a><h3> [[Pascal]] </h3>&#10;<p />&#10;<pre>&#10;program quicksort&semi;&#10;uses crt&semi;&#10;const&#10; left=1&semi;&#10; right=10&semi;&#10; type&#10;     vetor = array [left..right]of integer&semi;&#10;&#10;procedure ordena(var vet:vetor&semi; left:integer&semi; right:integer)&semi;&#10;var i,j,aux,meio:integer&semi;&#10;begin&#10; i:=left&semi;&#10; j:=right&semi;&#10; meio:=vet[(left + right) div 2]&semi;&#10; while(i &#60&semi; j)do begin&#10; while(vet[i] &#60&semi; meio)do begin&#10; i:=i + 1&semi;&#10; end&semi;&#10; while(vet[j] &#62&semi; meio)do begin&#10; j:=j &shy; 1&semi;&#10; end&semi;&#10; if(i &#60&semi;= j)then begin&#10; aux:= vet[i]&semi;&#10; vet[i]:=vet[j]&semi;&#10; vet[j]:=aux&semi;&#10; i:=i + 1&semi;&#10; j:=j &shy; 1&semi;&#10; end&semi;&#10; end&semi;&#10; if(j &#62&semi; left)then begin&#10; ordena(vet, left, j)&semi;&#10; end&semi;&#10; if(i &#60&semi; right)then begin&#10; ordena(vet, i, right)&semi;&#10; end&semi;&#10;end&semi;&#10;&#10;var&#10;   vet:vetor&semi;&#10;   i:integer&semi;&#10;&#10;begin&#10;    vet[1]:=2&semi;vet[2]:=4&semi;vet[3]:=7&semi;vet[4]:=5&semi;vet[5]:=8&semi;vet[6]:=10&semi;vet[7]:=3&semi;vet[8]:=1&semi;vet[9]:=6&semi;vet[10]:=9&semi;&#10;    for  i:= 1 to 10 do begin&#10;          write(vet[i],&#39&semi; &#39&semi;)&semi;&#10;    end&semi;&#10;    writeln()&semi;&#10;    writeln()&semi;&#10;    ordena(vet, left, right)&semi;&#10;    for  i:= 1 to 10 do begin&#10;          write(vet[i],&#39&semi; &#39&semi;)&semi;&#10;    end&semi;&#10;    readkey&semi;&#10;end.&#10;&#10;</pre>&#10;&#10;<a id="%5B%5BPHP_5_&shy;_OO%5D%5D" name="%5B%5BPHP_5_&shy;_OO%5D%5D"></a><h3> [[PHP 5 &shy; OO]] </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;php&#34&semi;&#62&semi;&#10;class QuickSortUtil {</p>&#10;<pre>  private static function partition(&#38&semi;$array, $f, $l, $property) {&#10;    $pivot = $array[$f]&shy;&#62&semi;$property&semi;&#10;    while ($f &#60&semi; $l) {&#10;       while ($array[$f]&shy;&#62&semi;$property &#60&semi; $pivot) $l++&semi;&#10;       while ($array[$l]&shy;&#62&semi;$property &#62&semi; $pivot) $f&shy;&shy;&semi;&#10;       $temp = $array[$f]&semi;&#10;       $array[$f] = $array[$l]&semi;&#10;       $array[$l] = $temp&semi;&#10;    }&#10;    return $f&semi;&#10;  }&#10;&#10;  public static function sort(&#38&semi;$array, $property, $f=null, $l=null) {&#10;if(is_null($f)) $f = 0&semi;&#10;if(is_null($l)) $l = count($array)&shy;1&semi;&#10;if ($f &#62&semi;= $l) return&semi;&#10;$pivot_index = self::partition($array, $f, $l, $property)&semi;&#10;self::sort($array, $property, $f, $pivot_index)&semi;&#10;self::sort($array, $property, $pivot_index+1, $l)&semi;&#10;  }&#10;</pre>&#10;<p>}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="%5B%5BDelphi%5D%5D_(M%C3%A9todo_Recursivo)" name="%5B%5BDelphi%5D%5D_(M%C3%A9todo_Recursivo)"></a><h3> [[Delphi]] (M&eacute;todo Recursivo) </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;delphi&#34&semi;&#62&semi;</p>&#10;<p>procedure Quick_Sort(var A: array of Integer)&semi;</p>&#10;<pre>procedure QuickSort(var A: array of Integer&semi; iLo, iHi: Integer)&semi;&#10;var&#10;  Lo, Hi, Mid, T: Integer&semi;&#10;begin&#10;  Lo := iLo&semi;&#10;  Hi := iHi&semi;&#10;  Mid := A[(Lo + Hi) div 2]&semi;&#10;  repeat&#10;    while A[Lo] &#60&semi; Mid do Inc(Lo)&semi;&#10;    while A[Hi] &#62&semi; Mid do Dec(Hi)&semi;&#10;    if Lo &#60&semi;= Hi then&#10;    begin&#10;      T := A[Lo]&semi;&#10;      A[Lo] := A[Hi]&semi;&#10;      A[Hi] := T&semi;&#10;      Inc(Lo)&semi;&#10;      Dec(Hi)&semi;&#10;    end&semi;&#10;  until Lo &#62&semi; Hi&semi;&#10;  if Hi &#62&semi; iLo then QuickSort(A, iLo, Hi)&semi;&#10;  if Lo &#60&semi; iHi then QuickSort(A, Lo, iHi)&semi;&#10;end&semi;&#10;</pre>&#10;<p>begin&#10;QuickSort(A, Low(A), High(A))&semi;&#10;end&semi;</p>&#10;<p>{Chamando em um evento de onClick}&#10;procedure TForm1.Button1Click(Sender: TObject)&semi;&#10;var&#10;arr: array[0..100] of integer&semi;&#10;I: Integer&semi;&#10;begin&#10;for I:=Low(arr) to High(arr) do&#10;  arr[I]:=Random(High(Integer))&semi;</p>&#10;<pre>Quick_Sort(arr)&semi;</pre>&#10;<p>end&semi;</p>&#10;<p>&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="%5B%5BVisual_Basic.Net%5D%5D" name="%5B%5BVisual_Basic.Net%5D%5D"></a><h3> [[Visual Basic.Net]] </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;vb&#34&semi;&#62&semi;&#10;Sub QuickSort(ByRef vetor() As String, ByVal inicio As Long, ByVal final As Long)&#10;       Dim pivo As String&#10;       Dim i As Long&#10;       Dim j As Long</p>&#10;<pre>       If final &#62&semi; inicio Then&#10;           i = inicio&#10;           j = final&#10;           pivo = vetor(Fix((inicio + final / 2)))&#10;           While i &#60&semi;= j&#10;               While vetor(i) &#60&semi; pivo&#10;                   i = i + 1&#10;               End While&#10;               While pivo &#60&semi; vetor(j)&#10;                   j = j &shy; 1&#10;               End While&#10;               If i &#60&semi;= j Then&#10;                   Troca(vetor(i), vetor(j))&#10;                   i = i + 1&#10;                   j = j &shy; 1&#10;               End If&#10;           End While&#10;           QuickSort(vetor, inicio, j)&#10;           QuickSort(vetor, final, i)&#10;       End If&#10;&#10;   End Sub&#10;&#10;   Sub Troca(ByRef val1 As String, ByRef val2 As String)&#10;       Dim aux As String&#10;       aux = val1&#10;       val1 = val2&#10;       val2 = aux&#10;   End Sub&#10;</pre>&#10;<p>&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="%5B%5BJavascript%5D%5D" name="%5B%5BJavascript%5D%5D"></a><h3> [[Javascript]] </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;javascript&#34&semi;&#62&semi;&#10;function quickSort(vet, esq, dir){&#10;   var ce = esq&semi;&#10;   var cd = dir&semi;&#10;   var meio = parseInt((ce + cd)/ 2)&semi;&#10;   while(ce &#60&semi; cd){&#10;       while(vet[ce] &#60&semi; vet[meio]){&#10;           ce++&semi;&#10;       }&#10;       while(vet[cd] &#62&semi; vet[meio]){&#10;           cd&shy;&shy;&semi;&#10;       }&#10;       if(ce &#60&semi;= cd){&#10;           var temp = vet[ce]&semi;&#10;           vet[ce] = vet[cd]&semi;&#10;           vet[cd] = temp&semi;&#10;           ce++&semi;&#10;           cd&shy;&shy;&semi;&#10;       }&#10;   }&#10;   if(cd &#62&semi; esq)&#10;       quickSort(vet, esq, cd)&semi;</p>&#10;<pre>   if(ce &#60&semi; dir)&#10;       quickSort(vet, ce, dir)&semi;</pre>&#10;<p>}</p>&#10;<p>var vet = [4,10,3,9,7,1,12]&semi; //adicionando elementos&#10;document.write(vet.join(&#34&semi; &#34&semi;)+&#34&semi;<br/>&#34&semi;)&semi;&#10;var esq = 0&semi;&#10;var dir = vet.length &shy; 1&semi; //indice m&aacute;ximo do array&#10;quickSort(vet, esq, dir)&semi;&#10;document.write(vet.join(&#34&semi; &#34&semi;))&semi;&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="%5B%5BPython%5D%5D" name="%5B%5BPython%5D%5D"></a><h3> [[Python]] </h3>&#10;<p><b>Vers&atilde;o simples</b>&#10;&#60&semi;syntaxhighlight lang=&#34&semi;python&#34&semi;&#62&semi;&#10;def quicksort(v):&#10;   if len(v) &#60&semi;= 1:&#10;       return v # uma lista vazia ou com 1 elemento ja esta ordenada&#10;   less, equal, greater = [], [], [] # cria as sublistas dos maiores, menores e iguais ao pivo&#10;   pivot = v[0] # escolhe o pivo. neste caso, o primeiro elemento da lista&#10;   for x in v:&#10;</p>&#10;<ol>&#10;<li>adiciona o elemento x a lista correspondeste</li></ol>&#10;<pre>       if x &#60&semi; pivot:&#10;           less.append(x)&#10;       elif x == pivot:&#10;           equal.append(x)&#10;       else:&#10;           greater.append(x)&#10;   return quicksort(less) + equal + quicksort(greater) # concatena e retorna recursivamente&#10;</pre>&#10;<ol>&#10;<li>.. as listas ordenadas</li></ol>&#10;<p>&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<p><b>Vers&atilde;o <i>in&shy;place</i></b>&#10;&#60&semi;syntaxhighlight lang=&#34&semi;python&#34&semi;&#62&semi;&#10;def partition(v, left, right):&#10;   i = left&#10;   for j in range(left + 1, right + 1):&#10;       if v[j] &#60&semi; v[left]: # Se um elemento j for menor que o pivo&#10;           i += 1 # .. incrementa&shy;se i&#10;           v[i], v[j] = v[j], v[i] # .. e troca o elemento j de posicao o elemento i&#10;   v[i], v[left] = v[left], v[i] # O pivo e&#39&semi; colocado em sua posicao final&#10;   return i</p>&#10;<p>def quicksort(v, left, right):&#10;   if right &#62&semi; left: # Verifica se a lista tem 2 ou mais itens&#10;       pivotIndex = partition(v, left, right) # Pega a posicao do pivo&#10;       quicksort(v, left, pivotIndex &shy; 1) # Ordena recursivamente os itens menores que o pivo&#10;       quicksort(v, pivotIndex + 1, right) # Ordena recursivamente os itens maiores que o pivo</p>&#10;<p><b>&#10;Exemplo de uso&#10;&#62&semi;&#62&semi;&#62&semi; a = [4, 2, 4, 6, 3, 2, 5, 1, 3]&#10;&#62&semi;&#62&semi;&#62&semi; quicksort(a, 0, len(a)&shy;1)&#10;&#62&semi;&#62&semi;&#62&semi; print a&#10;&#62&semi;&#62&semi;&#62&semi; [1, 2, 2, 3, 3, 4, 4, 5, 6]&#10;</b>&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="%5B%5BAssembly%5D%5D_x86&shy;gas&shy;Linux" name="%5B%5BAssembly%5D%5D_x86&shy;gas&shy;Linux"></a><h3> [[Assembly]] x86&shy;gas&shy;Linux </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;asm&#34&semi;&#62&semi;&#10;/*void quicksort_as (int *x, int n)&semi;*/&#10;.globl quicksort_as&#10;quicksort_as:&#10;pushl %ebp&#10;movl %esp, %ebp&#10;/* 8(%ebp)= ponteiro do arranjo */&#10;/* 12(%ebp)= num de elementos */&#10;movl 12(%ebp), %eax&#10;dec %eax&#10;movl $4, %ebx&#10;mul %ebx&#10;pushl %eax&#10;pushl $0&#10;pushl 8(%ebp)&#10;call quicksort_as_&#10;leave&#10;ret&#10;quicksort_as_:&#10;pushl %ebp&#10;movl %esp, %ebp&#10;/* 8(%ebp)= ponteiro do arranjo */&#10;/* 12(%ebp)= esq */&#10;/* 16(%ebp)= dir */&#10;movl 12(%ebp), %ecx&#10;movl %ecx, %edx&#10;movl 8(%ebp), %eax&#10;addl %ecx, %eax&#10;movl 16(%ebp), %ecx&#10;movl 8(%ebp), %ebx&#10;addl %ecx, %ebx&#10;/* agora %eax aponta p/ x[esq] e %ebx x[dir]*/&#10;addl %edx, %ecx         /*%ecx eh esq + dir*/&#10;pushl %eax&#10;movl %ecx, %eax&#10;movl $2, %ecx&#10;cltd&#10;idivl %ecx /* div %eax por 2=%ecx*/&#10;movl $4, %ecx&#10;cltd&#10;idivl %ecx&#10;mul  %ecx&#10;movl 8(%ebp), %ecx&#10;addl %eax, %ecx&#10;movl (%ecx), %ecx&#10;popl %eax&#10;/*%ecx = compare(cmp)*/&#10;quicksort_imj:&#10;cmp %eax, %ebx&#10;jle quicksort_fim&#10;quicksort_inci:&#10;cmp (%eax), %ecx&#10;jle quicksort_incj&#10;addl $4, %eax&#10;jmp quicksort_inci&#10;quicksort_incj:&#10;cmp (%ebx), %ecx&#10;jge quicksort_troca&#10;subl $4, %ebx&#10;jmp quicksort_incj&#10;quicksort_troca:&#10;cmp %eax, %ebx&#10;jl quicksort_fim&#10;movl (%ebx), %edx&#10;pushl (%eax)&#10;movl %edx, (%eax)&#10;popl (%ebx)&#10;addl $4, %eax&#10;subl $4, %ebx&#10;jmp quicksort_imj&#10;quicksort_fim:&#10;/*salvando registradores na pilha p/ fazer chamada de fun&ccedil;&atilde;o*/&#10;pushl %eax&#10;pushl %ebx&#10;/*passando parametros p/ chamada recursiva*/&#10;subl 8(%ebp), %eax&#10;cmp %eax, 16(%ebp)&#10;jle quicksort_2a_rec&#10;pushl 16(%ebp)&#10;pushl %eax&#10;pushl 8(%ebp)&#10;call quicksort_as_&#10;addl $12, %esp&#10;quicksort_2a_rec:&#10;/*recuperando registradores apos chamada de funcao*/&#10;popl %ebx&#10;popl %eax&#10;subl 8(%ebp), %ebx&#10;cmp %ebx, 12(%ebp)&#10;jge quicksort_final&#10;/*passando parametros p/ chamada recursiva*/&#10;pushl %ebx&#10;pushl 12(%ebp)&#10;pushl 8(%ebp)&#10;call quicksort_as_&#10;quicksort_final:&#10;leave&#10;ret&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="%5B%5BHaskell_(linguagem_de_programa%C3%A7%C3%A3o)%7CHaskell%5D%5D" name="%5B%5BHaskell_(linguagem_de_programa%C3%A7%C3%A3o)%7CHaskell%5D%5D"></a><h3> [[Haskell (linguagem de programa&ccedil;&atilde;o)|Haskell]] </h3>&#10;<p />&#10;<pre>&#10;  sort :: (Ord a)   =&#62&semi; [a] &shy;&#62&semi; [a]&#10;  sort []           = []&#10;  sort (pivot:rest) = (sort [y | y &#60&semi;&shy; rest, y &#60&semi; pivot])&#10;                       ++ [pivot] ++&#10;                      (sort [y | y &#60&semi;&shy; rest, y &#62&semi;=pivot])&#10;</pre>&#10;&#10;<a id="%5B%5BErlang%5D%5D" name="%5B%5BErlang%5D%5D"></a><h3> [[Erlang]] </h3>&#10;<p>Uma vers&atilde;o similar a Haskell, utilizando <a href="http://en.wikipedia.org/wiki/List_comprehension" id="w">list comprehensions</a>:&#10;&#60&semi;syntaxhighlight lang=&#34&semi;erlang&#34&semi;&#62&semi;&#10;quicksort([]) &shy;&#62&semi; []&semi;&#10;quicksort([Pivot|Rest]) &shy;&#62&semi;&#10; quicksort([Smaller || Smaller &#60&semi;&shy; Rest, Smaller =&#60&semi; Pivot])&#10; ++ [Pivot] ++&#10; quicksort([Larger  || Larger  &#60&semi;&shy; Rest, Larger &#62&semi; Pivot]).&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<p>Uma vers&atilde;o com melhor performance utilizando <a href="http://en.wikipedia.org/wiki/Recursividade_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)#Fun.C3.A7.C3.B5es_recursivas_em_cauda" id="w">recursividade em cauda</a>:&#10;&#60&semi;syntaxhighlight lang=&#34&semi;erlang&#34&semi;&#62&semi;&#10;qsort([]) &shy;&#62&semi; []&semi;&#10;qsort(L=[_|_]) &shy;&#62&semi; qsort(L, []).</p>&#10;<p>qsort([], Acc) &shy;&#62&semi; Acc&semi;&#10;qsort([Pivot|Rest], Acc) &shy;&#62&semi;&#10;   partition(Pivot, Rest, {[], [Pivot], []}, Acc).</p>&#10;<p>partition(_, [], {Smaller, Equal, Larger}, Acc) &shy;&#62&semi;&#10;   qsort(Smaller, Equal ++ qsort(Larger, Acc))&semi;&#10;partition(Pivot, [H|T], {Smaller, Equal, Larger}, Acc) &shy;&#62&semi;&#10;   if H &#60&semi; Pivot &shy;&#62&semi;&#10;          partition(Pivot, T, {[H|Smaller], Equal, Larger}, Acc)&semi;&#10;      H &#62&semi; Pivot &shy;&#62&semi;&#10;          partition(Pivot, T, {Smaller, Equal, [H|Larger]}, Acc)&semi;&#10;      H == Pivot &shy;&#62&semi;&#10;          partition(Pivot, T, {Smaller, [H|Equal], Larger}, Acc)&#10;   end.&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="%5B%5BLisp%5D%5D" name="%5B%5BLisp%5D%5D"></a><h3> [[Lisp]] </h3>&#10;<p />&#10;<pre>&#10;(defun partition (fun array)&#10;  (list (remove&shy;if&shy;not fun array) (remove&shy;if fun array)))&#10;&#10;(defun sort (array)&#10;  (if (null array) nil&#10;    (let ((part (partition (lambda (x) (&#60&semi; x (car array))) (cdr array))))&#10;      (append (sort (car part)) (cons (car array) (sort (cadr part)))))))&#10;</pre>&#10;&#10;<a id="%5B%5BPerl%5D%5D" name="%5B%5BPerl%5D%5D"></a><h3> [[Perl]] </h3>&#10;<p>Vers&otilde;es anteriores ao Perl 5.6 utilizavam o algoritmo quicksort para implementar a fun&ccedil;&atilde;o <a class="externallink" href="http://perldoc.perl.org/functions/sort.html" rel="nofollow" title="http://perldoc.perl.org/functions/sort.html">sort</a><sup id="_ref&shy;4" class="reference"><a href="#_note&shy;4" title="">[4]</a></sup>, ent&atilde;o o c&oacute;digo em Perl pode resumir&shy;se a:</p>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;perl&#34&semi;&#62&semi;&#10;my @ordenada = sort @lista&semi;&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<p>Como a implementa&ccedil;&atilde;o do quicksort pode assumir tempos quadr&aacute;ticos para algumas entradas, o algoritmo foi substitu&iacute;do na vers&atilde;o 5.8 pelo <a href="http://en.wikipedia.org/wiki/Ordena%C3%A7%C3%A3o_est%C3%A1vel" id="w">mais est&aacute;vel</a> <a href="http://en.wikipedia.org/wiki/Mergesort" id="w">mergesort</a>, cujo pior caso &eacute; &theta;(n lg<sub>2</sub> n). Ainda assim, &eacute; poss&iacute;vel for&ccedil;ar o uso do quicksort atrav&eacute;s do <a class="externallink" href="http://perldoc.perl.org/sort.html" rel="nofollow" title="http://perldoc.perl.org/sort.html">pragma &#39&semi;sort&#39&semi;</a>:</p>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;perl&#34&semi;&#62&semi;&#10;use sort &#39&semi;_quicksort&#39&semi;&semi;&#10;my @ordenada = sort @lista&semi;&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<p>Uma implementa&ccedil;&atilde;o em Perl puro (mais lenta que o &#39&semi;sort&#39&semi; embutido) pode ser:</p>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;perl&#34&semi;&#62&semi;&#10;sub quicksort {&#10;   my @lista = @_&semi;&#10;   my (@menores, @iguais, @maiores)&semi;</p>&#10;<pre>   return @lista if @lista &#60&semi; 2&semi;&#10;   foreach (@lista) {&#10;       if ($_ &#60&semi; $lista[0]) {&#10;           push @menores, $_&semi;&#10;       }&#10;       elsif ($_ == $lista[0]) {&#10;           push @iguais, $_&semi;&#10;       }&#10;       else {&#10;           push @maiores, $_&semi;&#10;       }&#10;   }&#10;   return quicksort(@menores), @iguais, quicksort(@maiores)&semi;</pre>&#10;<p>}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<p>J&aacute; uma vers&atilde;o menor (e certamente menos leg&iacute;vel) poderia ser:</p>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;perl&#34&semi;&#62&semi;&#10;sub quicksort {&#10;   return @_ if @_ &#60&semi; 2&semi;&#10;   my (@iguais, @maiores, @menores)&semi;&#10;   push @{ (\@iguais, \@menores, \@maiores)[ $_[0] &#60&semi;=&#62&semi; $_ ]}, $_ for @_&semi;&#10;   quicksort(@menores), @iguais, quicksort(@maiores)&semi;&#10;}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="%5B%5BRuby_(linguagem_de_programa%C3%A7%C3%A3o)%7CRuby%5D%5D" name="%5B%5BRuby_(linguagem_de_programa%C3%A7%C3%A3o)%7CRuby%5D%5D"></a><h3> [[Ruby (linguagem de programa&ccedil;&atilde;o)|Ruby]] </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;ruby&#34&semi;&#62&semi;&#10;def sort(array)&#10;  return array if array.size &#60&semi;= 1&#10;  pivot = array[0]&#10;  return sort(array.select { |y| y &#60&semi; pivot }) +&#10;         array.select { |y| y == pivot } +&#10;         sort(array.select { |y| y &#62&semi; pivot })&#10;end&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="%5B%5BGroovy%5D%5D" name="%5B%5BGroovy%5D%5D"></a><h3> [[Groovy]] </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;groovy&#34&semi;&#62&semi;&#10;def sort(list) {&#10;   if (list.isEmpty()) return list&#10;   anItem = list[0]&#10;   def smallerItems = list.findAll{it &#60&semi; anItem}&#10;   def equalItems = list.findAll{it == anItem}&#10;   def largerItems = list.findAll{it &#62&semi; anItem}&#10;   sort(smallerItems) + equalItems + sort(largerItems)&#10;}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<p><b>Implementa&ccedil;&atilde;o utilizando o groupBy e o compareTo &#34&semi;&#60&semi;=&#62&semi;&#34&semi;.&#10;</b>&#60&semi;syntaxhighlight lang=&#34&semi;groovy&#34&semi;&#62&semi;&#10;def sort(list) {&#10;   if (list.size() &#60&semi; 2) return list&#10;   def items = list.groupBy { it &#60&semi;=&#62&semi; list[0] }.withDefault { [] }&#10;   sort(items[&shy;1]) + items[0] + sort(items[1])&#10;}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="%5B%5BML%5D%5D" name="%5B%5BML%5D%5D"></a><h3> [[ML]] </h3>&#10;<p />&#10;<pre>&#10;fun filter nil elem cmp = nil&#10;  | filter (x::xl) elem cmp  =&#10;      if (cmp(x, elem))&#10;        then x :: filter xl elem cmp&#10;        else filter xl elem cmp&semi;&#10;&#10;fun quicksort nil = nil&#10;  | quicksort (pivot::xl) =&#10;      let&#10;        val small = filter xl pivot (op &#60&semi;)&semi;&#10;        val medium = pivot :: filter xl pivot (op =)&semi;&#10;        val large = filter xl pivot (op &#62&semi;)&semi;&#10;      in&#10;        (quicksort small) @ medium @ (quicksort large)&#10;      end&semi;&#10;</pre>&#10;&#10;<a id="%5B%5BPHP%5D%5D" name="%5B%5BPHP%5D%5D"></a><h3> [[PHP]] </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;php&#34&semi;&#62&semi;&#10;&#60&semi;?php&#10;/*********************************************************************&#10;</p>&#10;<ul>&#10;<li>Obs.: a implementa&ccedil;&atilde;o usa par&acirc;metros por refer&ecirc;ncia, isto &eacute;, o vetor passado ser&aacute; modificado.&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>&#10;<ul>&#10;<li>/</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>&#10;<p>function quicksort(&#38&semi;$vet, $ini, $fim)&#10;{&#10;$i = $ini&semi;&#10;$j = $fim&semi;&#10;$dir = 1&semi;</p>&#10;<pre>while ($i &#60&semi; $j)&#10;{&#10;if ($vet[$i] &#62&semi; $vet[$j])&#10;{&#10;$aux = $vet[$i]&semi;&#10;$vet[$i] = $vet[$j]&semi;&#10;$vet[$j] = $aux&semi;&#10;&#10;$dir = &shy; $dir&semi;&#10;}&#10;&#10;if ($dir == 1)&#10;$j&shy;&shy;&semi;&#10;else&#10;$i++&semi;&#10;}&#10;&#10;$k = $i&semi;&#10;if($ini &#60&semi; $f)&#10;quicksort($vet, $ini, $k&shy;1)&semi;&#10;&#10;if($i &#60&semi; $fim)&#10;quicksort($vet, $k+1, $fim)&semi;&#10;</pre>&#10;<p>}&#10;quicksort($vet,0,count($vet))&semi;&#10;?&#62&semi;&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="%5B%5BPHP_(utilizando_pivot)%5D%5D" name="%5B%5BPHP_(utilizando_pivot)%5D%5D"></a><h3> [[PHP (utilizando pivot)]] </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;php&#34&semi;&#62&semi;&#10;&#60&semi;?php&#10;/* Fun&ccedil;&atilde;o utilizando pivot */&#10;function quicksort(&#38&semi;$vet,$ini,$fim)&#10;{&#10;$i = $ini&semi;&#10;$f = $fim&semi;</p>&#10;<pre>$pivo = $vet[(int)(($ini+$fim)/2)]&semi;&#10;&#10;while($i &#60&semi; $f)&#10;{&#10;while($vet[$i] &#60&semi; $pivo)&#10;$i++&semi;&#10;&#10;while($vet[$f] &#62&semi; $pivo)&#10;$f&shy;&shy;&semi;&#10;&#10;if($i &#60&semi;= $f)&#10;{&#10;$aux = $vet[$i]&semi;&#10;$vet[$i] = $vet[$f]&semi;&#10;$vet[$f] = $aux&semi;&#10;$i++&semi;&#10;$f&shy;&shy;&semi;&#10;}&#10;}&#10;if($ini &#60&semi; $f)&#10;quicksort($vet,$ini,$f)&semi;&#10;&#10;if($i &#60&semi; $fim)&#10;quicksort($vet,$i,$fim)&semi;</pre>&#10;<p>}&#10;?&#62&semi;&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="C/%5B%5BC%2B%2B%5D%5D" name="C/%5B%5BC%2B%2B%5D%5D"></a><h3> C/[[C++]] </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;cpp&#34&semi;&#62&semi;&#10;void quickSort(int valor[], int esquerda, int direita)&#10;{&#10;   int i, j, x, y&semi;&#10;   i = esquerda&semi;&#10;   j = direita&semi;&#10;   x = valor[(esquerda + direita) / 2]&semi;</p>&#10;<pre>   while(i &#60&semi;= j)&#10;   {&#10;       while(valor[i] &#60&semi; x &#38&semi;&#38&semi; i &#60&semi; direita)&#10;       {&#10;           i++&semi;&#10;       }&#10;       while(valor[j] &#62&semi; x &#38&semi;&#38&semi; j &#62&semi; esquerda)&#10;       {&#10;           j&shy;&shy;&semi;&#10;       }&#10;       if(i &#60&semi;= j)&#10;       {&#10;           y = valor[i]&semi;&#10;           valor[i] = valor[j]&semi;&#10;           valor[j] = y&semi;&#10;           i++&semi;&#10;           j&shy;&shy;&semi;&#10;       }&#10;   }&#10;   if(j &#62&semi; esquerda)&#10;   {&#10;       quickSort(valor, esquerda, j)&semi;&#10;   }&#10;   if(i &#60&semi; direita)&#10;   {&#10;       quickSort(valor,  i, direita)&semi;&#10;   }</pre>&#10;<p>}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="%5B%5BASP%5D%5D" name="%5B%5BASP%5D%5D"></a><h3> [[ASP]] </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;asp&#34&semi;&#62&semi;&#10;&#60&semi;%&#10;Response.Write(&#34&semi;QuickSort Algorithm&#34&semi;)&#38&semi; vbNewLine</p>&#10;<p>Sub QuickSort(vec,loBound,hiBound)&#10; Dim pivot,loSwap,hiSwap,temp</p>&#10;<pre> &#39&semi;== Two items to sort&#10; if hiBound &shy; loBound = 1 then&#10;   if vec(loBound) &#62&semi; vec(hiBound) then&#10;     temp=vec(loBound)&#10;     vec(loBound) = vec(hiBound)&#10;     vec(hiBound) = temp&#10;   End If&#10; End If&#10;&#10; &#39&semi;== Three or more items to sort&#10; pivot = vec(int((loBound + hiBound) / 2))&#10; vec(int((loBound + hiBound) / 2)) = vec(loBound)&#10; vec(loBound) = pivot&#10; loSwap = loBound + 1&#10; hiSwap = hiBound&#10;&#10; do&#10;   &#39&semi;== Find the right loSwap&#10;   while loSwap &#60&semi; hiSwap and vec(loSwap) &#60&semi;= pivot&#10;     loSwap = loSwap + 1&#10;   wend&#10;   &#39&semi;== Find the right hiSwap&#10;   while vec(hiSwap) &#62&semi; pivot&#10;     hiSwap = hiSwap &shy; 1&#10;   wend&#10;   &#39&semi;== Swap values if loSwap is less then hiSwap&#10;   if loSwap &#60&semi; hiSwap then&#10;     temp = vec(loSwap)&#10;     vec(loSwap) = vec(hiSwap)&#10;     vec(hiSwap) = temp&#10;   End If&#10; loop while loSwap &#60&semi; hiSwap&#10;&#10; vec(loBound) = vec(hiSwap)&#10; vec(hiSwap) = pivot&#10;&#10; &#39&semi;== Recursively call function .. the beauty of Quicksort&#10;   &#39&semi;== 2 or more items in first section&#10;   if loBound &#60&semi; (hiSwap &shy; 1) then Call QuickSort(vec,loBound,hiSwap&shy;1)&#10;   &#39&semi;== 2 or more items in second section&#10;   if hiSwap + 1 &#60&semi; hibound then Call QuickSort(vec,hiSwap+1,hiBound)&#10;</pre>&#10;<p>End Sub  &#39&semi;QuickSort</p>&#10;<p>Sub PrintArray(vec,lo,hi)&#10; &#39&semi;== Simply print out an array from the lo bound to the hi bound.&#10; Dim i&#10; For i = lo to hi&#10;   Response.Write vec(i)&#10; Next&#10;End Sub  &#39&semi;PrintArray</p>&#10;<p>Randomize</p>&#10;<p>Dim x(9)</p>&#10;<p>For z = 0 to 9&#10; x(z) = int(Rnd*1000)&#10; If (Rnd &#60&semi; 0.5) then x(z) = x(z)&shy;1000&#10;Next</p>&#10;<p>Response.Write (&#34&semi;Here is a jumbled array:&#34&semi;) &#38&semi; vbNewLine&#10;Call PrintArray(x,0,9)</p>&#10;<p>Call QuickSort(x,0,9)</p>&#10;<p>Response.Write(&#34&semi;Now the array is sorted!&#34&semi;)&#38&semi; vbNewLine&#10;Call PrintArray(x,0,9)</p>&#10;<p>Response.Write(vbNewLine)&#10;%&#62&semi;&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="%5B%5BLinguagem_de_programa%C3%A7%C3%A3o_C%7CC%5D%5D" name="%5B%5BLinguagem_de_programa%C3%A7%C3%A3o_C%7CC%5D%5D"></a><h3> [[Linguagem de programa&ccedil;&atilde;o C|C]] </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;c&#34&semi;&#62&semi;</p>&#10;<p>void trocaValores(int* a, int* b)&#10;{&#10;   int aux&semi;&#10;   aux = *a&semi;&#10;   *a = *b&semi;&#10;   *b = aux&semi;&#10;}</p>&#10;<p>int divide(int vec[], int esquerdo, int direito)&#10;{&#10;   int i, j&semi;</p>&#10;<pre>   i = esquerdo&semi;&#10;   for (j = esquerdo + 1&semi; j &#60&semi;= direito&semi; ++j)&#10;   {&#10;       if (vec[j] &#60&semi; vec[esquerdo])&#10;       {&#10;           ++i&semi;&#10;           trocaValores(&#38&semi;vec[i], &#38&semi;vec[j])&semi;&#10;       }&#10;   }&#10;   trocaValores(&#38&semi;vec[esquerdo], &#38&semi;vec[i])&semi;&#10;&#10;   return i&semi;</pre>&#10;<p>}</p>&#10;<p>void quickSort(int vec[], int esquerdo, int direito)&#10;{&#10;   int r&semi;</p>&#10;<pre>   if (direito &#62&semi; esquerdo)&#10;   {&#10;       r = divide(vec, esquerdo, direito)&semi;&#10;       quickSort(vec, esquerdo, r &shy; 1)&semi;&#10;       quickSort(vec, r + 1, direito)&semi;&#10;   }</pre>&#10;<p>}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<p>Implementa&ccedil;&atilde;o quicksort testado com ate 1000000 de elementos para dados crescente, decrescente e aleat&oacute;rio&#10;&#60&semi;syntaxhighlight lang=&#34&semi;c&#34&semi;&#62&semi;&#10;void swap(int *a, int i, int j)&#10;{&#10;   int t = a[i]&semi;&#10;   a[i] = a[j]&semi;&#10;   a[j] = t&semi;&#10;}</p>&#10;<p>int partition(int *a, int left,int right,int pivot)&#10;{&#10;   int pos, i&semi;&#10;   swap(a, pivot, right)&semi;&#10;   pos = left&semi;&#10;   for(i = left&semi; i &#60&semi; right&semi; i++)&#10;   {&#10;       if (a[i] &#60&semi; a[right])&#10;       {&#10;           swap(a, i, pos)&semi;&#10;           pos++&semi;&#10;       }&#10;   }&#10;   swap(a, right, pos)&semi;&#10;   return pos&semi;&#10;}</p>&#10;<p>void quick(int *a, int left, int right)&#10;{&#10;   if (left &#60&semi; right)&#10;   {&#10;       int pivot = (left + right) / 2&semi;&#10;int pos = partition(a,left,right,pivot)&semi;&#10;quick(a, left, pos &shy; 1)&semi;&#10;quick(a, pos + 1, right)&semi;&#10;   }&#10;}&#10;&#60&semi;/syntaxhighlight&#62&semi;&#10;Implementa&ccedil;ao usando &#39&semi;fat pivot&#39&semi;:</p>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;c&#34&semi;&#62&semi;&#10;void sort(int array[], int begin, int end)&#10;{&#10;   int pivot = array[begin]&semi;&#10;   int i = begin + 1, j = end, k = end&semi;&#10;   int t&semi;</p>&#10;<pre>   while (i &#60&semi; j)&#10;   {&#10;       if (array[i] &#60&semi; pivot)&#10;           i++&semi;&#10;       else if (array[i] &#62&semi; pivot)&#10;       {&#10;           j&shy;&shy;&semi;&#10;           k&shy;&shy;&semi;&#10;           t = array[i]&semi;&#10;           array[i] = array[j]&semi;&#10;           array[j] = array[k]&semi;&#10;           array[k] = t&semi;&#10;       }&#10;       else&#10;       {&#10;           j&shy;&shy;&semi;&#10;           swap(array[i], array[j])&semi;&#10;       }&#10;   }&#10;   i&shy;&shy;&semi;&#10;   swap(array[begin], array[i])&semi;&#10;   if (i &shy; begin &#62&semi; 1)&#10;       sort(array, begin, i)&semi;&#10;   if (end &shy; k   &#62&semi; 1)&#10;       sort(array, k, end)&semi;</pre>&#10;<p>}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<p>Lembrando que quando voc&ecirc; for chamar a fun&ccedil;&atilde;o recursiva ter&aacute; que chamar a mesma da seguinte forma ordenar_quicksort_nome(0,n&shy;1). O 0(zero) serve para o in&iacute;cio receber a posi&ccedil;&atilde;o zero do vetor e o fim ser&aacute; o tamanho do vetor  &shy;1.</p>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;c&#34&semi;&#62&semi;</p>&#10;&#10;<ol>&#10;<li>include &#60&semi;string.h&#62&semi;</li></ol>&#10;<p>void ordenar_quicksort_nome(int ini, int fim, char vetor[][50])&#10;{&#10;   int i = ini, f = fim&semi;&#10;   char pivo[50], aux_char[50]&semi;&#10;   strcpy(pivo, vetor[(ini + fim) / 2])&semi;&#10;   if (i &#60&semi;= f)&#10;   {&#10;       while (strcasecmp(vetor[i], pivo)&#60&semi;0)&#10;           i++&semi;&#10;       while (strcasecmp(vetor[f], pivo)&#62&semi;0)&#10;           f&shy;&shy;&semi;&#10;       if (i &#60&semi;= f)&#10;       {&#10;           strcpy (aux_char, vetor[i])&semi;&#10;           strcpy (vetor[i], vetor[f])&semi;&#10;           strcpy (vetor[f], aux_char)&semi;&#10;           i++&semi;&#10;           f&shy;&shy;&semi;&#10;       }&#10;   }&#10;   if (f &#62&semi; ini)&#10;       ordenar_quicksort_nome(ini, f, vetor)&semi;&#10;   if (i &#60&semi; fim)&#10;       ordenar_quicksort_nome(i, fim, vetor)&semi;&#10;}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="%5B%5BJava_(linguagem_de_programa%C3%A7%C3%A3o)%7CJAVA%5D%5D" name="%5B%5BJava_(linguagem_de_programa%C3%A7%C3%A3o)%7CJAVA%5D%5D"></a><h3> [[Java (linguagem de programa&ccedil;&atilde;o)|JAVA]] </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;java&#34&semi;&#62&semi;&#10;public static void quick_sort(int []v,int ini, int fim) {&#10;  int meio&semi;</p>&#10;<pre>  if (ini &#60&semi; fim) {&#10;    meio = partition(v, ini, fim)&semi;&#10;    quick_sort(v, ini, meio)&semi;&#10;    quick_sort(v, meio + 1, fim)&semi;&#10;  }&#10;}&#10;&#10;public static int partition(int []v, int ini, int fim) {&#10;  int pivo, topo, i&semi;&#10;  pivo = v[ini]&semi;&#10;  topo = ini&semi;&#10;&#10;  for (i = ini + 1&semi; i &#60&semi;= fim&semi; i++) {&#10;    if (v[i] &#60&semi; pivo) {&#10;      v[topo] = v[i]&semi;&#10;      v[i] = v[topo + 1]&semi;&#10;      topo++&semi;&#10;    }&#10;  }&#10;  v[topo] = pivo&semi;&#10;  return topo&semi;&#10;}&#10;</pre>&#10;<p>&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="%5B%5BC_sharp%7CC%23%5D%5D" name="%5B%5BC_sharp%7CC%23%5D%5D"></a><h3> [[C sharp|C#]] </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;csharp&#34&semi;&#62&semi;&#10;static class QuickSort&#10;{&#10;  public static void Ordenar(int[] vetor)&#10;  {&#10;     Ordenar(vetor, 0, vetor.Length &shy; 1)&semi;&#10;  }</p>&#10;<pre>  private static void Ordenar(int[] vetor, int inicio, int fim)&#10;  {&#10;     if (inicio &#60&semi; fim)&#10;     {&#10;        int posicaoPivo = Separar(vetor, inicio, fim)&semi;&#10;        Ordenar(vetor, inicio, posicaoPivo &shy; 1)&semi;&#10;        Ordenar(vetor, posicaoPivo + 1, fim)&semi;&#10;     }&#10;  }&#10;&#10;  private static int Separar(int[] vetor, int inicio, int fim)&#10;  {&#10;     int pivo = vetor[inicio]&semi;&#10;     int i = inicio + 1, f = fim&semi;&#10;     while (i &#60&semi;= f)&#10;     {&#10;        if (vetor[i] &#60&semi;= pivo)&#10;           i++&semi;&#10;        else if (pivo &#60&semi; vetor[f])&#10;           f&shy;&shy;&semi;&#10;        else&#10;        {&#10;           int troca = vetor[i]&semi;&#10;           vetor[i] = vetor[f]&semi;&#10;           vetor[f] = troca&semi;&#10;           i++&semi;&#10;           f&shy;&shy;&semi;&#10;        }&#10;     }&#10;     vetor[inicio] = vetor[f]&semi;&#10;     vetor[f] = pivo&semi;&#10;     return f&semi;&#10;  }</pre>&#10;<p>}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="ARM_Assembly" name="ARM_Assembly"></a><h3> ARM Assembly </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;asm&#34&semi;&#62&semi;&#10; qsort:  @ Takes three parameters:&#10;       @   a:     Pointer to base of array a to be sorted (arrives in r0)&#10;       @   left:  First of the range of indexes to sort (arrives in r1)&#10;       @   right: One past last of range of indexes to sort (arrives in r2)&#10;       @ This function destroys: r1, r2, r3, r4, r5, r7&#10;       stmfd   sp!, {r4, r6, lr}     @ Save r4 and r6 for caller&#10;       mov     r6, r2                @ r6 &#60&semi;&shy; right&#10; qsort_tailcall_entry:&#10;       sub     r7, r6, r1            @ If right &shy; left &#60&semi;= 1 (already sorted),&#10;       cmp     r7, #1&#10;       ldmlefd sp!, {r1, r6, pc}     @ Return, moving r4&shy;&#62&semi;r1, restoring r6&#10;       ldr     r7, [r0, r1, asl #2]  @ r7 &#60&semi;&shy; a[left], gets pivot element&#10;       add     r2, r1, #1            @ l &#60&semi;&shy; left + 1&#10;       mov     r4, r6                @ r &#60&semi;&shy; right&#10; partition_loop:&#10;       ldr     r3, [r0, r2, asl #2]  @ r3 &#60&semi;&shy; a[l]&#10;       cmp     r3, r7                @ If a[l] &#60&semi;= pivot_element,&#10;       addle   r2, r2, #1            @ ... increment l, and&#10;       ble     partition_test        @ ... continue to next iteration.&#10;       sub     r4, r4, #1            @ Otherwise, decrement r,&#10;       ldr     r5, [r0, r4, asl #2]  @ ... and swap a[l] and a[r].&#10;       str     r5, [r0, r2, asl #2]&#10;       str     r3, [r0, r4, asl #2]&#10; partition_test:&#10;       cmp     r2, r4                @ If l &#60&semi; r,&#10;       blt     partition_loop        @ ... continue iterating.&#10; partition_finish:&#10;       sub     r2, r2, #1            @ Decrement l&#10;       ldr     r3, [r0, r2, asl #2]  @ Swap a[l] and pivot&#10;       str     r3, [r0, r1, asl #2]&#10;       str     r7, [r0, r2, asl #2]&#10;       bl      qsort                 @ Call self recursively on left part,&#10;                                     @  with args a (r0), left (r1), r (r2),&#10;                                     @  also preserves r6 and&#10;                                     @  moves r4 (l) to 2nd arg register (r1)&#10;       b       qsort_tailcall_entry  @ Tail&shy;call self on right part,&#10;                                     @  with args a (r0), l (r1), right (r6)&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="%5B%5BProlog%5D%5D" name="%5B%5BProlog%5D%5D"></a><h3> [[Prolog]] </h3>&#10;<p />&#10;<pre>&#10;partition([], _, [], []).&#10;partition([X|Xs], Pivot, Smalls, Bigs) :&shy;&#10;    (   X @&#60&semi; Pivot &shy;&#62&semi;&#10;        Smalls = [X|Rest],&#10;        partition(Xs, Pivot, Rest, Bigs)&#10;    &semi;   Bigs = [X|Rest],&#10;        partition(Xs, Pivot, Smalls, Rest)&#10;    ).&#10;&#10;quicksort([])     &shy;&shy;&#62&semi; [].&#10;quicksort([X|Xs]) &shy;&shy;&#62&semi;&#10;    { partition(Xs, X, Smaller, Bigger) },&#10;    quicksort(Smaller), [X], quicksort(Bigger).&#10;</pre>&#10;&#10;<a id="%5B%5BLua_(linguagem_de_programa%C3%A7%C3%A3o)%7CLua%5D%5D" name="%5B%5BLua_(linguagem_de_programa%C3%A7%C3%A3o)%7CLua%5D%5D"></a><h3> [[Lua (linguagem de programa&ccedil;&atilde;o)|Lua]] </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;lua&#34&semi;&#62&semi;&#10;function quickSort(v, ini, fim)&#10;i, j = ini, fim&#10;pivo = v[math.floor((ini + fim)/2)]&#10;while i &#60&semi;= j do&#10;while (v[i] &#60&semi; pivo) do i=i+1 end&#10;while (v[j] &#62&semi; pivo) do j=j&shy;1 end&#10;if (i&#60&semi;=j) then&#10;                 v[i], v[j] = v[j], v[i]&#10;  i, j = i+1, j&shy;1&#10;end&#10;end&#10;if j &#62&semi; ini then quickSort(v, ini, j) end&#10;if i &#60&semi; fim then quickSort(v, i, fim) end&#10;end&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="Compara%C3%A7%C3%A3o_com_outros_algoritmos_de_ordena%C3%A7%C3%A3o" name="Compara%C3%A7%C3%A3o_com_outros_algoritmos_de_ordena%C3%A7%C3%A3o"></a><h2> Compara&ccedil;&atilde;o com outros algoritmos de ordena&ccedil;&atilde;o </h2>&#10;<p><b>Quicksort</b> &eacute; uma vers&atilde;o optimizada de uma <a href="http://en.wikipedia.org/wiki/&Aacute;rvore_bin%C3%A1ria" id="w">&aacute;rvore bin&aacute;ria</a> ordenada. Em vez de introduzir itens sequencialmente numa &aacute;rvore explicita, o Quicksort organiza&shy;os correntemente na &aacute;rvore onde est&aacute; impl&iacute;cito, fazendo&shy;o com chamadas recursivas &agrave; mesma. O <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmo</a> faz exactamente as mesmas compara&ccedil;&otilde;es, mas com uma ordem diferente.</p>&#10;<p>O algoritmo que mais se familiariza com o Quicksort &eacute; o <a href="http://en.wikipedia.org/wiki/Heapsort" id="w">Heapsort</a>. Para o pior caso neste algoritmo temos <span class="math">\mathcal{O}(n \log2 n)</span>. Mas, o Heapsort em m&eacute;dia trata&shy;se de uma algoritmo mais lento que o Quicksort, embora tenha sido muito debatido essa afirma&ccedil;&atilde;o. No Quicksort permanece o caso do pior caso, &agrave; excep&ccedil;&atilde;o quando se trata de usar a variante <a href="http://en.wikipedia.org/wiki/Intro_sort" id="w">Intro sort</a>, que muda para Heapsort quando um pior caso &eacute; detectado. Caso se saiba &agrave; partida que ser&aacute; necess&aacute;rio o uso do heapsort &eacute; aconselh&aacute;vel us&aacute;&shy;lo directamente, do que usar o introsort e depois chamar o heapsort, torna mais r&aacute;pido o algoritmo.</p>&#10;<p>O Quicksort tamb&eacute;m compete com o <a href="http://en.wikipedia.org/wiki/Mergesort" id="w">Mergesort</a>, outro algoritmo de ordena&ccedil;&atilde;o recursiva, tendo este o benef&iacute;cio de ter como pior caso  <span class="math">\mathcal{O}(n \log n)</span>. Mergesort, ao contr&aacute;rio do Quicksort e do Heapsort, &eacute; est&aacute;vel e pode facilmente ser adptado para operar em listas encadeadas e em listas bastantes grandes alojadas num tipo de acesso lento a m&eacute;dia como um <i>Network&shy;Attached Storage</i> ou num disco. Embora o Quicksort possa ser operado em listas encadeadas, por vezes escolhendo um mau piv&ocirc; sem acesso aleat&oacute;rio. A maior desvantagem do Mergesort &eacute; que quando opera em <i>arrays</i>, requer <span class="math">\mathcal{O}(n)</span> de espa&ccedil;o para o melhor caso, considerando que o Quicksort com um particionamento espacial e com recurs&atilde;o utiliza apenas  <span class="math">\mathcal{O}(\log n)</span> de espa&ccedil;o.</p>&#10;<p><a href="http://en.wikipedia.org/wiki/Bucket_sort" id="w">Bucket sort</a> com dois <i>buckets</i> &eacute; muito parecido ao Quicksort (quase id&ecirc;ntico), o piv&ocirc; neste caso &eacute; garantidamente o valor do meio do vector.</p>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Ordena%C3%A7%C3%A3o_de_vetor" id="w">Ordena&ccedil;&atilde;o de vetor</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Merge_sort" id="w">Merge sort</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Heapsort" id="w">Heapsort</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Selection_sort" id="w">Selection sort</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Bubble_sort" id="w">Bubble sort</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Busca_linear" id="w">Busca linear</a></li></ul>&#10;<p> </p>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://www.ime.usp.br/~pf/algoritmos/aulas/quick.html" rel="nofollow" title="http://www.ime.usp.br/~pf/algoritmos/aulas/quick.html">R&aacute;pida aula de Quicksort</a></li>&#10;<li><a class="externallink" href="http://www.cs.ubc.ca/spider/harrison/Java/sorting&shy;demo.html" rel="nofollow" title="http://www.cs.ubc.ca/spider/harrison/Java/sorting&shy;demo.html">Anima&ccedil;&atilde;o do processo de ordena&ccedil;&atilde;o pelo Quicksort</a></li>&#10;<li><a class="externallink" href="http://www.datastructures.info/what&shy;is&shy;quicksort&shy;and&shy;how&shy;does&shy;it&shy;work&shy;quick&shy;sort&shy;algorithm/" rel="nofollow" title="http://www.datastructures.info/what&shy;is&shy;quicksort&shy;and&shy;how&shy;does&shy;it&shy;work&shy;quick&shy;sort&shy;algorithm/">Explana&ccedil;&atilde;o video de Quicksort usando cart&otilde;es e de c&oacute;digo em C++</a></li>&#10;<li><a class="externallink" href="http://www.algorithm&shy;code.com/wiki/Quick_Sort" rel="nofollow" title="http://www.algorithm&shy;code.com/wiki/Quick_Sort">QuickSort Code</a></li></ul>&#10;<p> </p>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos_de_ordena%C3%A7%C3%A3o" id="w">Categoria:Algoritmos de ordena&ccedil;&atilde;o</a></p>&#10;<p><a href="http://no.wikipedia.org/wiki/Sorteringsalgoritme">no:Sorteringsalgoritme</a></p></body></html>