<html><title>Compilador</title><body>&#10;<p> &#10;<a href="http://en.wikipedia.org/wiki/Imagem:GCC&shy;4.0.2&shy;screenshot.png%7Cthumb%7C300px%7CUma_captura_de_tela_do_compilador_%5B%5BGNU_Compiler_Collection" id="w">GCC]] vers&atilde;o 4.0.2 rodando em uma janela [[xterm]]. Um programa simples est&aacute; sendo compilado e ent&atilde;o executado.</a></p>&#10;<p>Um <b>compilador</b> &eacute; um <a href="http://en.wikipedia.org/wiki/Programa_de_computador" id="w">programa de computador</a> (ou um grupo de programas) que, a partir de um <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_fonte" id="w">c&oacute;digo fonte</a> escrito em uma <a href="http://en.wikipedia.org/wiki/Linguagem_compilada" id="w">linguagem compilada</a>, cria um programa semanticamente equivalente, por&eacute;m escrito em outra linguagem, <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_objeto" id="w">c&oacute;digo objeto</a>.<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup> Ele &eacute; chamado <b>compilador</b> por raz&otilde;es hist&oacute;ricas&semi; nos primeiros anos da programa&ccedil;&atilde;o autom&aacute;tica, existiam programas que percorriam bibliotecas de sub&shy;rotinas e as reunia juntas, ou compilava,<sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup> as subrotinas necess&aacute;rias para executar uma determinada tarefa.<sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup><sup id="_ref&shy;4" class="reference"><a href="#_note&shy;4" title="">[4]</a></sup></p>&#10;<p>O nome &#34&semi;compilador&#34&semi; &eacute; usado principalmente para os programas que <a href="http://en.wikipedia.org/wiki/Tradutor#Computa&ccedil;&atilde;o" id="w">traduzem</a> o c&oacute;digo fonte de uma <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_alto_n%C3%ADvel" id="w">linguagem de programa&ccedil;&atilde;o de alto n&iacute;vel</a> para uma <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_baixo_n%C3%ADvel" id="w">linguagem de programa&ccedil;&atilde;o de baixo n&iacute;vel</a> (por exemplo, <i><a href="http://en.wikipedia.org/wiki/Assembly" id="w">Assembly</a></i> ou <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_de_m%C3%A1quina" id="w">c&oacute;digo de m&aacute;quina</a>). Contudo alguns autores citam exemplos de compiladores que traduzem para linguagens de alto n&iacute;vel como <a href="http://en.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">C</a>.<sup id="_ref&shy;5" class="reference"><a href="#_note&shy;5" title="">[5]</a></sup> Para alguns autores um programa que faz uma tradu&ccedil;&atilde;o entre linguagens de alto n&iacute;vel &eacute; normalmente chamado um tradutor, filtro<sup id="_ref&shy;joaojose_a" class="reference"><a href="#_note&shy;joaojose" title="">[6]</a></sup> ou conversor de linguagem. Um programa que traduz uma linguagem de programa&ccedil;&atilde;o de baixo n&iacute;vel para uma linguagem de programa&ccedil;&atilde;o de alto n&iacute;vel &eacute; um <a href="http://en.wikipedia.org/wiki/Descompilador" id="w">descompilador</a>.<sup id="_ref&shy;watt_a" class="reference"><a href="#_note&shy;watt" title="">[7]</a></sup> Um programa que faz uma tradu&ccedil;&atilde;o entre uma linguagem de montagem e o c&oacute;digo de m&aacute;quina &eacute; denominado <a href="http://en.wikipedia.org/wiki/Montador" id="w">montador</a> (<i>assembler</i>).<sup id="_ref&shy;joaojose_b" class="reference"><a href="#_note&shy;joaojose" title="">[6]</a></sup> Um programa que faz uma tradu&ccedil;&atilde;o entre o c&oacute;digo de m&aacute;quina e uma linguagem de montagem &eacute; denominado <a href="http://en.wikipedia.org/wiki/Desmontador" id="w">desmontador</a> (<i>disassembler</i>).<sup id="_ref&shy;watt_b" class="reference"><a href="#_note&shy;watt" title="">[7]</a></sup> Se o programa compilado pode ser executado em um computador cuja <a href="http://en.wikipedia.org/wiki/CPU" id="w">CPU</a> ou <a href="http://en.wikipedia.org/wiki/Sistema_operacional" id="w">sistema operacional</a> &eacute; diferente daquele em que o compilador &eacute; executado, o compilador &eacute; conhecido como um <a href="http://en.wikipedia.org/wiki/Compilador_cruzado" id="w">compilador cruzado</a>.<sup id="_ref&shy;8" class="reference"><a href="#_note&shy;8" title="">[8]</a></sup></p>&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2> Hist&oacute;ria </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Grace_Hopper.jpg%7Cthumb%7C200px" id="w">[[Grace Hopper]] em [[1984]].</a>&#10;Os softwares para os primeiros computadores foram escritos principalmente em linguagem assembly por muitos anos. As linguagens de alto n&iacute;vel de programa&ccedil;&atilde;o n&atilde;o foram inventadas at&eacute; que os benef&iacute;cios de ser capaz de reutilizar software em diferentes tipos de <a href="http://en.wikipedia.org/wiki/CPU" id="w">CPUs</a> passassem a ser significativamente maiores do que o custo de se escrever um compilador. A capacidade de <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria" id="w">mem&oacute;ria</a> muito limitada dos primeiros computadores tamb&eacute;m criava muitos problemas t&eacute;cnicos na implementa&ccedil;&atilde;o de um compilador.</p>&#10;<p>No final da d&eacute;cada de 1950, as linguagens de programa&ccedil;&atilde;o independentes de m&aacute;quina foram propostas. Posteriormente, v&aacute;rios compiladores experimentais foram desenvolvidos. O primeiro compilador foi escrito por <a href="http://en.wikipedia.org/wiki/Grace_Hopper" id="w">Grace Hopper</a>,<sup id="_ref&shy;9" class="reference"><a href="#_note&shy;9" title="">[9]</a></sup> em 1952, para a linguagem de programa&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/Sistema_A&shy;0" id="w">A&shy;0</a>.<sup id="_ref&shy;wexel_a" class="reference"><a href="#_note&shy;wexel" title="">[10]</a></sup> Antes de 1957, foram desenvolvidos esfor&ccedil;os e v&aacute;rias contribui&ccedil;&otilde;es ao desenvolvimento de linguagens de alto n&iacute;vel foram feitas. Entre estes, o desenvolvimento da <a href="http://en.wikipedia.org/wiki/Short_Code" id="w">Short Code</a> (<a href="http://en.wikipedia.org/wiki/UNIVAC" id="w">UNIVAC</a>), <a href="http://en.wikipedia.org/wiki/Speedcoding" id="w">Speedcoding</a> no <a href="http://en.wikipedia.org/wiki/IBM_701" id="w">IBM 701</a>,<sup id="_ref&shy;ibm_a" class="reference"><a href="#_note&shy;ibm" title="">[11]</a></sup><sup id="_ref&shy;ieee_a" class="reference"><a href="#_note&shy;ieee" title="">[12]</a></sup> o Whirlwind, o BACAIC e o PRINT.<sup id="_ref&shy;13" class="reference"><a href="#_note&shy;13" title="">[13]</a></sup> A equipe de desenvolvimento do <a href="http://en.wikipedia.org/wiki/FORTRAN" id="w">FORTRAN</a> liderada por <a href="http://en.wikipedia.org/wiki/John_Backus" id="w">John Backus</a> na <a href="http://en.wikipedia.org/wiki/IBM" id="w">IBM</a> &eacute; geralmente creditada como tendo introduzido o primeiro compilador completo em 1957 (embora tenha ocorrido simultaneamente o desenvolvimento do <i>algebraic translator</i> de Laning e Zierler<sup id="_ref&shy;wexel_b" class="reference"><a href="#_note&shy;wexel" title="">[10]</a></sup>). O <a href="http://en.wikipedia.org/wiki/COBOL" id="w">COBOL</a> &eacute; um exemplo de uma linguagem da primeira gera&ccedil;&atilde;o que compilava em m&uacute;ltiplas arquiteturas, em 1960.<sup id="_ref&shy;14" class="reference"><a href="#_note&shy;14" title="">[14]</a></sup></p>&#10;<p>Em muitos dom&iacute;nios de aplica&ccedil;&atilde;o a id&eacute;ia de usar uma linguagem de alto n&iacute;vel rapidamente ganhou for&ccedil;a. Por causa da funcionalidade de expans&atilde;o apoiada por <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagens de programa&ccedil;&atilde;o</a> recentes e a complexidade crescente de arquiteturas de computadores, os compiladores tornaram&shy;se mais e mais complexos.</p>&#10;<p>Os primeiros compiladores foram escritos em linguagem <i>assembly</i>. O primeiro compilador de <i><a href="http://en.wikipedia.org/wiki/Auto&shy;hospedagem" id="w">auto&shy;hospedagem</a> </i>&shy; capaz de compilar seu pr&oacute;prio c&oacute;digo&shy;fonte em uma linguagem de alto n&iacute;vel &shy; foi criado para o <a href="http://en.wikipedia.org/wiki/Lisp" id="w">Lisp</a> por Tim Hart e Levin Mike no <a href="http://en.wikipedia.org/wiki/Massachusetts_Institute_of_Technology" id="w">MIT</a> em 1962.<sup id="_ref&shy;15" class="reference"><a href="#_note&shy;15" title="">[15]</a></sup></p>&#10;<a id="Caracter%C3%ADsticas" name="Caracter%C3%ADsticas"></a><h2> Caracter&iacute;sticas </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Nt&shy;compilador.png%7Cthumb%7Cesquerda%7C120px" id="w">O processo da compila&ccedil;&atilde;o.</a>&#10;Normalmente, o c&oacute;digo fonte &eacute; escrito em uma linguagem de programa&ccedil;&atilde;o de alto n&iacute;vel, com grande capacidade de abstra&ccedil;&atilde;o, e o c&oacute;digo objeto &eacute; escrito em uma linguagem de baixo n&iacute;vel,<sup id="_ref&shy;16" class="reference"><a href="#_note&shy;16" title="">[16]</a></sup> como uma sequ&ecirc;ncia de instru&ccedil;&otilde;es a ser executada pelo <a href="http://en.wikipedia.org/wiki/Microprocessador" id="w">microprocessador</a>.</p>&#10;<p>O processo de compila&ccedil;&atilde;o &eacute; composto de an&aacute;lise e s&iacute;ntese.<sup id="_ref&shy;holmes_a" class="reference"><a href="#_note&shy;holmes" title="">[17]</a></sup> A an&aacute;lise tem como objetivo entender o c&oacute;digo fonte e represent&aacute;&shy;lo em uma estrutura intermedi&aacute;ria. A s&iacute;ntese constr&oacute;i o c&oacute;digo objecto a partir desta representa&ccedil;&atilde;o intermedi&aacute;ria.</p>&#10;<p>A <i>an&aacute;lise</i> pode ser subdividida ainda em <a href="http://en.wikipedia.org/wiki/An%C3%A1lise_l%C3%A9xica" id="w">an&aacute;lise l&eacute;xica</a>, <a href="http://en.wikipedia.org/wiki/An%C3%A1lise_sint%C3%A1tica_(computa%C3%A7%C3%A3o)" id="w">an&aacute;lise sint&aacute;tica</a>, <a href="http://en.wikipedia.org/wiki/An%C3%A1lise_sem%C3%A2ntica" id="w">an&aacute;lise sem&acirc;ntica</a> e <a href="http://en.wikipedia.org/wiki/Gera%C3%A7%C3%A3o_de_c%C3%B3digo" id="w">gera&ccedil;&atilde;o de c&oacute;digo</a> intermedi&aacute;rio. &Eacute; tamb&eacute;m conhecida como <i>front end</i>.<sup id="_ref&shy;holmes_b" class="reference"><a href="#_note&shy;holmes" title="">[17]</a></sup> A <i>s&iacute;ntese</i> pode ter mais varia&ccedil;&otilde;es de um compilador a outro, podendo ser composta pelas etapas de optimiza&ccedil;&atilde;o de c&oacute;digo e gera&ccedil;&atilde;o de c&oacute;digo final (ou c&oacute;digo de m&aacute;quina), sendo somente esta &uacute;ltima etapa &eacute; obrigat&oacute;ria. &Eacute; tamb&eacute;m conhecida como <i>back end</i>.<sup id="_ref&shy;holmes_c" class="reference"><a href="#_note&shy;holmes" title="">[17]</a></sup></p>&#10;<p>Classicamente, um compilador traduz um programa de uma linguagem textual facilmente entendida por um ser humano para uma linguagem de m&aacute;quina, espec&iacute;fica para um processador e sistema operacional. Atualmente, por&eacute;m, s&atilde;o comuns compiladores que geram c&oacute;digo para uma m&aacute;quina virtual que &eacute;, depois, interpretada por um interpretador.</p>&#10;<p>Em <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagens</a> h&iacute;bridas, o compilador tem o papel de converter o c&oacute;digo fonte em um c&oacute;digo chamado de <i>byte code</i>, que &eacute; uma linguagem de baixo n&iacute;vel. Um exemplo deste comportamento &eacute; o do compilador da linguagem <a href="http://en.wikipedia.org/wiki/Java_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Java</a> que, em vez de gerar c&oacute;digo da m&aacute;quina hospedeira (onde se est&aacute; executando o compilador), gera c&oacute;digo chamado <i>Java <a href="http://en.wikipedia.org/wiki/Bytecode" id="w">Bytecode</a></i>.<sup id="_ref&shy;18" class="reference"><a href="#_note&shy;18" title="">[18]</a></sup></p>&#10;<p>Um compilador &eacute; chamado de <i><a href="http://en.wikipedia.org/wiki/JIT" id="w">Just&shy;in&shy;time compiler</a></i> (JIT) quando seu processo de compila&ccedil;&atilde;o acontece apenas quando o c&oacute;digo &eacute; chamado.<sup id="_ref&shy;jit_a" class="reference"><a href="#_note&shy;jit" title="">[19]</a></sup> Um JIT pode fazer otimiza&ccedil;&otilde;es &agrave;s instru&ccedil;&otilde;es a medida que as compila.<sup id="_ref&shy;jit_b" class="reference"><a href="#_note&shy;jit" title="">[19]</a></sup></p>&#10;<p>Muitos compiladores incluem um <a href="http://en.wikipedia.org/wiki/Pr%C3%A9&shy;processador" id="w">pr&eacute;&shy;processador</a>. Um pr&eacute;&shy;processador &eacute; um programa separado, ativado pelo compilador antes do in&iacute;cio do processo de tradu&ccedil;&atilde;o.<sup id="_ref&shy;20" class="reference"><a href="#_note&shy;20" title="">[20]</a></sup> Normalmente &eacute; respons&aacute;vel por mudan&ccedil;as no c&oacute;digo fonte destinadas de acordo com decis&otilde;es tomadas em tempo de compila&ccedil;&atilde;o. Por exemplo, um programa em <a href="http://en.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">C</a> permite instru&ccedil;&otilde;es condicionais para o pr&eacute;&shy;processador que podem incluir ou n&atilde;o parte do c&oacute;digo caso uma assertiva l&oacute;gica seja verdadeira ou falsa, ou simplesmente um termo esteja definido ou n&atilde;o. Tecnicamente, pr&eacute;&shy;processadores s&atilde;o muito mais simples que compiladores e s&atilde;o vistos, pelos desenvolvedores, como programas &agrave; parte, apesar dessa vis&atilde;o n&atilde;o ser necessariamente compartilhada pelo usu&aacute;rio.</p>&#10;<p>Outra parte separada do compilador que muitos usu&aacute;rios v&ecirc;em como integrada &eacute; o <a href="http://en.wikipedia.org/wiki/Linker" id="w">linker</a>, cuja fun&ccedil;&atilde;o &eacute; unir v&aacute;rios programas j&aacute; compilados de uma forma independente e unific&aacute;&shy;los em um programa execut&aacute;vel.<sup id="_ref&shy;21" class="reference"><a href="#_note&shy;21" title="">[21]</a></sup> Isso inclui colocar o programa final em um formato compat&iacute;vel com as necessidades do sistema operacional para carreg&aacute;&shy;lo em mem&oacute;ria e coloc&aacute;&shy;lo em execu&ccedil;&atilde;o.</p>&#10;<a id="Fases_da_compila%C3%A7%C3%A3o" name="Fases_da_compila%C3%A7%C3%A3o"></a><h2> Fases da compila&ccedil;&atilde;o </h2>&#10;<a id="An%C3%A1lise_l%C3%A9xica" name="An%C3%A1lise_l%C3%A9xica"></a><h3> An&aacute;lise l&eacute;xica </h3>&#10;<p> </p>&#10;<p>A an&aacute;lise l&eacute;xica &eacute; a primeira fase do compilador.<sup id="_ref&shy;ahoparsing_a" class="reference"><a href="#_note&shy;ahoparsing" title="">[22]</a></sup> A fun&ccedil;&atilde;o do analisador l&eacute;xico, tamb&eacute;m denominado <i>scanner</i>, &eacute; ler o c&oacute;digo fonte, caracter a caracter, buscando a separa&ccedil;&atilde;o e identifica&ccedil;&atilde;o dos elementos componentes do programa fonte, denominados s&iacute;mbolos l&eacute;xicos ou <i>tokens</i>.<sup id="_ref&shy;anaprice_a" class="reference"><a href="#_note&shy;anaprice" title="">[23]</a></sup> &Eacute; tamb&eacute;m de responsabilidade desta fase a elimina&ccedil;&atilde;o de elementos &#34&semi;decorativos&#34&semi; do programa, tais como espa&ccedil;os em branco, marcas de formata&ccedil;&atilde;o de texto e coment&aacute;rios.<sup id="_ref&shy;rangel_a" class="reference"><a href="#_note&shy;rangel" title="">[24]</a></sup> Existem dispon&iacute;veis uma s&eacute;rie de geradores autom&aacute;ticos de analisadores l&eacute;xicos, como por exemplo, o <a href="http://en.wikipedia.org/wiki/Lex" id="w">lex</a>. O objetivo dos geradores autom&aacute;ticos &eacute; limitar o esfor&ccedil;o de programa&ccedil;&atilde;o de um analisador l&eacute;xico especificando&shy;se apenas os <a href="http://en.wikipedia.org/wiki/Token" id="w">&#39&semi;&#39&semi;tokens&#39&semi;&#39&semi;</a> a ser reconhecidos.<sup id="_ref&shy;25" class="reference"><a href="#_note&shy;25" title="">[25]</a></sup></p>&#10;<a id="An%C3%A1lise_sint%C3%A1tica" name="An%C3%A1lise_sint%C3%A1tica"></a><h3> An&aacute;lise sint&aacute;tica </h3>&#10;<p> </p>&#10;<p>A an&aacute;lise sint&aacute;tica, ou an&aacute;lise gramatical &eacute; o processo de se determinar se uma cadeia de s&iacute;mbolos l&eacute;xicos pode ser gerada por uma <a href="http://en.wikipedia.org/wiki/Gram%C3%A1tica_formal" id="w">gram&aacute;tica</a>.<sup id="_ref&shy;aho_a" class="reference"><a href="#_note&shy;aho" title="">[26]</a></sup> O analisador sint&aacute;tico &eacute; o cerne do compilador, respons&aacute;vel por verificar se os s&iacute;mbolos contidos no programa fonte formam um programa v&aacute;lido, ou n&atilde;o.<sup id="_ref&shy;delamaro_a" class="reference"><a href="#_note&shy;delamaro" title="">[27]</a></sup> No caso de analisadores sint&aacute;ticos <i>top&shy;down</i>, temos a op&ccedil;&atilde;o de escrev&ecirc;&shy;los &agrave; m&atilde;o ou ger&aacute;&shy;los de forma autom&aacute;tica, mas os analisadores <i>bottom&shy;up</i> s&oacute; podem ser gerados automaticamente.<sup id="_ref&shy;grune_a" class="reference"><a href="#_note&shy;grune" title="">[28]</a></sup> A maioria dos m&eacute;todos de an&aacute;lise sint&aacute;tica, cai em uma dessas duas classes denominadas <i>top&shy;down</i> e <i>bottom&shy;up</i>.<sup id="_ref&shy;lewis_a" class="reference"><a href="#_note&shy;lewis" title="">[29]</a></sup> Entre os m&eacute;todos <i>top&shy;down</i> os mais importantes s&atilde;o a an&aacute;lise sint&aacute;tica descendente recursiva e a an&aacute;lise sint&aacute;tica preditiva n&atilde;o&shy;recursiva. Entre os m&eacute;todos de an&aacute;lise sint&aacute;tica <i>bottom&shy;up</i> os mais importantes s&atilde;o a an&aacute;lise sint&aacute;tica de preced&ecirc;ncia de operadores, an&aacute;lise sint&aacute;tica LR can&ocirc;nico, an&aacute;lise sint&aacute;tica LALR e an&aacute;lise sint&aacute;tica SLR.<sup id="_ref&shy;aho_b" class="reference"><a href="#_note&shy;aho" title="">[26]</a></sup> Existem dispon&iacute;veis uma s&eacute;rie de geradores autom&aacute;ticos de analisadores sint&aacute;ticos,<sup id="_ref&shy;30" class="reference"><a href="#_note&shy;30" title="">[30]</a></sup> como por exemplo, o <a href="http://en.wikipedia.org/wiki/Yacc" id="w">Yacc</a>, o <a href="http://en.wikipedia.org/wiki/Bison" id="w">Bison</a> e o <a href="http://en.wikipedia.org/wiki/JavaCC" id="w">JavaCC</a>.</p>&#10;<a id="An%C3%A1lise_sem%C3%A2ntica" name="An%C3%A1lise_sem%C3%A2ntica"></a><h3> An&aacute;lise sem&acirc;ntica </h3>&#10;<p> </p>&#10;<p>As an&aacute;lises l&eacute;xica e sint&aacute;tica n&atilde;o est&atilde;o preocupadas com o significado ou sem&acirc;ntica dos programas que elas processam. O papel do analisador sem&acirc;ntico &eacute; prover m&eacute;todos pelos quais as estruturas constru&iacute;das pelo analisador sint&aacute;tico possam ser avaliadas ou executadas.<sup id="_ref&shy;watson_a" class="reference"><a href="#_note&shy;watson" title="">[31]</a></sup> As gram&aacute;ticas livres de contexto n&atilde;o s&atilde;o suficientemente poderosas para descrever uma s&eacute;rie de constru&ccedil;&otilde;es das linguagens de programa&ccedil;&atilde;o, como por exemplo regras de escopo, regras de visibilidade e consist&ecirc;ncia de tipos.<sup id="_ref&shy;wilhelm_a" class="reference"><a href="#_note&shy;wilhelm" title="">[32]</a></sup> &Eacute; papel do analisador sem&acirc;ntico assegurar que todas as regras sens&iacute;veis ao contexto da linguagem estejam analisadas e verificadas quanto &agrave; sua validade. Um exemplo de tarefa pr&oacute;pria do analisador sem&acirc;ntico &eacute; a checagem de tipos de vari&aacute;veis em express&otilde;es.<sup id="_ref&shy;tremblay_a" class="reference"><a href="#_note&shy;tremblay" title="">[33]</a></sup> Um dos mecanismos comumente utilizados por implementadores de compiladores &eacute; a <a href="http://en.wikipedia.org/wiki/Gram%C3%A1tica_de_Atributos" id="w">Gram&aacute;tica de Atributos</a>, que consiste em uma <a href="http://en.wikipedia.org/wiki/Gram%C3%A1tica_formal" id="w">gram&aacute;tica</a> livre de contexto acrescentada de um conjunto finito de atributos e um conjunto finito de predicados sobre estes atributos.<sup id="_ref&shy;pittman_a" class="reference"><a href="#_note&shy;pittman" title="">[34]</a></sup></p>&#10;<a id="Gera%C3%A7%C3%A3o_de_c%C3%B3digo_intermedi%C3%A1rio" name="Gera%C3%A7%C3%A3o_de_c%C3%B3digo_intermedi%C3%A1rio"></a><h3> Gera&ccedil;&atilde;o de c&oacute;digo intermedi&aacute;rio </h3>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Cod_3_end.png%7Cthumb%7C200px%7CExemplo_de_c%C3%B3digo_de_tr%C3%AAs_endere%C3%A7os_e_um_%5B%5BGrafos_ac%C3%ADclicos_dirigidos" id="w">DAG]] correspondente para uma express&atilde;o aritim&eacute;tica.</a>&#10; </p>&#10;<p>Na fase de gera&ccedil;&atilde;o de c&oacute;digo intermedi&aacute;rio, ocorre a transforma&ccedil;&atilde;o da &aacute;rvore sint&aacute;tica em uma representa&ccedil;&atilde;o intermedi&aacute;ria do c&oacute;digo fonte. Esta linguagem intermedi&aacute;ria &eacute; mais pr&oacute;xima da linguagem objeto do que o c&oacute;digo fonte, mas ainda permite uma manipula&ccedil;&atilde;o mais f&aacute;cil do que se c&oacute;digo assembly ou c&oacute;digo de m&aacute;quina fosse utilizado.<sup id="_ref&shy;35" class="reference"><a href="#_note&shy;35" title="">[35]</a></sup> Um tipo popular de linguagem intermedi&aacute;ria &eacute; conhecido como <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_de_tr%C3%AAs_endere%C3%A7os" id="w">c&oacute;digo de tr&ecirc;s endere&ccedil;os</a>.<sup id="_ref&shy;36" class="reference"><a href="#_note&shy;36" title="">[36]</a></sup> Neste tipo de c&oacute;digo uma senten&ccedil;a t&iacute;pica tem a forma <code>X := A op B</code>, onde <i>X</i>, <i>A</i> e <i>B</i> s&atilde;o operandos e <i>op</i> uma opera&ccedil;&atilde;o qualquer. Uma forma pr&aacute;tica de representar senten&ccedil;as de tr&ecirc;s endere&ccedil;os &eacute; atrav&eacute;s do uso de qu&aacute;druplas (operador, argumento 1, argumento 2 e, resultado). Este esquema de representa&ccedil;&atilde;o de c&oacute;digo intermedi&aacute;rio &eacute; preferido por diversos compiladores, principalmente aqueles que executam extensivas otimiza&ccedil;&otilde;es de c&oacute;digo, uma vez que o c&oacute;digo intermedi&aacute;rio pode ser rearranjado de uma maneira conveniente com facilidade.<sup id="_ref&shy;aho pcd_a" class="reference"><a href="#_note&shy;aho pcd" title="">[37]</a></sup>Outras representa&ccedil;&otilde;es de c&oacute;digo intermedi&aacute;rio comumente usadas s&atilde;o as triplas, (similares as qu&aacute;druplas exceto pelo fato de que os resultados n&atilde;o s&atilde;o nomeados explicitamente) as &aacute;rvores, os <a href="http://en.wikipedia.org/wiki/Grafos_ac%C3%ADclicos_dirigidos" id="w">grafos ac&iacute;clicos dirigidos</a>(DAG) e a <a href="http://en.wikipedia.org/wiki/Nota%C3%A7%C3%A3o_polonesa" id="w">nota&ccedil;&atilde;o polonesa</a>.<sup id="_ref&shy;38" class="reference"><a href="#_note&shy;38" title="">[38]</a></sup></p>&#10;<a id="Optimiza%C3%A7%C3%A3o_de_c%C3%B3digo" name="Optimiza%C3%A7%C3%A3o_de_c%C3%B3digo"></a><h3> Optimiza&ccedil;&atilde;o de c&oacute;digo </h3>&#10;&#10;<p>A Otimiza&ccedil;&atilde;o de c&oacute;digo &eacute; a estrat&eacute;gia de examinar o c&oacute;digo intermedi&aacute;rio, produzido durante a fase de gera&ccedil;&atilde;o de c&oacute;digo com objetivo de produzir, atrav&eacute;s de algumas t&eacute;cnicas, um c&oacute;digo que execute com bastante efici&ecirc;ncia.<sup id="_ref&shy;tremblay_b" class="reference"><a href="#_note&shy;tremblay" title="">[33]</a></sup> O nome optimizador deve sempre ser encarado com cuidado, pois n&atilde;o se pode criar um programa que leia um programa P e gere um programa P&acute; equivalente sendo melhor poss&iacute;vel segundo o crit&eacute;rio adotado.<sup id="_ref&shy;rangel_b" class="reference"><a href="#_note&shy;rangel" title="">[24]</a></sup> V&aacute;rias t&eacute;cnicas e v&aacute;rias tarefas se re&uacute;nem sob o nome de Optimiza&ccedil;&atilde;o. Estas t&eacute;cnicas consistem em detectar padr&otilde;es dentro do c&oacute;digo produzido e substitu&iacute;&shy;los por c&oacute;digos mais eficientes.<sup id="_ref&shy;aho pcd_b" class="reference"><a href="#_note&shy;aho pcd" title="">[37]</a></sup> Entre as t&eacute;cnicas usadas est&atilde;o a substitui&ccedil;&atilde;o de express&otilde;es que podem ser avaliadas durante o tempo de compila&ccedil;&atilde;o pelos seus valores calculados, elimina&ccedil;&atilde;o de sub&shy;express&otilde;es redundantes, desmembramento de la&ccedil;os, substitui&ccedil;&atilde;o de opera&ccedil;&otilde;es (multiplica&ccedil;&atilde;o por <i>shifts</i>), entre outras.<sup id="_ref&shy;tremblay_c" class="reference"><a href="#_note&shy;tremblay" title="">[33]</a></sup> Uma das t&eacute;cnicas de optimiza&ccedil;&atilde;o mais eficazes e independente de m&aacute;quina &eacute; a otimiza&ccedil;&atilde;o de la&ccedil;os, pois la&ccedil;os internos s&atilde;o bons candidatos para melhorias. Por exemplo, em caso de computa&ccedil;&otilde;es fixas dentro de la&ccedil;os, &eacute; poss&iacute;vel mover estas computa&ccedil;&otilde;es para fora dos mesmos reduzindo processamento.<sup id="_ref&shy;39" class="reference"><a href="#_note&shy;39" title="">[39]</a></sup></p>&#10;<a id="Gera%C3%A7%C3%A3o_de_c%C3%B3digo_final" name="Gera%C3%A7%C3%A3o_de_c%C3%B3digo_final"></a><h3> Gera&ccedil;&atilde;o de c&oacute;digo final </h3>&#10;<p> </p>&#10;<p>A fase de gera&ccedil;&atilde;o de c&oacute;digo final &eacute; a &uacute;ltima fase da compila&ccedil;&atilde;o. A gera&ccedil;&atilde;o de um bom c&oacute;digo objeto &eacute; dif&iacute;cil devido aos detalhes particulares das m&aacute;quinas para os quais o c&oacute;digo &eacute; gerado. Contudo, &eacute; uma fase importante, pois uma boa gera&ccedil;&atilde;o de c&oacute;digo pode ser, por exemplo, duas vezes mais r&aacute;pida que um algoritmo de gera&ccedil;&atilde;o de c&oacute;digo ineficiente.<sup id="_ref&shy;aho pcd_c" class="reference"><a href="#_note&shy;aho pcd" title="">[37]</a></sup> Nem todas as t&eacute;cnicas de optimiza&ccedil;&atilde;o s&atilde;o independentes da arquitetura da m&aacute;quina&shy;alvo. Optimiza&ccedil;&otilde;es dependentes da m&aacute;quina necessitam de informa&ccedil;&otilde;es tais como os limites e os recursos especiais da m&aacute;quina&shy;alvo a fim de produzir um c&oacute;digo mais compacto e eficiente. O c&oacute;digo produzido pelo compilador deve se aproveitar dos recursos especiais de cada m&aacute;quina&shy;alvo.<sup id="_ref&shy;tremblay_d" class="reference"><a href="#_note&shy;tremblay" title="">[33]</a></sup> Segundo Aho, o c&oacute;digo objeto pode ser uma sequ&ecirc;ncia de instru&ccedil;&otilde;es absolutas de m&aacute;quina, uma sequ&ecirc;ncia de instru&ccedil;&otilde;es de m&aacute;quina reloc&aacute;veis, um programa em linguagem assembly ou um programa em outra linguagem.<sup id="_ref&shy;40" class="reference"><a href="#_note&shy;40" title="">[40]</a></sup></p>&#10;<a id="Tratamento_de_erros" name="Tratamento_de_erros"></a><h2> Tratamento de erros </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Erro_de_execu%C3%A7%C3%A3o.png%7Cthumb%7Cesquerda%7C300px%7CTratamento_de_erro_de_execu%C3%A7%C3%A3o_em_uma_aplica%C3%A7%C3%A3o_%5B%5BJava_(linguagem_de_programa%C3%A7%C3%A3o)%7CJava%5D%5D_no_%5B%5BEclipse_(software)" id="w">Eclipse]].</a>&#10;O tratamento de erros est&aacute; voltado a falhas devido a muitas causas: erros no compilador, erros na elabora&ccedil;&atilde;o do programa a ser compilado, erros no ambiente (hardware, sistema operacional), dados incorretos, etc. As tarefas relacionadas ao tratamento de erros consitem em detectar cada erro, report&aacute;&shy;lo ao usu&aacute;rio e possivelmente fazer algum reparo para que o processamento possa continuar.<sup id="_ref&shy;41" class="reference"><a href="#_note&shy;41" title="">[41]</a></sup></p>&#10;<p>Os erros podem ser classificados em erros l&eacute;xicos, erros sint&aacute;ticos, erros n&atilde;o independentes de contexto (sem&acirc;nticos), erros de execu&ccedil;&atilde;o e erros de limite.<sup id="_ref&shy;hunter_a" class="reference"><a href="#_note&shy;hunter" title="">[42]</a></sup> Os erros l&eacute;xicos ocorrem quando um <a href="http://en.wikipedia.org/wiki/Token" id="w">token</a> identificado n&atilde;o pertence a gram&aacute;tica da linguagem fonte. Os erros sint&aacute;ticos ocorrem quando alguma estrutura de frase n&atilde;o est&aacute; de acordo com a gram&aacute;tica, como por exemplo par&ecirc;nteses sem correspond&ecirc;ncia. Os erros n&atilde;o independentes de contexto em geral s&atilde;o associados a n&atilde;o declara&ccedil;&atilde;o de objetos como vari&aacute;veis e erros de tipos. Os erros de execu&ccedil;&atilde;o ocorrem ap&oacute;s a compila&ccedil;&atilde;o, quando o programa j&aacute; est&aacute; sendo executado. Um exemplo t&iacute;pico &eacute; o da divis&atilde;o por zero. Os erros de limite, ocorrem durante a execu&ccedil;&atilde;o e est&atilde;o relacionados as caracter&iacute;sticas da m&aacute;quina na qual o programa est&aacute; sendo executado, como por exemplo, estouro de pilha.<sup id="_ref&shy;hunter_b" class="reference"><a href="#_note&shy;hunter" title="">[42]</a></sup></p>&#10;<p>Alguns compiladores encerram o processo de tradu&ccedil;&atilde;o logo ao encontrar o primeiro erro do programa&shy;fonte. Esta &eacute; uma pol&iacute;tica de f&aacute;cil implementa&ccedil;&atilde;o. Compiladores mais sofisticados, por&eacute;m, detectam o maior n&uacute;mero poss&iacute;vel de erros visando diminuir o n&uacute;mero de compila&ccedil;&otilde;es.<sup id="_ref&shy;43" class="reference"><a href="#_note&shy;43" title="">[43]</a></sup></p>&#10;<p>A recupera&ccedil;&atilde;o de erros em analisadores sint&aacute;ticos <i>top&shy;down</i> &eacute; mais f&aacute;cil de implementar do que em analisadores <i>bottom&shy;up</i>.<sup id="_ref&shy;holub_a" class="reference"><a href="#_note&shy;holub" title="">[44]</a></sup> O problema &eacute; que diferente de um analisador <i>top&shy;down</i>, este &uacute;ltimo n&atilde;o sabe quais s&iacute;mbolos s&atilde;o esperados na entrada, somente os que j&aacute; foram processados. Pode&shy;se usar neste caso t&eacute;cnicas como, por exemplo, a t&eacute;cnica de <i>panic&shy;mode</i> que procura em tabelas sint&aacute;ticas em busca de s&iacute;mbolos v&aacute;lidos na entrada.<sup id="_ref&shy;holub_b" class="reference"><a href="#_note&shy;holub" title="">[44]</a></sup> Nesta t&eacute;cnica se descartam s&iacute;mbolos da entrada at&eacute; que um delimitador (como um ponto e v&iacute;rgula, por exemplo) seja encontrado. O analisador apaga as entradas da pilha at&eacute; que encontre uma entrada que permita que o processo de an&aacute;lise prossiga em diante.<sup id="_ref&shy;45" class="reference"><a href="#_note&shy;45" title="">[45]</a></sup></p>&#10;<a id="Notas" name="Notas"></a><h2> Notas </h2>&#10;<p /><ol class="references">&#10;<li id="_note&shy;1"><b><a href="#_ref&shy;1" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;2"><b><a href="#_ref&shy;2" title="">&uarr&semi;</a></b> Em <a href="http://en.wikipedia.org/wiki/L%C3%ADngua_portuguesa" id="w">portugu&ecirc;s</a>, &#34&semi;<i>compilar</i>&#34&semi; significa, por exemplo: reunir obras liter&aacute;rias, documentos, escritos de v&aacute;rios autores, entre outros, compondo uma obra com esse material.  </li><li id="_note&shy;3"><b><a href="#_ref&shy;3" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;4"><b><a href="#_ref&shy;4" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;5"><b><a href="#_ref&shy;5" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;joaojose">&uarr&semi; <a href="#_ref&shy;joaojose_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;joaojose_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;watt">&uarr&semi; <a href="#_ref&shy;watt_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;watt_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;8"><b><a href="#_ref&shy;8" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;9"><b><a href="#_ref&shy;9" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;wexel">&uarr&semi; <a href="#_ref&shy;wexel_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;wexel_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;11"><b><a href="#_ref&shy;11" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;12"><b><a href="#_ref&shy;12" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;13"><b><a href="#_ref&shy;13" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;14"><b><a href="#_ref&shy;14" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;15"><b><a href="#_ref&shy;15" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;16"><b><a href="#_ref&shy;16" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;holmes">&uarr&semi; <a href="#_ref&shy;holmes_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;holmes_b" title=""><sup><i><b>b</b></i></sup></a> <a href="#_ref&shy;holmes_c" title=""><sup><i><b>c</b></i></sup></a>  </li><li id="_note&shy;18"><b><a href="#_ref&shy;18" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;jit">&uarr&semi; <a href="#_ref&shy;jit_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;jit_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;20"><b><a href="#_ref&shy;20" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;21"><b><a href="#_ref&shy;21" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;22"><b><a href="#_ref&shy;22" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;23"><b><a href="#_ref&shy;23" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;rangel">&uarr&semi; <a href="#_ref&shy;rangel_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;rangel_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;25"><b><a href="#_ref&shy;25" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;aho">&uarr&semi; <a href="#_ref&shy;aho_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;aho_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;27"><b><a href="#_ref&shy;27" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;28"><b><a href="#_ref&shy;28" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;29"><b><a href="#_ref&shy;29" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;30"><b><a href="#_ref&shy;30" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;31"><b><a href="#_ref&shy;31" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;32"><b><a href="#_ref&shy;32" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;tremblay">&uarr&semi; <a href="#_ref&shy;tremblay_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;tremblay_b" title=""><sup><i><b>b</b></i></sup></a> <a href="#_ref&shy;tremblay_c" title=""><sup><i><b>c</b></i></sup></a> <a href="#_ref&shy;tremblay_d" title=""><sup><i><b>d</b></i></sup></a>  </li><li id="_note&shy;34"><b><a href="#_ref&shy;34" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;35"><b><a href="#_ref&shy;35" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;36"><b><a href="#_ref&shy;36" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;aho pcd">&uarr&semi; <a href="#_ref&shy;aho pcd_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;aho pcd_b" title=""><sup><i><b>b</b></i></sup></a> <a href="#_ref&shy;aho pcd_c" title=""><sup><i><b>c</b></i></sup></a>  </li><li id="_note&shy;38"><b><a href="#_ref&shy;38" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;39"><b><a href="#_ref&shy;39" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;40"><b><a href="#_ref&shy;40" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;41"><b><a href="#_ref&shy;41" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;hunter">&uarr&semi; <a href="#_ref&shy;hunter_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;hunter_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;43"><b><a href="#_ref&shy;43" title="">&uarr&semi;</a></b>  </li><li id="_note&shy;holub">&uarr&semi; <a href="#_ref&shy;holub_a" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref&shy;holub_b" title=""><sup><i><b>b</b></i></sup></a>  </li><li id="_note&shy;45"><b><a href="#_ref&shy;45" title="">&uarr&semi;</a></b>  </li></ol><a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">Ci&ecirc;ncia da computa&ccedil;&atilde;o</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/JIT" id="w">Compilador Just in Time (JIT)</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagens_formais_e_compiladores" id="w">Linguagens formais</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">Linguagem de programa&ccedil;&atilde;o</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Interpretador" id="w">Interpretador</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Linker" id="w">Linker</a></li></ul>&#10;<a id="Bibliografia" name="Bibliografia"></a><h2> Bibliografia </h2>&#10;&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li></ul>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;<p> &#10;</p>&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Compiladores" id="w"> </a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Programa%C3%A7%C3%A3o" id="w">Categoria:Programa&ccedil;&atilde;o</a></p></body></html>