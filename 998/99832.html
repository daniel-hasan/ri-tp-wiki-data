<html><title>&Aacute;lgebra relacional</title><body>&#10;<p>Em <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncias_da_computa%C3%A7%C3%A3o" id="w">ci&ecirc;ncias da computa&ccedil;&atilde;o</a>, <b>&aacute;lgebra relacional</b> e uma deriva&ccedil;&atilde;o descendente da <a href="http://en.wikipedia.org/wiki/L%C3%B3gica_de_primeira_ordem" id="w">l&oacute;gica de primeira ordem</a> e da <a href="http://en.wikipedia.org/wiki/&Aacute;lgebra_de_conjuntos" id="w">&aacute;lgebra de conjuntos</a> em rela&ccedil;&atilde;o das <a href="http://en.wikipedia.org/wiki/Opera%C3%A7%C3%A3o_(matem%C3%A1tica)" id="w">opera&ccedil;&otilde;es</a> sobre a <a href="http://en.wikipedia.org/wiki/Rela%C3%A7%C3%A3o_(matem%C3%A1tica)" id="w">rela&ccedil;&atilde;o fin&iacute;timo</a>, que auxilia o trabalho ao identificar os componentes de uma <a href="http://en.wikipedia.org/wiki/Tupla" id="w">tupla</a> por nome (chamado o atributo) ao inv&eacute;s de uma coluna de chaves num&eacute;ricas, o qual &eacute; chamado a <a href="http://en.wikipedia.org/wiki/Rela%C3%A7%C3%A3o_(bancodados)" id="w">rela&ccedil;&atilde;o</a> na terminologia de banco de dados.</p>&#10;<p>A principal aplica&ccedil;&atilde;o da &aacute;lgebra relacional &eacute; sustentar a fundamenta&ccedil;&atilde;o te&oacute;rica de <a href="http://en.wikipedia.org/wiki/Banco_de_dados_relacional" id="w">banco de dados relacional</a>, particularmente <a href="http://en.wikipedia.org/wiki/Linguagem_de_consulta" id="w">linguagem de consulta</a> para tais bancos de dados, entre os maiores o <a href="http://en.wikipedia.org/wiki/SQL" id="w">SQL</a>.</p>&#10;<a id="Introdu%C3%A7%C3%A3o" name="Introdu%C3%A7%C3%A3o"></a><h2> Introdu&ccedil;&atilde;o </h2>&#10;<p>A &aacute;lgebra relacional recebia pouca aten&ccedil;&atilde;o fora do campo da matem&aacute;tica pura at&eacute; &agrave; publica&ccedil;&atilde;o em 1970 do <a href="http://en.wikipedia.org/wiki/Modelo__relacional" id="w">modelo relacional de dados</a> de <a href="http://en.wikipedia.org/wiki/Edgar_Frank_Codd" id="w">E.F. Codd</a>. Codd prop&ocirc;s tal &aacute;lgebra como a base das linguagens de consulta de banco de dados. (Ver sec&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/#Implementa&ccedil;&otilde;es" id="w">Implementa&ccedil;&otilde;es</a>.) </p>&#10;<p>Na &aacute;lgebra relacional, s&atilde;o admitidas ambas perspectivas de dar um nome ou n&atilde;o, dependendo se as tuplas s&atilde;o dotadas de nome de componente ou n&atilde;o. Na perspectiva sem nome, a <a href="http://en.wikipedia.org/wiki/Enupla" id="w">tupla</a> &eacute; simplesmente um membro de um <a href="http://en.wikipedia.org/wiki/Produto_cartesiano" id="w">produto cartesiano</a>. Na perspectiva da tupla ter um nome de componente, tuplas s&atilde;o fun&ccedil;&otilde;es do conjunto finito de atributos <i>U</i> (da rela&ccedil;&atilde;o) a um domin&iacute;o de valores (assumidos distintos dos de <i>U</i>).<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup> As &aacute;lgebras relacionais obtidas das duas perspectivas s&atilde;o equivalentes.<sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup> Um livro t&iacute;pico de gradua&ccedil;&atilde;o apresenta s&oacute; a perspectiva de nomear<sup id="_ref&shy;SilberschatzKorth2010_a" class="reference"><a href="#_note&shy;SilberschatzKorth2010" title="">[3]</a></sup><sup id="_ref&shy;RamakrishnanGehrke2003_a" class="reference"><a href="#_note&shy;RamakrishnanGehrke2003" title="">[4]</a></sup> e este artigo segue isso.</p>&#10;<p>A &aacute;lgebra relacional &eacute; equivalente em poder expressivo a <a href="http://en.wikipedia.org/wiki/C%C3%A1lculo_relacional" id="w">c&aacute;lculo relacional</a> (e por conseguinte <a href="http://en.wikipedia.org/wiki/L%C3%B3gica_de_primeira_ordem" id="w">l&oacute;gica de predicado ou primeira ordem</a>)&semi; esse resultado &eacute; conhecido como o <a href="http://en.wikipedia.org/wiki/Teorema_de_Codd" id="w">teorema de Codd</a>. Na pr&aacute;tica, deve ser prestada aten&ccedil;&atilde;o em desambiguar as duas linguagens porque a nega&ccedil;&atilde;o quando aplicada a uma formula em c&aacute;lculo, faz a constru&ccedil;&atilde;o da formula que pode ser verdadeira ou um conjunto infinito de tuplas, enquanto o operador diferen&ccedil;a na &aacute;lgebra relacional devolve sempre um resultado finito. Para ultrapassar estas dificuldades, Codd restringiu os operandos da &aacute;lgebra relacional somente para rela&ccedil;&atilde;o finita e prop&ocirc;s suporte restrito para a nega&ccedil;&atilde;o (NOT) e a disjun&ccedil;&atilde;o (OR). Restri&ccedil;&otilde;es an&aacute;logas s&atilde;o encontradas em muitas outras linguagens de programa&ccedil;&atilde;o l&oacute;gicas. Codd definiu o termo <b><i>completeza relacional</i></b> para se referir a uma linguagem que est&aacute; completa em respeito a c&aacute;lculo de l&oacute;gica da primeira ordem &agrave; parte com as restri&ccedil;&otilde;es que ele propunha. Na pr&aacute;tica as restri&ccedil;&otilde;es t&ecirc;m um efeito adverso na aplicabilidade da sua &aacute;lgebra relacional para usos de banco de dados. </p>&#10;<p>Definimos assim a &aacute;lgebra relacional como uma linguagem de consulta formal i.e. uma cole&ccedil;&atilde;o de opera&ccedil;&otilde;es de alto n&iacute;vel sobre rela&ccedil;&otilde;es ou <a href="http://en.wikipedia.org/wiki/Conjuntos" id="w">conjuntos</a>. As opera&ccedil;&otilde;es em quest&atilde;o s&atilde;o: <a href="http://en.wikipedia.org/wiki/Sele%C3%A7%C3%A3o_(%C3%81lgebra_Relacional)" id="w">restri&ccedil;&atilde;o (sele&ccedil;&atilde;o)</a>, <a href="http://en.wikipedia.org/wiki/Proje%C3%A7%C3%A3o_(%C3%81lgebra_Relacional)" id="w">proje&ccedil;&atilde;o</a>, <a href="http://en.wikipedia.org/wiki/Produto_Cartesiano_(%C3%81lgebra_Relacional)" id="w">produto</a>, <a href="http://en.wikipedia.org/wiki/Uni%C3%A3o_(%C3%81lgebra_Relacional)" id="w">uni&atilde;o</a>, intercess&atilde;o, <a href="http://en.wikipedia.org/wiki/Diferen%C3%A7a_(%C3%81lgebra_Relacional)" id="w">diferen&ccedil;a</a>, jun&ccedil;&atilde;o e dividir.<sup id="_ref&shy;5" class="reference"><a href="#_note&shy;5" title="">[5]</a></sup> O leitor deve entender que as oito opera&ccedil;&otilde;es n&atilde;o s&atilde;o um conjunto m&iacute;nimo. De facto, dos oito, s&oacute; 5 s&atilde;o primitivos, nomeadamente restri&ccedil;&atilde;o, proje&ccedil;&atilde;o, produto, uni&atilde;o, e diferen&ccedil;a. Os outros tr&ecirc;s podem ser definidos destes cinco. Todas essas opera&ccedil;&otilde;es produzem uma nova rela&ccedil;&atilde;o como seu resultado.</p>&#10;<a id="Operadores_primitivos" name="Operadores_primitivos"></a><h2> Operadores primitivos </h2>&#10;<p>Como em qualquer &aacute;lgebra, alguns operadores s&atilde;o primitivos e os outros s&atilde;o derivados em termos dos primitivos. &Eacute; &uacute;til que a escolha dos operadores primitivos se compare a casos comuns onde se fa&ccedil;a uso dos operadores l&oacute;gicos primitivos. </p>&#10;<p>Os cinco operadores primitivos de Codd na &aacute;lgebra s&atilde;o o de <i><a href="http://en.wikipedia.org/wiki/Sele%C3%A7%C3%A3o_(%C3%A1lgebra_relacional)" id="w">sele&ccedil;&atilde;o</a></i>, a <i><a href="http://en.wikipedia.org/wiki/Proje%C3%A7%C3%A3o_(%C3%A1lgebra_relacional)" id="w">proje&ccedil;&atilde;o</a></i>, <i><a href="http://en.wikipedia.org/wiki/Produto_cartesiano" id="w">produto cartesiano</a> </i>(tamb&eacute;m chamado de produto cruz ou jun&ccedil;&atilde;o cruz), a <i><a href="http://en.wikipedia.org/wiki/Uni%C3%A3o_(%C3%A1lgebra_relacional)" id="w">uni&atilde;o</a></i>, e a <i><a href="http://en.wikipedia.org/wiki/Diferen%C3%A7a" id="w">diferen&ccedil;a</a></i> . Outro operador, <i><a href="http://en.wikipedia.org/wiki/Renomear_(%C3%A1lgebra_relacional)" id="w">renomear</a></i> n&atilde;o foi aponte por Codd, (Na verdade, Codd omite o renomear, para proceder) mas a sua necessidade foi mostrada pelos inventores da ISBL. Estes seis operadores s&atilde;o fundamentais no sentido de que nenhum deles pode ser omitido sem perder poder expressivo. Muitos outros operadores foram definidos em termos destes seis. Entre os mais importantes s&atilde;o <a href="http://en.wikipedia.org/wiki/Intercess%C3%A3o" id="w">intercess&atilde;o</a>, divis&atilde;o e a jun&ccedil;&atilde;o natural. Na verdade a ISBL fez a substitui&ccedil;&atilde;o do produto cartesiano pela jun&ccedil;&atilde;o natural, dado que o produto cartesiano &eacute; um caso degenerado. Embora seja sabido que na l&oacute;gica do E, OU e N&Atilde;O a escolha &eacute; um pouco arbitr&aacute;ria, Codd usou de escolha semelhantes para a sua &aacute;lgebra. </p>&#10;<p>Ao todo, os operadores da &aacute;lgebra relacional t&ecirc;m poder expressivo id&ecirc;ntico ao do calculo de dom&iacute;nio relacional ou calculo de tuplas relacionais. No entanto, pelas raz&otilde;es apontadas na introdu&ccedil;&atilde;o acima, a &aacute;lgebra relacional tem estritamente menos expressivo do que a <a href="http://en.wikipedia.org/wiki/L%C3%B3gica_de_primeira_ordem" id="w">l&oacute;gica de primeira ordem</a> sem s&iacute;mbolos de fun&ccedil;&atilde;o. &Aacute;lgebra relacional efectivamente corresponde a um subconjunto da <a href="http://en.wikipedia.org/wiki/L%C3%B3gica_de_primeira_ordem" id="w">l&oacute;gica de primeira ordem</a> que &eacute; a <a href="http://en.wikipedia.org/wiki/Cl%C3%A1usula_de_horn" id="w">cl&aacute;usula de horn</a> sem recursividade e nega&ccedil;&atilde;o.</p>&#10;<a id="Opera%C3%A7%C3%B5es_de_conjuntos" name="Opera%C3%A7%C3%B5es_de_conjuntos"></a><h3> Opera&ccedil;&otilde;es de conjuntos </h3>&#10;<p>A &aacute;lgebra relacional usa <a href="http://en.wikipedia.org/wiki/Uni%C3%A3o_(matem%C3%A1tica)" id="w">conjunto uni&atilde;o</a>, <a href="http://en.wikipedia.org/wiki/Complementar" id="w">conjunto complementar</a> e o <a href="http://en.wikipedia.org/wiki/Produto_cartesiano" id="w">produto cartesiano</a> da <a href="http://en.wikipedia.org/wiki/Teoria_dos_conjuntos" id="w">Teoria dos conjuntos</a>, mas adiciona restri&ccedil;&otilde;es adicionais a esses operadores.</p>&#10;<p>Para uni&atilde;o de conjunto e conjunto complementar, as duas rela&ccedil;&otilde;es envolvidas devem ser compat&iacute;veis com uni&atilde;o &shy; isto &eacute;, as duas rela&ccedil;&otilde;es devem ter o mesmo conjunto de atributos. Porque a <a href="http://en.wikipedia.org/wiki/Intersec%C3%A7%C3%A3o_(%C3%81lgebra_Relacional)" id="w">interce&ccedil;&atilde;o de conjuntos</a> pode definir&shy;se em termos da diferen&ccedil;a do conjunto, as duas rela&ccedil;&otilde;es envolvidas na diferen&ccedil;a do conjunto devem ser compat&iacute;veis com uni&atilde;o.</p>&#10;<p>Para definir o produto Cartesiano, as duas rela&ccedil;&otilde;es envolvidas devem ter cabe&ccedil;alhos disjuntivos &shy; isto &eacute;, estes n&atilde;o podem partilhar um nome comum de atributo.</p>&#10;<p>Em soma, o produto Cartesiano &eacute; definido de maneira diferente do produto em teoria do <a href="http://en.wikipedia.org/wiki/Conjunto" id="w">conjunto</a> no sentido que tuplas s&atilde;o consideradas serem &#34&semi;baixinhas&#34&semi; para usos da opera&ccedil;&atilde;o. Isto &eacute;, o produto Cartesiano do conjunto de <i>n</i>&shy;tuplas com um conjunto de <i>m</i>&shy;tuplas resulta um conjunto (<i>n</i>&#160&semi;+&#160&semi;<i>m</i>)&shy;tuplas  &#34&semi;alisadas&#34&semi; (onde na teoria b&aacute;sica de conjuntos ter&iacute;amos prescrito um conjunto de 2&shy;tuplas, cada contendo uma <i>n</i>&shy;tupla e outra <i>m</i>&shy;tupla). Mais formalmente, <i>R</i> &times; <i>S</i> &eacute; definido como segue:&#10;</p><dl><dd><i>R</i> &times; <i>S</i> = {(<i>r</i><sub>1</sub>, <i>r</i><sub>2</sub>, ..., <i>r</i><sub><i>n</i></sub>, <i>s</i><sub>1</sub>, <i>s</i><sub>2</sub>, ..., <i>s</i><sub><i>m</i></sub>) | (<i>r</i><sub>1</sub>, <i>r</i><sub>2</sub>, ..., <i>r</i><sub><i>n</i></sub>) &isin; <i>R</i>, (<i>s</i><sub>1</sub>, <i>s</i><sub>2</sub>, ..., <i>s</i><sub><i>m</i></sub>) &isin; <i>S</i>}</dd></dl>&#10;<p>A cardinalidade do produto Cartesiano &eacute; o produto das cardinalidades dos seus fatores, i.e., |<i>R</i> &times; <i>S</i>| = |<i>R</i>| &times; |<i>S</i>|.</p>&#10;<a id="Proje%C3%A7%C3%A3o_(%3Cmath%3E%5Cpi_%3C/math%3E)" name="Proje%C3%A7%C3%A3o_(%3Cmath%3E%5Cpi_%3C/math%3E)"></a><h3> Proje&ccedil;&atilde;o (&#60&semi;math&#62&semi;\pi &#60&semi;/math&#62&semi;) </h3>&#10;<p> &#10;A <b>proje&ccedil;&atilde;o</b> &eacute; uma <a href="http://en.wikipedia.org/wiki/Opera%C3%A7%C3%A3o_un%C3%A1ria" id="w">opera&ccedil;&atilde;o un&aacute;ria</a> escrita como <span class="math">\pi_ {( a_1, \dots , a_n)}( R )</span> onde <span class="math">a_1, \dots, a_n</span> &eacute; um conjunto de nome de atributos. O resultado de tal proje&ccedil;&atilde;o &eacute; definida como o <a href="http://en.wikipedia.org/wiki/Conjunto" id="w">conjunto</a> que &eacute; obtido quando todas as <a href="http://en.wikipedia.org/wiki/Enupla" id="w">tuplas</a> em <i>R</i> s&atilde;o restritas ao conjunto <span class="math">a_1, \dots, a_n</span>.</p>&#10;<p>Isto especifica o subconjunto de colunas (atributos de cada tupla) a ser seleccionado. Para obter os nomes e n&uacute;mero de telefones da lista de endere&ccedil;os, a proje&ccedil;&atilde;o poderia ser escrita <span class="math">\pi_{\text{Nomecontacto, Ntelefonecontacto}}( \text{livroendere&ccedil;os} )</span>.  O resultado de tal proje&ccedil;&atilde;o seria uma rela&ccedil;&atilde;o com apenas os Nomecontacto e Ntelefonecontacto para cada entrada &uacute;nica no livroendere&ccedil;os.</p>&#10;<a id="Sele%C3%A7%C3%A3o_(''%26sigma%3B'')" name="Sele%C3%A7%C3%A3o_(''%26sigma%3B'')"></a><h3> Sele&ccedil;&atilde;o (&#39&semi;&#39&semi;&#963&semi;&#39&semi;&#39&semi;) </h3>&#10;<p> &#10;Uma <b>sele&ccedil;&atilde;o generalizada</b> &eacute; uma <a href="http://en.wikipedia.org/wiki/Opera%C3%A7%C3%A3o_un%C3%A1ria" id="w">opera&ccedil;&atilde;o un&aacute;ria</a> escrita como <span class="math">\sigma_\varphi(R)</span> onde <span class="math">\varphi</span> &eacute; uma f&oacute;rmula proposicional que consiste de <a href="http://en.wikipedia.org/wiki/F%C3%B3rmula_at%C3%B4mica" id="w">&aacute;tomos</a> como &eacute; permitido na <a href="http://en.wikipedia.org/wiki/Sele%C3%A7%C3%A3o_(%C3%A1lgebra_relacional)" id="w">sele&ccedil;&atilde;o normal</a> e operadores os l&oacute;gicos <span class="math">\and</span> (<a href="http://en.wikipedia.org/wiki/Conjun%C3%A7%C3%A3o_l%C3%B3gica" id="w">and</a>), <span class="math">\or</span> (<a href="http://en.wikipedia.org/wiki/Disjun%C3%A7%C3%A3o_l%C3%B3gica" id="w">or</a>) e <span class="math">\lnot</span> (<a href="http://en.wikipedia.org/wiki/Nega%C3%A7%C3%A3o" id="w">nega&ccedil;&atilde;o</a>). Esta sele&ccedil;&atilde;o seleciona todas as tuplas em <i>R</i> para cada valor de <span class="math">\varphi</span>.</p>&#10;<p>Para obter uma listagem de todos os amigos ou associados no livro de endere&ccedil;os, a selec&atilde;o podia ser escrita como <span class="math">\sigma_{\text{eamigo = verdadeiro} \or \text{econtactocomercial = verdadeiro}}( \text{livroendere&ccedil;os} )</span>. O resultado seria uma rela&ccedil;&atilde;o que tinha todos atributos de todos os registo &uacute;nicos onde eamigo &eacute; verdadeiro ou onde econtactocomercial &eacute; verdadeiro.</p>&#10;<p>No paper acad&eacute;mico de Codd de 1970, a sele&ccedil;&atilde;o &eacute; chamada de restri&ccedil;&atilde;o.<sup id="_ref&shy;Codd1970_a" class="reference"><a href="#_note&shy;Codd1970" title="">[6]</a></sup></p>&#10;<a id="Renomear_(%3Cmath%3E_%5Crho_%3C/math%3E)" name="Renomear_(%3Cmath%3E_%5Crho_%3C/math%3E)"></a><h3> Renomear (&#60&semi;math&#62&semi; \rho &#60&semi;/math&#62&semi;) </h3>&#10;<p> &#10;<b>Renomear</b> &eacute; uma <a href="http://en.wikipedia.org/wiki/Opera%C3%A7%C3%A3o_un%C3%A1ria" id="w">opera&ccedil;&atilde;o un&aacute;ria</a> escrita como <span class="math">\rho_{a / b}(R)</span> onde o resultado &eacute; id&ecirc;ntico ao <i>R</i> excepto que o campo <i>b</i> em todas as tuplas &eacute; renomeado para um atributo <i>a</i>. Isto &eacute; simplesmente usado para mudar o nome do atributo de uma rela&ccedil;&atilde;o ou a rela&ccedil;&atilde;o em si.</p>&#10;<p>Para renomear o atributo &#39&semi;eamigo&#39&semi; para &#39&semi;econtactocomercial&#39&semi; na rela&ccedil;&atilde;o, <span class="math">\rho_{\text{econtatocomercial / eamigo} } ( \text{Livroendere&ccedil;o} )</span> pode ser utilizado.</p>&#10;<a id="Jun%C3%A7%C3%B5es_e_opera%C3%A7%C3%B5es_com_as_jun%C3%A7%C3%B5es&shy;like" name="Jun%C3%A7%C3%B5es_e_opera%C3%A7%C3%B5es_com_as_jun%C3%A7%C3%B5es&shy;like"></a><h2> Jun&ccedil;&otilde;es e opera&ccedil;&otilde;es com as jun&ccedil;&otilde;es&shy;like </h2>&#10;<a id="Jun%C3%A7%C3%A3o_natural_(%3Cmath%3E%5Cbowtie%3C/math%3E)" name="Jun%C3%A7%C3%A3o_natural_(%3Cmath%3E%5Cbowtie%3C/math%3E)"></a><h3> Jun&ccedil;&atilde;o natural (&#60&semi;math&#62&semi;\bowtie&#60&semi;/math&#62&semi;) </h3>&#10;<p>A jun&ccedil;&atilde;o natural &eacute; uma <a href="http://en.wikipedia.org/wiki/Opera%C3%A7%C3%A3o_bin%C3%A1ria" id="w">opera&ccedil;&atilde;o bin&aacute;ria</a> que &eacute; escrita como (<i>R</i> <span class="math">\bowtie</span> <i>S</i>) onde <i>R</i> e <i>S</i> s&atilde;o rela&ccedil;&otilde;es.<sup id="_ref&shy;7" class="reference"><a href="#_note&shy;7" title="">[7]</a></sup> O resultado da jun&ccedil;&atilde;o natural &eacute; uma tabela com todas as combina&ccedil;&otilde;es das tuplas em <i>R</i> e <i>S</i> que seu atributos em comum s&atilde;o iguais. Por exemplo, considerando as tabelas <i>Empregado</i> e <i>Departamento</i> e sua jun&ccedil;&atilde;o natural:&#10;</p>&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table cellpadding="20" style="margin: 0 auto&semi;">&#10;<tr valign="top">&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>IdEmp </th>&#10;<th>DeptNome&#10;<pre>|&shy;&#10;| Harry  </pre></th>&#10;<td>3415  </td>&#10;<td>Finan&ccedil;as&#10;<pre>|&shy;&#10;| Sally  </pre></td>&#10;<td>2241  </td>&#10;<td>Vendas&#10;<pre>|&shy;&#10;| George </pre></td>&#10;<td>3401  </td>&#10;<td>Finan&ccedil;as&#10;<pre>|&shy;&#10;| Harriet </pre></td>&#10;<td>2202 </td>&#10;<td>Vendas</td></tr></table></div></td>&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>Gerente&#10;<pre>|&shy;&#10;| Finan&ccedil;as  </pre></th>&#10;<td>George&#10;<pre>|&shy;&#10;| Vendas  </pre></td>&#10;<td>Harriet&#10;<pre>|&shy;&#10;| Produ&ccedil;&atilde;o </pre></td>&#10;<td>Charles</td></tr></table></div></td>&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>IdEmp </th>&#10;<th>DeptNome   </th>&#10;<th>Gerente&#10;<pre>|&shy;&#10;| Harry  </pre></th>&#10;<td>3415   </td>&#10;<td>Finan&ccedil;as  </td>&#10;<td>George&#10;<pre>|&shy;&#10;| Sally  </pre></td>&#10;<td>2241   </td>&#10;<td>Vendas  </td>&#10;<td>Harriet&#10;<pre>|&shy;&#10;| George </pre></td>&#10;<td>3401  </td>&#10;<td>Finan&ccedil;as </td>&#10;<td>George&#10;<pre>|&shy;&#10;| Harriet </pre></td>&#10;<td>2202 </td>&#10;<td>Vendas </td>&#10;<td>Harriet</td></tr></table></div></td></tr></table></div>&#10;&#10;<p>Isso tamb&eacute;m pode ser usado para definir as <a href="http://en.wikipedia.org/wiki/Composi%C3%A7%C3%A3o_das_rela%C3%A7%C3%B5es" id="w">composi&ccedil;&atilde;o das rela&ccedil;&otilde;es</a>. Na <a href="http://en.wikipedia.org/wiki/Teoria_das_categorias" id="w">teoria das categorias</a>, a jun&ccedil;&atilde;o &eacute;, precisamente, o <a href="http://en.wikipedia.org/wiki/Produto_fibrado" id="w">produto fibrado</a>.</p>&#10;<p>A jun&ccedil;&atilde;o natural &eacute;, indiscutivelmente, uma das mais importante opera&ccedil;&otilde;es visto que ela &eacute; a contraparte relacional do AND (E) l&oacute;gico. Observe com aten&ccedil;&atilde;o que se as mesmas vari&aacute;veis forem mostradas nos dois predicados que s&atilde;o conectados pelo AND, ent&atilde;o essa vari&aacute;vel representa a mesma coisa e ambas as apar&ecirc;ncias sempre devem ser substitu&iacute;das pelo mesmo valor. Particularmente, a jun&ccedil;&atilde;o natural permite a combina&ccedil;&atilde;o de rela&ccedil;&otilde;es que s&atilde;o associados por uma <a href="http://en.wikipedia.org/wiki/Chave_estrangeira" id="w">chave estrangeira</a>. No exemplo que procedeu, provavelmente existe uma chave estrangeira em <i>Empregado</i>.<i>DeptNome</i> para <i>Departamento</i>.<i>DeptNome</i> e ent&atilde;o a jun&ccedil;&atilde;o natural de <i>Empregado</i> e <i>Departamento</i> combina todos os empregados com seus departamentos. Nota que isso funciona porque a chave estrangeira det&eacute;m os atributos entre os de mesmo nome. Se esse n&atilde;o for o caso, como em uma chave estrangeira de <i>Departamento</i>.<i>Gerente</i> para <i>Empregado</i>.<i>n&uacute;mero&shy;emp</i>, deve&shy;se, ent&atilde;o, renomear essas colunas antes de fazer a jun&ccedil;&atilde;o natural. Essa &eacute;, &agrave;s vezes, uma <b>equijun&ccedil;&atilde;o</b> (veja &theta;&shy;jun&ccedil;&atilde;o).</p>&#10;<p>Mais formalmente, a sem&acirc;ntica da jun&ccedil;&atilde;o natural &eacute; definida como segue:</p>&#10;<dl><dd><span class="math">R \bowtie S = \left\{ t \cup s \ \vert \ t \in R \ \land \ s \in S \ \land \ \mathit{Fun}(t \cup s) \right\}</span></dd></dl>&#10;<p>onde <i>Fun</i> &eacute; um <a href="http://en.wikipedia.org/wiki/Predicado_(matem%C3%A1tica)" id="w">predicado</a> que &eacute; verdadeiro para uma <a href="http://en.wikipedia.org/wiki/Rela%C3%A7%C3%A3o_bin%C3%A1ria" id="w">rela&ccedil;&atilde;o bin&aacute;ria</a> <i>r</i> <a href="http://en.wikipedia.org/wiki/Se_e_somente_se" id="w">se e somente se</a> <span class="math">r</span> &eacute; uma rela&ccedil;&atilde;o funcional bin&aacute;ria. Normalmente, &eacute; necess&aacute;rio que <i>R</i> e <i>S</i> tenham, pelo menos, um atributo em comum, mas se essa restri&ccedil;&atilde;o &eacute; omitida, ent&atilde;o a jun&ccedil;&atilde;o natural torna&shy;se, exatamente, o produto cartesiano.</p>&#10;<p>A jun&ccedil;&atilde;o natural pode ser simulada com <i>primitivos de Codd</i>, como segue. Sup&otilde;em&shy;se que <i>b<sub>1</sub>,&hellip;,b<sub>m</sub></i> s&atilde;o nomes de atributos comuns em <i>R</i>, <i>S</i>, <i>a<sub>1</sub>,&hellip;,a<sub>n</sub></i> s&atilde;o os atributos de nome &uacute;nico de <i>R</i> e <i>c<sub>1</sub>,&hellip;,c<sub>k</sub></i> s&atilde;o os atributos de nome &uacute;nico de <i>S</i>. Al&eacute;m disso, assume&shy;se que os nomes dos atributos <i>d<sub>1</sub>,&hellip;,d<sub>m</sub></i> n&atilde;o s&atilde;o nem de <i>R</i> ou de <i>S</i>. Primeiramente, n&oacute;s podemos mudar, agora, o nome do atributo em comum em <i>S</i>:</p>&#10;<dl><dd><span class="math">T = \rho_{d_1/b_1,\ldots,d_m/b_m}(S) = \rho_{d_1/b_1}(\rho_{d_2/b_2}(\ldots\rho_{d_m/b_m}(S)\ldots))</span></dd></dl>&#10;<p>Ent&atilde;o toma&shy;se o produto cartesiano e faz&shy;se a sele&ccedil;&atilde;o as tuplas que devem ser ligadas: </p>&#10;<dl><dd><span class="math">P = \sigma_{b_1=d_1,\ldots,b_m=d_m}(R \times T) = \sigma_{b_1=d_1}(\sigma_{b_2=d_2}(\ldots\sigma_{b_m=d_m}(R \times T)\ldots))</span></dd></dl>&#10;<p>Finalmente, pegue a proje&ccedil;&atilde;o para se livrar dos atributos renomeados: </p>&#10;<dl><dd><span class="math">U = \pi_{a_1,\ldots,a_n,b_1,\ldots,b_m,c_1,\ldots,c_k}(P)</span></dd></dl>&#10;<a id="''%CE%B8''&shy;jun%C3%A7%C3%A3o_e_equijun%C3%A7%C3%A3o" name="''%CE%B8''&shy;jun%C3%A7%C3%A3o_e_equijun%C3%A7%C3%A3o"></a><h3> &#39&semi;&#39&semi;&theta;&#39&semi;&#39&semi;&shy;jun&ccedil;&atilde;o e equijun&ccedil;&atilde;o </h3>&#10;<p>Equacionar&iacute;amos como tabelas <i>Carro</i> e <i>Barco</i> os quais listam modelos de carros e barcos e seus respectivos pre&ccedil;os. Por exemplo, suponha que um cliente quer comprar um carro e um barco, mas n&atilde;o quer gastar mais dinheiro para o barco do que para o carro. A &theta;&shy;jun&ccedil;&atilde;o (<span class="math">\bowtie</span><sub>&theta;</sub>) na <a href="http://en.wikipedia.org/wiki/Rela%C3%A7%C3%A3o_(bancodados)" id="w">rela&ccedil;&atilde;o</a> <i>Pre&ccedil;oCarro</i> &ge; <i>Pre&ccedil;oBarco</i> produz uma tabela com todas as op&ccedil;&otilde;es poss&iacute;veis. Ao utilizar uma condi&ccedil;&atilde;o em que os atributos s&atilde;o iguais, por exemplo, pre&ccedil;o, ent&atilde;o a condi&ccedil;&atilde;o pode ser especificada como <i>Pre&ccedil;o=Pre&ccedil;o</i>&#10;ou alternativamente <i>(pre&ccedil;o)</i> sozinho.</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table cellpadding="20" style="margin: 0 auto&semi;">&#10;<tr valign="top">&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>Pre&ccedil;oCarro&#10;<pre>|&shy;&#10;| CarroA  </pre></th>&#10;<td>20,000&#10;<pre>|&shy;&#10;| CarroB  </pre></td>&#10;<td>30,000&#10;<pre>|&shy;&#10;| CarroC  </pre></td>&#10;<td>50,000</td></tr></table></div></td>&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>Pre&ccedil;oBarco&#10;<pre>|&shy;&#10;| Barco1  </pre></th>&#10;<td>10,000&#10;<pre>|&shy;&#10;| Barco2  </pre></td>&#10;<td>40,000&#10;<pre>|&shy;&#10;| Barco3  </pre></td>&#10;<td>60,000</td></tr></table></div></td>&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>Pre&ccedil;oCarro </th>&#10;<th>BarcoModelo </th>&#10;<th>Pre&ccedil;oBarco&#10;<pre>|&shy;&#10;| CarroA  </pre></th>&#10;<td>20,000   </td>&#10;<td>Barco1 </td>&#10;<td>10,000&#10;<pre>|&shy;&#10;| CarroB  </pre></td>&#10;<td>30,000   </td>&#10;<td>Barco1 </td>&#10;<td>10,000&#10;<pre>|&shy;&#10;| CarroC  </pre></td>&#10;<td>50,000   </td>&#10;<td>Barco1 </td>&#10;<td>10,000&#10;<pre>|&shy;&#10;| CarroC  </pre></td>&#10;<td>50,000   </td>&#10;<td>Barco2 </td>&#10;<td>40,000</td></tr></table></div></td></tr></table></div>&#10;&#10;<p>Se quisermos combinar tuplas de duas rela&ccedil;&otilde;es em que a condi&ccedil;&atilde;o combina&ccedil;&atilde;o n&atilde;o &eacute; simplesmente a igualdade de atributos comuns, ent&atilde;o &eacute; conveniente ter uma forma mais geral do operador de jun&ccedil;&atilde;o, que &eacute; o &theta;&shy;jun&ccedil;&atilde;o (ou theta&shy;jun&ccedil;&atilde;o). A &theta;&shy;jun&ccedil;&atilde;o &eacute; um operador bin&aacute;rio que &eacute; escrito como <span class="math">\begin{matrix} R\ \bowtie\ S \\ a\ \theta\ b\end{matrix}</span> ou <span class="math">\begin{matrix} R\ \bowtie\ S \\ a\ \theta\ v\end{matrix}</span>, onde <i>a</i> e <i>b</i> s&atilde;o nomes de atributos, &theta; &eacute; uma <a href="http://en.wikipedia.org/wiki/Rela%C3%A7%C3%A3o_bin%C3%A1ria" id="w">rela&ccedil;&atilde;o bin&aacute;ria</a> no conjunto {&#60&semi;, &le;, =,&#62&semi;, &ge;}, <i>v</i> &eacute; um valor constante, e <i> R</i> e <i>S</i> s&atilde;o rela&ccedil;&otilde;es. O resultado desta opera&ccedil;&atilde;o consiste em todas as combina&ccedil;&otilde;es de tuplas em  <i>R</i> e <i>S</i> que satisfazem a rela&ccedil;&atilde;o &theta;. O resultado do &theta;&shy;jun&ccedil;&atilde;o &eacute; definida somente se os cabe&ccedil;alhos de <i>S</i> e <i>R</i> s&atilde;o disjuntos, ou seja, n&atilde;o cont&ecirc;m um atributo comum.</p>&#10;<p>A simula&ccedil;&atilde;o da opera&ccedil;&atilde;o nas opera&ccedil;&otilde;es fundamentais &eacute;, por conseguinte, como se segue:&#10;</p><dl><dd><i>R</i> <span class="math">\bowtie</span><sub>&theta;</sub> <i>S</i> = &sigma;<sub>&theta;</sub>(<i>R</i> &times; <i>S</i>)</dd></dl>&#10;<p>No caso de o operador &theta; &eacute; o operador de igualdade (=), ent&atilde;o este essa jun&ccedil;&atilde;o tamb&eacute;m &eacute; chamado de <i>equijun&ccedil;&atilde;o</i>.</p>&#10;<p>Note&shy;se, no entanto, que uma linguagem de computador que suporta os operadores naturais jun&ccedil;&atilde;o e renomear n&atilde;o precisa &theta;&shy;jun&ccedil;&atilde;o, assim, como isso pode ser alcan&ccedil;ado por meio da sele&ccedil;&atilde;o a partir do resultado de uma jun&ccedil;&atilde;o natural (que degenera em produto cartesiano quando n&atilde;o h&aacute; compartilhada de atributos).</p>&#10;<a id="Semijun%C3%A7%C3%A3o_(%E2%8B%89)(%E2%8B%8A)" name="Semijun%C3%A7%C3%A3o_(%E2%8B%89)(%E2%8B%8A)"></a><h3> Semijun&ccedil;&atilde;o (&#8905;)(&#8906;) </h3>&#10;&#10;<p>A semijun&ccedil;&atilde;o esquerdo est&aacute; juntando semelhante &agrave; jun&ccedil;&atilde;o natural e escrito como <i>R</i> <span class="math">\ltimes</span> <i>S</i> onde <i>R</i> e <i>S</i> s&atilde;o <a href="http://en.wikipedia.org/wiki/Rela%C3%A7%C3%A3o_(bancodados)" id="w">rela&ccedil;&otilde;es</a>.<sup id="_ref&shy;8" class="reference"><a href="#_note&shy;8" title="">[8]</a></sup> O resultado desta semijun&ccedil;&atilde;o &eacute; o conjunto de todas as tuplas em <i>R</i> para o qual existe uma tupla em <i>S</i> que &eacute; igual em seus nomes de atributos comuns. Por exemplo, considere as tabelas Empregado <i>e</i> e seu <i>Dept</i> e suas semijun&ccedil;&otilde;es:&#10;</p>&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table cellpadding="20" style="margin: 0 auto&semi;">&#10;<tr valign="top">&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>IdEmp </th>&#10;<th>NomeDept&#10;<pre>|&shy;&#10;| Harry  </pre></th>&#10;<td>3415  </td>&#10;<td>Finan&ccedil;as&#10;<pre>|&shy;&#10;| Sally  </pre></td>&#10;<td>2241  </td>&#10;<td>Vendas&#10;<pre>|&shy;&#10;| George </pre></td>&#10;<td>3401  </td>&#10;<td>Finan&ccedil;as&#10;<pre>|&shy;&#10;| Harriet </pre></td>&#10;<td>2202 </td>&#10;<td>Produ&ccedil;&atilde;o</td></tr></table></div></td>&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>Gerente&#10;<pre>|&shy;&#10;| Vendas  </pre></th>&#10;<td>Bob&#10;<pre>|&shy;&#10;| Vendas  </pre></td>&#10;<td>Thomas&#10;<pre>|&shy;&#10;| Produ&ccedil;&atilde;o </pre></td>&#10;<td>Katie&#10;<pre>|&shy;&#10;| Produ&ccedil;&atilde;o </pre></td>&#10;<td>Marco</td></tr></table></div></td>&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>IdEmp </th>&#10;<th>NomeDept&#10;<pre>|&shy;&#10;| Sally  </pre></th>&#10;<td>2241   </td>&#10;<td>Vendas&#10;<pre>|&shy;&#10;| Harriet </pre></td>&#10;<td>2202 </td>&#10;<td>Produ&ccedil;&atilde;o</td></tr></table></div></td></tr></table></div>&#10;&#10;<p>Mais formalmente a sem&acirc;ntica do semijun&ccedil;&atilde;o &eacute; definido como&#10;segue:</p>&#10;<dl><dd><i>R</i> <span class="math">\ltimes</span> <i>S</i> = { <i>t</i> <span class="math">\in</span> <i>R</i>, <i>s</i> <span class="math">\in</span> <i>S</i>, <i>Fun</i> (<i>t</i> <span class="math">\cup</span> <i>s</i>) }</dd></dl>&#10;<p>Onde <i>Fun</i>(<i>r</i>) &eacute; como na defini&ccedil;&atilde;o de jun&ccedil;&atilde;o natural.</p>&#10;<p>A semijun&ccedil;&atilde;o pode ser simulada usando a jun&ccedil;&atilde;o natural como&#10;segue. Se <i>a</i><sub>1</sub>, ..., <i>a</i><sub><i>n</i></sub> s&atilde;o nomes de atributo de <i>R</i>, segue&#10;</p><dl><dd><i>R</i> <span class="math">\ltimes</span> <i>S</i> = <span class="math">\pi</span><sub><i>a</i><sub>1</sub>,..,<i>a</i><sub><i>n</i></sub></sub>(<i>R</i> <span class="math">\bowtie</span> <i>S</i>).</dd></dl>&#10;<p>Uma vez que pode simular a jun&ccedil;&atilde;o natural com os operadores b&aacute;sicos segue&shy;se que isso tamb&eacute;m vale para o semijun&ccedil;&atilde;o.</p>&#10;<a id="Anti_jun%C3%A7%C3%A3o" name="Anti_jun%C3%A7%C3%A3o"></a><h3> Anti jun&ccedil;&atilde;o </h3>&#10;<p>A anti jun&ccedil;&atilde;o, escrito como <i>R</i> <span class="math">\triangleright</span> <i>S</i> onde <i>R</i> e <i>S</i> s&atilde;o rela&ccedil;&otilde;es, &eacute; similar &agrave; semijun&ccedil;&atilde;o (jun&ccedil;&atilde;o natural), mas o resultado de uma anti jun&ccedil;&atilde;o &eacute; apenas aquelas tuplas em <i>R</i> para as quais N&Atilde;O existe uma tupla em <i>S</i> que possua os mesmos nomes de atributos. </p>&#10;<p>Por exemplo, considerando as tabelas <i>Empregado</i> e <i>Departamento</i> e sua anti jun&ccedil;&atilde;o:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table cellpadding="20" style="margin: 0 auto&semi;">&#10;<tr valign="top">&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>IdEmp </th>&#10;<th>DeptNome&#10;<pre>|&shy;&#10;| Harry  </pre></th>&#10;<td>3415  </td>&#10;<td>Finan&ccedil;as&#10;<pre>|&shy;&#10;| Sally  </pre></td>&#10;<td>2241  </td>&#10;<td>Vendas&#10;<pre>|&shy;&#10;| George </pre></td>&#10;<td>3401  </td>&#10;<td>Finan&ccedil;as&#10;<pre>|&shy;&#10;| Harriet </pre></td>&#10;<td>2202 </td>&#10;<td>Produ&ccedil;&atilde;o</td></tr></table></div></td>&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>Gerente&#10;<pre>|&shy;&#10;| Vendas  </pre></th>&#10;<td>Harriet&#10;<pre>|&shy;&#10;| Produ&ccedil;&atilde;o </pre></td>&#10;<td>Charles</td></tr></table></div></td>&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>IdEmp </th>&#10;<th>DeptNome&#10;<pre>|&shy;&#10;| Harry  </pre></th>&#10;<td>3415  </td>&#10;<td>Finan&ccedil;as&#10;<pre>|&shy;&#10;| George </pre></td>&#10;<td>3401  </td>&#10;<td>Finan&ccedil;as</td></tr></table></div></td></tr></table></div>&#10;&#10;<p>A anti jun&ccedil;&atilde;o &eacute; formalmente definida como segue:</p>&#10;<dl><dd><i>R</i> <span class="math">\triangleright</span> <i>S</i> = { <i>t</i> : <i>t</i> <span class="math">\in</span> <i>R</i> <span class="math">\and</span> <span class="math">\neg\exists</span><i>s</i> <span class="math">\in</span> <i>S</i> : fun (<i>t</i> <span class="math">\cup</span> <i>s</i>) }</dd></dl>&#10;<p>ou</p>&#10;<dl><dd><i>R</i> <span class="math">\triangleright</span> <i>S</i> = { <i>t</i> : <i>t</i> <span class="math">\in</span> <i>R</i>, n&atilde;o existe uma tupla s de S que satisfaz  fun (<i>t</i> <span class="math">\cup</span> <i>s</i>) }</dd></dl>&#10;<p>onde fun(<i>r</i>) est&aacute; definida como na jun&ccedil;&atilde;o natural.</p>&#10;<p>A anti jun&ccedil;&atilde;o tamb&eacute;m pode ser definida como o  <a href="http://en.wikipedia.org/wiki/Complement_(set_theory)" id="w">complemento</a> da semijun&ccedil;&atilde;o, como segue:&#10;</p><dl><dd><i>R</i> <span class="math">\triangleright</span> <i>S</i> = <i>R</i> &shy; <i>R</i> <span class="math">\ltimes</span> <i>S</i></dd></dl>&#10;<p>Sendo assim, a anti jun&ccedil;&atilde;o &agrave;s vezes &eacute; chamada de anti&shy;semijun&ccedil;&atilde;o, e o operador de anti jun&ccedil;&atilde;o &agrave;s vezes &eacute; escrito como um s&iacute;mbolo da semijun&ccedil;&atilde;o com uma barra acima, ao inv&eacute;s de  <span class="math">\triangleright</span>.</p>&#10;<a id="Divis%C3%A3o" name="Divis%C3%A3o"></a><h3> Divis&atilde;o </h3>&#10;<p>A divis&atilde;o &eacute; uma <a href="http://en.wikipedia.org/wiki/Opera%C3%A7%C3%A3o_bin%C3%A1ria" id="w">opera&ccedil;&atilde;o bin&aacute;ria</a> que &eacute; escrita como <i>R</i> &divide; <i>S</i>. O resultado consiste em restri&ccedil;&otilde;es de tuplas em <i>R</i> at&eacute; ao nome dos atributos &uacute;nicos a <i>R</i>, i.e., no cabe&ccedil;alho de <i>R</i> mas n&atilde;o no cabe&ccedil;alho de <i>S</i>, onde &eacute; verific&aacute;vel que todas as suas combina&ccedil;&otilde;es de tuplas <i>S</i> est&atilde;o presentes em <i>R</i>. Por exemplo, considerando as tabelas <i>Finalizado</i>, <i>ProjectoBD</i> e sua divis&atilde;o:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table cellpadding="20" style="margin: 0 auto&semi;">&#10;<tr>&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>Tarefa&#10;<pre>|&shy;&#10;| Fred  </pre></th>&#10;<td>Basedados1&#10;<pre>|&shy;&#10;| Fred  </pre></td>&#10;<td>Basedados2&#10;<pre>|&shy;&#10;| Fred </pre></td>&#10;<td>Compiladores1&#10;<pre>|&shy;&#10;| Pedro  </pre></td>&#10;<td>Basedados1&#10;<pre>|&shy;&#10;| Pedro  </pre></td>&#10;<td>Compiladores1&#10;<pre>|&shy;&#10;| Sara  </pre></td>&#10;<td>Basedados1&#10;<pre>|&shy;&#10;| Sara  </pre></td>&#10;<td>Basedados2</td></tr></table></div></td>&#10;<td>&#10;</td>&#10;<td>&#10;</td></tr></table></div>&#10;&#10;<p>Se <i>ProjectoBD</i> cont&ecirc;m todas as tarefas do projecto Basedados, deduz&shy;se que o resultado da divis&atilde;o do exemplo cont&ecirc;m exactamente os estudantes que completaram ambas as tarefas no projecto Basedados.</p>&#10;<p>Mais formalmente, as sem&acirc;nticas da divis&atilde;o s&atilde;o definidas como:&#10;</p><dl><dd><i>R</i> &divide; <i>S</i> = { <i>t</i>[<i>a</i><sub>1</sub>,...,<i>a</i><sub><i>n</i></sub>] : <i>t</i> <span class="math">\in</span> <i>R</i> <span class="math">\wedge</span> <span class="math">\forall</span><i>s</i> <span class="math">\in</span> <i>S</i> ( (<i>t</i>[<i>a</i><sub>1</sub>,...,<i>a</i><sub><i>n</i></sub>] <span class="math">\cup</span> <i>s</i>) <span class="math">\in</span> <i>R</i>) }</dd></dl>&#10;<p>onde {<i>a</i><sub>1</sub>,...,<i>a</i><sub><i>n</i></sub>} &eacute; o conjunto de nomes de atributos &uacute;nicos a <i>R</i> e &#10;<i>t</i>[<i>a</i><sub>1</sub>,...,<i>a</i><sub><i>n</i></sub>] &eacute; a restri&ccedil;&atilde;o de <i>t</i> a este conjunto. &Eacute; normalmente requerido que os nomes do atributo no cabe&ccedil;alho de <i>S</i> s&atilde;o subsets do mesmo que <i>R</i> porque de outra maneira o resultado da opera&ccedil;&atilde;o vai ser vazio.</p>&#10;<p>A simula&ccedil;&atilde;o da divis&atilde;o com opera&ccedil;&otilde;es b&aacute;sicas segue assim. Assumindo que <i>a</i><sub>1</sub>,...,<i>a</i><sub><i>n</i></sub> s&atilde;o os nomes do atributos &uacute;nicos de <i>R</i> e <i>b</i><sub>1</sub>,...,<i>b</i><sub><i>m</i></sub> s&atilde;o os nomes do atributos &uacute;nicos de <i>S</i>. No  primeiro passo projectamos <i>R</i> no seu nome de atributo &uacute;nico e constru&iacute;mos todas as combina&ccedil;&otilde;es de tuplas em <i>S</i>:&#10;</p><dl><dd><i>T</i> := &pi;<sub><i>a</i><sub>1</sub>,...,<i>a</i><sub><i>n</i></sub></sub>(<i>R</i>) &times; <i>S</i></dd></dl>&#10;<p>No anterior exemplo, T iria representar uma tabela no qual todos os Estudantes (porque Estudante &eacute; a chave / atributo &uacute;nica da tabela Finalizada) &eacute; combinada com todas as Tarefas dadas. Por isso Fred, por exemplo, tinha duas linhas, Fred &shy;&#62&semi; Basedados1 e Fred &shy;&#62&semi; Basedados2 em T.</p>&#10;<p>Na pr&oacute;xima etapa n&oacute;s subtra&iacute;mos <i>R</i> da sua <a href="http://en.wikipedia.org/wiki/Rela%C3%A7%C3%A3o_(basedados)" id="w">rela&ccedil;&atilde;o</a>:&#10;</p><dl><dd><i>U</i> := <i>T</i> &#8722&semi; <i>R</i></dd></dl>&#10;<p>Nota que em <i>U</i> n&oacute;s temos poss&iacute;veis combina&ccedil;&otilde;es que &#34&semi;poderia estar&#34&semi; em <i>R</i>, mas n&atilde;o estavam. Por isso se n&oacute;s agora fizermos a proje&ccedil;&atilde;o nos nome de atributos &uacute;nicos a <i>R</i> agora temos as restri&ccedil;&otilde;es das tuplas em <i>R</i> para o qual nem todas as combina&ccedil;&otilde;es de tuplas em  <i>S</i> estavam presentes em <i>R</i>:&#10;</p><dl><dd><i>V</i> := &pi;<sub><i>a</i><sub>1</sub>,...,<i>a</i><sub><i>n</i></sub></sub>(<i>U</i>)</dd></dl>&#10;<p>Agora o que sobra fazer e tomar a proje&ccedil;&atilde;o de <i>R</i> em seus nomes de atributos e subtrair o que est&atilde;o em  <i>V</i>:&#10;</p><dl><dd><i>W</i> := &pi;<sub><i>a</i><sub>1</sub>,...,<i>a</i><sub><i>n</i></sub></sub>(<i>R</i>) &#8722&semi; <i>V</i></dd></dl>&#10;<a id="Extens%C3%B5es_comuns" name="Extens%C3%B5es_comuns"></a><h2> Extens&otilde;es comuns </h2>&#10;<p>Na pr&aacute;tica, a &aacute;lgebra relacional cl&aacute;ssica descrita acima &eacute; estendido com v&aacute;rias opera&ccedil;&otilde;es, como jun&ccedil;&otilde;es externas, fun&ccedil;&otilde;es de agrega&ccedil;&atilde;o e at&eacute; de encerramentos transitivos.<sup id="_ref&shy;&Ouml;zsuValduriez2011_a" class="reference"><a href="#_note&shy;&Ouml;zsuValduriez2011" title="">[9]</a></sup></p>&#10;<a id="Jun%C3%A7%C3%A3o_de_fora" name="Jun%C3%A7%C3%A3o_de_fora"></a><h3> Jun&ccedil;&atilde;o de fora</h3>&#10;<p>Considerando que o resultado de um <i>jun&ccedil;&atilde;o</i> (ou <i>Jun&ccedil;&atilde;o de dentro</i>) consiste em combinar tuplas correspondentes nos dois operandos, uma <i>jun&ccedil;&atilde;o de fora</i> cont&eacute;m essas tuplas e mais algumas formadas pelo &#34&semi;enchimento&#34&semi; dos valores que n&atilde;o casam em um operador com cada atributo do outro operador. Note que os que as jun&ccedil;&otilde;os de fora n&atilde;o s&atilde;o considerados parte da &aacute;lgebra cl&aacute;ssica relacional, discutida at&eacute; aqui.<sup id="_ref&shy;O'NeilO'Neil2001_a" class="reference"><a href="#_note&shy;O'NeilO'Neil2001" title="">[10]</a></sup></p>&#10;<p>Os operadores definidos nessa se&ccedil;&atilde;o assumem que existe um valor <i>null</i>(<i>&omega;</i>), que n&atilde;o definem, para ser utilizado para os valores de &#34&semi;enchimento&#34&semi;&semi; na pr&aacute;tica, isso corresponde ao valor <a href="http://en.wikipedia.org/wiki/Null_(SQL)" id="w">NULL</a> em SQL.  A fim de tornar as opera&ccedil;&otilde;es de sele&ccedil;&atilde;o subsequentes na tabela resultante significativa, um significado sem&acirc;ntico precisa ser atribu&iacute;do ao nulos, na abordagem de Codd a l&oacute;gica proposicional usada pela sele&ccedil;&atilde;o &eacute; <a href="http://en.wikipedia.org/wiki/En:Null_(SQL)#Comparisons_with_NULL_and_the_three&shy;valued_logic_.283VL.29" id="w">estendido a uma l&oacute;gica de tr&ecirc;s valores</a>, embora elidimos os detalhes neste artigo.</p>&#10;<p>Tr&ecirc;s operadores <i>jun&ccedil;&atilde;o de fora</i> s&atilde;o definidos: <i>jun&ccedil;&atilde;o de fora esquerda</i>, <i>jun&ccedil;&atilde;o de fora direita</i>, e <i>jun&ccedil;&atilde;o de fora cheia</i>. (Algumas vezes a palavra <i>de fora</i> &eacute; omitida.)</p>&#10;<a id="Jun%C3%A7%C3%A3o_de_fora_esquerda_(%E2%9F%95)" name="Jun%C3%A7%C3%A3o_de_fora_esquerda_(%E2%9F%95)"></a><h4> Jun&ccedil;&atilde;o de fora esquerda (&#10197;) </h4>&#10;<p>A <i>jun&ccedil;&atilde;o de fora esquerda</i> &eacute; escrito como <i>R</i> =X <i>S</i> onde <i>R</i> e <i>S</i> s&atilde;o rela&ccedil;&otilde;es. O resultado do <i>jun&ccedil;&atilde;o esquerda</i> &eacute; o conjunto de todas as combina&ccedil;&otilde;es das tuplas em <i>R</i> e <i>S</i> que seus atributos em comum s&atilde;o iguais , al&eacute;m disso, tuplas em <i>R</i> que n&atilde;o tem correspond&ecirc;ncia em <i>S</i>.</p>&#10;<p>Por exemplo considere as tabelas <i>Empregado</i> e <i>Departamento</i> e seu <i>esquerda outer jun&ccedil;&atilde;o</i>:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table cellpadding="20" style="margin: 0 auto&semi;">&#10;<tr valign="top">&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>IdEmp </th>&#10;<th>DeptNome&#10;<pre>|&shy;&#10;| Harry  </pre></th>&#10;<td>3415  </td>&#10;<td>Finan&ccedil;as&#10;<pre>|&shy;&#10;| Sally  </pre></td>&#10;<td>2241  </td>&#10;<td>Vendas&#10;<pre>|&shy;&#10;| George </pre></td>&#10;<td>3401  </td>&#10;<td>Finan&ccedil;as&#10;<pre>|&shy;&#10;| Harriet </pre></td>&#10;<td>2202 </td>&#10;<td>Vendas&#10;<pre>|&shy;&#10;| Tim </pre></td>&#10;<td>1123 </td>&#10;<td>Executivo</td></tr></table></div></td>&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>Gerente&#10;<pre>|&shy;&#10;| Vendas  </pre></th>&#10;<td>Harriet&#10;<pre>|&shy;&#10;| Produ&ccedil;&atilde;o </pre></td>&#10;<td>Charles</td></tr></table></div></td>&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>IdEmp </th>&#10;<th>DeptNome </th>&#10;<th>Gerente&#10;<pre>|&shy;&#10;| Harry  </pre></th>&#10;<td>3415  </td>&#10;<td>Finan&ccedil;as </td>&#10;<td>&omega;&#10;<pre>|&shy;&#10;| Sally  </pre></td>&#10;<td>2241   </td>&#10;<td>Vendas </td>&#10;<td>Harriet&#10;<pre>|&shy;&#10;| George </pre></td>&#10;<td>3401  </td>&#10;<td>Finan&ccedil;as </td>&#10;<td>&omega;&#10;<pre>|&shy;&#10;| Harriet </pre></td>&#10;<td>2202 </td>&#10;<td>Vendas </td>&#10;<td>Harriet&#10;<pre>|&shy;&#10;| Tim </pre></td>&#10;<td>1123 </td>&#10;<td>Executivo </td>&#10;<td>&omega;</td></tr></table></div></td></tr></table></div>&#10;&#10;<p>Na rela&ccedil;&atilde;o resultante, tuplas em <i>S</i> que n&atilde;o tem valores com os mesmos nomes de atributos com tuplas em <i>R</i> recebem um valor <i>null</i>, <i>&omega;</i>.</p>&#10;<p>Dado que n&atilde;o existem tuplas em <i>Departamento</i> com <i>DeptNome</i> igual a <i>Finan&ccedil;as</i> ou <i>Executivo</i>, <i>&omega;</i>s aparecem na rela&ccedil;&atilde;o resultante onde tuplas em <i>DeptNome</i> tem <i>Finan&ccedil;as</i> ou <i>Executivo</i>.</p>&#10;<p>Sendo <i>r<sub>1</sub></i>, <i>r<sub>2</sub></i>, &hellip;, <i>r<sub>n</sub></i> atributos da rela&ccedil;&atilde;o <i>R</i> e <i>{(&omega;, &hellip;, &omega;)}</i> os &uacute;nicos atributos que s&atilde;o <i>&uacute;nicos</i> para a rela&ccedil;&atilde;o <i>S</i> (aqueles que n&atilde;o s&atilde;o atributos de <i>R</i>). Ent&atilde;o o <i>jun&ccedil;&atilde;o de fora esquerda</i> pode ser escrito em termos do <i>jun&ccedil;&atilde;o natural</i>(utilizando operadores b&aacute;sicos) como segue:</p>&#10;<dl><dd><span class="math">(R \bowtie S) \cup ((R &shy; \pi_{r_1, r_2, \dots, r_n}(R \bowtie S)) \times \{(\omega, \dots \omega)\})</span></dd></dl>&#10;<a id="Jun%C3%A7%C3%A3o_de_fora_direita_(%E2%9F%96)" name="Jun%C3%A7%C3%A3o_de_fora_direita_(%E2%9F%96)"></a><h4> Jun&ccedil;&atilde;o de fora direita (&#10198;) </h4>&#10;<p>Se comporta da mesma maneira que o anterior, s&oacute; que os pap&eacute;is da tabela s&atilde;o comutados. </p>&#10;<p>A <i>jun&ccedil;&atilde;o de fora direita</i> das rela&ccedil;&otilde;es <i>R</i> e <i>S</i> &eacute; escrito como <i>R</i> X= <i>S</i>. O resultado do <i>jun&ccedil;&atilde;o direita</i> &eacute; &eacute; o conjunto de todas as combina&ccedil;&otilde;es das tuplas em <i>R</i> e <i>S</i> que seus atributos em comum s&atilde;o iguais, al&eacute;m disso, tuplas em <i>S</i> que n&atilde;o possuem correspond&ecirc;ncia com tuplas em <i>R</i>.</p>&#10;<p>Por exemplo considere as tabelas <i>Empregado</i> e <i>Departamento</i> e a <i>jun&ccedil;&atilde;o de fora direita</i>:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table cellpadding="20" style="margin: 0 auto&semi;">&#10;<tr valign="top">&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>IdEmp </th>&#10;<th>DeptNome&#10;<pre>|&shy;&#10;| Harry  </pre></th>&#10;<td>3415  </td>&#10;<td>Finan&ccedil;as&#10;<pre>|&shy;&#10;| Sally  </pre></td>&#10;<td>2241  </td>&#10;<td>Vendas&#10;<pre>|&shy;&#10;| George </pre></td>&#10;<td>3401  </td>&#10;<td>Finan&ccedil;as&#10;<pre>|&shy;&#10;| Harriet </pre></td>&#10;<td>2202 </td>&#10;<td>Vendas&#10;<pre>|&shy;&#10;| Tim </pre></td>&#10;<td>1123 </td>&#10;<td>Executivo</td></tr></table></div></td>&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>Gerente&#10;<pre>|&shy;&#10;| Vendas  </pre></th>&#10;<td>Harriet&#10;<pre>|&shy;&#10;| Produ&ccedil;&atilde;o </pre></td>&#10;<td>Charles</td></tr></table></div></td>&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>IdEmp </th>&#10;<th>DeptNome </th>&#10;<th>Gerente&#10;<pre>|&shy;&#10;| Sally  </pre></th>&#10;<td>2241   </td>&#10;<td>Vendas  </td>&#10;<td>Harriet&#10;<pre>|&shy;&#10;| Harriet </pre></td>&#10;<td>2202 </td>&#10;<td>Vendas  </td>&#10;<td>Harriet&#10;<pre>|&shy;&#10;| &omega; </pre></td>&#10;<td>&omega; </td>&#10;<td>Produ&ccedil;&atilde;o  </td>&#10;<td>Charles</td></tr></table></div></td></tr></table></div>&#10;&#10;<p>Na rela&ccedil;&atilde;o resultante, tuplas em <i>R</i> que n&atilde;o tem valores com os mesmos nomes de atributos com tuplas em <i>S</i> recebem um valor <i>null</i>, <i>&omega;</i>.</p>&#10;<p>Dado que n&atilde;o existem tuplas em <i>Empregado</i> com <i>DeptNome</i> igual a <i>Produ&ccedil;&atilde;o</i>, <i>&omega;</i>s aparecem na rela&ccedil;&atilde;o resultante onde tuplas em <i>DeptNome</i> tem tuplas com <i>Produ&ccedil;&atilde;o</i>.</p>&#10;<p>Sendo <i>s<sub>1</sub></i>, <i>s<sub>2</sub></i>, &hellip;, <i>s<sub>n</sub></i> atributos da rela&ccedil;&atilde;o <i>S</i> e <i>{(&omega;, &hellip;, &omega;)}</i> os &uacute;nicos atributos que s&atilde;o <i>&uacute;nicos</i> para a rela&ccedil;&atilde;o <i>R</i> (aqueles que n&atilde;o s&atilde;o atributos de <i>S</i>). Ent&atilde;o, como no <i>esquerda jun&ccedil;&atilde;o</i>, o <i>jun&ccedil;&atilde;o de fora direita</i> pode ser escrito em termos da <i>jun&ccedil;&atilde;o natural</i>(utilizando operadores b&aacute;sicos) como segue:</p>&#10;<dl><dd><span class="math">(R \bowtie S) \cup ((S &shy; \pi_{s_1, s_2, \dots, s_n}(R \bowtie S)) \times \{(\omega, \dots, \omega)\})</span></dd></dl>&#10;<a id="Jun%C3%A7%C3%A3o_de_fora_cheia" name="Jun%C3%A7%C3%A3o_de_fora_cheia"></a><h4> Jun&ccedil;&atilde;o de fora cheia </h4>&#10;<p>A <b>jun&ccedil;&atilde;o de fora</b> ou <b>jun&ccedil;&atilde;o de fora cheia</b> combina os efeitos dos resultados da <i>esquerda</i> e da <i>jun&ccedil;&atilde;o de fora direita</i>.</p>&#10;<p>A <i>jun&ccedil;&atilde;o de fora cheia</i> &eacute; escrito como <i>R</i> =X= <i>S</i> onde <i>R</i> e <i>S</i> s&atilde;o rela&ccedil;&otilde;es. O resultado do <i>jun&ccedil;&atilde;o de fora cheia</i> &eacute; o conjunto de todas as combina&ccedil;&otilde;es em <i>R</i> e <i>S</i> que s&atilde;o iguais em seus atributos com nomes iguais, al&eacute;m de tuplas em <i>S</i> que n&atilde;o possuem casamento com tuplas em <i>R</i> e tuplas em <i>R</i> que n&atilde;o possuem casamento com tuplas em <i>S</i> em seus atributos com nomes iguais.</p>&#10;<p>Por exemplo, considere as tabelas <i>Empregado</i> e <i>Departamento</i> e a jun&ccedil;&atilde;o de fora:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table cellpadding="20" style="margin: 0 auto&semi;">&#10;<tr valign="top">&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>IdEmp </th>&#10;<th>DeptNome&#10;<pre>|&shy;&#10;| Harry  </pre></th>&#10;<td>3415  </td>&#10;<td>Finan&ccedil;as&#10;<pre>|&shy;&#10;| Sally  </pre></td>&#10;<td>2241  </td>&#10;<td>Vendas&#10;<pre>|&shy;&#10;| George </pre></td>&#10;<td>3401  </td>&#10;<td>Finan&ccedil;as&#10;<pre>|&shy;&#10;| Harriet </pre></td>&#10;<td>2202 </td>&#10;<td>Vendas&#10;<pre>|&shy;&#10;| Tim </pre></td>&#10;<td>1123 </td>&#10;<td>Executivo</td></tr></table></div></td>&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>Gerente&#10;<pre>|&shy;&#10;| Vendas  </pre></th>&#10;<td>Harriet&#10;<pre>|&shy;&#10;| Produ&ccedil;&atilde;o </pre></td>&#10;<td>Charles</td></tr></table></div></td>&#10;<td>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>IdEmp </th>&#10;<th>DeptName </th>&#10;<th>Gerente&#10;<pre>|&shy;&#10;| Harry  </pre></th>&#10;<td>3415  </td>&#10;<td>Finan&ccedil;as </td>&#10;<td>&omega;&#10;<pre>|&shy;&#10;| Sally  </pre></td>&#10;<td>2241   </td>&#10;<td>Vendas </td>&#10;<td>Harriet&#10;<pre>|&shy;&#10;| George </pre></td>&#10;<td>3401  </td>&#10;<td>Finan&ccedil;as </td>&#10;<td>&omega;&#10;<pre>|&shy;&#10;| Harriet </pre></td>&#10;<td>2202 </td>&#10;<td>Vendas </td>&#10;<td>Harriet&#10;<pre>|&shy;&#10;| Tim </pre></td>&#10;<td>1123 </td>&#10;<td>Executivo </td>&#10;<td>&omega;&#10;<pre>|&shy;&#10;| &omega; </pre></td>&#10;<td>&omega; </td>&#10;<td>Produ&ccedil;&atilde;o </td>&#10;<td>Charles</td></tr></table></div></td></tr></table></div>&#10;&#10;<p>Na rela&ccedil;&atilde;o resultante, tuplas em <i>R</i> que n&atilde;o t&ecirc;m valores em comum nos nomes dos atributos com as tuplas em <i>S</i> recebem um valor <i>null&#34&semi;, </i>&omega;<i>. Tuplas em </i>S<i> que n&atilde;o t&ecirc;m valores em comum nos nomes dos atributos com as tuplas em </i>S<i> tamb&eacute;m recebem um valor </i>null&#34&semi;, <i>&omega;</i>.</p>&#10;<p>O jun&ccedil;&atilde;o de fora cheia pode ser simulado usando a <i>esquerda</i> e a <i>jun&ccedil;&atilde;o de fora direita</i> (e, consequentemente, a <i>jun&ccedil;&atilde;o natural</i> e <i>uni&atilde;o</i>) como segue:</p>&#10;<dl><dd><i>R</i>=X=<i>S</i> = (<i>R</i>=X<i>S</i>) <span class="math">\cup</span> (<i>R</i>X=<i>S</i>)</dd></dl>&#10;<a id="Opera%C3%A7%C3%B5es_para_o_dom%C3%ADnio_computacional" name="Opera%C3%A7%C3%B5es_para_o_dom%C3%ADnio_computacional"></a><h3> Opera&ccedil;&otilde;es para o dom&iacute;nio computacional </h3>&#10;<p>N&atilde;o h&aacute; nada na &aacute;lgebra relacional introduzido at&eacute; agora, que permitiria c&aacute;lculos sobre os dom&iacute;nios de dados (exceto avalia&ccedil;&atilde;o de express&otilde;es proposicionais envolvendo igualidade). Por exemplo, n&atilde;o &eacute; poss&iacute;vel usando apenas a &aacute;lgebra introduzida at&eacute; agora para escrever uma express&atilde;o que iria multiplicar os n&uacute;meros de duas colunas, por exemplo, pre&ccedil;o unit&aacute;rio com a quantidade para obter um pre&ccedil;o total. Linguagens de consulta pr&aacute;ticas t&ecirc;m tais instala&ccedil;&otilde;es, por exemplo, o SQL SELECT permite opera&ccedil;&otilde;es aritm&eacute;ticas para definir novas colunas no resultado <code>SELECT unit_price * quantidade AS total_price FROM t</code> e uma facilidade semelhante &eacute; fornecida de forma mais expl&iacute;cita pelo <a href="http://en.wikipedia.org/wiki/Tutorial_D" id="w">Tutorial D</a> <code>EXTEND</code> palavra&shy;chave.<sup id="_ref&shy;Date2011_a" class="reference"><a href="#_note&shy;Date2011" title="">[11]</a></sup> Em teoria banco de dados, isto &eacute; chamado<b>projec&ccedil;&atilde;o alargada</b>.<sup id="_ref&shy;Garcia&shy;MolinaUllman2009_a" class="reference"><a href="#_note&shy;Garcia&shy;MolinaUllman2009" title="">[12]</a></sup> </p>&#10;<a id="Agrega%C3%A7%C3%A3o" name="Agrega%C3%A7%C3%A3o"></a><h4> Agrega&ccedil;&atilde;o </h4>&#10;<p>Al&eacute;m disso, a computa&ccedil;&atilde;o de v&aacute;rias fun&ccedil;&otilde;es numa coluna, como no somat&oacute;rio de seus elementos, tamb&eacute;m n&atilde;o &eacute; poss&iacute;vel utilizar a &aacute;lgebra relacional introduzida at&eacute; o momento. Existem cinco opera&ccedil;&otilde;es de agrega&ccedil;&atilde;o que s&atilde;o inclu&iacute;das na maioria dos bancos de dados. Esses operadores s&atilde;o <i>Soma</i>, <i>Contagem</i>, <i>M&eacute;dia</i>, <i>M&aacute;ximo</i> e <i>M&iacute;nimo</i>. Na &aacute;lgebra relacional a opera&ccedil;&atilde;o de agrega&ccedil;&atilde;o escreve&shy;se ao longo de um esquema (A<sub>1</sub>, A<sub>2</sub>, ... A<sub>n</sub>), &eacute; escrito como G<sub>1</sub>, G<sub>2</sub>, ..., G<sub>m</sub> <i>g</i><sub> f<sub>1</sub>(A<sub>1</sub>&#39&semi;), f<sub>2</sub>(A<sub>2</sub>&#39&semi;), ..., f<sub>k</sub>(A<sub>k</sub>&#39&semi;)</sub> (<b>r</b>)</p>&#10;<p>onde cada A<sub>j</sub>&#39&semi;, 1 &le; j &le; k, &eacute; um dos atributos originais A<sub>i</sub>, 1 &le; i &le; n.</p>&#10;<p>Os atributos que antecedem o <i>g</i> s&atilde;o os atributos de agrupamento, que funcionam como um &#34&semi;grupo de&#34&semi; cl&aacute;usula SQL. Depois, h&aacute; um n&uacute;mero arbitr&aacute;rio de fun&ccedil;&otilde;es de agrega&ccedil;&atilde;o aplicados aos atributos individuais. A opera&ccedil;&atilde;o &eacute; aplicada a uma rela&ccedil;&atilde;o arbitr&aacute;ria <b>r</b>. Os atributos de agrupamento s&atilde;o opcionais, e se eles n&atilde;o s&atilde;o fornecidos, as fun&ccedil;&otilde;es de agrega&ccedil;&atilde;o s&atilde;o aplicadas em toda a rela&ccedil;&atilde;o com o qual a opera&ccedil;&atilde;o &eacute; aplicada.</p>&#10;<p>Vamos assumir que temos uma tabela chamada Conta com tr&ecirc;s colunas, a saber N&uacute;mero_conta, Nome_ramo e Equil&iacute;brio. Queremos encontrar o m&aacute;ximo de equil&iacute;brio de cada ramo. Isto &eacute; realizado por <sub>Nome_ramo</sub>G<sub>Max (Equil&iacute;brio)</sub>(Conta). Para encontrar o maior saldo de todas as contas, independentemente do ramo, poder&iacute;amos simplesmente escrever G<sub>Max (Equil&iacute;brio)</sub>(Conta).</p>&#10;<a id="Limita%C3%A7%C3%A3o_da_%C3%A1lgebra_relacional" name="Limita%C3%A7%C3%A3o_da_%C3%A1lgebra_relacional"></a><h2> Limita&ccedil;&atilde;o da &aacute;lgebra relacional </h2>&#10;<p>Embora a &aacute;lgebra relacional pare&ccedil;a suficientemente poderosa para a maioria dos efeitos pr&aacute;ticos, existem alguns operadores simples e naturais nas rela&ccedil;&otilde;es que n&atilde;o podem ser expressos pela &aacute;lgebra relacional. O fecho transitivo de uma rela&ccedil;&atilde;o bin&aacute;ria &eacute; um deles. &#10;Dado um dom&iacute;nio <i>D</i>, a rela&ccedil;&atilde;o bin&aacute;ria <i>R</i> &eacute; um subconjunto de <i>D</i>&#215&semi;<i>D</i>. O encerramento transitivo The transitive closure <i>R<sup>+</sup></i> de <i>R</i> &eacute; o menor subconjunto de <i>D</i>&#215&semi;<i>D</i> contendo<b>&#39&semi;R<i> que satisfaz a seguinte condi&ccedil;&atilde;o:</i></b></p>&#10;<dl><dd><span class="math">\forall x \forall y \forall z \left( (x,y) \in R^+ \wedge (y,z) \in R^+ \Rightarrow (x,z) \in R^+ \right)</span></dd></dl>&#10;<p>Isto pode provar que n&atilde;o existe uma express&atilde;o de &aacute;lgebra relacional <i>E</i>(<i>R</i>), tendo <i>R</i> como argumento vari&aacute;vel que produz <i>R</i><sup>+</sup>. A prova &eacute; baseada no fato de que, dada uma express&atilde;o relacional <i>E</i> que se alega que <i>E</i>(<i>R</i>) = <i>R</i><sup>+</sup>, onde <i>R</i> &eacute; uma vari&aacute;vel, podemos sempre encontrar uma inst&acirc;ncia <b><i>r</i></b> ou <i>R</i> (e um dom&iacute;nio correspondente <i>d</i>), de modo que <i>E</i>(<b><i>r</i></b>) &ne; <b><i>r</i></b><sup>+</sup>.<sup id="_ref&shy;13" class="reference"><a href="#_note&shy;13" title="">[13]</a></sup></p>&#10;<p>O SQL por&eacute;m suporta oficialmente tais consultas hier&aacute;rquicas e recursivas em SQL (consultas Fixpoint) desde 1999, e tinha extens&otilde;es espec&iacute;ficas do fornecedor neste sentido bem antes disso.</p>&#10;<a id="Uso_das_propriedades_alg%C3%A9bricas_para_optimiza%C3%A7%C3%A3o_de_consultas" name="Uso_das_propriedades_alg%C3%A9bricas_para_optimiza%C3%A7%C3%A3o_de_consultas"></a><h4> Uso das propriedades alg&eacute;bricas para optimiza&ccedil;&atilde;o de consultas </h4>&#10;<p> &#10;<a href="http://en.wikipedia.org/wiki/Banco_de_dados_relacional" id="w">Banco de dados relacional</a> pode ser representado como uma <a href="http://en.wikipedia.org/wiki/&Aacute;rvore_(estrutura_de_dados)" id="w">&aacute;rvore</a>, onde&#10;</p>&#10;<ul>&#10;<li>Os nodos internos s&atilde;o operadores,</li>&#10;<li>Folhas s&atilde;o as rela&ccedil;&otilde;es,</li>&#10;<li>Sub &aacute;rvores s&atilde;o sub&shy;express&otilde;es&semi;</li></ul>&#10;<p>Nosso principal objectivo &eacute; transformar a express&atilde;o de &aacute;rvores em express&otilde;es equivalentes de &aacute;rvores, onde a dimens&atilde;o m&eacute;dia das rela&ccedil;&otilde;es geradas por sub&shy;express&otilde;es na &aacute;rvore s&atilde;o menores do que eram antes da optimiza&ccedil;&atilde;o. Nosso segundo objectivo &eacute; tentar formar sub&shy;express&otilde;es comuns dentro de uma &uacute;nica consulta, ou se houver mais de uma consulta a ser avaliada, ao mesmo tempo, em todas essas consultas. A l&oacute;gica subjacente &eacute; a de que o segundo objectivo  &eacute; o suficiente para computar sub&shy;express&otilde;es comuns uma vez, e os resultados podem ser utilizados em todas as consultas que contenham essa  sub&shy;express&atilde;o.</p>&#10;<p>Aqui, apresentamos um conjunto de regras, que podem ser utilizados em tais transforma&ccedil;&otilde;es.</p>&#10;<a id="Sele%C3%A7%C3%A3o" name="Sele%C3%A7%C3%A3o"></a><h3> Sele&ccedil;&atilde;o </h3>&#10;<p>Regras sobre  operadores de sele&ccedil;&atilde;o desempenham papel mais importante na optimiza&ccedil;&atilde;o  da busca. Sele&ccedil;&atilde;o &eacute; um operador que de forma muito eficaz diminui o n&uacute;mero de linhas no seu operando, por isso, se n&oacute;s conseguirmos passar as sele&ccedil;&otilde;es em uma &aacute;rvore de express&atilde;o para as folhas, as rela&ccedil;&otilde;es internas (geradas por sub&shy;express&otilde;es) provavelmente ir&atilde;o encolher.</p>&#10;<a id="Propriedades_b%C3%A1sicas__de_sele%C3%A7%C3%A3o" name="Propriedades_b%C3%A1sicas__de_sele%C3%A7%C3%A3o"></a><h4> Propriedades b&aacute;sicas  de sele&ccedil;&atilde;o </h4>&#10;<p>Sele&ccedil;&atilde;o &eacute; uma opera&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/Idempot%C3%AAncia" id="w">idempotente</a> (m&uacute;ltiplas aplica&ccedil;&otilde;es da mesma sele&ccedil;&atilde;o t&ecirc;m o mesmo efeito de uma &uacute;nica aplica&ccedil;&atilde;o), e <a href="http://en.wikipedia.org/wiki/Comutatividade" id="w">comutativa</a> (a ordem em que as sele&ccedil;&otilde;es s&atilde;o aplicadas n&atilde;o influencia o resultado).</p>&#10;&#10;<ol>&#10;<li><span class="math">\sigma_{A}(R)=\sigma_{A}\sigma_{A}(R)\,\!</span></li>&#10;<li><span class="math">\sigma_{A}\sigma_{B}(R)=\sigma_{B}\sigma_{A}(R)\,\!</span></li></ol>&#10;<a id="Quebrando_sele%C3%A7%C3%B5es_com_condi%C3%A7%C3%B5es_complexas" name="Quebrando_sele%C3%A7%C3%B5es_com_condi%C3%A7%C3%B5es_complexas"></a><h4> Quebrando sele&ccedil;&otilde;es com condi&ccedil;&otilde;es complexas </h4>&#10;<p>Uma sele&ccedil;&atilde;o cuja condi&ccedil;&atilde;o &eacute; uma <a href="http://en.wikipedia.org/wiki/Conjun%C3%A7%C3%A3o_l%C3%B3gica" id="w">conjun&ccedil;&atilde;o</a> de condi&ccedil;&otilde;es mais simples &eacute; equivalente a uma sequ&ecirc;ncia de sele&ccedil;&otilde;es com as mesmas condi&ccedil;&otilde;es individuais, e a sele&ccedil;&atilde;o cuja a  condi&ccedil;&atilde;o &eacute; uma <a href="http://en.wikipedia.org/wiki/Disjun%C3%A7%C3%A3o_l%C3%B3gica" id="w">disjun&ccedil;&atilde;o</a> &eacute; equivalente a uma uni&atilde;o de sele&ccedil;&otilde;es. Essas identidades podem ser usadas para mesclar sele&ccedil;&otilde;es de modo que menos sele&ccedil;&otilde;es precisem de ser avaliadas, ou para dividir&shy;las de modo a que a componente sele&ccedil;&otilde;es possa ser movida ou optimizada separadamente.</p>&#10;&#10;<ol>&#10;<li><span class="math">\sigma_{A \land B}(R)=\sigma_{A}(\sigma_{B}(R))=\sigma_{B}(\sigma_{A}(R))</span></li>&#10;<li><span class="math">\sigma_{A \lor B}(R)=\sigma_{A}(R)\cup\sigma_{B}(R)</span></li></ol>&#10;<a id="Sele%C3%A7%C3%A3o_e_cruzamento_de_produto" name="Sele%C3%A7%C3%A3o_e_cruzamento_de_produto"></a><h4> Sele&ccedil;&atilde;o e cruzamento de produto </h4>&#10;<p>O operador de cruzamento de produto &eacute; o de maior custo computacional para avaliar. Se a entrada da rela&ccedil;&atilde;o tem <span class="math">N</span> e <span class="math">M</span>linhas, o resultado ir&aacute; conter <span class="math">NM</span> linhas. Portanto isso &eacute; muito importante para ter um menor tamanho de ambos os operadores antes de ser aplicado o operador de cruzamento de produto.</p>&#10;<p>Isso pode ser feito de forma eficaz, se o cruzamento de produto for seguido de um operador de sele&ccedil;&atilde;o, ex. <span class="math">\sigma_{A}</span>(<span class="math">R</span> &times; <span class="math">P</span>). Considerando a defini&ccedil;&atilde;o de sele&ccedil;&atilde;o, isto &eacute; o caso mais prov&aacute;vel. Se o cruzamento de produto n&atilde;o for seguido de um operador de sele&ccedil;&atilde;o, podemos tentar descer at&eacute; um n&iacute;vel mais baixo a partir de n&iacute;veis mais altos da &aacute;rvore de express&otilde;es usando outra regra de sele&ccedil;&atilde;o. </p>&#10;<p>No caso acima quebramos a condi&ccedil;&atilde;o <span class="math">A</span> introduzindo a condi&ccedil;&atilde;o <span class="math">B</span>, <span class="math">C</span> e <span class="math">D</span> usando regras de divis&atilde;o sobre complexas condi&ccedil;&otilde;es de sele&ccedil;&atilde;o, de modo que <span class="math">A</span> = <span class="math">B</span> <span class="math">\wedge</span><span class="math">C</span> <span class="math">\wedge</span> <span class="math">D</span> e <span class="math">B</span> somente cont&eacute;m atributos de <span class="math">R</span>, <span class="math">C</span>cont&eacute;m atributos somente de <span class="math">P</span> e <span class="math">D</span> cont&eacute;m partes de <span class="math">A</span> que cont&eacute;m os atributos tanto de<span class="math">R</span> como de <span class="math">P</span>. Observe que <span class="math">B</span>, <span class="math">C</span> ou <span class="math">D</span> podem ser possivelmente vazios. Depois os seguintes det&eacute;m:&#10;</p><dl><dd><span class="math">\sigma_{A}(R \times P) = \sigma_{B \wedge C \wedge D}(R \times P) = \sigma_{D}(\sigma_{B}(R) \times \sigma_{C}(P))</span></dd></dl>&#10;<a id="Sele%C3%A7%C3%A3o_e_produto_cartesiano" name="Sele%C3%A7%C3%A3o_e_produto_cartesiano"></a><h4> Sele&ccedil;&atilde;o e produto cartesiano </h4>&#10;<p>O produto cartesiano &eacute; o operador mais caro de avaliar. Se as rela&ccedil;&otilde;es de entrada t&ecirc;m <i>N</i> e <i>M</i> linhas, o resultado ir&aacute; conter <i>NM</i> linhas. Por isso, &eacute; muito importante fazer o nosso melhor para diminuir o tamanho de ambos os operandos antes de aplicar o operador produto cartesiano.</p>&#10;<p>Isto pode ser feito eficazmente, se o produto cartesiano &eacute; seguido por um operador de sele&ccedil;&atilde;o, por exemplo, <span class="math">\sigma_{A}(R \times P) </span>. Considerando a defini&ccedil;&atilde;o de jun&ccedil;&atilde;o, isto &eacute; o caso mais prov&aacute;vel. Se o produto cartesiano n&atilde;o &eacute; seguido por um operador de sele&ccedil;&atilde;o, podemos tentar empurrar para baixo uma sele&ccedil;&atilde;o a partir de n&iacute;veis mais altos da &aacute;rvore de express&atilde;o usando a outra regra de sele&ccedil;&atilde;o.</p>&#10;<dl><dd><span class="math">\sigma_{A}(R \times P) = \sigma_{B \wedge C \wedge D}(R \times P) = \sigma_{D}(\sigma_{B}(R) \times \sigma_{C}(P))</span></dd></dl>&#10;<a id="Sele%C3%A7%C3%A3o_e_operadores_de_conjuntos" name="Sele%C3%A7%C3%A3o_e_operadores_de_conjuntos"></a><h4> Sele&ccedil;&atilde;o e operadores de conjuntos </h4>&#10;<p>Sele&ccedil;&atilde;o &eacute; <a href="http://en.wikipedia.org/wiki/Distributividade" id="w">distributiva</a> ao longo dos operadores <i>setminus</i>, <i>intersec&ccedil;&atilde;o</i> e <i>uni&atilde;o</i>. As tr&ecirc;s regras seguintes s&atilde;o utilizadas para definir as opera&ccedil;&otilde;es na &aacute;rvore de express&atilde;o. Note, que nos operadores <i>setminus</i> e <i>intersec&ccedil;&atilde;o</i>, &eacute; poss&iacute;vel aplicar o operador <i>sele&ccedil;&atilde;o</i> apenas em um dos operandos ap&oacute;s a transforma&ccedil;&atilde;o. Isso pode fazer sentido nos casos em que um dos operandos &eacute; pequeno, e os custos gerais da avalia&ccedil;&atilde;o do operador de <i>sele&ccedil;&atilde;o</i> superam os benef&iacute;cios de se utilizar uma menor rela&ccedil;&atilde;o como um operando.</p>&#10;&#10;<ol>&#10;<li><span class="math">\sigma_{A}(R\setminus P)=\sigma_{A}(R)\setminus \sigma_{A}(P) =\sigma_{A}(R)\setminus P</span></li>&#10;<li><span class="math">\sigma_{A}(R\cup P)=\sigma_{A}(R)\cup\sigma_{A}(P)</span></li>&#10;<li><span class="math">\sigma_{A}(R\cap P)=\sigma_{A}(R)\cap\sigma_{A}(P)=\sigma_{A}(R)\cap P=R\cap \sigma_{A}(P)</span></li></ol>&#10;<a id="Sele%C3%A7%C3%A3o_e_proje%C3%A7%C3%A3o" name="Sele%C3%A7%C3%A3o_e_proje%C3%A7%C3%A3o"></a><h4> Sele&ccedil;&atilde;o e proje&ccedil;&atilde;o </h4>&#10;<p>Sele&ccedil;&atilde;o &eacute; associativo com proje&ccedil;&atilde;o se e somente se os campos referenciados na condi&ccedil;&atilde;o da sele&ccedil;&atilde;o s&atilde;o um subconjunto dos campos na proje&ccedil;&atilde;o. Fazer a sele&ccedil;&atilde;o antes da proje&ccedil;&atilde;o pode ser &uacute;til se o operando &eacute; um produto cartesiano ou jun&ccedil;&atilde;o. Em outros casos, se a condi&ccedil;&atilde;o da sele&ccedil;&atilde;o &eacute; relativamente cara na computa&ccedil;&atilde;o, mover a sele&ccedil;&atilde;o para fora da proje&ccedil;&atilde;o pode reduzir o n&uacute;mero de tuplas que devem ser testadas (desde que a proje&ccedil;&atilde;o possa produzir menos tuplas devido &agrave; elimina&ccedil;&atilde;o de duplicados, resultado da omiss&atilde;o de campos).</p>&#10;<dl><dd><span class="math">\pi_{a_1, ...,a_n}(\sigma_A( R )) = \sigma_A(\pi_{a_1, ...,a_n}( R ))\&semi;\&semi;\&semi;\mathrm{onde}\&semi;\&semi;\mathrm{campos\ em}\ A \subseteq \{a_1,...,a_n\}</span></dd></dl>&#10;<a id="Proje%C3%A7%C3%A3o" name="Proje%C3%A7%C3%A3o"></a><h3> Proje&ccedil;&atilde;o </h3>&#10;<a id="Propriedades_b%C3%A1sicas_da_proje%C3%A7%C3%A3o" name="Propriedades_b%C3%A1sicas_da_proje%C3%A7%C3%A3o"></a><h4> Propriedades b&aacute;sicas da proje&ccedil;&atilde;o </h4>&#10;<p>Proje&ccedil;&atilde;o &eacute; idempotente, de forma que uma s&eacute;rie de proje&ccedil;&otilde;es (v&aacute;lida) &eacute; equivalente a proje&ccedil;&atilde;o mais de fora.</p>&#10;<dl><dd><span class="math">\pi_{a_1, ..., a_n}(\pi_{b_1, ..., b_m}(R)) = \pi_{a_1, ..., a_n}(R)\&semi;\&semi;\&semi;\mathrm{onde}\&semi;\&semi;\{a_1, ..., a_n\} \subseteq \{b_1, ..., b_m\}</span></dd></dl>&#10;<a id="Proje%C3%A7%C3%A3o_e_operadores_de_conjunto" name="Proje%C3%A7%C3%A3o_e_operadores_de_conjunto"></a><h4> Proje&ccedil;&atilde;o e operadores de conjunto </h4>&#10;<p>Proje&ccedil;&atilde;o &eacute; <a href="http://en.wikipedia.org/wiki/Distributividade" id="w">distributiva</a> sobre a uni&atilde;o de conjunto.</p>&#10;<dl><dd><span class="math">\pi_{a_1, \ldots, a_n}(R \cup P) = \pi_{a_1, \ldots, a_n}(R) \cup \pi_{a_1, \ldots, a_n}(P). \, </span></dd></dl>&#10;<p>Proje&ccedil;&atilde;o n&atilde;o distribui sobre intersec&ccedil;&atilde;o e diferen&ccedil;a de conjuntos. Contra&shy;exemplos s&atilde;o dados por:</p>&#10;<dl><dd><span class="math">\pi_A(\{ \langle A=a, B=b \rangle \} \cap \{ \langle A=a, B=b' \rangle \}) = \emptyset</span></dd></dl>&#10;<dl><dd><span class="math">\pi_A(\{ \langle A=a, B=b \rangle \}) \cap \pi_A(\{ \langle A=a, B=b' \rangle \}) = \{ \langle A=a \rangle \}</span></dd></dl>&#10;<p>e</p>&#10;<dl><dd><span class="math">\pi_A(\{ \langle A=a, B=b \rangle \} \setminus \{ \langle A=a, B=b' \rangle \}) = \{ \langle A=a\}</span></dd></dl>&#10;<dl><dd><span class="math">\pi_A(\{ \langle A=a, B=b \rangle \}) \setminus \pi_A(\{ \langle A=a, B=b' \rangle \}) = \emptyset\,,</span></dd></dl>&#10;<p>onde <i>b</i> &eacute; assumido distinto de <i>b </i>.</p>&#10;<a id="Renomear" name="Renomear"></a><h3> Renomear </h3>&#10;<a id="Propriedades_b%C3%A1sicas_de_renomear" name="Propriedades_b%C3%A1sicas_de_renomear"></a><h4> Propriedades b&aacute;sicas de renomear </h4>&#10;<p>Renomear sucessivamente uma vari&aacute;vel pode se desmanchar em um &uacute;nico renome. Opera&ccedil;&otilde;es de renomear que n&atilde;o possuem vari&aacute;veis em comum podem ser arbitrariamente reordenadas, uma com rela&ccedil;&atilde;o a outra, e podem ser aproveitadas para fazer sucessivas nomea&ccedil;&otilde;es adjacentes.</p>&#10;&#10;<ol>&#10;<li><span class="math">\rho_{a / b}(\rho_{b / c}(R)) = \rho_{a / c}(R)\,\!</span></li>&#10;<li><span class="math">\rho_{a / b}(\rho_{c / d}(R)) = \rho_{c / d}(\rho_{a / b}(R))\,\!</span></li></ol>&#10;<a id="Renomear_e_opera%C3%A7%C3%B5es_de_conjuntos" name="Renomear_e_opera%C3%A7%C3%B5es_de_conjuntos"></a><h4> Renomear e opera&ccedil;&otilde;es de conjuntos </h4>&#10;<p>Renomear &eacute; distributivo sobre a diferen&ccedil;a, uni&atilde;o e intersec&ccedil;&atilde;o.</p>&#10;&#10;<ol>&#10;<li><span class="math">\rho_{a / b}(R \setminus P) = \rho_{a / b}(R) \setminus \rho_{a / b}(P)</span></li>&#10;<li><span class="math">\rho_{a / b}(R \cup P) = \rho_{a / b}(R) \cup \rho_{a / b}(P)</span></li>&#10;<li><span class="math">\rho_{a / b}(R \cap P) = \rho_{a / b}(R) \cap \rho_{a / b}(P)</span></li></ol>&#10;<a id="Implementa%C3%A7%C3%B5es" name="Implementa%C3%A7%C3%B5es"></a><h2> Implementa&ccedil;&otilde;es </h2>&#10;<p>A primeira linguagem de consulta que foi baseada na da &aacute;lgebra Codd foi ISBL, e este trabalho pioneiro tem sido aclamado por v&aacute;rias autoridades como tendo mostrado o caminho para tornar a ideia de Codd em uma linguagem &uacute;til. Business System 12 foi uma ind&uacute;stria de vida curta que usava a for&ccedil;a do SGBD relacional que o exemplo seguiu do ISBL.</p>&#10;<p>Em 1998, Chris Data e Hugh Darwen prop&ocirc;s uma linguagem chamada Tutorial D destinado a ser utilizada no ensino de teoria de banco de dados relacional, e sua linguagem de consulta tamb&eacute;m usa as ideias do ISBL. Rel &eacute; uma implementa&ccedil;&atilde;o do <b>Tutorial D</b>. </p>&#10;<p>Mesmo a linguagem de consulta SQL &eacute; vagamente baseada em uma &aacute;lgebra relacional, embora os operandos em SQL (<a href="http://en.wikipedia.org/wiki/Banco_de_dados" id="w">tabelas</a>) n&atilde;o s&atilde;o exatamente a <a href="http://en.wikipedia.org/wiki/Rela%C3%A7%C3%A3o_(bancodados)" id="w">rela&ccedil;&atilde;o</a> e diversos teoremas &uacute;teis sobre a &aacute;lgebra relacional n&atilde;o det&ecirc;m hom&oacute;logo no SQL (provavelmente em detrimento de otimizadores e ou usu&aacute;rios). O modelo da tabela SQL &eacute; um saco (<a href="http://en.wikipedia.org/wiki/Multiconjunto" id="w">multiconjunto</a>), ao inv&eacute;s de um conjunto. Por exemplo, a express&atilde;o (R &cup; S) &shy; T = (R &shy; T) &cup; (S &shy; T) &eacute; um teorema de &aacute;lgebra relacional em conjuntos, mas n&atilde;o para &aacute;lgebra relacional em sacos, para um tratamento de &aacute;lgebra relacional em sacos ver cap&iacute;tulo 5 do livro &#34&semi;Complete&#34&semi; por <a href="http://en.wikipedia.org/wiki/Garcia&shy;Molina" id="w">Garcia&shy;Molina</a>, <a href="http://en.wikipedia.org/wiki/Jeffrey_Ullman" id="w">Ullman</a> e Jennifer Widom.<sup id="_ref&shy;Garcia&shy;MolinaUllman2009_b" class="reference"><a href="#_note&shy;Garcia&shy;MolinaUllman2009" title="">[12]</a></sup></p>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;<p />&#10;<div style="&shy;moz&shy;column&shy;count:3&semi; column&shy;count:3&semi;">&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Produto_cartesiano" id="w">Produto cartesiano</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Banco_de_dados" id="w">Banco de dados</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Proje%C3%A7%C3%A3o_(matem%C3%A1tica)" id="w">Proje&ccedil;&atilde;o (matem&aacute;tica)</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Proje%C3%A7%C3%A3o_(%C3%A1lgebra_relacional)" id="w">Proje&ccedil;&atilde;o (&aacute;lgebra relacional)</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Rela%C3%A7%C3%A3o_(matem%C3%A1tica)" id="w">Rela&ccedil;&atilde;o</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Banco_de_dados_relacional" id="w">Banco de dados relacional</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Modelo_relacional" id="w">Modelo relacional</a></li></ul>&#10;<p /></div>&#10;&#10;<p> </p>&#10;<a id="Bibliografia" name="Bibliografia"></a><h2> Bibliografia </h2>&#10;<p> &#10;</p>&#10;<ul>&#10;<li>Practicamente qualquer livro acad&eacute;mico sobre banco de dados tem um tratamento cl&aacute;ssico da &aacute;lgebra relacional.</li>&#10;<li>  (Para rela&ccedil;&otilde;es com &aacute;lgebras cil&iacute;ndricas).</li></ul>&#10;<p> &#10; </p>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li></ul>&#10;<p> &#10;<a href="http://en.wikipedia.org/wiki/Categoria:SGBDs" id="w">Categoria:SGBDs</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Modelo_relacional" id="w">Categoria:Modelo relacional</a></p></body></html>