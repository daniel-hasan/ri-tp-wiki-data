<html><title>N&uacute;cleo (software)</title><body>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:Kernel_Layout.svg%7Cthumb%7C200px" id="w">Um n&uacute;cleo de sistema conecta o software aplicativo ao hardware de um computador.</a></p>&#10;<p>Em <a href="http://en.wikipedia.org/wiki/Computa%C3%A7%C3%A3o" id="w">computa&ccedil;&atilde;o</a>, o <b>n&uacute;cleo</b> ou <b>cerne</b> ( ) &eacute; o componente central do <a href="http://en.wikipedia.org/wiki/Sistema_operativo" id="w">sistema operativo</a> da maioria dos computadores&semi; ele serve de ponte entre aplicativos e o processamento real de dados feito a n&iacute;vel de hardware. As responsabilidades do n&uacute;cleo incluem gerenciar os recursos do sistema (a comunica&ccedil;&atilde;o entre componentes de <a href="http://en.wikipedia.org/wiki/Hardware" id="w">hardware</a> e <a href="http://en.wikipedia.org/wiki/Software" id="w">software</a>).<sup id="_ref&shy;Wulf74_a" class="reference"><a href="#_note&shy;Wulf74" title="">[1]</a></sup> Geralmente como um componente b&aacute;sico do sistema operativo, um n&uacute;cleo pode oferecer a <a href="http://en.wikipedia.org/wiki/Camada_de_abstra%C3%A7%C3%A3o" id="w">camada de abstra&ccedil;&atilde;o</a> de n&iacute;vel mais baixo para os recursos (especialmente <a href="http://en.wikipedia.org/wiki/Unidade_central_de_processamento" id="w">processadores</a> e dispositivos de <a href="http://en.wikipedia.org/wiki/Entrada/sa%C3%ADda" id="w">entrada/sa&iacute;da</a>) que softwares aplicativos devem controlar para realizar sua fun&ccedil;&atilde;o. Ele tipicamente torna estas facilidades dispon&iacute;veis para os <a href="http://en.wikipedia.org/wiki/Processo_(inform%C3%A1tica)" id="w">processos</a> de <a href="http://en.wikipedia.org/wiki/Aplicativos" id="w">aplicativos</a> atrav&eacute;s de mecanismos de <a href="http://en.wikipedia.org/wiki/Comunica%C3%A7%C3%A3o_entre_processos" id="w">comunica&ccedil;&atilde;o entre processos</a> e <a href="http://en.wikipedia.org/wiki/Chamada_de_sistema" id="w">chamadas de sistema</a>.</p>&#10;<p>Tarefas de sistemas operativos s&atilde;o feitas de maneiras diferentes por n&uacute;cleos diferentes, dependendo do seu desenho e abordagem. Enquanto <a href="http://en.wikipedia.org/wiki/N%C3%BAcleo_monol%C3%ADtico" id="w">n&uacute;cleos monol&iacute;ticos</a> tentar&atilde;o alcan&ccedil;ar seus objetivos executando todos c&oacute;digos de sistema no mesmo <a href="http://en.wikipedia.org/wiki/Espa%C3%A7o_de_endere%C3%A7amento" id="w">espa&ccedil;o de endere&ccedil;amento</a> para aumentar a performance do sistema, <a href="http://en.wikipedia.org/wiki/Micron%C3%BAcleo_(inform%C3%A1tica)" id="w">micron&uacute;cleos</a> executam a maioria dos servi&ccedil;os do sistema no <a href="http://en.wikipedia.org/wiki/Espa%C3%A7o_de_usu%C3%A1rio" id="w">espa&ccedil;o de usu&aacute;rio</a> como <a href="http://en.wikipedia.org/wiki/Servidores" id="w">servidores</a>, buscando melhorar a manuten&ccedil;&atilde;o e a modularidade do sistema operativo.<sup id="_ref&shy;mono&shy;micro_a" class="reference"><a href="#_note&shy;mono&shy;micro" title="">[2]</a></sup> Uma gama de possibilidades existem entre estes extremos.</p>&#10;<a id="Vis%C3%A3o_geral" name="Vis%C3%A3o_geral"></a><h2> Vis&atilde;o geral </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:Computer_abstraction_layers.svg%7Cthumb%7C200px%7CUma_vis%C3%A3o_t%C3%ADpica_de_uma_%5B%5Barquitetura_de_computadores%5D%5D_como_s%C3%A9ries_de_camadas_de_abstra%C3%A7%C3%A3o:_%5B%5Bhardware%5D%5D%2C_%5B%5Bfirmware%5D%5D%2C_%5B%5Blinguagem_de_montagem%7Cmontador%5D%5D%2C_n%C3%BAcleo%2C_%5B%5Bsistema_operativo%5D%5D_e_%5B%5Bprocesso_(inform%C3%A1tica)" id="w">aplicativos]] (veja tamb&eacute;m [http://www.pearsonhighered.com/educator/academic/product/0,,0131485210,00%2ben&shy;USS_01DBC.html &#39&semi;&#39&semi;Organiza&ccedil;&atilde;o Estruturada de Computadores&#39&semi;&#39&semi;, por Andrew S. Tanenbaum.]).</a>&#10;Na defini&ccedil;&atilde;o do &#39&semi;n&uacute;cleo&#39&semi;, <a href="http://en.wikipedia.org/wiki/Jochen_Liedtke" id="w">Jochen Liedtke</a> disse que a palavra &eacute; &#34&semi;tradicionalmente usada para definir a parte do sistema operativo que &eacute; obrigat&oacute;ria e comum a todo software no sistema.&#34&semi;<sup id="_ref&shy;Liedtke95_a" class="reference"><a href="#_note&shy;Liedtke95" title="">[3]</a></sup></p>&#10;<p>A maioria dos sistemas operativos depende do conceito de <b>n&uacute;cleo</b>. A exist&ecirc;ncia de um n&uacute;cleo &eacute; uma consequ&ecirc;ncia natural de projetar um sistema de computador como s&eacute;ries de <a href="http://en.wikipedia.org/wiki/Camada_de_abstra%C3%A7%C3%A3o" id="w">camadas de abstra&ccedil;&atilde;o</a>,<sup id="_ref&shy;Tanenbaum79_a" class="reference"><a href="#_note&shy;Tanenbaum79" title="">[4]</a></sup> cada uma das fun&ccedil;&otilde;es dependendo das fun&ccedil;&otilde;es das camadas abaixo de si. O n&uacute;cleo deste ponto de vista, &eacute; simplesmente o nome dado ao n&iacute;vel mais inferior de abstra&ccedil;&atilde;o que &eacute; implementado em <a href="http://en.wikipedia.org/wiki/Software" id="w">software</a>. Para evitar ter um n&uacute;cleo, teria&shy;se que projetar todo o software no sistema de modo a n&atilde;o utilizar abstra&ccedil;&atilde;o alguma&semi; isto iria aumentar a complexidade e o projeto a tal ponto que apenas os sistemas mais simples seriam capazes de ser implementados.</p>&#10;<p>Enquanto isto hoje &eacute; chamado <i>n&uacute;cleo</i>, originalmente a mesma parte do sistema tamb&eacute;m foi chamado o <b><i>nucleus</i></b> ou <b><i>caro&ccedil;o</i></b><sup id="_ref&shy;Wulf74_b" class="reference"><a href="#_note&shy;Wulf74" title="">[1]</a></sup><sup id="_ref&shy;Deitel82_a" class="reference"><a href="#_note&shy;Deitel82" title="">[5]</a></sup><sup id="_ref&shy;kernelnames_a" class="reference"><a href="#_note&shy;kernelnames" title="">[6]</a></sup><sup id="_ref&shy;Hansen70_a" class="reference"><a href="#_note&shy;Hansen70" title="">[7]</a></sup> (Nota, no entanto, este termo <i>caro&ccedil;o</i> tamb&eacute;m foi usado para se referir a mem&oacute;ria primordial de um sistema de computador, por que alguns dos primeiros computadores usaram uma forma de mem&oacute;ria chamada <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_de_caro%C3%A7os_magn%C3%A9ticos" id="w">mem&oacute;ria de caro&ccedil;os magn&eacute;ticos</a>), e foi concebido originalmente como contendo apenas os recursos de suporte essenciais do sistema operativo.</p>&#10;<p>Na grande maioria dos casos, o <a href="http://en.wikipedia.org/wiki/Processo_de_inicia%C3%A7%C3%A3o" id="w">processo de inicia&ccedil;&atilde;o</a> come&ccedil;a executando o n&uacute;cleo no modo supervisor.<sup id="_ref&shy;supervisor_a" class="reference"><a href="#_note&shy;supervisor" title="">[8]</a></sup> O n&uacute;cleo depois inicializa a si e depois o primeiro processo. Depois disto, tipicamente, o n&uacute;cleo n&atilde;o executa diretamente, apenas em resposta para eventos externos (<i>ex.</i>, atrav&eacute;s de chamadas de sistema usados pelos aplicativos para requisitar servi&ccedil;os do n&uacute;cleo, ou via <a href="http://en.wikipedia.org/wiki/Interrup%C3%A7%C3%A3o_de_hardware" id="w">interrup&ccedil;&otilde;es</a> usadas pelo hardware para notificar o n&uacute;cleo sobre eventos). Al&eacute;m disso, tipicamente o n&uacute;cleo fornece um la&ccedil;o que &eacute; executado sempre que nenhum processo esta dispon&iacute;vel para execu&ccedil;&atilde;o&semi; geralmente chamado de <i>processo desocupado</i>.</p>&#10;<p>O desenvolvimento do n&uacute;cleo &eacute; considerado uma das mais complexas e dif&iacute;ceis tarefas em programa&ccedil;&atilde;o.<sup id="_ref&shy;bkerndev_a" class="reference"><a href="#_note&shy;bkerndev" title="">[9]</a></sup> Sua posi&ccedil;&atilde;o central em um sistema operativo implica a necessidade de bom desempenho, que define o n&uacute;cleo como pe&ccedil;a de software cr&iacute;tica e torna seu desenvolvimento correto e implementa&ccedil;&atilde;o correta dif&iacute;cil. Devido a diversas raz&otilde;es, o n&uacute;cleo pode at&eacute; n&atilde;o ser capaz de utilizar mecanismos de <a href="http://en.wikipedia.org/wiki/Abstra%C3%A7%C3%A3o_(programa%C3%A7%C3%A3o)" id="w">abstra&ccedil;&atilde;o</a>, que ele fornece a outro software. Tais raz&otilde;es incluem preocupa&ccedil;&otilde;es com o <a href="http://en.wikipedia.org/wiki/Gerenciamento_de_mem%C3%B3ria" id="w">gerenciamento de mem&oacute;ria</a> (ex. uma fun&ccedil;&atilde;o em modo de usu&aacute;rio pode depender de mem&oacute;ria estando sujeita a <a href="http://en.wikipedia.org/wiki/Pagina%C3%A7%C3%A3o_por_demanda" id="w">pagina&ccedil;&atilde;o por demanda</a>, mas como o pr&oacute;prio n&uacute;cleo fornece esta facilidade, ele n&atilde;o pode utiliz&aacute;&shy;la, pois ele pode n&atilde;o permanecer na mem&oacute;ria para fornecer esta facilidade) e a falta de <a href="http://en.wikipedia.org/wiki/Reentr%C3%A2ncia" id="w">reentr&acirc;ncia</a>, logo o seu desenvolvimento torna&shy;se ainda mais dif&iacute;cil para engenheiros de software.</p>&#10;<p>Geralmente um n&uacute;cleo vai fornecer recursos para <a href="http://en.wikipedia.org/wiki/Escalonamento_de_processos" id="w">escalonamento de processos</a> de baixo n&iacute;vel,<sup id="_ref&shy;Deitel82sched_a" class="reference"><a href="#_note&shy;Deitel82sched" title="">[10]</a></sup> <a href="http://en.wikipedia.org/wiki/Comunica%C3%A7%C3%A3o_entre_processos" id="w">comunica&ccedil;&atilde;o entre processos</a>, <a href="http://en.wikipedia.org/wiki/Sincroniza%C3%A7%C3%A3o" id="w">sincroniza&ccedil;&atilde;o</a> de processos, <a href="http://en.wikipedia.org/wiki/Troca_de_contexto" id="w">troca de contexto</a>, manipula&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Bloco_de_controle_de_processo" id="w">blocos de controle de processo</a>, gerenciamento de <a href="http://en.wikipedia.org/wiki/Interrup%C3%A7%C3%A3o_de_hardware" id="w">interrup&ccedil;&otilde;es</a>, cria&ccedil;&atilde;o e destrui&ccedil;&atilde;o de processos, e suspens&atilde;o e continua&ccedil;&atilde;o de processos (veja <a href="http://en.wikipedia.org/wiki/Estados_de_processos" id="w">estados de processos</a>).<sup id="_ref&shy;Deitel82_b" class="reference"><a href="#_note&shy;Deitel82" title="">[5]</a></sup><sup id="_ref&shy;Hansen70_b" class="reference"><a href="#_note&shy;Hansen70" title="">[7]</a></sup></p>&#10;<a id="Finalidades_b%C3%A1sicas_do_n%C3%BAcleo" name="Finalidades_b%C3%A1sicas_do_n%C3%BAcleo"></a><h2> Finalidades b&aacute;sicas do n&uacute;cleo </h2>&#10;<p>O principal prop&oacute;sito do n&uacute;cleo &eacute; gerenciar os recursos do computador e permitir que outros programas rodem e usem destes recursos.<sup id="_ref&shy;Wulf74_c" class="reference"><a href="#_note&shy;Wulf74" title="">[1]</a></sup> Tipicamente estes recursos consistem de:&#10;</p>&#10;<ul>&#10;<li>A <a href="http://en.wikipedia.org/wiki/Unidade_de_processamento_central" id="w">unidade de processamento central</a> (CPU, o processador). Esta &eacute; a parte mais central de um sistema de computa&ccedil;&atilde;o, respons&aacute;vel por <i>rodar</i> ou <i>executar</i> programas nele. O n&uacute;cleo t&ecirc;m a responsabilidade de decidir em qualquer momento qual dos programas em execu&ccedil;&atilde;o deve ser alocado para o processador ou processadores (cada um dos quais geralmente pode executar um programa por vez)</li>&#10;<li>A <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_de_acesso_aleat%C3%B3rio" id="w">mem&oacute;ria</a>. A mem&oacute;ria &eacute; usada para armazenar ambos instru&ccedil;&otilde;es do programa e dados. Tipicamente, ambos precisam estar presentes na mem&oacute;ria de modo a tornar a execu&ccedil;&atilde;o do programa poss&iacute;vel. Frequentemente m&uacute;ltiplos programas buscar&atilde;o acesso &agrave; mem&oacute;ria ao mesmo tempo, na maioria das vezes exigindo mais mem&oacute;ria do que o computador pode disponibilizar. O n&uacute;cleo &eacute; respons&aacute;vel pela decis&atilde;o de que mem&oacute;ria cada processo pode utilizar, e determinar o que fazer quando menos do suficiente est&aacute; dispon&iacute;vel.</li>&#10;<li>Qualquer dispositivo de <a href="http://en.wikipedia.org/wiki/Entrada/sa%C3%ADda" id="w">entrada/sa&iacute;da</a> presente no computador, tais como teclado, rato, entradas de disquete, impressoras, telas, etc. O n&uacute;cleo aloca pedidos de aplicativos para realizar entrada/sa&iacute;da para um dispositivo apropriado (ou subse&ccedil;&atilde;o de um dispositivo, no caso de arquivos em um disco ou janelas em uma tela) e fornece m&eacute;todos convenientes para o uso do dispositivo (tipicamente abstra&iacute;do ao ponto onde o aplicativo n&atilde;o precisa mais conhecer os detalhes da implementa&ccedil;&atilde;o do dispositivo).</li></ul>&#10;<p>Aspectos importantes no gerenciamento de recursos s&atilde;o a defini&ccedil;&atilde;o de um dom&iacute;nio de execu&ccedil;&atilde;o (<a href="http://en.wikipedia.org/wiki/Espa%C3%A7o_de_endere%C3%A7amento" id="w">espa&ccedil;o de endere&ccedil;amento</a>) e o mecanismo de prote&ccedil;&atilde;o utilizado para mediar o acesso a recursos dentro de um dom&iacute;nio.<sup id="_ref&shy;Wulf74_d" class="reference"><a href="#_note&shy;Wulf74" title="">[1]</a></sup></p>&#10;<p>N&uacute;cleos geralmente n&atilde;o oferecem m&eacute;todos para <a href="http://en.wikipedia.org/wiki/Sincroniza%C3%A7%C3%A3o" id="w">sincroniza&ccedil;&atilde;o</a> e <a href="http://en.wikipedia.org/wiki/Comunica%C3%A7%C3%A3o_entre_processos" id="w">comunica&ccedil;&atilde;o entre processos</a> (IPC  ).</p>&#10;<p>Um n&uacute;cleo pode implementar estes recursos ele mesmo, ou depender de alguns processos que ele executa para fornecer estas facilidades a outros processos, no entanto neste caso ele deve oferecer algum modo do IPC permitir que processos acessem as facilidades fornecidas um pelo outro.</p>&#10;<p>Finalmente, um n&uacute;cleo deve oferecer um m&eacute;todo de acesso a estas facilidades para os programas em execu&ccedil;&atilde;o.</p>&#10;<a id="Gerenciamento_de_Processos" name="Gerenciamento_de_Processos"></a><h3> Gerenciamento de Processos </h3>&#10;<p>A principal tarefa de um n&uacute;cleo &eacute; permitir a execu&ccedil;&atilde;o de aplicativos e ajud&aacute;&shy;los com recursos como abstra&ccedil;&otilde;es de hardware. Um processo define que por&ccedil;&otilde;es da mem&oacute;ria o aplicativo pode acessar.<sup id="_ref&shy;Levy84_a" class="reference"><a href="#_note&shy;Levy84" title="">[11]</a></sup> (Para esta introdu&ccedil;&atilde;o, processo, aplicativo e programa s&atilde;o usados como sin&ocirc;nimos.)  O <a href="http://en.wikipedia.org/wiki/Gerenciamento_de_processos" id="w">gerenciamento de processos</a> do n&uacute;cleo deve levar em conta o equipamento de hardware embarcado para <a href="http://en.wikipedia.org/wiki/Prote%C3%A7%C3%A3o_de_mem%C3%B3ria" id="w">prote&ccedil;&atilde;o de mem&oacute;ria</a>.<sup id="_ref&shy;12" class="reference"><a href="#_note&shy;12" title="">[12]</a></sup></p>&#10;<p>Para rodar um aplicativo, um n&uacute;cleo geralmente cria um <a href="http://en.wikipedia.org/wiki/Espa%C3%A7o_de_endere%C3%A7amento" id="w">espa&ccedil;o de endere&ccedil;amento</a> para o aplicativo, carrega o arquivo contendo de instru&ccedil;&otilde;es do programa na mem&oacute;ria (talvez via <a href="http://en.wikipedia.org/wiki/Pagina%C3%A7%C3%A3o_por_demanda" id="w">pagina&ccedil;&atilde;o por demanda</a>), cria uma <a href="http://en.wikipedia.org/wiki/Pilha_de_chamada" id="w">pilha</a> para o programa e ramos para uma dada localiza&ccedil;&atilde;o dentro do programa, iniciando, portanto a sua execu&ccedil;&atilde;o.<sup id="_ref&shy;OS&shy;Concepts_a" class="reference"><a href="#_note&shy;OS&shy;Concepts" title="">[13]</a></sup></p>&#10;<p>N&uacute;cleos <a href="http://en.wikipedia.org/wiki/Multitarefa" id="w">multitarefa</a> s&atilde;o capazes de dar ao usu&aacute;rio a ilus&atilde;o de que um n&uacute;mero de processos que esta rodando simultaneamente no sistema &eacute; maior do que o n&uacute;mero de processos que aquele sistema &eacute; fisicamente capaz de rodar simultaneamente. Usualmente, o n&uacute;mero de processos que um sistema pode rodar simultaneamente &eacute; igual o n&uacute;mero de CPUs que ele possui instaladas (no entanto, isto pode n&atilde;o ser o caso de processadores que suportam <a href="http://en.wikipedia.org/wiki/M%C3%BAltiplas_linhas_de_execu%C3%A7%C3%A3o_simult%C3%A2neas" id="w">m&uacute;ltiplas linhas de execu&ccedil;&atilde;o simult&acirc;neas</a>).</p>&#10;<p>Em um sistema multitarefas <a href="http://en.wikipedia.org/wiki/Preemptividade" id="w">preemptivo</a>, o n&uacute;cleo dar&aacute; a todos programas uma parcela do tempo e vai alternar de processo a processo t&atilde;o rapidamente que dar&aacute; ao usu&aacute;rio a impress&atilde;o de como se os processos estivessem sendo executados simultaneamente. O n&uacute;cleo utiliza <a href="http://en.wikipedia.org/wiki/Algoritmo_de_escalonamento" id="w">algoritmos de escalonamento</a> para determinar qual processo ser&aacute; executado a seguir e quanto tempo lhe ser&aacute; dado. O algoritmo escolhido pode permitir que alguns processos tenham uma prioridade mais alta que muitos outros. O n&uacute;cleo geralmente tamb&eacute;m prov&ecirc; a esses processos uma maneira de comunicarem&shy;se&semi; isto &eacute; chamado <a href="http://en.wikipedia.org/wiki/Comunica%C3%A7%C3%A3o_entre_processos" id="w">comunica&ccedil;&atilde;o entre processos</a> (IPC  ) e as principais implementa&ccedil;&otilde;es s&atilde;o <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_compartilhada" id="w">mem&oacute;ria compartilhada</a>, <a href="http://en.wikipedia.org/wiki/Troca_de_mensagem" id="w">troca de mensagens</a> e <a href="http://en.wikipedia.org/wiki/Chamada_de_procedimento_remoto" id="w">chamadas de procedimento remoto</a> (veja <a href="http://en.wikipedia.org/wiki/Computa%C3%A7%C3%A3o_concorrente" id="w">computa&ccedil;&atilde;o concorrente</a>).</p>&#10;<p>Outros sistemas (particularmente em computadores menores, menos potentes) podem fornecer <a href="http://en.wikipedia.org/wiki/Multitarefa#Multitarefa de coopera&ccedil;&atilde;o" id="w">multitarefa de coopera&ccedil;&atilde;o</a>, em que cada processo &eacute; permitido rodar sem ininterruptamente at&eacute; que ele fa&ccedil;a uma requisi&ccedil;&atilde;o especial que avisa ao n&uacute;cleo que ele pode alternar para outro processo. Tais requisi&ccedil;&otilde;es s&atilde;o conhecidos como &#34&semi;indulg&ecirc;ncias&#34&semi; (yielding , e tipicamente ocorrem em resposta a um pedido para comunica&ccedil;&atilde;o entre processos, ou para esperar at&eacute; o acontecimento de um evento. Vers&otilde;es mais antigas de ambos <a href="http://en.wikipedia.org/wiki/Microsoft_Windows" id="w">Microsoft Windows</a> e <a href="http://en.wikipedia.org/wiki/Mac_OS" id="w">Mac OS</a> utilizaram o conceito de multitarefa cooperativa, mas alternaram para esquemas preemptivos conforme a pot&ecirc;ncia dos computadores alvo de seu mercado aumentava .</p>&#10;<p>O sistema operativo pode tamb&eacute;m suportar o <a href="http://en.wikipedia.org/wiki/Multiprocessamento" id="w">multiprocessamento</a> (<a href="http://en.wikipedia.org/wiki/Multiprocessamento_sim%C3%A9trico" id="w">multiprocessamento sim&eacute;trico</a> (SMP  ), ou, <a href="http://en.wikipedia.org/wiki/Acesso_n%C3%A3o&shy;uniforme_a_mem%C3%B3ria" id="w">acesso n&atilde;o&shy;uniforme a mem&oacute;ria</a>)&semi; neste caso, diferentes programas e linhas de execu&ccedil;&atilde;o podem rodar em diferentes processadores. Um n&uacute;cleo para tal sistema deve ser projetado para ser reentrante, o que significa que ele pode rodar seguramente duas partes de seu c&oacute;digo simultaneamente. Isto tipicamente significa oferecer mecanismos de <a href="http://en.wikipedia.org/wiki/Sincroniza%C3%A7%C3%A3o" id="w">sincroniza&ccedil;&atilde;o</a> (como <a href="http://en.wikipedia.org/wiki/Trava&shy;giro" id="w">trava&shy;giros</a>) para assegurar que dois processadores n&atilde;o tentar&atilde;o modificar os mesmos dados ao mesmo tempo.</p>&#10;<a id="Gerenciamento_de_Mem%C3%B3ria" name="Gerenciamento_de_Mem%C3%B3ria"></a><h3> Gerenciamento de Mem&oacute;ria </h3>&#10;<p>O n&uacute;cleo possui acesso completo a mem&oacute;ria do sistema e deve permitir que processos acessem a mem&oacute;ria com seguran&ccedil;a conforme a sua necessidade. Frequentemente o primeiro passo para isso &eacute; o <a href="http://en.wikipedia.org/wiki/Endere%C3%A7amento_virtual" id="w">endere&ccedil;amento virtual</a>, geralmente alcan&ccedil;ado atrav&eacute;s da <a href="http://en.wikipedia.org/wiki/Pagina%C3%A7%C3%A3o" id="w">pagina&ccedil;&atilde;o</a> e/ou <a href="http://en.wikipedia.org/wiki/Segmenta%C3%A7%C3%A3o_de_mem%C3%B3ria" id="w">segmenta&ccedil;&atilde;o</a>. Endere&ccedil;amento virtual permite ao n&uacute;cleo fazer com que um dado endere&ccedil;o f&iacute;sico pare&ccedil;a ser outro endere&ccedil;o, o endere&ccedil;o virtual. Espa&ccedil;os de endere&ccedil;o virtual podem ser diferentes para diferentes processos&semi; a mem&oacute;ria que um processos acessa em um endere&ccedil;o (virtual) particular pode ser diferente da que um outro processo acessa pelo mesmo endere&ccedil;o. Isto permite a todos programas funcionar como se ele fosse o &uacute;nico em execu&ccedil;&atilde;o, al&eacute;m do n&uacute;cleo, e por isso evita que aplicativos travem uns aos outros.<sup id="_ref&shy;OS&shy;Concepts_b" class="reference"><a href="#_note&shy;OS&shy;Concepts" title="">[13]</a></sup></p>&#10;<p>Em v&aacute;rios sistemas, o endere&ccedil;o virtual de um programa pode se referir a dados que n&atilde;o est&atilde;o na mem&oacute;ria atualmente. A cama de indire&ccedil;&atilde;o oferecida pelo endere&ccedil;amento virtual permite que o sistema utilize meios de armazenagem de dados, como um <a href="http://en.wikipedia.org/wiki/Disco_r%C3%ADgido" id="w">disco r&iacute;gido</a>, para armazenar o que de outro modo teria que permanecer na mem&oacute;ria (RAM ). Como resultado. sistemas operativos podem permitir que programas usem mais mem&oacute;ria do que est&aacute; fisicamente dispon&iacute;vel. Quando um programa precisa de dados que n&atilde;o est&atilde;o na RAM, a CPU avisa o n&uacute;cleo que isto ocorre, e o n&uacute;cleo responde escrevendo o conte&uacute;do de um bloco de mem&oacute;ria inativo para o disco (se necess&aacute;rio), e substituindo&shy;o na mem&oacute;ria com os dados requisitados pelo programa. O programa pode ent&atilde;o continuar sua execu&ccedil;&atilde;o do ponto em que foi suspenso. Este esquema &eacute; geralmente conhecido como <a href="http://en.wikipedia.org/wiki/Pagina%C3%A7%C3%A3o_por_demanda" id="w">pagina&ccedil;&atilde;o por demanda</a>.</p>&#10;<p>Endere&ccedil;amento virtual tamb&eacute;m permite a cria&ccedil;&atilde;o de parti&ccedil;&otilde;es virtuais de mem&oacute;ria em duas &aacute;reas separadas, uma sedo reservada para o n&uacute;cleo (<a href="http://en.wikipedia.org/wiki/Espa%C3%A7o_de_n%C3%BAcleo" id="w">espa&ccedil;o de n&uacute;cleo</a>) e o outro para os aplicativos (<a href="http://en.wikipedia.org/wiki/Espa%C3%A7o_de_usu%C3%A1rio" id="w">espa&ccedil;o de usu&aacute;rio</a>). Os aplicativos n&atilde;o tem permiss&atilde;o do processador para acessar a mem&oacute;ria do n&uacute;cleo, portanto prevenindo que um aplicativo possa danificar o n&uacute;cleo em execu&ccedil;&atilde;o. Esta parti&ccedil;&atilde;o fundamental de espa&ccedil;o de mem&oacute;ria contribuiu muito para os projetos de n&uacute;cleos realmente de prop&oacute;sito geral e &eacute; quase universal em tais sistemas, embora algumas n&uacute;cleos de pesquisa (ex. <a href="http://en.wikipedia.org/wiki/Singularity" id="w">Singularity</a>) usarem outros m&eacute;todos.</p>&#10;<a id="Gerenciamento_de_dispositivos" name="Gerenciamento_de_dispositivos"></a><h3> Gerenciamento de dispositivos </h3>&#10;<p>Para realizar fun&ccedil;&otilde;es &uacute;teis, processos precisam acessar <a href="http://en.wikipedia.org/wiki/Perif%C3%A9rico" id="w">perif&eacute;ricos</a> conectados ao computador, que s&atilde;o controlados pelo n&uacute;cleo atrav&eacute;s do <a href="http://en.wikipedia.org/wiki/Driver_de_dispositivo" id="w">driver do dispositivo</a>. Por exemplo, para mostrar ao usu&aacute;rio algo utilizando a tela, um aplicativo teria que fazer um requisi&ccedil;&atilde;o ao n&uacute;cleo que encaminharia a requisi&ccedil;&atilde;o para o seu driver de tela, que &eacute; respons&aacute;vel por realmente tracejar os car&aacute;cteres/pixeis.<sup id="_ref&shy;OS&shy;Concepts_c" class="reference"><a href="#_note&shy;OS&shy;Concepts" title="">[13]</a></sup></p>&#10;<p>Um n&uacute;cleo deve manter uma lista de dispositivos dispon&iacute;veis. Esta lista pode ser conhecida de antem&atilde;o (ex. em um sistema embarcado onde o n&uacute;cleo ser&aacute; reescrito se o hardware dispon&iacute;vel mudar), configurado pelo usu&aacute;rio (t&iacute;pico em computadores pessoais antigos e em sistemas projetados para uso pessoal) ou detectado pelo sistema durante a execu&ccedil;&atilde;o (normalmente chamado <a href="http://en.wikipedia.org/wiki/Ligar_e_Usar" id="w">Ligar e Usar</a>).</p>&#10;<p>Num sistema &#34&semi;Ligar e Usar&#34&semi;, um dispositivo realiza primeiro uma sondagem nos diferentes <a href="http://en.wikipedia.org/wiki/Barramento" id="w">barramentos</a> de hardware, como <a href="http://en.wikipedia.org/wiki/Interconector_de_Componentes_Perif%C3%A9ricos" id="w">Interconector de Componentes Perif&eacute;ricos</a> (PCI ) ou <a href="http://en.wikipedia.org/wiki/Universal_Serial_Bus" id="w">Barramento Serial Universal</a> (USB ), para detetar os dispositivos instalados, depois procura os drivers apropriados.</p>&#10;<p>Como a gest&atilde;o de dispositivos &eacute; uma tarefa muito especifica do SO, os drivers s&atilde;o manipulados de forma diferente pelo tipo de arquitetura do n&uacute;cleo, mas em todos os casos, o n&uacute;cleo tem que fornecer a <a href="http://en.wikipedia.org/wiki/Entrada/sa%C3%ADda" id="w">entrada/sa&iacute;da</a> para permitir que os drivers acedam fisicamente seus dispositivos atrav&eacute;s alguma porta ou localiza&ccedil;&atilde;o da mem&oacute;ria. Decis&otilde;es muito importantes precisam ser feitas ao projetar o sistema de gest&atilde;o de dispositivos, j&aacute; que em alguns projetos de acesso podem envolver <a href="http://en.wikipedia.org/wiki/Troca_de_contexto" id="w">trocas de contexto</a> , tornando a opera&ccedil;&atilde;o custosa para o processador e causando um gasto excessivo de recursos. </p>&#10;<a id="Chamadas_do_Sistema" name="Chamadas_do_Sistema"></a><h3> Chamadas do Sistema </h3>&#10;<p>Para realmente realizar algo &uacute;til, um processo deve acessar os servi&ccedil;os oferecidos pelo n&uacute;cleo. Isto &eacute; implementado por cada n&uacute;cleo, mas a maioria oferece uma <a href="http://en.wikipedia.org/wiki/Biblioteca_padr%C3%A3o_do_C" id="w">Biblioteca padr&atilde;o do C</a> ou uma <a href="http://en.wikipedia.org/wiki/Interface_de_programa%C3%A7%C3%A3o_de_aplicativos" id="w">Interface de programa&ccedil;&atilde;o de aplicativos</a>, que envolve as fun&ccedil;&otilde;es relativas ao n&uacute;cleo.<sup id="_ref&shy;14" class="reference"><a href="#_note&shy;14" title="">[14]</a></sup></p>&#10;<p>O m&eacute;todo de invocar as fun&ccedil;&otilde;es do n&uacute;cleo varia de n&uacute;cleo para n&uacute;cleo. Se o isolamento de mem&oacute;ria est&aacute; sendo usado, &eacute; imposs&iacute;vel para um processo de usu&aacute;rio chamar o n&uacute;cleo diretamente, por que isso seria uma viola&ccedil;&atilde;o das regras de controle de acesso do processador. Algumas possibilidades s&atilde;o:&#10;</p>&#10;<ul>&#10;<li>Usar uma <a href="http://en.wikipedia.org/wiki/Interrup%C3%A7%C3%A3o" id="w">interrup&ccedil;&atilde;o</a> de software simulada. Este m&eacute;todo est&aacute; dispon&iacute;vel na maioria dos hardwares, e &eacute;, portanto, muito comum.</li>&#10;<li>Usando um <a href="http://en.wikipedia.org/wiki/Port%C3%A3o_de_chamada" id="w">port&atilde;o de chamada</a>. Um port&atilde;o de chamada &eacute; um endere&ccedil;o especial armazenado pelo n&uacute;cleo em uma lista na mem&oacute;ria do n&uacute;cleo em uma localiza&ccedil;&atilde;o conhecida pelo processador. Quando o processador detecta uma chamada para este endere&ccedil;o, ele ao inv&eacute;s disso redireciona para a localiza&ccedil;&atilde;o alvo sem causar nenhuma viola&ccedil;&atilde;o de acesso. Exige suporte no hardware, mas este tipo de hardware &eacute; muito comum.</li>&#10;<li>Usando uma instru&ccedil;&atilde;o de chamada de sistema especial. Esta t&eacute;cnica exige suporte especial no hardware, que em algumas arquiteturas habituais n&atilde;o possuem (notavelmente, <a href="http://en.wikipedia.org/wiki/X86" id="w">x86</a>). Instru&ccedil;&otilde;es de chamadas de sistema foram adicionadas a modelos recentes do processadores x86, embora, poucos (mas n&atilde;o todos) sistemas operativos fazem uso destes quando dispon&iacute;veis.</li>&#10;<li>Usando uma fila baseada na mem&oacute;ria. Um aplicativo que faz um grande n&uacute;mero de requisi&ccedil;&otilde;es mas n&atilde;o precisa esperar o resultado de cada uma pode adicionar detalhes das requisi&ccedil;&otilde;es em uma &aacute;rea da mem&oacute;ria que o n&uacute;cleo sonda periodicamente para encontrar requisi&ccedil;&otilde;es.</li></ul>&#10;<a id="Decis%C3%B5es_de_desenho_do_N%C3%BAcleo" name="Decis%C3%B5es_de_desenho_do_N%C3%BAcleo"></a><h2> Decis&otilde;es de desenho do N&uacute;cleo </h2>&#10;<a id="Problemas_com_o_suporte_do_n%C3%BAcleo_para_prote%C3%A7%C3%A3o" name="Problemas_com_o_suporte_do_n%C3%BAcleo_para_prote%C3%A7%C3%A3o"></a><h3> Problemas com o suporte do n&uacute;cleo para prote&ccedil;&atilde;o </h3>&#10;<p>Uma considera&ccedil;&atilde;o importante no desenho do n&uacute;cleo &eacute; o suporte que ele oferece para prote&ccedil;&atilde;o contra faltas (<a href="http://en.wikipedia.org/wiki/Toler%C3%A2ncia_a_falhas" id="w">toler&acirc;ncia a falhas</a>) e de comportamentos # mal&shy;intencionados (<a href="http://en.wikipedia.org/wiki/Seguran%C3%A7a_de_computador" id="w">seguran&ccedil;a</a>). Estes dois aspectos geralmente n&atilde;o s&atilde;o claramente distinguidos, e a <a href="http://en.wikipedia.org/wiki/Separa%C3%A7%C3%A3o_entre_prote%C3%A7%C3%A3o_e_seguran%C3%A7a" id="w">separa&ccedil;&atilde;o</a> no desenho do n&uacute;cleo leva a rejei&ccedil;&atilde;o de uma <a href="http://en.wikipedia.org/wiki/Anel_(seguran%C3%A7a)" id="w">estrutura hier&aacute;rquica de prote&ccedil;&atilde;o</a>.<sup id="_ref&shy;Wulf74_e" class="reference"><a href="#_note&shy;Wulf74" title="">[1]</a></sup></p>&#10;<p>Os mecanismos ou pol&iacute;ticas oferecidos pelo n&uacute;cleo podem ser classificados de acordo com v&aacute;rios crit&eacute;rios, como: est&aacute;tico (for&ccedil;ado durante o <a href="http://en.wikipedia.org/wiki/Tempo_de_compila%C3%A7%C3%A3o" id="w">tempo de compila&ccedil;&atilde;o</a>) ou din&acirc;mico (for&ccedil;ado durante o <a href="http://en.wikipedia.org/wiki/Tempo_de_execu%C3%A7%C3%A3o" id="w">tempo de execu&ccedil;&atilde;o</a>)&semi; preemptivo ou p&oacute;s&shy;detec&ccedil;&atilde;o&semi; de acordo com os princ&iacute;pios de prote&ccedil;&atilde;o a que eles correspondem (ex. <a href="http://en.wikipedia.org/wiki/Peter_J._Denning" id="w">Denning</a><sup id="_ref&shy;Denning76_a" class="reference"><a href="#_note&shy;Denning76" title="">[15]</a></sup><sup id="_ref&shy;Swift05Denning76_a" class="reference"><a href="#_note&shy;Swift05Denning76" title="">[16]</a></sup>)&semi; quer eles sejam suportados pelo hardware ou baseados em linguagem&semi;  quer eles sejam mais um mecanismo aberto ou ma pol&iacute;tica compulsiva&semi; e muito mais.</p>&#10;<a id="Toler%C3%A2ncia_a_falhas" name="Toler%C3%A2ncia_a_falhas"></a><h4> Toler&acirc;ncia a falhas </h4>&#10;<p>Uma medida &uacute;til para o n&iacute;vel de toler&acirc;ncia a falhas de um sistema &eacute; qu&atilde;o estrito ele &eacute; com rela&ccedil;&atilde;o ao <a href="http://en.wikipedia.org/wiki/Princ%C3%ADpio_do_menor_privil%C3%A9gio" id="w">princ&iacute;pio do menor privil&eacute;gio</a>.<sup id="_ref&shy;17" class="reference"><a href="#_note&shy;17" title="">[17]</a></sup> Em casos onde m&uacute;ltiplos programas est&atilde;o rodando em um &uacute;nico computador, &eacute; importante prevenir falhas em um dos programas de afetar negativamente outro. Estendendo&shy;se ao desenho com m&aacute;s&shy;inten&ccedil;&otilde;es mais do que a falha em si, isto tamb&eacute;m implica a <a href="http://en.wikipedia.org/wiki/Seguran%C3%A7a_de_computadores" id="w">seguran&ccedil;a</a>, quando &eacute; necess&aacute;rio impedir processos de acessar informa&ccedil;&otilde;es sem que lhes seja dada a devida permiss&atilde;o.</p>&#10;<p>As duas principais implementa&ccedil;&otilde;es via hardware<sup id="_ref&shy;Swift05_a" class="reference"><a href="#_note&shy;Swift05" title="">[18]</a></sup> para prote&ccedil;&atilde;o (de informa&ccedil;&otilde;es sens&iacute;veis) s&atilde;o <a href="http://en.wikipedia.org/wiki/Anel_(seguran%C3%A7a)" id="w">dom&iacute;nios hier&aacute;rquicos de prote&ccedil;&atilde;o</a> (tamb&eacute;m chamadas arquiteturas <a href="http://en.wikipedia.org/wiki/Anel_(seguran%C3%A7a)" id="w">anel</a>, arquiteturas de segmento ou <a href="http://en.wikipedia.org/wiki/Anel_(Seguran%C3%A7a)#Modo supervisor" id="w">modo supervisor</a>),<sup id="_ref&shy;19" class="reference"><a href="#_note&shy;19" title="">[19]</a></sup> e <a href="http://en.wikipedia.org/wiki/Endere%C3%A7amento_baseado_em_capacidades" id="w">endere&ccedil;amento baseado em capacidades</a>.<sup id="_ref&shy;20" class="reference"><a href="#_note&shy;20" title="">[20]</a></sup></p>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:Priv_rings.svg%7C250px%7Cthumb%7Cright%7C%5B%5Banel_de_privil%C3%A9gio%7Can%C3%A9is_de_privil%C3%A9gio%5D%5D%2C_como_na_%5B%5Bx86%5D%5D%2C_s%C3%A3o_uma_abordagem_habitual_de_%5B%5BAnel_(seguran%C3%A7a)" id="w">dom&iacute;nios hier&aacute;rquicos de prote&ccedil;&atilde;o]] usados em muitos sistemas comerciais para obter algum n&iacute;vel de toler&acirc;ncia a falhas.</a>&#10;Dom&iacute;nios hier&aacute;rquicos de prote&ccedil;&atilde;o s&atilde;o muito menos flex&iacute;veis, como no caso de qualquer n&uacute;cleo com uma estrutura hier&aacute;rquica presumida como um crit&eacute;rio de desenvolvimento global.<sup id="_ref&shy;Wulf74_f" class="reference"><a href="#_note&shy;Wulf74" title="">[1]</a></sup> No caso de prote&ccedil;&atilde;o n&atilde;o &eacute; poss&iacute;vel designar diferentes privil&eacute;gios a processos que n&atilde;o est&atilde;o no mesmo n&iacute;vel de privil&eacute;gio, e por isso n&atilde;o &eacute; poss&iacute;vel corresponder aos quatro princ&iacute;pios de <a href="http://en.wikipedia.org/wiki/Peter_J._Denning" id="w">Denning</a> para a toler&acirc;ncia a falhas,<sup id="_ref&shy;Denning76_b" class="reference"><a href="#_note&shy;Denning76" title="">[15]</a></sup><sup id="_ref&shy;Swift05Denning76_b" class="reference"><a href="#_note&shy;Swift05Denning76" title="">[16]</a></sup> particularmente o princ&iacute;pio do menor privil&eacute;gio. Dom&iacute;nios hier&aacute;rquicos de prote&ccedil;&atilde;o tamb&eacute;m carregam uma enorme desvantagem na performance, j&aacute; que a intera&ccedil;&atilde;o entre diferentes n&iacute;veis de prote&ccedil;&atilde;o, quando um processos tem que manipular uma estrutura de dados em ambos &#39&semi;modo usu&aacute;rio&#39&semi; e &#39&semi;modo supervisor&#39&semi;, sempre exige c&oacute;pia de mensagens (transmiss&atilde;o <a href="http://en.wikipedia.org/wiki/Estrat%C3%A9gia_de_avalia%C3%A7%C3%A3o#Chamada por valor" id="w">por valor</a>).<sup id="_ref&shy;Hansen73SupervisorMode_a" class="reference"><a href="#_note&shy;Hansen73SupervisorMode" title="">[21]</a></sup> Um n&uacute;cleo baseado em capacidades, no entanto, &eacute; mais flex&iacute;vel em designar privil&eacute;gios, pode corresponder aos princ&iacute;pios de Denning para a toler&acirc;ncia a falhas,<sup id="_ref&shy;LindenCapabilityAddressing_a" class="reference"><a href="#_note&shy;LindenCapabilityAddressing" title="">[22]</a></sup> e geralmente n&atilde;o sofrem de problemas de performance da c&oacute;pia por valor.</p>&#10;<p>Ambas implementa&ccedil;&otilde;es tipicamente exigem algum suporte de hardware ou firmware para serem oper&aacute;veis e eficientes. O suporte de hardware para dom&iacute;nios hier&aacute;rquicos de prote&ccedil;&atilde;o<sup id="_ref&shy;Schroeder72_a" class="reference"><a href="#_note&shy;Schroeder72" title="">[23]</a></sup> geralmente &eacute; de &#34&semi;<a href="http://en.wikipedia.org/wiki/Modos_de_CPU" id="w">modos de CPU</a>.&#34&semi; Um modo simples e eficiente de fornecer suporte a hardware &eacute; delegar &agrave; <a href="http://en.wikipedia.org/wiki/Unidade_de_gerenciamento_de_mem%C3%B3ria" id="w">unidade de gerenciamento de mem&oacute;ria</a> a responsabilidade por checar as permiss&otilde;es de acesso para todos acessos a mem&oacute;ria, um mecanismo chamado <a href="http://en.wikipedia.org/wiki/Endere%C3%A7amento_baseado_em_capacidades" id="w">endere&ccedil;amento baseado em capacidades</a>.<sup id="_ref&shy;LindenCapabilityAddressing_b" class="reference"><a href="#_note&shy;LindenCapabilityAddressing" title="">[22]</a></sup> Falta na maioria das arquiteturas comerciais, o suporte a MMU para capacidades.</p>&#10;<p>Uma abordagem alternativa &eacute; simular capacidades usando dom&iacute;nios hier&aacute;rquicos comumente suportados&semi; nesta abordagem, cada objeto protegido deve residir num espa&ccedil;o de endere&ccedil;amento ao qual o aplicativo n&atilde;o possui acesso&semi; o n&uacute;cleo tamb&eacute;m mant&eacute;m uma lista de capacidades em tal mem&oacute;ria. Quando um aplicativo precisa acessar um objeto protegido por uma capacidade, ele realiza uma chamada de sistema e o n&uacute;cleo realiza o acesso a ele. O custo de performance de trocar de espa&ccedil;o de endere&ccedil;amento limita a praticabilidade desta abordagem em sistemas com intera&ccedil;&otilde;es complexas entre objetos, mas &eacute; utilizado nos sistemas operativos atuais para objetos que n&atilde;o s&atilde;o acessados frequentemente ou que n&atilde;o devem ser feitos rapidamente.<sup id="_ref&shy;EranianMosberger_a" class="reference"><a href="#_note&shy;EranianMosberger" title="">[24]</a></sup><sup id="_ref&shy;25" class="reference"><a href="#_note&shy;25" title="">[25]</a></sup>&#10;Implementa&ccedil;&otilde;es onde os mecanismos de prote&ccedil;&atilde;o n&atilde;o suportados pelo firmware, mas s&atilde;o, ao inv&eacute;s disso, simulados em n&iacute;veos mais altos (ex. simulando capacidades ao manipular tabelas de p&aacute;ginas em hardware que n&atilde;o possui suporte direto), s&atilde;o poss&iacute;veis, mas h&aacute; implica&ccedil;&otilde;es de performance.<sup id="_ref&shy;HochBrowne_a" class="reference"><a href="#_note&shy;HochBrowne" title="">[26]</a></sup> No entanto, falta de suporte no hardware pode n&atilde;o ser problema, para sistemas que escolhem usar uma prote&ccedil;&atilde;o baseada em linguagem.<sup id="_ref&shy;Schneider_a" class="reference"><a href="#_note&shy;Schneider" title="">[27]</a></sup></p>&#10;<p>Uma decis&atilde;o importante no projeto do n&uacute;cleo &eacute; a escolha dos n&iacute;veis de abstra&ccedil;&atilde;o em que os mecanismos e pol&iacute;ticas de seguran&ccedil;a devem ser implementados. Os mecanismos de seguran&ccedil;a do n&uacute;cleo t&ecirc;m um papel cr&iacute;tico no suporte a seguran&ccedil;a nos n&iacute;veis superiores.<sup id="_ref&shy;LindenCapabilityAddressing_c" class="reference"><a href="#_note&shy;LindenCapabilityAddressing" title="">[22]</a></sup><sup id="_ref&shy;Loscocco98_a" class="reference"><a href="#_note&shy;Loscocco98" title="">[28]</a></sup><sup id="_ref&shy;29" class="reference"><a href="#_note&shy;29" title="">[29]</a></sup><sup id="_ref&shy;30" class="reference"><a href="#_note&shy;30" title="">[30]</a></sup><sup id="_ref&shy;31" class="reference"><a href="#_note&shy;31" title="">[31]</a></sup></p>&#10;<p>Uma abordagem &eacute; utilizar suporte no n&uacute;cleo e firmware para toler&acirc;ncia a falhas (ver acima), e montar as pol&iacute;ticas de seguran&ccedil;a para comportamento malicioso em cima disso (adicionando recursos como mecanismos de <a href="http://en.wikipedia.org/wiki/Criptografia" id="w">criptografia</a> quando necess&aacute;rio), delegar mais responsabilidade para o <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compilador</a>. Implementa&ccedil;&otilde;es que delegam a aplica&ccedil;&atilde;o de pol&iacute;ticas de seguran&ccedil;a para o compilador e/ou n&iacute;vel do aplicativo s&atilde;o geralmente chamados <i>seguran&ccedil;a baseada em linguagem</i>.</p>&#10;<p>A falta de muitos mecanismos cr&iacute;ticos de seguran&ccedil;a nos principais sistemas operativos impede a implementa&ccedil;&atilde;o adequada de pol&iacute;ticas de seguran&ccedil;a no <a href="http://en.wikipedia.org/wiki/N%C3%ADvel_de_abstra%C3%A7%C3%A3o" id="w">n&iacute;vel de abstra&ccedil;&atilde;o</a> do aplicativo.<sup id="_ref&shy;Loscocco98_b" class="reference"><a href="#_note&shy;Loscocco98" title="">[28]</a></sup> Na verdade, um engano muito comum na seguran&ccedil;a de computadores &eacute; que qualquer pol&iacute;tica de seguran&ccedil;a pode ser implementada no aplicativo, independentemente do suporte no n&uacute;cleo.<sup id="_ref&shy;Loscocco98_c" class="reference"><a href="#_note&shy;Loscocco98" title="">[28]</a></sup></p>&#10;<a id="Prote%C3%A7%C3%A3o_baseada_em_hardware_ou_linguagem" name="Prote%C3%A7%C3%A3o_baseada_em_hardware_ou_linguagem"></a><h4> Prote&ccedil;&atilde;o baseada em hardware ou linguagem </h4>&#10;<p>Hoje, t&iacute;picos sistemas de computa&ccedil;&atilde;o usam regras aplicadas pelo hardware sobre quais programas t&ecirc;m permiss&atilde;o para acessar quais dados. O processador monitora a execu&ccedil;&atilde;o e desliga um programa que viole uma regra (ex., um processo de usu&aacute;rio que tenta ler ou escrever na mem&oacute;ria do n&uacute;cleo, e assim por diante). Em sistemas que n&atilde;o possuem suporte para capacidades, processos s&atilde;o isolados um do outro, utilizando&shy;se espa&ccedil;os de endere&ccedil;amento separados.<sup id="_ref&shy;32" class="reference"><a href="#_note&shy;32" title="">[32]</a></sup> Chamadas de um processo de usu&aacute;rio no n&uacute;cleo s&atilde;o regidas pela exig&ecirc;ncia de que eles usem um dos m&eacute;todos de chamada do sistema descritos acima.</p>&#10;<p>Uma abordagem alternativa &eacute; usar prote&ccedil;&atilde;o baseada em linguagem. Em um <a href="http://en.wikipedia.org/wiki/Sistemas_baseado_em_linguagem" id="w">sistema de prote&ccedil;&atilde;o baseado em linguagem</a>, o n&uacute;cleo vai permitir a execu&ccedil;&atilde;o apenas de c&oacute;digo produzido por um <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compilador</a> em que ele confie. A linguagem pode ent&atilde;o, ser projetada de modo tal que ser&aacute; imposs&iacute;vel para o programador instruir algo que violaria os requisitos de seguran&ccedil;a.<sup id="_ref&shy;Schneider_b" class="reference"><a href="#_note&shy;Schneider" title="">[27]</a></sup></p>&#10;<p>Desvantagens incluem:&#10;</p>&#10;<ul>&#10;<li>Demora maior para a inicializa&ccedil;&atilde;o efetiva do aplicativo. Aplicativos deve ser verificadas sempre que elas s&atilde;o iniciadas para garantir que eles foram compiladas utilizando um compilador &#34&semi;corret&#34&semi;, ou podem necessitar de recompila&ccedil;&atilde;o de ambos <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_fonte" id="w">c&oacute;digo fonte</a> ou <a href="http://en.wikipedia.org/wiki/Bytecode" id="w">bytecode</a>.</li>&#10;<li>Sistema s de tipo inflex&iacute;vel. Em sistemas tradicionais, aplicativos realizam frequentemente opera&ccedil;&otilde;es que n&atilde;o s&atilde;o de <a href="http://en.wikipedia.org/wiki/Tipagem_forte" id="w">tipagem forte</a>. Tais opera&ccedil;&otilde;es  n&atilde;o podem ser permitidas em um sistema de prote&ccedil;&atilde;o baseado em linguagem, o que significa que aplicativos podem precisar ser reescritos e podem, em alguns casos, perder performance.</li></ul>&#10;<p>Vantagens desta abordagem incluem:&#10;</p>&#10;<ul>&#10;<li>Separa&ccedil;&atilde;o de espa&ccedil;os de endere&ccedil;amento desnecess&aacute;ria. A troca de espa&ccedil;os de endere&ccedil;amento &eacute; uma opera&ccedil;&atilde;o lenta que causa grande degrada&ccedil;&atilde;o na performance, e muito trabalho de otimiza&ccedil;&atilde;o &eacute; feito atualmente para prevenir trocar desnecess&aacute;rias nos sistemas operativos. Trocar &eacute; complemente desnecess&aacute;rio em um sistema de prote&ccedil;&atilde;o baseada em linguagem, j&aacute; que todo c&oacute;digo opera no mesmo espa&ccedil;o de endere&ccedil;amento.</li>&#10;<li>Flexibilidade. Qualquer esquema de prote&ccedil;&atilde;o que possa ser desenvolvida para ser expresso atrav&eacute;s de linguagem de programa&ccedil;&atilde;o pode ser implementada atrav&eacute;s deste m&eacute;todo. Mudan&ccedil;as no esquema de prote&ccedil;&atilde;o (ex. de um sistema hier&aacute;rquico para um baseado em capacidades) n&atilde;o exigem novo hardware.</li></ul>&#10;<p>Exemplos de sistemas com prote&ccedil;&atilde;o baseada em linguagem incluem o <a href="http://en.wikipedia.org/wiki/JX" id="w">JX</a> e <a href="http://en.wikipedia.org/wiki/Singularity" id="w">Singularity</a>.</p>&#10;<a id="Coopera%C3%A7%C3%A3o_de_processos" name="Coopera%C3%A7%C3%A3o_de_processos"></a><h3> Coopera&ccedil;&atilde;o de processos </h3>&#10;<p><a href="http://en.wikipedia.org/wiki/Edsger_Dijkstra" id="w">Edsger Dijkstra</a> provou que partindo de um ponto de vista l&oacute;gico, opera&ccedil;&otilde;es <a href="http://en.wikipedia.org/wiki/Atomicidade" id="w">at&ocirc;micas</a> de <a href="http://en.wikipedia.org/wiki/Trava_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">travamento</a> e destravamento operando em <a href="http://en.wikipedia.org/wiki/Sem%C3%A1foro_(computa%C3%A7%C3%A3o)" id="w">sem&aacute;foros</a> bin&aacute;rios s&atilde;o suficientemente primitivos para expressar a qualquer funcionalidade de coopera&ccedil;&atilde;o entre processos.<sup id="_ref&shy;Dijkstra65_a" class="reference"><a href="#_note&shy;Dijkstra65" title="">[33]</a></sup> No entanto esta abordagem &eacute; geralmente tomada como deficiente em termos de seguran&ccedil;a e efici&ecirc;ncia, enquanto que uma abordagem via <a href="http://en.wikipedia.org/wiki/Troca_de_mensagens" id="w">troca de mensagens</a> &eacute; mais flex&iacute;vel.<sup id="_ref&shy;Hansen70_c" class="reference"><a href="#_note&shy;Hansen70" title="">[7]</a></sup></p>&#10;<a id="Gerenciamento_de_dispositivos_de_entrada/sa%C3%ADda" name="Gerenciamento_de_dispositivos_de_entrada/sa%C3%ADda"></a><h3> Gerenciamento de dispositivos de entrada/sa&iacute;da </h3>&#10;<p>A ideia de um n&uacute;cleo onde dispositivos de entrada/sa&iacute;da s&atilde;o gerenciados uniformemente com outros processos, como processos paralelos em coopera&ccedil;&atilde;o, foi proposta e implementada primeiramente por <a href="http://en.wikipedia.org/wiki/Brinch_Hansen" id="w">Brinch Hansen</a> (embora ideias similares tenham sido sugeridas em 1967<sup id="_ref&shy;34" class="reference"><a href="#_note&shy;34" title="">[34]</a></sup><sup id="_ref&shy;35" class="reference"><a href="#_note&shy;35" title="">[35]</a></sup>). Na descri&ccedil;&atilde;o de Hansen disto, os processos &#34&semi;comuns&#34&semi; s&atilde;o chamados <i>processos internos</i>, enquanto que os dispositivos de entrada/sa&iacute;da s&atilde;o chamados <i>processos externos</i>.<sup id="_ref&shy;Hansen70_d" class="reference"><a href="#_note&shy;Hansen70" title="">[7]</a></sup></p>&#10;<a id="Abordagens_de_desenvolvimento_de_todo_o_n%C3%BAcleo" name="Abordagens_de_desenvolvimento_de_todo_o_n%C3%BAcleo"></a><h2> Abordagens de desenvolvimento de todo o n&uacute;cleo </h2>&#10;<p>Naturalmente, as tarefas e recursos listados acima podem ser fornecidas de v&aacute;rios modos que diferem entre si em projeto e implementa&ccedil;&atilde;o.</p>&#10;<p>O princ&iacute;pio da <i><a href="http://en.wikipedia.org/wiki/Separa%C3%A7%C3%A3o_entre_mecanismo_e_pol%C3%ADtica" id="w">separa&ccedil;&atilde;o entre o mecanismo e a pol&iacute;tica</a></i> &eacute; a diferen&ccedil;a substancial entre a filosofia de micron&uacute;cleo e n&uacute;cleo monol&iacute;tico.<sup id="_ref&shy;36" class="reference"><a href="#_note&shy;36" title="">[36]</a></sup><sup id="_ref&shy;Levin75_a" class="reference"><a href="#_note&shy;Levin75" title="">[37]</a></sup> Aqui um <i>mecanismo</i> &eacute; o apoio que permite a implementa&ccedil;&atilde;o de v&aacute;rias pol&iacute;ticas diferentes, enquanto uma pol&iacute;tica &eacute; um &#34&semi;modo de opera&ccedil;&atilde;o&#34&semi; particular. Por exemplo, uma mecanismo pode oferecer &agrave;s tentativas de entrada de um usu&aacute;rio um m&eacute;todo de chamar um servidor de autoriza&ccedil;&atilde;o para determinar se um acesso deve ser dado&semi; uma pol&iacute;tica pode ser para o servidor de autoriza&ccedil;&atilde;o exigir uma senha e chec&aacute;&shy;la contra uma senha <a href="http://en.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_de_embaralhamento_criptogr%C3%A1fico" id="w">embaralhada</a> armazenada numa base de dados. Devido ao fato do mecanismo ser gen&eacute;rico, a pol&iacute;tica pode ser alterada com mais facilidade (ex. ao exigir o uso de um <a href="http://en.wikipedia.org/wiki/Token_(chave_eletr%C3%B4nica)" id="w">passe</a>) do que se um mecanismo e pol&iacute;tica fossem integrados no mesmo m&oacute;dulo.</p>&#10;<p>Em um micron&uacute;cleo m&iacute;nimo algumas pol&iacute;ticas b&aacute;sicas s&atilde;o inclu&iacute;das,<sup id="_ref&shy;Levin75_b" class="reference"><a href="#_note&shy;Levin75" title="">[37]</a></sup> e seus mecanismos permite que o que est&aacute; rodando sobre o n&uacute;cleo (a parte remanescente do sistema operativo e outras aplica&ccedil;&otilde;es) decida quais pol&iacute;ticas adotar (como gerenciamento de mem&oacute;ria, escalonamento de processo de alto n&iacute;vel, gerenciamento de sistema de arquivos, etc.).<sup id="_ref&shy;Wulf74_g" class="reference"><a href="#_note&shy;Wulf74" title="">[1]</a></sup><sup id="_ref&shy;Hansen70_e" class="reference"><a href="#_note&shy;Hansen70" title="">[7]</a></sup> Um n&uacute;cleo monol&iacute;tico ao inv&eacute;s disso, tende a incluir v&aacute;rias pol&iacute;ticas, ent&atilde;o restringindo o resto do sistema dependente delas.</p>&#10;<p><a href="http://en.wikipedia.org/wiki/Per_Brinch_Hansen" id="w">Per Brinch Hansen</a> apresentou um argumento <a href="http://en.wikipedia.org/wiki/Convic%C3%A7%C3%A3o" id="w">convincente</a> a favor da separa&ccedil;&atilde;o do mecanismo e da pol&iacute;tica.<sup id="_ref&shy;Wulf74_h" class="reference"><a href="#_note&shy;Wulf74" title="">[1]</a></sup><sup id="_ref&shy;Hansen70_f" class="reference"><a href="#_note&shy;Hansen70" title="">[7]</a></sup> A falha em preencher completamente esta separa&ccedil;&atilde;o, &eacute; uma das maiores causas para a falta de inova&ccedil;&atilde;o nos sistemas operativos existentes atualmente,<sup id="_ref&shy;Wulf74_i" class="reference"><a href="#_note&shy;Wulf74" title="">[1]</a></sup> um problema comum nas arquiteturas de computador.<sup id="_ref&shy;Denning80_a" class="reference"><a href="#_note&shy;Denning80" title="">[38]</a></sup><sup id="_ref&shy;Nehmer91_a" class="reference"><a href="#_note&shy;Nehmer91" title="">[39]</a></sup><sup id="_ref&shy;40" class="reference"><a href="#_note&shy;40" title="">[40]</a></sup> O projeto monol&iacute;tico &eacute; induzido pela abordagem de arquitetura &#34&semi;modo n&uacute;cleo&#34&semi;/&#34&semi;modo usu&aacute;rio&#34&semi; para prote&ccedil;&atilde;o (tecnicamente chamada de <a href="http://en.wikipedia.org/wiki/Anel_(seguran%C3%A7a)" id="w">dom&iacute;nios hier&aacute;rquicos de prote&ccedil;&atilde;o</a>), que &eacute; comum em sistemas comercias convencionais&semi;<sup id="_ref&shy;Levy84privilegedmode_a" class="reference"><a href="#_note&shy;Levy84privilegedmode" title="">[41]</a></sup> na verdade, todo m&oacute;dulo que necessite de prote&ccedil;&atilde;o &eacute; portanto preferivelmente inclu&iacute;do no n&uacute;cleo.<sup id="_ref&shy;Levy84privilegedmode_b" class="reference"><a href="#_note&shy;Levy84privilegedmode" title="">[41]</a></sup> Esta liga&ccedil;&atilde;o entre projeto e &#34&semi;modo privilegiado&#34&semi; pode ser reconduzida at&eacute; o problema chave da separa&ccedil;&atilde;o do mecanismo e da pol&iacute;tica&semi;<sup id="_ref&shy;Wulf74_j" class="reference"><a href="#_note&shy;Wulf74" title="">[1]</a></sup> de fato, a abordagem de arquitetura de &#34&semi;modo privilegiado&#34&semi; se funde ao mecanismo de prote&ccedil;&atilde;o com as pol&iacute;ticas de seguran&ccedil;a, enquanto a principal abordagem de arquitetura alternativa , <a href="http://en.wikipedia.org/wiki/Endere%C3%A7amento_baseado_em_capacidades" id="w">endere&ccedil;amento baseado em capacidades</a>, claramente distingue ambos, levando naturalmente ao desenvolvimento de um micron&uacute;cleo design<sup id="_ref&shy;Wulf74_k" class="reference"><a href="#_note&shy;Wulf74" title="">[1]</a></sup>(veja <a href="http://en.wikipedia.org/wiki/Separa%C3%A7%C3%A3o_entre_prote%C3%A7%C3%A3o_e_seguran%C3%A7a" id="w">Separa&ccedil;&atilde;o entre prote&ccedil;&atilde;o e seguran&ccedil;a</a>).</p>&#10;<p>Enquanto <a href="http://en.wikipedia.org/wiki/N%C3%BAcleo_monol%C3%ADtico" id="w">n&uacute;cleos monol&iacute;ticos</a> executam todo seu c&oacute;digo no mesmo espa&ccedil;o de endere&ccedil;amento (<a href="http://en.wikipedia.org/wiki/Espa%C3%A7o_de_n%C3%BAcleo" id="w">espa&ccedil;o de n&uacute;cleo</a>) <a href="http://en.wikipedia.org/wiki/Micron%C3%BAcleo_(inform%C3%A1tica)" id="w">micron&uacute;cleos</a> tentam executar a maior parte dos seus servi&ccedil;os no espa&ccedil;o de usu&aacute;rio, buscando aprimorar a manuten&ccedil;&atilde;o e modulabilidade do c&oacute;digo base.<sup id="_ref&shy;mono&shy;micro_b" class="reference"><a href="#_note&shy;mono&shy;micro" title="">[2]</a></sup> A maioria dos n&uacute;cleos n&atilde;o se encaixa exatamente em uma destas categorias, sendo mais encontrados entre estes dois projetos. Os chamados <a href="http://en.wikipedia.org/wiki/N%C3%BAcleo_h%C3%ADbrido" id="w">n&uacute;cleos h&iacute;bridos</a>. Projetos mais ex&oacute;ticos como <a href="http://en.wikipedia.org/wiki/Nanon%C3%BAcleo" id="w">nanon&uacute;cleos</a> e <a href="http://en.wikipedia.org/wiki/Exon%C3%BAcleo" id="w">exon&uacute;cleos</a> est&atilde;o dispon&iacute;veis, mas s&atilde;o usados raramente utilizado para sistemas produtivos. O virtualizador <a href="http://en.wikipedia.org/wiki/Xen" id="w">Xen</a>, por exemplo, &eacute; um exon&uacute;cleo.</p>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:Kernel&shy;monolithic.svg%7Cthumb%7C260px" id="w">Diagrama de n&uacute;cleos monol&iacute;ticos.</a></p>&#10;<a id="N%C3%BAcleos_monol%C3%ADticos" name="N%C3%BAcleos_monol%C3%ADticos"></a><h3> N&uacute;cleos monol&iacute;ticos </h3>&#10;<p> </p>&#10;<p>Em um n&uacute;cleo monol&iacute;tico, todos os servi&ccedil;os do sistema operativo rodam junto com a linha de execu&ccedil;&atilde;o principal do n&uacute;cleo, portanto, tamb&eacute;m se encontram na mesma &aacute;rea de mem&oacute;ria. Esta abordagem permite o acesso vasto e poderoso de hardwares. Alguns desenvolvedores, como desenvolvedor do UNIX Ken Thompson, defendem que &eacute; &#34&semi;mais f&aacute;cil de implementar um n&uacute;cleo monol&iacute;tico&#34&semi;<sup id="_ref&shy;Linuxisobsoletedebate_a" class="reference"><a href="#_note&shy;Linuxisobsoletedebate" title="">[42]</a></sup> que micron&uacute;cleos. As principais desvantagens de n&uacute;cleos monol&iacute;ticos s&atilde;o as depend&ecirc;ncias entre os componentes do sistema &shy; um defeito em um driver de dispositivo pode paralisar todo o sistema &shy; e o fato de n&uacute;cleos grandes podem se tornar muito dif&iacute;ceis de manter.</p>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:Kernel&shy;microkernel.svg%7Cthumb%7C260px%7CNa_abordagem_do_%5B%5Bmicron%C3%BAcleo_(inform%C3%A1tica)%7Cmicron%C3%BAcleo%5D%5D%2C_o_pr%C3%B3prio_n%C3%BAcleo_fornece_apenas_funcionalidades_b%C3%A1sicas_que_permite_a_execu%C3%A7%C3%A3o_de_%5B%5BCliente&shy;servidor" id="w">servidores]], programas separados que assumem fun&ccedil;&otilde;es que seriam do n&uacute;cleo monol&iacute;tico, como drivers de dispositivos, servidores de interface de usu&aacute;rio, etc.</a></p>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Berkeley_Software_Distribution" id="w">BSD</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Linux_(n%C3%BAcleo)" id="w">Linux</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/MS&shy;DOS" id="w">MS&shy;DOS</a> e derivados, incluindo <a href="http://en.wikipedia.org/wiki/Windows_95" id="w">Windows 95</a>, <a href="http://en.wikipedia.org/wiki/Windows_98" id="w">Windows 98</a> e <a href="http://en.wikipedia.org/wiki/Windows_ME" id="w">Windows ME</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Solaris" id="w">Solaris</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Palm_OS" id="w">Palm OS</a></li></ul>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:Kernel&shy;microkernel.svg%7Cthumb%7Cright" id="w">Diagrama de intera&ccedil;&atilde;o de um micron&uacute;cleo.</a></p>&#10;<a id="Micron%C3%BAcleos" name="Micron%C3%BAcleos"></a><h3> Micron&uacute;cleos </h3>&#10;<p> </p>&#10;<p>A abordagem de micron&uacute;cleo consiste em definir abstra&ccedil;&otilde;es simples sobre o hardware, com um conjunto de primitivos ou <a href="http://en.wikipedia.org/wiki/Chamada_de_sistema" id="w">chamadas de sistema</a> para implementar servi&ccedil;os m&iacute;nimos do sistema operativo como <a href="http://en.wikipedia.org/wiki/Gerenciamento_de_mem%C3%B3ria" id="w">gerenciamento de mem&oacute;ria</a>, <a href="http://en.wikipedia.org/wiki/Multitarefas" id="w">multitarefas</a>, e <a href="http://en.wikipedia.org/wiki/Comunica%C3%A7%C3%A3o_entre_processos" id="w">comunica&ccedil;&atilde;o entre processos</a>. Outros servi&ccedil;os, incluindo aqueles normalmente fornecidos por um n&uacute;cleo monol&iacute;tico como <a href="http://en.wikipedia.org/wiki/Rede_de_computadores" id="w">rede</a>, s&atilde;o implementados em programas de espa&ccedil;o de usu&aacute;rio, conhecidos como <i>servidores</i>. Micron&uacute;cleos s&atilde;o mais f&aacute;ceis de manter do n&uacute;cleos monol&iacute;ticos, mas um grande n&uacute;mero de chamadas de sistemas de <a href="http://en.wikipedia.org/wiki/Troca_de_contexto" id="w">trocas de contexto</a> podem desacelerar o sistema por que eles geralmente geram mais degrada&ccedil;&atilde;o na performance do que simples chamadas de fun&ccedil;&atilde;o.</p>&#10;<p>Um micron&uacute;cleo permite a implementa&ccedil;&atilde;o das partes restantes do sistema operativo como aplicativos normais escritos em <a href="http://en.wikipedia.org/wiki/Linguagem_de_alto_n%C3%ADvel" id="w">linguagem de alto n&iacute;vel</a>, e o uso de diferentes sistemas operativos sobre o mesmo n&uacute;cleo n&atilde;o&shy;modificado.<sup id="_ref&shy;Hansen70_g" class="reference"><a href="#_note&shy;Hansen70" title="">[7]</a></sup> Ele tamb&eacute;m torna poss&iacute;vel alternar dinamicamente entre sistemas operativos e manter mais de um deles ativos simultaneamente.<sup id="_ref&shy;Hansen70_h" class="reference"><a href="#_note&shy;Hansen70" title="">[7]</a></sup></p>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Hurd" id="w">Hurd</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/MINIX" id="w">MINIX</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Mach" id="w">Mach</a></li></ul>&#10;<a id="N%C3%BAcleos_monol%C3%ADticos_x_micron%C3%BAcleos" name="N%C3%BAcleos_monol%C3%ADticos_x_micron%C3%BAcleos"></a><h3> N&uacute;cleos monol&iacute;ticos x micron&uacute;cleos </h3>&#10;<p>Conforme o n&uacute;cleo do computador crescem, um n&uacute;mero de problemas se tornam evidentes. Um dos mais &oacute;bvios &eacute; que o <a href="http://en.wikipedia.org/wiki/Espa%C3%A7o_de_mem%C3%B3ria" id="w">espa&ccedil;o de mem&oacute;ria</a> aumenta. Isto &eacute; mitigado de certo modo ao aperfei&ccedil;oar o sistema de <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_virtual" id="w">mem&oacute;ria virtual</a>, mas nem todas <a href="http://en.wikipedia.org/wiki/Arquitetura_de_computador" id="w">arquitetura de computador</a> suportam mem&oacute;rias virtuais.<sup id="_ref&shy;43" class="reference"><a href="#_note&shy;43" title="">[43]</a></sup> Para reduzir o espa&ccedil;o utilizado pelo n&uacute;cleo, modifica&ccedil;&otilde;es extensivas precisam ser realizadas para remover cuidadosamente c&oacute;digo in&uacute;til, que pode ser muito dif&iacute;cil devido a depend&ecirc;ncias pouco aparentes entre partes de um n&uacute;cleo com milh&otilde;es de linhas de c&oacute;digo.</p>&#10;<p>Pelo come&ccedil;o dos anos 1990, devido a v&aacute;rios problemas de n&uacute;cleos monol&iacute;ticos em compara&ccedil;&atilde;o a micron&uacute;cleos, n&uacute;cleos monol&iacute;ticos foram considerados obsoletos por virtualmente todos pesquisadores de sistemas operativos. Como resultado, o projeto do <a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a>, um n&uacute;cleo monol&iacute;tico mais do que um micron&uacute;cleo foi o t&oacute;pico da famosa discuss&atilde;o <a href="http://en.wikipedia.org/wiki/Flamming" id="w">inflamada</a> entre <a href="http://en.wikipedia.org/wiki/Linus_Torvalds" id="w">Linus Torvalds</a> e <a href="http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum" id="w">Andrew Tanenbaum</a>.<sup id="_ref&shy;TorvaldsTanenbaum_a" class="reference"><a href="#_note&shy;TorvaldsTanenbaum" title="">[44]</a></sup> H&aacute; m&eacute;ritos em ambos argumentos presentes no <a href="http://en.wikipedia.org/wiki/Debate_entre_Tanenbaum_e_Torvalds" id="w">debate Tanenbaum&ndash;Torvalds</a>.</p>&#10;<a id="Performances" name="Performances"></a><h4> Performances </h4>&#10;<p><a href="http://en.wikipedia.org/wiki/N%C3%BAcleo_monol%C3%ADtico" id="w">N&uacute;cleos monol&iacute;ticos</a> s&atilde;o projetados para que todo o seu c&oacute;digo fique no mesmo espa&ccedil;o de endere&ccedil;amento (<a href="http://en.wikipedia.org/wiki/Espa%C3%A7o_de_n%C3%BAcleo" id="w">espa&ccedil;o de n&uacute;cleo</a>), que alguns desenvolvedores argumentam ser necess&aacute;rio para aumentar a performance do sistema.<sup id="_ref&shy;MatthewRussell_a" class="reference"><a href="#_note&shy;MatthewRussell" title="">[45]</a></sup> Alguns desenvolvedores tamb&eacute;m sustentam a hip&oacute;tese de que n&uacute;cleos monol&iacute;ticos s&atilde;o extremamente eficientes se forem bem escritos.<sup id="_ref&shy;MatthewRussell_b" class="reference"><a href="#_note&shy;MatthewRussell" title="">[45]</a></sup> </p>&#10;<p>A performance de micron&uacute;cleos constru&iacute;dos nos anos 1980 e come&ccedil;os dos 1990 era terr&iacute;vel.<sup id="_ref&shy;Liedtke95_b" class="reference"><a href="#_note&shy;Liedtke95" title="">[3]</a></sup><sup id="_ref&shy;Hartig97_a" class="reference"><a href="#_note&shy;Hartig97" title="">[46]</a></sup> Estudos emp&iacute;ricos que mediram a performance destes micron&uacute;cleos n&atilde;o analisaram os motivos para tal inefici&ecirc;ncia .<sup id="_ref&shy;Liedtke95_c" class="reference"><a href="#_note&shy;Liedtke95" title="">[3]</a></sup> As explica&ccedil;&otilde;es para estes dados foram deixadas para o &#34&semi;folclore&#34&semi; , com a suposi&ccedil;&atilde;o de que eles eram devido ao aumento da frequ&ecirc;ncia da troca de modo n&uacute;cleo para modo usu&aacute;rio,<sup id="_ref&shy;Liedtke95_d" class="reference"><a href="#_note&shy;Liedtke95" title="">[3]</a></sup> devido a maior frequ&ecirc;ncia de <a href="http://en.wikipedia.org/wiki/Comunica%C3%A7%C3%A3o_entre_processos" id="w">comunica&ccedil;&atilde;o entre processos</a><sup id="_ref&shy;Liedtke95_e" class="reference"><a href="#_note&shy;Liedtke95" title="">[3]</a></sup> e a maioria frequ&ecirc;ncia de <a href="http://en.wikipedia.org/wiki/Troca_de_contexto" id="w">trocas de contexto</a>.<sup id="_ref&shy;Liedtke95_f" class="reference"><a href="#_note&shy;Liedtke95" title="">[3]</a></sup></p>&#10;<p>De fato, como foi conjeturado em 1995, os motivos para a terr&iacute;vel performance dos micron&uacute;cleos pode tamb&eacute;m ter sido: (1) uma real inefici&ecirc;ncia na implementa&ccedil;&atilde;o de toda a <i>abordagem</i> de micron&uacute;cleo, (2) <i>conceitos</i> particulares implementados nesses micron&uacute;cleos, e (3) a <i>implementa&ccedil;&atilde;o</i> individual destes conceitos.<sup id="_ref&shy;Liedtke95_g" class="reference"><a href="#_note&shy;Liedtke95" title="">[3]</a></sup> Portanto ainda falta estudar se a solu&ccedil;&atilde;o para construir um micron&uacute;cleo eficiente foi, ao contr&aacute;rio de tentativas anteriores, a de aplicar as t&eacute;cnicas corretas de constru&ccedil;&atilde;o.<sup id="_ref&shy;Liedtke95_h" class="reference"><a href="#_note&shy;Liedtke95" title="">[3]</a></sup></p>&#10;<p>No outro extremo, a arquitetura de <a href="http://en.wikipedia.org/wiki/Anel_(seguran%C3%A7a" id="w">dom&iacute;nios hier&aacute;rquicos de prote&ccedil;&atilde;o</a> que leva a um projeto de n&uacute;cleo monol&iacute;tico<sup id="_ref&shy;Levy84privilegedmode_c" class="reference"><a href="#_note&shy;Levy84privilegedmode" title="">[41]</a></sup> gera impactos significativos na performance cada vez que h&aacute; uma intera&ccedil;&atilde;o entre diferentes n&iacute;veis de prote&ccedil;&atilde;o (ex. quando um processo tem que manipular uma estrutura de dados em ambos &#39&semi;modo usu&aacute;rio&#39&semi; e &#39&semi;modo supervisor&#39&semi;), desde que isto exija c&oacute;pia de mensagem <a href="http://en.wikipedia.org/wiki/Estrat%C3%A9gia_de_avalia%C3%A7%C3%A3o#Chamada por valor" id="w">por valor</a>.<sup id="_ref&shy;Hansen73SupervisorMode_b" class="reference"><a href="#_note&shy;Hansen73SupervisorMode" title="">[21]</a></sup></p>&#10;<p>Em meados de 1990, a maioria dos pesquisadores abandonou a cren&ccedil;a de que ajustes cuidadosos poderiam reduzir estes impactos dramaticamente,  mas recentemente, novos micron&uacute;cleos, otimizados para performance, tais como os <a href="http://en.wikipedia.org/wiki/N%C3%BAcleo_L4" id="w">L4</a><sup id="_ref&shy;l4_a" class="reference"><a href="#_note&shy;l4" title="">[47]</a></sup> e <a href="http://en.wikipedia.org/wiki/K42" id="w">K42</a> v&ecirc;m trabalhando nestes problemas. </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:Kernel&shy;hybrid.svg%7Cthumb%7C260px" id="w">A abordagem de [[n&uacute;cleo h&iacute;brido]] combina velocidade e projetos mais simples de um n&uacute;cleo monol&iacute;tico com a modularidade e execu&ccedil;&atilde;o segura de um micron&uacute;cleo.</a></p>&#10;<a id="N%C3%BAcleos_h%C3%ADbridos" name="N%C3%BAcleos_h%C3%ADbridos"></a><h3> N&uacute;cleos h&iacute;bridos </h3>&#10;<p> </p>&#10;<p>N&uacute;cleos h&iacute;bridos s&atilde;o um acordo entre o desenvolvimento de micron&uacute;cleos e n&uacute;cleos monol&iacute;ticos. Isto implica executar alguns servi&ccedil;os (como a <a href="http://en.wikipedia.org/wiki/Pilha_de_rede" id="w">pilha de rede</a> ou o <a href="http://en.wikipedia.org/wiki/Sistema_de_arquivos" id="w">sistema de arquivos</a>) no espa&ccedil;o do n&uacute;cleo para reduzir o impacto na performance  de um micron&uacute;cleo tradicional, mas ainda executar o c&oacute;digo no n&uacute;cleo (como drivers de dispositivos) como servidores no espa&ccedil;o de usu&aacute;rio.</p>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/BeOS" id="w">BeOS</a> / <a href="http://en.wikipedia.org/wiki/Haiku_(sistema_operacional)" id="w">Haiku</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Windows_NT" id="w">Microsoft Windows NT</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/XNU" id="w">XNU</a> (n&uacute;cleo do <a href="http://en.wikipedia.org/wiki/Darwin_(sistema_operativo)" id="w">Darwin</a> utilizado no <a href="http://en.wikipedia.org/wiki/Mac_OS_X" id="w">Mac OS X</a>)</li></ul>&#10;<a id="Nanon%C3%BAcleos" name="Nanon%C3%BAcleos"></a><h3> Nanon&uacute;cleos </h3>&#10;<p> </p>&#10;<p>Um nanon&uacute;cleo delega virtualmente todos os servi&ccedil;os &mdash; incluindo at&eacute; os mais b&aacute;sicos como <a href="http://en.wikipedia.org/wiki/Controlador_de_interrup%C3%A7%C3%A3o_programada" id="w">controlador de interrup&ccedil;&otilde;es</a> ou o <a href="http://en.wikipedia.org/wiki/Temporizador" id="w">temporizador</a> &mdash; para <a href="http://en.wikipedia.org/wiki/Driver_de_dispositivo" id="w">drivers de dispositivo</a> para tornar o requerimento de mem&oacute;ria do n&uacute;cleo ainda menor do que o dos tradicionais micron&uacute;cleos.<sup id="_ref&shy;48" class="reference"><a href="#_note&shy;48" title="">[48]</a></sup></p>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Adaptive_Domain_Environment_for_Operating_Systems" id="w">Adeos</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Dycos" id="w">Dycos</a> <a class="externallink" href="http://www13.informatik.tu&shy;muenchen.de/forschung/modis/dycos/" rel="nofollow" title="http://www13.informatik.tu&shy;muenchen.de/forschung/modis/dycos/">http://www13.informatik.tu&shy;muenchen.de/forschung/modis/dycos/</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/EROS" id="w">EROS</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/EKA2" id="w">EKA2</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Jari_Operating_System" id="w">Jari Operating System</a> <a class="externallink" href="http://jarios.org/" rel="nofollow" title="http://jarios.org/">http://jarios.org/</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/JNode" id="w">JNode</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/KeyKOS" id="w">KeyKOS</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/LSE/OS" id="w">LSE/OS</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Mac_OS_nanon%C3%BAcleo" id="w">Mac OS nanon&uacute;cleo</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/OZONE" id="w">OZONE</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Trion_Operating_System" id="w">Trion Operating System</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/XtratuM" id="w">XtratuM</a> <a class="externallink" href="http://www.xtratum.org/" rel="nofollow" title="http://www.xtratum.org/">http://www.xtratum.org/</a></li></ul>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:Kernel&shy;exo.svg%7Cthumb%7Cright" id="w">Diagrama de intera&ccedil;&atilde;o de um exon&uacute;cleo.</a></p>&#10;<a id="Exon%C3%BAcleos" name="Exon%C3%BAcleos"></a><h3> Exon&uacute;cleos </h3>&#10;<p> </p>&#10;<p>Um exon&uacute;cleo &eacute; um tipo de n&uacute;cleo que n&atilde;o abstrai hardware in modelos te&oacute;ricos. Ao inv&eacute;s disso ele aloca recursos f&iacute;sicos de hardware, como o tempo de um processador, p&aacute;ginas de mem&oacute;ria, e blocos de disco, para diferentes programas. Um programa rodando em um exon&uacute;cleo pode ligar para uma <i>biblioteca do sistema operativo</i> que usa o exon&uacute;cleo para simular as astra&ccedil;&otilde;es de um sistema operativo conhecido, ou ele pode desenvolver abstra&ccedil;&otilde;es espec&iacute;ficas para aquele aplicativo para ume performance superior.<sup id="_ref&shy;49" class="reference"><a href="#_note&shy;49" title="">[49]</a></sup></p>&#10;<a id="Hist%C3%B3ria_do_desenvolvimento_do_n%C3%BAcleo" name="Hist%C3%B3ria_do_desenvolvimento_do_n%C3%BAcleo"></a><h2> Hist&oacute;ria do desenvolvimento do n&uacute;cleo </h2>&#10;<a id="N%C3%BAcleos_dos_primeiros_sistemas_operativos" name="N%C3%BAcleos_dos_primeiros_sistemas_operativos"></a><h3> N&uacute;cleos dos primeiros sistemas operativos </h3>&#10;<p> </p>&#10;<p>Falando estritamente, um sistema operativo (e, isto inclui um n&uacute;cleo) n&atilde;o &eacute; <i>obrigado</i> a rodar um computador. Programas podem ser carregados diretamente e executados na m&aacute;quina de &#34&semi;metal descoberto&#34&semi;, desde que os autores destes programas estiverem dispostos a trabalhar sem nenuma abstra&ccedil;&atilde;o de hardware ou suporte a sistema operativo. Os primeiros computadores operaram deste maneira durante os anos de 1950, come&ccedil;o dos 1960, eram reiniciados e recarregados entre cada execu&ccedil;&atilde;o de diferentes programas. Eventualmente, pequenos programas auxiliares como <a href="http://en.wikipedia.org/wiki/Carregador_de_programa" id="w">carregadores de programas</a> e <a href="http://en.wikipedia.org/wiki/Depurador" id="w">depuradores</a> foram mantidos na mem&oacute;ria entre as execu&ccedil;&otilde;es, ou carregados de <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_somente_de_leitura" id="w">mem&oacute;ria somente de leitura</a> . Conforme estas eram desenvolvidas, elas formaram a base do que depois se tornaria o n&uacute;cleo dos sistemas operativos. A abordagem de <a href="http://en.wikipedia.org/wiki/Metal_descoberto" id="w">&#34&semi;metal descoberto&#34&semi;</a> ainda &eacute; usada hoje em alguns <a href="http://en.wikipedia.org/wiki/Console_de_videogame" id="w">consoles de v&iacute;deo&shy;jogo</a> e <a href="http://en.wikipedia.org/wiki/Sistema_embarcado" id="w">sistemas embarcados</a>, mas no geral, computadores novos usam sistemas operativos e n&uacute;cleos modernos.</p>&#10;<p>Em 1969 o <a href="http://en.wikipedia.org/wiki/RC_4000_Multiprogramming_System" id="w">RC 4000 Multiprogramming System</a> introduziu a filosofia de desenvolvimento de sistemas de pequeno <i>nucleus</i> &#34&semi;na qual sistemas operativos para diferentes prop&oacute;sitos poderiam ser criados de maneira met&oacute;dica&#34&semi;,<sup id="_ref&shy;Hansen2001RC4k_a" class="reference"><a href="#_note&shy;Hansen2001RC4k" title="">[50]</a></sup> algo que poderia ser chamado de abordagem de micron&uacute;cleo.</p>&#10;<a id="sistemas_operativos_de_tempo_compartilhado" name="sistemas_operativos_de_tempo_compartilhado"></a><h3> sistemas operativos de tempo compartilhado </h3>&#10;<p> </p>&#10;<p>Na d&eacute;cada precedendo o fen&ocirc;meno <a href="http://en.wikipedia.org/wiki/Unix" id="w">Unix</a>, computadores aumentaram muito em poder de processamento &mdash; ao ponto onde operadores de computador estavam buscando novos modos de conseguir com que as pessoas usarem o tempo livre em seus computadores. Uma das maiores evolu&ccedil;&otilde;es durantes esta era foi o <a href="http://en.wikipedia.org/wiki/Tempo_compartilhado" id="w">tempo compartilhado</a>, onde um n&uacute;mero de usu&aacute;rios conseguiria pequenas parcelas do tempo do computador, em uma taxa que pareceria que eles estavam cada um conectado a sua pr&oacute;pria m&aacute;quina, embora mais lenta.<sup id="_ref&shy;51" class="reference"><a href="#_note&shy;51" title="">[51]</a></sup></p>&#10;<p>O desenvolvimento dos sistemas de tempo compartilhado levou a in&uacute;meros problemas. Um deles foi que usu&aacute;rios, particularmente em universidades, onde os sistemas estavam sendo desenvolvidos, pareciam tentar <a href="http://en.wikipedia.org/wiki/Hackear" id="w">hackear</a> o sistema para conseguir mais tempo de <a href="http://en.wikipedia.org/wiki/Unidade_central_de_processamento" id="w">processamento</a>. Por esta raz&atilde;o, <a href="http://en.wikipedia.org/wiki/Seguran%C3%A7a_de_computadores" id="w">seguran&ccedil;a</a> e <a href="http://en.wikipedia.org/wiki/Controle_de_acesso" id="w">controles de acesso</a> se tornaram um foco principal do projeto <a href="http://en.wikipedia.org/wiki/Multics" id="w">Multics</a> em 1965.<sup id="_ref&shy;52" class="reference"><a href="#_note&shy;52" title="">[52]</a></sup> Outro problema corrente era gerenciar apropriadamente os recursos do sistema: usu&aacute;rios gastavam a maior parte do tempo iniciando na tela e pensando ao inv&eacute;s de realmente utilizar os recursos do computador, e o sistema de tempo compartilhado deveria dar tempo de processamento para um usu&aacute;rio ativo durante estes per&iacute;odos. Por fim, tipicamente os sistemas ofereciam uma <a href="http://en.wikipedia.org/wiki/Hierarquia_de_mem%C3%B3ria" id="w">hierarquia de mem&oacute;ria</a> de v&aacute;rias camadas de profundidade, e particionar este recurso caro levou a um grande desenvolvimento nos sistemas de <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_virtual" id="w">mem&oacute;ria virtual</a>.</p>&#10;<a id="UNIX" name="UNIX"></a><h3> UNIX </h3>&#10;<p> &#10;<a href="http://en.wikipedia.org/wiki/Ficheiro:Unix&shy;history.svg%7C300px%7Cthumb" id="w">Diagrama da rela&ccedil;&atilde;o de fam&iacute;lia de predecessor/sucessor para os sistemas [[tipo unix]].</a></p>&#10;<p>Durante a fase de projeto do <a href="http://en.wikipedia.org/wiki/Unix" id="w">Unix</a>, os programadores decidiram modelar todo dispositivo de alto n&iacute;vel <a href="http://en.wikipedia.org/wiki/Arquivo_de_dispositivo" id="w">como um arquivo</a>, por que eles acreditavam que o prop&oacute;sito da computa&ccedil;&atilde;o era a transforma&ccedil;&atilde;o de dados.<sup id="_ref&shy;unix_a" class="reference"><a href="#_note&shy;unix" title="">[53]</a></sup> Por exemplo, impressoras eram representadas como um &#34&semi;ficheiro&#34&semi; em uma localiza&ccedil;&atilde;o conhecida &mdash; quando dados eram copiados para o arquivo, ela imprimia&shy;os. Outros sistemas, para fornecer uma funcionalidade similar, possuem a tend&ecirc;ncia de virtualizar dispositivos em um n&iacute;vel mais baixo &mdash; ou seja, ambos dispositivos <i>e</i> ficheiros seriam inst&acirc;ncias de algum conceito de n&iacute;vel inferior. Virtualizar o sistema a n&iacute;vel de ficheiros permitiu aos usu&aacute;rios manipular todo o sistema usando seus conceitos e ferramentas de gerenciamento de ficheiros, simplificando a opera&ccedil;&atilde;o dramaticamente. Como uma extens&atilde;o do mesmo paradigma, o Unix permite que programadores manipulem arquivos usando uma s&eacute;rie de pequenos programas, usando o conceito de <a href="http://en.wikipedia.org/wiki/Encadeamento" id="w">encadeamento</a>, que permitir aos usu&aacute;rios completar opera&ccedil;&otilde;es em etapas, alimentando um ficheiro atrav&eacute;s de uma cadeia de ferramentas de prop&oacute;sito &uacute;nico. Embora o resultado final fosse o mesmo, usar programas menores deste modo aumentou drasticamente a flexibilidade, assim como o uso e desenvolvimento, permitindo que o usu&aacute;rio modificasse seu fluxo de trabalho ao adicionar ou remover um programa da cadeia.</p>&#10;<p>No modelo Unix, o <i>sistema operativo</i> consiste de duas partes&semi; primeira, a enorme cole&ccedil;&atilde;o de programas de utilidades que guiam a maioria das opera&ccedil;&otilde;es.<sup id="_ref&shy;unix_b" class="reference"><a href="#_note&shy;unix" title="">[53]</a></sup> No Unix, do ponto de vista da programa&ccedil;&atilde;o, a distin&ccedil;&atilde;o entre os dois &eacute; extremamente t&ecirc;nue&semi; o n&uacute;cleo &eacute; um programa rodando no modo supervisor<sup id="_ref&shy;supervisor_b" class="reference"><a href="#_note&shy;supervisor" title="">[8]</a></sup> que age como um carregador de programas e supervisor para os pequenos programas de utilidade que integram o resto do sistema, e fornecem <a href="http://en.wikipedia.org/wiki/Trava_(engenharia_de_software)" id="w">travas</a> e servi&ccedil;os de <a href="http://en.wikipedia.org/wiki/Entrada/sa%C3%ADda" id="w">entrada/sa&iacute;da</a> para estes programas&semi; al&eacute;m disso, o n&uacute;cleo n&atilde;o interv&eacute;m de modo algum no <a href="http://en.wikipedia.org/wiki/Espa%C3%A7o_de_usu%C3%A1rio" id="w">espa&ccedil;o de usu&aacute;rio</a>.</p>&#10;<p>Ao longo dos anos o modelo de computa&ccedil;&atilde;o mudou, e o tratamento do Unix de tudo como um ficheiro ou fluxo de bytes n&atilde;o era mais universalmente aplic&aacute;vel como antes. Embora um <a href="http://en.wikipedia.org/wiki/Terminal_de_computador" id="w">terminal</a> pudesse ser tratado como um ficheiro ou fluxo de bytes, de que se exibia ou lia, o mesmo n&atilde;o parecia ser verdade para a <a href="http://en.wikipedia.org/wiki/Interface_gr%C3%A1fica" id="w">interface gr&aacute;fica</a>. <a href="http://en.wikipedia.org/wiki/Rede_de_computador" id="w">Rede</a> se tornou outro problema. Mesmo se a comunica&ccedil;&atilde;o de rede pudesse ser comparada ao acesso de ficheiros, a arquitetura de baixo n&iacute;vel orientada a pacotes lidava com peda&ccedil;os discretos de dados e n&atilde;o com ficheiros completos. Conforme a capacidade dos computadores crescia, o Unix se tornava cada vez mais desorganizado com rela&ccedil;&atilde;o a c&oacute;digo. Enquanto n&uacute;cleos podiam ter 100.000 <a href="http://en.wikipedia.org/wiki/Linhas_de_c%C3%B3digo_fonte" id="w">linhas de c&oacute;digo</a> nos anos 1970 e 1980, n&uacute;cleos sucessores modernos do n&uacute;cleo do Unix como o <a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a> possuem mais de 4.5 milh&otilde;es de linhas.<sup id="_ref&shy;54" class="reference"><a href="#_note&shy;54" title="">[54]</a></sup></p>&#10;<p>Derivados modernos do Unix s&atilde;o geralmente baseados um n&uacute;cleos monol&iacute;ticos que carregam m&oacute;dulos. Exemplos disto s&atilde;o o <a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a>, um n&uacute;cleo monol&iacute;tico com suporte a n&uacute;cleos, e diversas <a href="http://en.wikipedia.org/wiki/Distribui%C3%A7%C3%A3o_linux" id="w">distribui&ccedil;&otilde;es</a> que o incluem, assim como os n&uacute;cleos das variantes do <a href="http://en.wikipedia.org/wiki/Berkeley_software_distribution" id="w">BSD</a> como <a href="http://en.wikipedia.org/wiki/FreeBSD" id="w">FreeBSD</a>, <a href="http://en.wikipedia.org/wiki/DragonflyBSD" id="w">DragonflyBSD</a>, <a href="http://en.wikipedia.org/wiki/OpenBSD" id="w">OpenBSD</a>, <a href="http://en.wikipedia.org/wiki/NetBSD" id="w">NetBSD</a>, etc. Al&eacute;m destas alternativas, desenvolvedores amadores mant&eacute;m uma comunidade ativa de <a href="http://en.wikipedia.org/wiki/Desenvolvimento_de_sistema_operativo" id="w">desenvolvimento de sistemas operativos</a>, cheia de n&uacute;cleos que s&atilde;o criados como passa&shy;tempo que acabam compartilhando v&aacute;rios dos recursos com o Linux, e/ou os n&uacute;cleos do FreeBSD, DragonflyBSD, OpenBSD e NetBSD e/ou sendo compat&iacute;veis com eles.<sup id="_ref&shy;55" class="reference"><a href="#_note&shy;55" title="">[55]</a></sup></p>&#10;<a id="Mac_OS" name="Mac_OS"></a><h3> Mac OS </h3>&#10;<p> </p>&#10;<p>A <a href="http://en.wikipedia.org/wiki/Apple" id="w">Apple</a> lan&ccedil;ou <a href="http://en.wikipedia.org/wiki/Mac_OS" id="w">Mac OS</a> pela primeira vez em  , empacotado com o seu <a href="http://en.wikipedia.org/wiki/Computador_pessoal" id="w">computador pessoal</a> <a href="http://en.wikipedia.org/wiki/Apple_Macintosh" id="w">Macintosh Apple</a>. Pelos primeiros lan&ccedil;amento, o Mac OS (ou Sistema de Software, como ele foi chamado) #careceu de muitos recursos b&aacute;sicos, como multitarefas e um sistema hier&aacute;rquico. Com o tempo, o sistema operativo evoluiu e se tornou o Mac OS 9 com alguns recursos adicionados, mas o n&uacute;cleo se manteve basicamente o mesmo.  Em oposi&ccedil;&atilde;o a isto, o <a href="http://en.wikipedia.org/wiki/Mac_OS_X" id="w">Mac OS X</a> &eacute; baseado no <a href="http://en.wikipedia.org/wiki/Darwin_(sistema_operativo)" id="w">Darwin</a>, que utiliza um conceito de n&uacute;cleo h&iacute;brido chamado <a href="http://en.wikipedia.org/wiki/XNU" id="w">XNU</a>, criado combinando o n&uacute;cleo do <a href="http://en.wikipedia.org/wiki/BSD#4.3BSD" id="w">4.3BSD</a> e o <a href="http://en.wikipedia.org/wiki/Mach_(n%C3%BAcleo)" id="w">Mach</a>.<sup id="_ref&shy;56" class="reference"><a href="#_note&shy;56" title="">[56]</a></sup></p>&#10;<a id="Amiga" name="Amiga"></a><h3> Amiga </h3>&#10;<p> </p>&#10;<p>O <a href="http://en.wikipedia.org/wiki/Amiga" id="w">Amiga</a> da <a href="http://en.wikipedia.org/wiki/Commodore_International" id="w">Commodore</a> foi lan&ccedil;ado em  , e estava dentre os primeiros (e certamente mais bem sucedidos) computadores dom&eacute;sticos a apresenter um sistema operativo com um micron&uacute;cleo.  O n&uacute;cleo do Amiga, a <i>exec.library</i>, era pequena mas capaz, oferecendo multitarefas r&aacute;pidas e preemptivas em hardware similar ao do Apple Macintosh, e um sistema avan&ccedil;ado de <a href="http://en.wikipedia.org/wiki/Liga%C3%A7%C3%A3o_din%C3%A2mica" id="w">liga&ccedil;&otilde;es din&acirc;micas</a> que permitia uma expans&atilde;o f&aacute;cil.<sup id="_ref&shy;57" class="reference"><a href="#_note&shy;57" title="">[57]</a></sup></p>&#10;<a id="Microsoft_Windows" name="Microsoft_Windows"></a><h3> Microsoft Windows </h3>&#10;<p> </p>&#10;<p>O <a href="http://en.wikipedia.org/wiki/Microsoft_Windows" id="w">Microsoft Windows</a> foi lan&ccedil;ado em 1985 como uma extens&atilde;o para o <a href="http://en.wikipedia.org/wiki/MS&shy;DOS" id="w">MS&shy;DOS</a>. Devido &agrave; sua depend&ecirc;ncia de outro sistema operativo, todas as vers&otilde;es at&eacute; a 95 s&atilde;o consideradas um <a href="http://en.wikipedia.org/wiki/Ambiente_operacional" id="w">ambiente operacional</a> (e n&atilde;o um <a href="http://en.wikipedia.org/wiki/Sistema_operativo" id="w">sistema operativo</a> propriamente dito).  Tal linha de produtos continuou por 1980 e 1990, resultando nos lan&ccedil;amentos das s&eacute;ries <a href="http://en.wikipedia.org/wiki/Windows_9x" id="w">Windows 9x</a>, atualizando as capacidades do sistema para endere&ccedil;amento de 32 bits e multitarefas preemptivo, ao longo dos anos 1990, terminando com o lan&ccedil;amento do <a href="http://en.wikipedia.org/wiki/Windows_Me" id="w">Windows Me</a> em 2000.</p>&#10;<p>O lan&ccedil;amento do <a href="http://en.wikipedia.org/wiki/Windows_XP" id="w">Windows XP</a> em outubro de 2001 uniu as duas linhas de produto, com a inten&ccedil;&atilde;o de combinar a estabilidade do n&uacute;cleo NT com os recursos ao consumidor das s&eacute;ries 9x.<sup id="_ref&shy;58" class="reference"><a href="#_note&shy;58" title="">[58]</a></sup> A <a href="http://en.wikipedia.org/wiki/Arquitetura_do_Windows_NT" id="w">arquitetura do n&uacute;cleo do windows nt</a> &eacute; considerada h&iacute;brida pois o pŕoprio n&uacute;cleo cont&eacute;m tarefas como o gerenciador de janelas e o gerenciador de comunica&ccedil;&atilde;o entre processos, mas v&aacute;rios subsistemas s&atilde;o executados no modo de usu&aacute;rio.<sup id="_ref&shy;59" class="reference"><a href="#_note&shy;59" title="">[59]</a></sup> O ponto de quebra exato entre espa&ccedil;o de usu&aacute;rio e espa&ccedil;o de n&uacute;cleo t&ecirc;m deslocado conforme a vers&atilde;o, mas a introdu&ccedil;&atilde;o do <a href="http://en.wikipedia.org/wiki/Arcabou%C3%A7o_de_driver_de_espa%C3%A7o_de_usu%C3%A1rio" id="w">Arcabou&ccedil;o de driver de espa&ccedil;o de usu&aacute;rio</a> no windows vista, e escalonamento de linha de execu&ccedil;&atilde;o no espa&ccedil;o de usu&aacute;rio no <a href="http://en.wikipedia.org/wiki/Windows_7" id="w">Windows 7</a>,<sup id="_ref&shy;60" class="reference"><a href="#_note&shy;60" title="">[60]</a></sup> deslocou mais recursos do n&uacute;cleo para processos no espa&ccedil;o de usu&aacute;rio.</p>&#10;<a id="Desenvolvimento_de_micron%C3%BAcleos" name="Desenvolvimento_de_micron%C3%BAcleos"></a><h3> Desenvolvimento de micron&uacute;cleos </h3>&#10;<p>Embora o <a href="http://en.wikipedia.org/wiki/Mach_(n%C3%BAcleo)" id="w">Mach</a>, desenvolvido na <a href="http://en.wikipedia.org/wiki/Universidade_Carnegie_Mellon" id="w">Universidade Carnegie Mellon</a> de   a  , &eacute; o micron&uacute;cleo de prop&oacute;sito geral mais conhecido, outros micron&uacute;cleos foram desenvolvidos com objetivos mais espec&iacute;ficos. Um fam&iacute;lia de micron&uacute;cleos <a href="http://en.wikipedia.org/wiki/L4_(micron%C3%BAcleo)" id="w">L4</a> (principalmente o micron&uacute;cleo L3 e o L4) foi criada para demonstrar que micron&uacute;cleos n&atilde;o s&atilde;o necessariamente lentos.<sup id="_ref&shy;l4_b" class="reference"><a href="#_note&shy;l4" title="">[47]</a></sup> Implementa&ccedil;&otilde;es mais novas como <a href="http://en.wikipedia.org/wiki/Fiasco_(L4_clone)" id="w">Fiasco</a> e <a href="http://en.wikipedia.org/wiki/Pistachio_(L4_clone)" id="w">Pistachio</a> s&atilde;o capazes de executar o <a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a> junto com outros processo L4 em espa&ccedil;os de endere&ccedil;amento separados.<sup id="_ref&shy;61" class="reference"><a href="#_note&shy;61" title="">[61]</a></sup><sup id="_ref&shy;62" class="reference"><a href="#_note&shy;62" title="">[62]</a></sup></p>&#10;<p><a href="http://en.wikipedia.org/wiki/QNX" id="w">QNX</a> &eacute; um <a href="http://en.wikipedia.org/wiki/Sistema_operativo_de_tempo&shy;real" id="w">Sistema operativo de tempo&shy;real</a> com um projeto de micron&uacute;cleo minimalista que vem sendo desenvolvido desde  , sendo mais bem&shy;sucedido do que o Mach em alcan&ccedil;ar os objetivos do paradigma do micron&uacute;cleo.<sup id="_ref&shy;63" class="reference"><a href="#_note&shy;63" title="">[63]</a></sup> Ele &eacute; usado principalmente em <a href="http://en.wikipedia.org/wiki/Sistema_embarcad" id="w">sistemas embarcados</a> e em situa&ccedil;&otilde;es em que o software n&atilde;o pode falhar, como nos bra&ccedil;os rob&oacute;ticos do <a href="http://en.wikipedia.org/wiki/&Ocirc;nibus_espacial" id="w">&ocirc;nibus espacial</a> e m&aacute;quinas que controlam a moe&ccedil;&atilde;o de vidro a toler&acirc;ncias extremamente finas, onde um min&uacute;sculo erro poderia custar centenas de milhares de reais.</p>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;<p> &#10;</p>&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Compara%C3%A7%C3%A3o_entre_n%C3%BAcleos" id="w">Compara&ccedil;&atilde;o entre n&uacute;cleos</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Compilador" id="w">Compilador</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Driver_de_dispositivo" id="w">Driver de dispositivo</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Entrada/sa%C3%ADda" id="w">Entrada/sa&iacute;da</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Pedido_de_interrup%C3%A7%C3%A3o" id="w">Pedido de interrup&ccedil;&atilde;o</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_(computador)" id="w">Mem&oacute;ria</a>&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_de_acesso_aleat%C3%B3rio" id="w">Mem&oacute;ria de acesso aleat&oacute;rio</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_virtual" id="w">Mem&oacute;ria virtual</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Pagina%C3%A7%C3%A3o" id="w">Pagina&ccedil;&atilde;o</a>, <a href="http://en.wikipedia.org/wiki/Segmenta%C3%A7%C3%A3o_(mem%C3%B3ria)" id="w">Segmenta&ccedil;&atilde;o</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_paginada" id="w">Espa&ccedil;o de troca</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Espa%C3%A7o_de_usu%C3%A1rio" id="w">Espa&ccedil;o de usu&aacute;rio</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Unidade_de_gerenciamento_de_mem%C3%B3ria" id="w">Unidade de gerenciamento de mem&oacute;ria</a></li></ul></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Multitarefa" id="w">Multitarefa</a>&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Processo_(inform%C3%A1tica)" id="w">Processo</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Linha_de_execu%C3%A7%C3%A3o" id="w">Linha de execu&ccedil;&atilde;o</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Escalonamento" id="w">Escalonamento</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Tempo_compartilhado" id="w">Tempo compartilhado</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Troca_de_contexto" id="w">Troca de contexto</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Comunica%C3%A7%C3%A3o_entre_processos" id="w">Comunica&ccedil;&atilde;o entre processos</a></li></ul></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Sistema_operativo" id="w">Sistema operativo</a></li></ul>&#10;<p> </p>&#10;<a id="Refer%C3%AAncias" name="Refer%C3%AAncias"></a><h2> Refer&ecirc;ncias </h2>&#10;<p> &#10;</p>&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> inclu&iacute;do em livro:  </li>&#10;<li><a href="http://en.wikipedia.org/wiki/Hermann_H%C3%A4rtig" id="w">Hermann H&auml;rtig</a>, Michael Hohmuth, <a href="http://en.wikipedia.org/wiki/Jochen_Liedtke" id="w">Jochen Liedtke</a>, Sebastian Sch&ouml;nberg, Jean Wolter <i><a class="externallink" href="http://os.inf.tu&shy;dresden.de/pubs/sosp97/#Karshmer:1991:OSA" rel="nofollow" title="http://os.inf.tu&shy;dresden.de/pubs/sosp97/#Karshmer:1991:OSA">A performance de sistemas baseados no n&uacute;cleo &mu;</a></i> <a class="externallink" href="http://doi.acm.org/10.1145/268998.266660" rel="nofollow" title="http://doi.acm.org/10.1145/268998.266660">http://doi.acm.org/10.1145/268998.266660</a> ACM SIGOPS Operating Systems Review, v.31 n.5, p.&#160&semi;66&shy;77, Dec. 1997</li>&#10;<li>Houdek, M. E., Soltis, F. G., and Hoffman, R. L. 1981. <i><a class="externallink" href="http://portal.acm.org/citation.cfm?id=800052.801885" rel="nofollow" title="http://portal.acm.org/citation.cfm?id=800052.801885">IBM System/38 support for capability&shy;based addressing</a></i>. In Proceedings of the 8th ACM International Symposium on Computer Architecture. ACM/IEEE, pp.&#160&semi;341&ndash;348.</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Intel_Corporation" id="w">Intel Corporation</a> (2002) <i><a class="externallink" href="http://www.intel.com/design/pentium4/manuals/24547010.pdf" rel="nofollow" title="http://www.intel.com/design/pentium4/manuals/24547010.pdf">The IA&shy;32 Architecture Software Developer&rsquo;s Manual, Volume 1: Basic Architecture</a></i></li>&#10;<li> </li>&#10;<li> </li>&#10;<li><a href="http://en.wikipedia.org/wiki/Jochen_Liedtke" id="w">Liedtke, Jochen</a>. <i><a class="externallink" href="http://i30www.ira.uka.de/research/publications/papers/index.php?lid=en&#38&semi;docid=642" rel="nofollow" title="http://i30www.ira.uka.de/research/publications/papers/index.php?lid=en&#38&semi;docid=642">Sobre a constru&ccedil;&atilde;o do n&uacute;cleo &micro;</a></i>, <i>Proc. 15th ACM Symposium on Operating System Principles (SOSP)</i>, December 1995</li>&#10;<li>  <a class="externallink" href="http://csrc.nist.gov/publications/history/lind76.pdf" rel="nofollow" title="http://csrc.nist.gov/publications/history/lind76.pdf">http://csrc.nist.gov/publications/history/lind76.pdf</a></li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li>  <a class="externallink" href="http://www.cs.virginia.edu/papers/p337&shy;wulf.pdf" rel="nofollow" title="http://www.cs.virginia.edu/papers/p337&shy;wulf.pdf">http://www.cs.virginia.edu/papers/p337&shy;wulf.pdf</a></li>&#10;<li> </li>&#10;<li>Swift, Michael M&semi; Brian N. Bershad , Henry M. Levy, <i><a class="externallink" href="http://nooks.cs.washington.edu/nooks&shy;tocs.pdf" rel="nofollow" title="http://nooks.cs.washington.edu/nooks&shy;tocs.pdf">Improving the reliability of commodity operating systems</a></i>, <a class="externallink" href="http://doi.acm.org/10.1145/1047915.1047919" rel="nofollow" title="http://doi.acm.org/10.1145/1047915.1047919">http://doi.acm.org/10.1145/1047915.1047919</a> ACM Transactions on Computer Systems (TOCS), v.23 n.1, p.&#160&semi;77&shy;110, February 2005</li></ul>&#10;<p> </p>&#10;<a id="Leituras_importantes" name="Leituras_importantes"></a><h2> Leituras importantes </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Andrew_Tanenbaum" id="w">Andrew Tanenbaum</a>, <i>Operating Systems &shy; Design and Implementation (Third edition)</i>&semi;</li>&#10;<li>Andrew Tanenbaum, <i>Modern Operating Systems (Second edition)</i>&semi;</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Daniel_P._Bovet" id="w">Daniel P. Bovet</a>, <a href="http://en.wikipedia.org/wiki/Marco_Cesati" id="w">Marco Cesati</a>, <i>The Linux Kernel</i>&semi;</li>&#10;<li><a href="http://en.wikipedia.org/wiki/David_A._Peterson" id="w">David A. Peterson</a>, <a href="http://en.wikipedia.org/wiki/Nitin_Indurkhya" id="w">Nitin Indurkhya</a>, Patterson, <i>Computer Organization and Design</i>, <a href="http://en.wikipedia.org/wiki/Morgan_Koffman" id="w">Morgan Koffman</a> <small>(<a class="external text" href="http://www.amazon.com/exec/obidos/ASIN/1558604286" rel="nofollow" title="http://www.amazon.com/exec/obidos/ASIN/1558604286">ISBN 1&shy;55860&shy;428&shy;6</a>)</small>&semi;</li>&#10;<li><a href="http://en.wikipedia.org/wiki/B.S._Chalk" id="w">B.S. Chalk</a>, <i>Computer Organisation and Architecture</i>, Macmillan P.(<a class="external text" href="http://www.amazon.com/exec/obidos/ASIN/0333645510" rel="nofollow" title="http://www.amazon.com/exec/obidos/ASIN/0333645510">ISBN 0&shy;333&shy;64551&shy;0</a>).</li></ul>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li> .</li>&#10;<li> .</li>&#10;<li> .</li>&#10;<li> .</li>&#10;<li> .</li>&#10;<li> , um artigo de 1992 por <a href="http://en.wikipedia.org/wiki/Norman_Hardy" id="w">Norman Hardy</a> <i>e outros.</i>.</li>&#10;<li> , um artigo de 1994 por Drew Major, Greg Minshall, e Kyle Powell (arquitetos pfincipais por tr&aacute;s do SO NetWare).</li>&#10;<li> , uma comunidade para aprender a hackear o Linux.</li>&#10;<li> .</li></ul>&#10;<p> &#10;<a href="http://en.wikipedia.org/wiki/Categoria:N%C3%BAcleo_de_sistema_operativo" id="w"> </a></p></body></html>