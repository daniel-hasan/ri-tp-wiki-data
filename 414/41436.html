<html><title>Deadlock</title><body>&#10;<p> &#10; </p>&#10;<p><b>Deadlock</b> (interbloqueio, &shy;blocagem, impasse), no contexto do <a href="http://en.wikipedia.org/wiki/Sistema_operativo" id="w">sistemas operacionais</a> (SO), caracteriza uma situa&ccedil;&atilde;o em que ocorre um impasse e dois ou mais <a href="http://en.wikipedia.org/wiki/Processo_(inform%C3%A1tica)" id="w">processos</a> ficam impedidos de continuar suas execu&ccedil;&otilde;es, ou seja, ficam bloqueados. Trata&shy;se de um problema bastante estudado no contexto dos Sistemas Operacionais, assim como em outras disciplinas, como <a href="http://en.wikipedia.org/wiki/Banco_de_dados" id="w">banco de dados</a>, pois &eacute; inerente &agrave; pr&oacute;pria natureza desses sistemas.</p>&#10;<p>O <i>deadlock</i> ocorre com um conjunto de <a href="http://en.wikipedia.org/wiki/Processo" id="w">processos</a> e recursos n&atilde;o&shy;preempt&iacute;veis, onde um ou mais processos desse conjunto est&aacute; aguardando a libera&ccedil;&atilde;o de um recurso por um outro processo que, por sua vez, aguarda a libera&ccedil;&atilde;o de outro recurso alocado ou dependente do primeiro processo.</p>&#10;<p>A defini&ccedil;&atilde;o textual de <i>deadlock</i> normalmente, por ser muito abstrata, &eacute; mais dif&iacute;cil de se compreender do que a representa&ccedil;&atilde;o por <a href="http://en.wikipedia.org/wiki/Grafo" id="w">grafos</a>, que ser&aacute; resumida mais adiante. No entanto, algumas observa&ccedil;&otilde;es s&atilde;o pertinentes:</p>&#10;&#10;<ul>&#10;<li>O <i>deadlock</i> pode ocorrer mesmo que haja somente um processo no SO, considerando que este processo utilize m&uacute;ltiplos <i><a href="http://en.wikipedia.org/wiki/Thread_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">threads</a></i> e que tais <i>threads</i> requisitem os recursos alocados a outros <i><a href="http://en.wikipedia.org/wiki/Threads" id="w">threads</a></i> no mesmo processo&semi;</li></ul>&#10;&#10;<ul>&#10;<li>O <i>deadlock</i> independe da quantidade de recursos dispon&iacute;veis no sistema&semi;</li></ul>&#10;&#10;<ul>&#10;<li>Normalmente o <i>deadlock</i> ocorre com recursos como dispositivos, arquivos, mem&oacute;ria, etc. Apesar da <a href="http://en.wikipedia.org/wiki/Unidade_Central_de_Processamento" id="w">CPU</a> tamb&eacute;m ser um recurso para o SO, em geral &eacute; um recurso facilmente preempt&iacute;vel, pois existem os escalonadores para compartilhar o processador entre os diversos processos, quando trata&shy;se de um ambiente <a href="http://en.wikipedia.org/wiki/Multitarefa" id="w">multitarefa</a>.</li></ul>&#10;<p>Um exemplo onde erros de <i>deadlock</i> ocorrem &eacute; no <a href="http://en.wikipedia.org/wiki/Banco_de_dados" id="w">banco de dados</a>. Suponha que uma empresa tenha v&aacute;rios vendedores e v&aacute;rios pontos de venda/caixas. O vendedor A vendeu 1 martelo e 1 furadeira. O sistema ent&atilde;o solicita o travamento do registro da tabela ESTOQUE que cont&eacute;m o total de martelos em estoque e em seguida solicita o travamento do registro que cont&eacute;m o total de furadeiras em estoque. De posse da exclusividade de acesso aos dois registros, ele l&ecirc; a quantidade de martelos, subtrai 1 e escreve de novo no registro, o mesmo com o registro de furadeiras. Observe, no entanto que existem diversos caixas operando simultaneamente de forma que se algum outro caixa naquele exato instante estiver vendendo um furadeira, ele ficar&aacute; de aguardando a libera&ccedil;&atilde;o do registro das furadeiras para depois alter&aacute;&shy;lo. Note que ele s&oacute; altera os registro depois que for dada exclusividade para ele de TODOS os recursos que ele precisa, ou seja, de todos os registro. Suponha agora que em outro caixa a venda foram vendidos 1 furadeira e 1 martelo e que o outro caixa solicitou o travamento do registro com a quantidade de furadeiras e agora quer o acesso ao de martelos, no entanto o de martelos est&aacute; travado para o primeiro caixa. Nenhum deles devolve o recurso (registro) sobre o qual tem exclusividade e tamb&eacute;m n&atilde;o consegue acesso ao outro registro que falta para terminar a opera&ccedil;&atilde;o. Isto &eacute; um deadlock.</p>&#10;<a id="Condi%C3%A7%C3%B5es_necess%C3%A1rias_para_a_ocorr%C3%AAncia_de_''deadlock''" name="Condi%C3%A7%C3%B5es_necess%C3%A1rias_para_a_ocorr%C3%AAncia_de_''deadlock''"></a><h2> Condi&ccedil;&otilde;es necess&aacute;rias para a ocorr&ecirc;ncia de &#39&semi;&#39&semi;deadlock&#39&semi;&#39&semi; </h2>&#10;<p>No texto acima, foi dito que o <i>deadlock</i> ocorre naturalmente em alguns sistemas. No entanto, &eacute; necess&aacute;rio ressaltar que tais sistemas precisam obedecer a algumas condi&ccedil;&otilde;es para que uma situa&ccedil;&atilde;o de <i>deadlock</i> se manifeste.</p>&#10;<p>Essas condi&ccedil;&otilde;es est&atilde;o listadas abaixo, onde as tr&ecirc;s primeiras caracterizam um modelo de sistema, e a &uacute;ltima &eacute; o <i>deadlock</i> propriamente dito: processos que estejam de posse &#10;de recursos obtidos anteriormente podem solicitar novos recursos. &#10;Caso estes recursos j&aacute; estejam alocados a outros processos, o processo solicitante deve aguardar pela libera&ccedil;&atilde;o do mesmo&semi;</p>&#10;&#10;<ul>&#10;<li><b>Condi&ccedil;&atilde;o de n&atilde;o&shy;preemp&ccedil;&atilde;o</b>: recursos j&aacute; alocados a processos n&atilde;o podem ser tomados a for&ccedil;a. Eles precisam ser liberados explicitamente pelo processo que det&eacute;m a sua posse&semi;</li></ul>&#10;&#10;<ul>&#10;<li><b>Condi&ccedil;&atilde;o de exclusividade m&uacute;tua</b>: cada recurso ou est&aacute; alocado a exatamente um processo, ou est&aacute; dispon&iacute;vel&semi;</li></ul>&#10;&#10;<ul>&#10;<li><b>Condi&ccedil;&atilde;o de posse&shy;e&shy;espera</b>: cada processo pode solicitar um recurso, ter esse recurso alocado para si e ficar bloqueado esperando por um outro recurso&semi;</li></ul>&#10;&#10;<ul>&#10;<li><b>Condi&ccedil;&atilde;o de espera circular</b>: deve existir uma cadeia circular de dois ou mais processos, cada um dos quais esperando por um recurso que est&aacute; com o pr&oacute;ximo membro da cadeia.</li></ul>&#10;<a id="Representa%C3%A7%C3%A3o_de_''deadlock''_em_grafos" name="Representa%C3%A7%C3%A3o_de_''deadlock''_em_grafos"></a><h2> Representa&ccedil;&atilde;o de &#39&semi;&#39&semi;deadlock&#39&semi;&#39&semi; em grafos </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:DeadlockGraph.svg%7Cright%7Cframe" id="w">Exemplo de representa&ccedil;&atilde;o de &#39&semi;&#39&semi;deadlock&#39&semi;&#39&semi; em grafos de aloca&ccedil;&atilde;o de recursos, com dois processos &#39&semi;&#39&semi;&#39&semi;A&#39&semi;&#39&semi;&#39&semi; e &#39&semi;&#39&semi;&#39&semi;B&#39&semi;&#39&semi;&#39&semi;, e dois recursos &#39&semi;&#39&semi;&#39&semi;R1&#39&semi;&#39&semi;&#39&semi; e &#39&semi;&#39&semi;&#39&semi;R2&#39&semi;&#39&semi;&#39&semi;.</a></p>&#10;<p>O <i>deadlock</i> tamb&eacute;m pode ser representado na forma de <a href="http://en.wikipedia.org/wiki/Grafo" id="w">grafos</a> dirigidos, onde o processo &eacute; representado por um quadrado e o recurso por um c&iacute;rculo. Quando um processo solicita um recurso, uma seta &eacute; dirigida do quadrado ao c&iacute;rculo. Quando um recurso &eacute; alocado a um processo, uma seta &eacute; dirigida do c&iacute;rculo ao quadrado.</p>&#10;<p>Na figura do exemplo, podem&shy;se ver dois processos diferentes (<b>A</b> e <b>B</b>), cada um com um recurso diferente alocado (<b>R1</b> e <b>R2</b>). Nesse exemplo cl&aacute;ssico de <i>deadlock</i>, &eacute; facilmente vis&iacute;vel a condi&ccedil;&atilde;o de <b>espera circular</b> em que os processos se encontram, onde cada um solicita o recurso que est&aacute; alocado ao outro processo.</p>&#10;<a id="Tratamento_de_''deadlock''" name="Tratamento_de_''deadlock''"></a><h2> Tratamento de &#39&semi;&#39&semi;deadlock&#39&semi;&#39&semi; </h2>&#10;<p>As situa&ccedil;&otilde;es de deadlock podem ser tratadas ou n&atilde;o em um <a href="http://en.wikipedia.org/wiki/Sistema_operativo" id="w">sistema</a>, e cabe aos desenvolvedores avaliar o custo/benef&iacute;cio que essas implementa&ccedil;&otilde;es podem trazer. Normalmente, as estrat&eacute;gias usadas para detectar e tratar as situa&ccedil;&otilde;es de <i>deadlocks</i> geram grande sobrecarga, podendo at&eacute; causar um dano maior que a pr&oacute;pria ocorr&ecirc;ncia do <i>deadlock</i>, sendo, &agrave;s vezes, melhor ignorar a situa&ccedil;&atilde;o.</p>&#10;<p>Existem tr&ecirc;s estrat&eacute;gias para tratamento de <i>deadlocks</i>:</p>&#10;&#10;<ul>&#10;<li>Ignorar a situa&ccedil;&atilde;o&semi;</li>&#10;<li>Detectar o <i>deadlock</i> e recuperar o sistema&semi; e</li>&#10;<li>Evitar o <i>deadlock</i>&semi;</li></ul>&#10;<a id="Algoritmo_do_Avestruz_(Ignorar_a_situa%C3%A7%C3%A3o)" name="Algoritmo_do_Avestruz_(Ignorar_a_situa%C3%A7%C3%A3o)"></a><h3> Algoritmo do Avestruz (Ignorar a situa&ccedil;&atilde;o) </h3>&#10;<p>A estrat&eacute;gia mais simples para tratamento (ou n&atilde;o) do &#34&semi;deadlock&#34&semi;, conhecida como <a href="http://en.wikipedia.org/wiki/Algoritmo_do_Avestruz" id="w">Algoritmo do Avestruz</a>, &eacute; simplesmente ignor&aacute;&shy;lo. Muitos defendem que a freq&uuml;&ecirc;ncia de ocorr&ecirc;ncia deste tipo de evento &eacute; baixa demais para que seja necess&aacute;rio sobrecarregar a <a href="http://en.wikipedia.org/wiki/Unidade_Central_de_Processamento" id="w">CPU</a> com c&oacute;digos extras de tratamento, e que, ocasionalmente, &eacute; toler&aacute;vel reiniciar o sistema como uma a&ccedil;&atilde;o corretiva.</p>&#10;<a id="Detectar_o_''deadlock''_e_recuperar_o_sistema" name="Detectar_o_''deadlock''_e_recuperar_o_sistema"></a><h3> Detectar o &#39&semi;&#39&semi;deadlock&#39&semi;&#39&semi; e recuperar o sistema </h3>&#10;<p>Nessa estrat&eacute;gia, o sistema permite que ocorra o <i>deadlock</i> e s&oacute; ent&atilde;o executa o procedimento de recupera&ccedil;&atilde;o, que resume&shy;se na detec&ccedil;&atilde;o da ocorr&ecirc;ncia e na recupera&ccedil;&atilde;o posterior do sistema. &Eacute; na execu&ccedil;&atilde;o desse procedimento que ocorre a sobrecarga, pois existem dois grandes problemas: primeiramente, como/quando detectar o <i>deadlock</i> e depois, como corrigi&shy;lo.</p>&#10;<p>Para detectar o <i>deadlock</i>, o sistema deve implementar uma estrutura de dados que armazene as informa&ccedil;&otilde;es sobre os processos e os recursos alocados a eles. Essas estruturas dever&atilde;o ser atualizadas dinamicamente, de modo que reflitam realmente a situa&ccedil;&atilde;o de cada processo/recurso no sistema.</p>&#10;<p>S&oacute; o mero procedimento de atualiza&ccedil;&atilde;o dessas estruturas j&aacute; gera uma sobrecarga no sistema, pois toda vez que um processo aloca, libera ou requisita um recurso, as estruturas precisam ser atualizadas.</p>&#10;<p>Al&eacute;m disso, o SO precisa verificar a ocorr&ecirc;ncia da condi&ccedil;&atilde;o de <b>espera circular</b> nessas estruturas para a efetiva detec&ccedil;&atilde;o do <i>deadlock</i>. Esse procedimento, por sua vez, gera outra sobrecarga, que pode ser mais intensa se n&atilde;o for definido um evento em particular para ser executado, como a libera&ccedil;&atilde;o de um recurso, por exemplo. Assim, ou o SO verifica periodicamente as estruturas (o que n&atilde;o &eacute; aconselh&aacute;vel, pois pode aumentar consideravelmente o tempo de espera dos processos n&atilde;o&shy;bloqueados), ou pode&shy;se implementar uma pol&iacute;tica, onde o SO verifica as estruturas quando o mesmo realizar algum procedimento de manuten&ccedil;&atilde;o do sistema, por exemplo.</p>&#10;<p>Finalmente, s&oacute; ap&oacute;s detectar a presen&ccedil;a do <i>deadlock</i> no sistema, o SO precisa corrigi&shy;lo, executando um procedimento de recupera&ccedil;&atilde;o.</p>&#10;<p>Quanto &agrave; detec&ccedil;&atilde;o do deadlock, vamos apresentar uma das t&eacute;cnicas usadas para detectar a ocorr&ecirc;ncia de deadlock em sistemas que possuem v&aacute;rios recursos de cada tipo.</p>&#10;<a id="Detec%C3%A7%C3%A3o_de_''deadlock''_com_v%C3%A1rios_recursos_de_cada_tipo" name="Detec%C3%A7%C3%A3o_de_''deadlock''_com_v%C3%A1rios_recursos_de_cada_tipo"></a><h4> Detec&ccedil;&atilde;o de &#39&semi;&#39&semi;deadlock&#39&semi;&#39&semi; com v&aacute;rios recursos de cada tipo </h4>&#10;<p>O <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmo</a> de detec&ccedil;&atilde;o de <i>deadlock</i> com v&aacute;rios recursos de cada tipo baseia&shy;se em um ambiente que possua v&aacute;rios recursos do mesmo tipo e os processos solicitam apenas pelo tipo de recursos, n&atilde;o especificando qual recurso desejam utilizar.</p>&#10;<p>Assim, um processo pode requisitar uma unidade de CD para leitura. Se o sistema possuir duas, o processo pode utilizar a que estiver dispon&iacute;vel, em vez de especificar uma delas. Dessa forma, o processo solicita o recurso pelo tipo, sem discrimina&ccedil;&atilde;o.</p>&#10;<p>O algoritmo para essa detec&ccedil;&atilde;o trabalha com duas vari&aacute;veis, tr&ecirc;s matrizes unidimensionais (vetores) e duas matrizes bidimensionais, descritas a seguir:</p>&#10;&#10;<ul>&#10;<li>Estruturas:&#10;<ul>&#10;<li><i>n</i>: Vari&aacute;vel inteira. Representa a <b>Quantidade de Processos Ativos</b>&semi;</li>&#10;<li><i>m</i>: Vari&aacute;vel inteira. Representa a <b>Quantidade de Tipos de Recursos</b>&semi;</li>&#10;<li>Matriz <i>E</i> = <span class="math">\left (e_{j}\right )_m</span>: Matriz unidimensional, de tamanho <i>m</i>. Representa a <b>Matriz de Recursos Existentes</b>&semi;</li>&#10;<li>Matriz <i>A</i> = <span class="math">\left (a_{j}\right )_m</span>: Matriz unidimensional, de tamanho <i>m</i>. Representa a <b>Matriz de Recursos Atualmente Dispon&iacute;veis</b>&semi;</li>&#10;<li>Matriz <i>W</i> = <span class="math">\left (w_{j}\right )_m</span>: Matriz unidimensional, de tamanho <i>m</i>. Representa uma <b>Matriz Auxiliar</b>, presente somente para facilitar o c&aacute;lculo durante a execu&ccedil;&atilde;o do algoritmo&semi;</li>&#10;<li>Matriz <i>C</i> = <span class="math">\left (c_{ij}\right )_{n x m}</span>: Matriz bidimensional, de tamanho <i>n</i> x <i>m</i>. Representa a <b>Matriz de Aloca&ccedil;&atilde;o Corrente</b>&semi;</li>&#10;<li>Matriz <i>R</i> = <span class="math">\left (r_{ij}\right )_{n x m}</span>: Matriz bidimensional, de tamanho <i>n</i> x <i>m</i>. Representa a <b>Matriz de Recursos Requisitados</b>.</li></ul></li></ul>&#10;&#10;<ul>&#10;<li>Fa&ccedil;a (para preenchimento das estruturas):&#10;<ol>&#10;<li>Preencher a Matriz <i>E</i> com as quantidade de inst&acirc;ncias de cada tipo de recurso&semi;</li>&#10;<li>Preencher a Matriz <i>C</i> com as quantidade de inst&acirc;ncias de cada tipo alocadas aos processos, sendo que o somat&oacute;rio de cada coluna da Matriz <i>C</i> deve ser menor ou igual &agrave; quantidade do recurso correspondente na Matriz <i>E</i> (os processos nunca podem requisitar mais recursos que existentes no sistema)&semi;</li>&#10;<li>Preencher a Matriz <i>W</i> com o resultado da subtra&ccedil;&atilde;o da quantidade de cada recurso da Matriz <i>E</i> com o valor do somat&oacute;rio de cada coluna do recurso correspondente da Matriz <i>C</i>, ou seja:<br/><center><span class="math">w_{j} = e_{j} &shy; \sum_{i=1}^{n} c_{ij}</span></center></li>&#10;<li>Preencher inicialmente a Matriz <i>A</i> com os valores da Matriz <i>W</i>.<br/> Note que: <span class="math">a_{j} = e_{j} + w_{j}\,\!</span>&semi;</li>&#10;<li>Preencher a Matriz <i>R</i> com as pr&oacute;ximas requisi&ccedil;&otilde;es dos processos, seguindo as mesmas regras da Matriz <i>C</i>.</li></ol></li></ul>&#10;&#10;<ul>&#10;<li>Fa&ccedil;a (para detec&ccedil;&atilde;o do <i>deadlock</i>):&#10;<ol>&#10;<li>Inicialmente, desmarcar todos os processos&semi;</li>&#10;<li>Para um processo P<sub>i</sub> desmarcado, verificar se todos os elementos da linha <i>i</i> na Matriz <i>R</i> s&atilde;o menores ou iguais aos da Matriz <i>A</i>&semi;</li>&#10;<li>Se for, ent&atilde;o marque o execute o processo P<sub>i</sub> e libere os recursos requisitados pelo processo na Matriz <i>C</i> (adicionar a linha <i>i</i> da Matriz <i>C</i> na Matriz <i>A</i>)&semi;</li>&#10;<li>Retornar ao passo 2.</li></ol></li></ul>&#10;<p>A l&oacute;gica do algoritmo &eacute; a seguinte: cada processo &eacute; considerado como apto a ser executado at&eacute; que a detec&ccedil;&atilde;o prove o contr&aacute;rio. A detec&ccedil;&atilde;o apenas verifica se os processos requisitam mais recursos do que est&atilde;o dispon&iacute;veis, o que caracteriza um <i>deadlock</i>. Caso o processo requisite uma quantidade dispon&iacute;vel, ent&atilde;o ele pode ser executado, e os recursos que foram solicitados antes podem tamb&eacute;m ser liberados de volta ao sistema, o que pode permitir que outros processos tamb&eacute;m concluam suas execu&ccedil;&otilde;es e liberem os recursos.</p>&#10;<p>Um exemplo do preenchimento das matrizes encontra&shy;se na figura abaixo, considerando&shy;se <i>n=2</i> e <i>m=3</i>.</p>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:MatrizesDeadlock.png%7Ccenter%7Cframe" id="w">Exemplo do preenchimento das matrizes do algoritmo de detec&ccedil;&atilde;o de &#39&semi;&#39&semi;deadlock&#39&semi;&#39&semi; com v&aacute;rios recursos de cada tipo.</a></p>&#10;<a id="Refer%C3%AAncias_na_internet" name="Refer%C3%AAncias_na_internet"></a><h2> Refer&ecirc;ncias na internet </h2>&#10;&#10;<ul>&#10;<li>Com rela&ccedil;&atilde;o a detec&ccedil;&atilde;o de deadlock com v&aacute;rios recursos, existe um software educacional online, o <b>SISO 2.0</b>, que permite simular a implementa&ccedil;&atilde;o desse algoritmo (<a class="externallink" href="http://www.martins.eti.br/2009/03/siso&shy;20&shy;simulador&shy;de&shy;sistema.html" rel="nofollow" title="http://www.martins.eti.br/2009/03/siso&shy;20&shy;simulador&shy;de&shy;sistema.html">SISO 2.0 &shy; Simulador de Sistema Operacional</a>).</li>&#10;<li><a class="externallink" href="http://www&shy;asc.di.fct.unl.pt/~jcc/scpd&shy;05&shy;06/Teoricas/st1/node31.html&#38&semi;e=10401" rel="nofollow" title="http://www&shy;asc.di.fct.unl.pt/~jcc/scpd&shy;05&shy;06/Teoricas/st1/node31.html&#38&semi;e=10401">Tratamento de situa&ccedil;&otilde;es de deadlock</a></li>&#10;<li><a class="externallink" href="http://homepages.dcc.ufmg.br/~scampos/cursos/so/aulas/aula9.html" rel="nofollow" title="http://homepages.dcc.ufmg.br/~scampos/cursos/so/aulas/aula9.html">O que &eacute; um deadlock</a></li></ul>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Tecnologia_dos_sistemas_operacionais" id="w">Categoria:Tecnologia dos sistemas operacionais</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Computa%C3%A7%C3%A3o_concorrente" id="w">Categoria:Computa&ccedil;&atilde;o concorrente</a></p></body></html>