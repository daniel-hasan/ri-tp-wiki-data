<html><title>M&aacute;quina de estados finitos</title><body>&#10;<p> &#10; </p>&#10;<p>Uma <b>m&aacute;quina de estados finitos</b> (<b>FSM</b> &shy; do ingl&ecirc;s <i>Finite State Machine</i>) ou <b><a href="http://en.wikipedia.org/wiki/Aut%C3%B4mato" id="w">aut&ocirc;mato finito</a></b> &eacute; um <a href="http://en.wikipedia.org/wiki/Modelo_(matem%C3%A1tica)" id="w"> modelo matem&aacute;tico</a> usado para representar <a href="http://en.wikipedia.org/wiki/Programa_de_computador" id="w">programas de computadores</a> ou <a href="http://en.wikipedia.org/wiki/Porta_l%C3%B3gica" id="w">circuitos l&oacute;gicos</a>. O conceito &eacute; concebido como uma m&aacute;quina abstrata que deve estar em um de seus finitos estados. A m&aacute;quina est&aacute; em apenas um estado por vez, este estado &eacute; chamado de <i>estado atual</i>. Um estado armazena informa&ccedil;&otilde;es sobre o passado, isto &eacute;, ele reflete as mudan&ccedil;as desde a entrada num estado, no in&iacute;cio do sistema, at&eacute; o momento presente. Uma transi&ccedil;&atilde;o indica uma mudan&ccedil;a de estado e &eacute; descrita por uma condi&ccedil;&atilde;o que precisa ser realizada para que a transi&ccedil;&atilde;o ocorra. Uma a&ccedil;&atilde;o &eacute; a descri&ccedil;&atilde;o de uma atividade que deve ser realizada num determinado momento.</p>&#10;<p>M&aacute;quinas de estado finito podem modelar um grande n&uacute;mero de problemas, entre os quais a automa&ccedil;&atilde;o de design eletr&ocirc;nico, projeto de <a href="http://en.wikipedia.org/wiki/Protocolo_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">protocolo de comunica&ccedil;&atilde;o</a>, an&aacute;lise e outras aplica&ccedil;&otilde;es de engenharia. Na <a href="http://en.wikipedia.org/wiki/Biologia" id="w">biologia</a> e na pesquisa da <a href="http://en.wikipedia.org/wiki/Intelig%C3%AAncia_artificial" id="w">intelig&ecirc;ncia artificial</a>, m&aacute;quinas de estado ou hierarquias de m&aacute;quinas de estado s&atilde;o, por vezes, utilizadas para descrever sistemas neurol&oacute;gicos e em <a href="http://en.wikipedia.org/wiki/Lingu%C3%ADstica" id="w">lingu&iacute;stica</a> para descrever as gram&aacute;ticas das <a href="http://en.wikipedia.org/wiki/Linguagens_naturais" id="w">linguagens naturais</a>.</p>&#10;<a id="Conceitos_e_Vocabul%C3%A1rio" name="Conceitos_e_Vocabul%C3%A1rio"></a><h2> Conceitos e Vocabul&aacute;rio </h2>&#10;&#10;<p>Um estado descreve um n&oacute; de comportamento do sistema em que est&aacute; &agrave; espera de uma condi&ccedil;&atilde;o para executar uma transi&ccedil;&atilde;o. Normalmente, um estado &eacute; introduzido quando o sistema n&atilde;o reage da mesma forma para uma mesma condi&ccedil;&atilde;o. No exemplo de um sistema de r&aacute;dio de carro, quando se est&aacute; ouvindo uma esta&ccedil;&atilde;o de r&aacute;dio, o est&iacute;mulo &#34&semi;pr&oacute;ximo&#34&semi; significa ir para a pr&oacute;xima esta&ccedil;&atilde;o. Mas quando o sistema est&aacute; no estado de CD, o est&iacute;mulo &#34&semi;pr&oacute;ximo&#34&semi; significa ir para a pr&oacute;xima faixa. O mesmo est&iacute;mulo desencadeia a&ccedil;&otilde;es diferentes, dependendo do estado atual. Em algumas representa&ccedil;&otilde;es de estado finito m&aacute;quina, tamb&eacute;m &eacute; poss&iacute;vel associar a&ccedil;&otilde;es a um estado:</p>&#10;&#10;<ul>&#10;<li>A&ccedil;&atilde;o de entrada: o que &eacute; realizado ao entrar no estado,</li>&#10;<li>A&ccedil;&atilde;o de sa&iacute;da: o que &eacute; executado ao sair do estado.</li></ul>&#10;<p>A transi&ccedil;&atilde;o &eacute; um conjunto de a&ccedil;&otilde;es a serem executadas quando uma condi&ccedil;&atilde;o for cumprida ou quando um evento &eacute; recebido.&#10;M&aacute;quinas de estado s&atilde;o utilizadas para descrever circuitos sequenciais. Diferentemente de um contador que em geral conta eventos, uma m&aacute;quina de estado costuma ser usada para controlar o evento.</p>&#10;<p>A m&aacute;quina est&aacute; em apenas um estado por vez, este estado &eacute; chamado de estado atual. Um estado armazena informa&ccedil;&otilde;es sobre o passado, isto &eacute;, ele reflete as mudan&ccedil;as desde a entrada num estado, no in&iacute;cio do sistema, at&eacute; o momento presente. Uma transi&ccedil;&atilde;o indica uma mudan&ccedil;a de estado e &eacute; descrita por uma condi&ccedil;&atilde;o que precisa ser realizada para que a transi&ccedil;&atilde;o ocorra. Uma a&ccedil;&atilde;o &eacute; a descri&ccedil;&atilde;o de uma atividade que deve ser realizada num determinado momento.</p>&#10;<a id="Representa%C3%A7%C3%A3o" name="Representa%C3%A7%C3%A3o"></a><h2> Representa&ccedil;&atilde;o </h2>&#10;<p><div style="wigth:250px"><a class="internal" href="http://en.wikipedia.org/wiki/Image:250px&shy;SdlStateMachine.png" title="Fig. 1 Exemplo de m&aacute;quina de estados SDL"><img src="http://en.wikipedia.org/wiki/250px&shy;SdlStateMachine.png" alt="Fig. 1 Exemplo de m&aacute;quina de estados SDL" title="Fig. 1 Exemplo de m&aacute;quina de estados SDL" class="location&shy;right type&shy;thumb" width="250px" />&#10;</a>&#10;<div class="thumbcaption">Fig. 1 Exemplo de m&aacute;quina de estados SDL</div></div>&#10;&#10;<a href="http://en.wikipedia.org/wiki/File:Finite_state_machine_example_with_comments.svg%7Cthumb%7C250px%7Cright" id="w">Fig. 2 Exemplo de uma m&aacute;quina de estados finitos simples</a></p>&#10;<a id="Diagrama_de_estados" name="Diagrama_de_estados"></a><h3> Diagrama de estados </h3>&#10;<p>M&aacute;quinas de estados finitos podem ser representadas por meio de um diagrama de estados (ou <a href="http://en.wikipedia.org/wiki/Diagrama_de_transi%C3%A7%C3%A3o_de_estados" id="w">diagrama de transi&ccedil;&atilde;o de estados</a>). Diversas tabelas de transi&ccedil;&atilde;o de estados s&atilde;o usadas, a mais famosa &eacute; a mostrada abaixo. A combina&ccedil;&atilde;o do estado atual (ex: B) com uma condi&ccedil;&atilde;o (ex: Y) determina o pr&oacute;ximo estado (ex: C).&#10;Atrav&eacute;s do uso das tabelas podemos representar uma de m&aacute;quina finita de estados que contenha informa&ccedil;&otilde;es completas sobre as a&ccedil;&otilde;es.</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable" style="text&shy;align:center&semi; margin&shy;left:auto&semi; margin&shy;right:auto">&#10;<caption>Tabela de transi&ccedil;&atilde;o de estados</caption>&#10;<tr>&#10;<th>Estado Atual&#160&semi;&rarr; <br/> Condi&ccedil;&atilde;o&#160&semi;&darr; </th>&#10;<td>Estado A </td>&#10;<td>Estado B </td>&#10;<td>Estado C</td></tr>&#10;<tr>&#10;<th>Condi&ccedil;&atilde;o X</th>&#10;<td>... </td>&#10;<td>... </td>&#10;<td>...</td></tr>&#10;<tr>&#10;<th>Condi&ccedil;&atilde;o Y</th>&#10;<td>... </td>&#10;<td>Estado C </td>&#10;<td>...</td></tr>&#10;<tr>&#10;<th>Condi&ccedil;&atilde;o Z</th>&#10;<td>... </td>&#10;<td>... </td>&#10;<td>...</td></tr></table></div>&#10;&#10;<a id="M%C3%A1quinas_de_estados_UML" name="M%C3%A1quinas_de_estados_UML"></a><h3> M&aacute;quinas de estados UML </h3>&#10;&#10;<p>A <b><a href="http://en.wikipedia.org/wiki/UML" id="w">UML</a></b> tem uma nota&ccedil;&atilde;o para descrever m&aacute;quinas de estado. M&aacute;quinas de estado UML superam as limita&ccedil;&otilde;es das FSMs tradicionais, mantendo os seus principais benef&iacute;cios. M&aacute;quinas de estados UML introduzem os novos conceitos de estados aninhados hierarquicamente e regi&otilde;es ortogonais, enquanto estende a no&ccedil;&atilde;o de a&ccedil;&otilde;es. M&aacute;quinas de estado UML t&ecirc;m as caracter&iacute;sticas de ambas as m&aacute;quinas de Mealy e Moore. Elas suportam a&ccedil;&otilde;es que dependem tanto do estado do sistema quanto da condi&ccedil;&atilde;o, como em m&aacute;quinas de Mealy, assim como a&ccedil;&otilde;es de entrada e sa&iacute;da que est&atilde;o associadas com os estados em vez de transi&ccedil;&otilde;es, como em m&aacute;quinas de Moore.</p>&#10;<a id="M%C3%A1quinas_de_estados_SDL" name="M%C3%A1quinas_de_estados_SDL"></a><h3> M&aacute;quinas de estados SDL </h3>&#10;&#10;<p>A <b><a href="http://en.wikipedia.org/wiki/SDL_(linguagem)" id="w"> SDL</a></b> &eacute; um padr&atilde;o da <a href="http://en.wikipedia.org/wiki/Uni%C3%A3o_Internacional_de_Telecomunica%C3%A7%C3%B5es" id="w">Uni&atilde;o Internacional de Telecomunica&ccedil;&otilde;es</a> e &eacute; uma das melhores linguagens para descrever m&aacute;quinas de estado, pois inclui s&iacute;mbolos gr&aacute;ficos para descrever as a&ccedil;&otilde;es na transi&ccedil;&atilde;o:</p>&#10;&#10;<ul>&#10;<li>enviar um evento</li>&#10;<li>receber um evento</li>&#10;<li>iniciar um temporizador</li>&#10;<li>cancelar um temporizador</li>&#10;<li>iniciar uma nova m&aacute;quina de estado simult&acirc;nea</li>&#10;<li>decis&atilde;o</li></ul>&#10;<p>SDL incorpora tipos b&aacute;sicos de dados chamado Abstract Data Types, uma linguagem de a&ccedil;&atilde;o, e uma sem&acirc;ntica de execu&ccedil;&atilde;o, a fim de tornar a m&aacute;quina de estados finitos execut&aacute;vel. Um exemplo &eacute; visto na figura 1.</p>&#10;<a id="Outros_diagramas_de_estado" name="Outros_diagramas_de_estado"></a><h3> Outros diagramas de estado </h3>&#10;&#10;<p>Existem v&aacute;rias outras maneiras de se representar uma FSM, assim como mostrado na figura 2.</p>&#10;<p>Um exemplo &eacute; o HDL:</p>&#10;<p>Em HDL (Hardware Description Language) ou LDH(<a href="http://en.wikipedia.org/wiki/Linguagem_de_descri%C3%A7%C3%A3o_de_hardware" id="w">Linguagem de Descri&ccedil;&atilde;o de Hardware</a>) &eacute; poss&iacute;vel criar m&aacute;quinas de estado simples e de descri&ccedil;&atilde;o intuitiva. &Eacute; feito o uso de estados nomeados para os quais n&atilde;o h&aacute; valores bin&aacute;rios definidos.&#10;Em <a href="http://en.wikipedia.org/wiki/VHDL" id="w">VHDL</a> existem as palavras&shy;chave como TYPE por exemplo, que define o tipo enumerado em <a href="http://en.wikipedia.org/wiki/VHDL" id="w">VHDL</a>. O projetista lista em nomes simb&oacute;licos (diferentes das palavras&shy;chave) todos os poss&iacute;veis valores que um sinal, vari&aacute;vel ou porto que &eacute; declarado como sendo deste tipo pode assumir. O <a href="http://en.wikipedia.org/wiki/Bin%C3%A1rio" id="w">valor bin&aacute;rio</a> &eacute; determinado pelo <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compilador</a>, deixando o trabalho do projetista mais simples.</p>&#10;<a id="Uso" name="Uso"></a><h2> Uso </h2>&#10;&#10;<p>Al&eacute;m de seu uso na modelagem de sistemas reativos aqui apresentados, aut&ocirc;matos de estados finitos s&atilde;o significativos em diversas &aacute;reas, incluindo <a href="http://en.wikipedia.org/wiki/Engenharia_el%C3%A9trica" id="w">engenharia el&eacute;trica</a>, lingu&iacute;stica, <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">ci&ecirc;ncia da computa&ccedil;&atilde;o</a>, <a href="http://en.wikipedia.org/wiki/Filosofia" id="w">filosofia</a>, biologia, <a href="http://en.wikipedia.org/wiki/Matem%C3%A1tica" id="w">matem&aacute;tica</a> e <a href="http://en.wikipedia.org/wiki/L%C3%B3gica" id="w">l&oacute;gica</a>. M&aacute;quinas de estados finitos s&atilde;o uma classe de aut&ocirc;matos estudada na <a href="http://en.wikipedia.org/wiki/Teoria_dos_aut%C3%B4matos" id="w">teoria dos aut&ocirc;matos</a> e <a href="http://en.wikipedia.org/wiki/Teoria_da_computa%C3%A7%C3%A3o" id="w">teoria da computa&ccedil;&atilde;o</a>. Em ci&ecirc;ncia da computa&ccedil;&atilde;o, m&aacute;quinas de estados finitos s&atilde;o amplamente utilizados na modelagem do comportamento do aplicativo, design de sistemas digitais de hardware, engenharia de software, compiladores, protocolos de rede, e o estudo da computa&ccedil;&atilde;o e linguagens.</p>&#10;<a id="Classifica%C3%A7%C3%A3o" name="Classifica%C3%A7%C3%A3o"></a><h2> Classifica&ccedil;&atilde;o </h2>&#10;<p>Existem dois grupos: Aceitadores/Reconhecedores e Transdutores.</p>&#10;<a id="Aceitadores_e_reconhecedores" name="Aceitadores_e_reconhecedores"></a><h3> Aceitadores e reconhecedores </h3>&#10;<p><a href="http://en.wikipedia.org/wiki/File:Fsm_parsing_word_nice.svg%7Cthumb%7C400px%7Cright" id="w">Fig. 3 FSM aceitador: analisando a palavra &#34&semi;nice&#34&semi;</a></p>&#10;<p>Aceitadores e reconhecedores produzem uma sa&iacute;da bin&aacute;ria, dizendo sim ou n&atilde;o para responder se a entrada &eacute; aceita pela m&aacute;quina ou n&atilde;o. Todos os estados do FSM est&atilde;o a dizer se quer aceitar ou n&atilde;o quer aceitar. No momento em que todas as entradas s&atilde;o processadas, se o estado atual &eacute; um estado de aceita&ccedil;&atilde;o, a entrada &eacute; aceita, caso contr&aacute;rio &eacute; rejeitada. Como regra a entrada s&atilde;o s&iacute;mbolos (caracteres)&semi; a&ccedil;&otilde;es n&atilde;o s&atilde;o usadas. O exemplo da figura 3 mostra uma m&aacute;quina de estados finitos que aceita a palavra &#34&semi;nice&#34&semi;. Neste FSM o &uacute;nico estado de aceita&ccedil;&atilde;o &eacute; o n&uacute;mero 7.</p>&#10;<p>A m&aacute;quina tamb&eacute;m pode ser descrita como a defini&ccedil;&atilde;o de uma linguagem, que conteria todas as palavras aceitas pela m&aacute;quina e nenhuma das que s&atilde;o rejeitadas&semi; dizemos ent&atilde;o que a linguagem &eacute; aceita pela m&aacute;quina. Por defini&ccedil;&atilde;o, linguagens aceitas por FSMs s&atilde;o as <a href="http://en.wikipedia.org/wiki/Linguagens_regulares" id="w">linguagens regulares</a>, isto &eacute;, uma linguagem &eacute; regular se existe alguma FSM que a aceita.</p>&#10;<a id="Estado_Inicial" name="Estado_Inicial"></a><h4> Estado Inicial </h4>&#10;&#10;<p>O estado inicial &eacute; geralmente mostrado desenhando uma seta &#34&semi;apontando para ele a partir de qualquer lugar&#34&semi; (Sipser (2006) p. 34).</p>&#10;<a id="Estados_de_aceita%C3%A7%C3%A3o_(ou_Estados_Finais)" name="Estados_de_aceita%C3%A7%C3%A3o_(ou_Estados_Finais)"></a><h4> Estados de aceita&ccedil;&atilde;o (ou Estados Finais) </h4>&#10;<p><a href="http://en.wikipedia.org/wiki/File:DFAexample.svg%7C220px%7Cright%7Cthumb" id="w">Fig. 4: Representa&ccedil;&atilde;o de uma FSM. Este exemplo mostra uma FSM que determina se um n&uacute;mero bin&aacute;rio tem um n&uacute;mero par ou &iacute;mpar de 0&#39&semi;s, onde S&#60&semi;sub&#62&semi;1&#60&semi;/sub&#62&semi; &eacute; um &#39&semi;&#39&semi;&#39&semi;estado de aceita&ccedil;&atilde;o&#39&semi;&#39&semi;&#39&semi;.</a></p>&#10;<p>Estados de aceita&ccedil;&atilde;o s&atilde;o aqueles em que a m&aacute;quina relata que a seq&uuml;&ecirc;ncia de entrada, como processadas &#8203;&#8203;at&eacute; agora, &eacute; membro da linguagem que ela aceita. &Eacute; geralmente representado por um c&iacute;rculo duplo.&#10;Um exemplo de um estado de aceita&ccedil;&atilde;o aparece na figura 4: um <a href="http://en.wikipedia.org/wiki/Aut%C3%B4mato_finito_determin%C3%ADstico" id="w">aut&ocirc;mato finito determin&iacute;stico</a> (AFD) que detecta se a seq&uuml;&ecirc;ncia de entrada <a href="http://en.wikipedia.org/wiki/Codifica%C3%A7%C3%A3o_bin%C3%A1ria_decimal" id="w">bin&aacute;ria</a> cont&eacute;m um n&uacute;mero par de 0&#39&semi;s.&#10;S<sub>1</sub> (que tamb&eacute;m &eacute; o estado inicial) indica o estado no qual um n&uacute;mero par de 0&#39&semi;s foi dado na entrada. S<sub>1</sub> &eacute;, portanto, um estado de aceita&ccedil;&atilde;o. Esta m&aacute;quina vai terminar em um estado de aceita&ccedil;&atilde;o se a seq&uuml;&ecirc;ncia bin&aacute;ria cont&eacute;m um n&uacute;mero par de 0&#39&semi;s (incluindo qualquer seq&uuml;&ecirc;ncia bin&aacute;ria que n&atilde;o contenham 0&#39&semi;s). Exemplos de cadeias aceitas por este AFD s&atilde;o: epsilon (a cadeia vazia), 1, 11, 11 ..., 00, 010, 1010, 10110, etc.</p>&#10;<a id="Transdutores" name="Transdutores"></a><h3> Transdutores </h3>&#10;<p><a href="http://en.wikipedia.org/wiki/Transdutores" id="w">Transdutores</a> geram uma sa&iacute;da baseada em uma entrada e/ou um estado utilizando a&ccedil;&otilde;es. Eles s&atilde;o utilizados para aplica&ccedil;&otilde;es de controle.</p> &#10;<p>A sa&iacute;da produzida por um contador ou uma <a href="http://en.wikipedia.org/wiki/M%C3%A1quina_de_estado" id="w">m&aacute;quina de estado</a> pode vir diretamente das sa&iacute;das do <a href="http://en.wikipedia.org/wiki/Flip&shy;flop" id="w">flip&shy;flop</a>, ou alguns <a href="http://en.wikipedia.org/wiki/Circuitos_l%C3%B3gicos" id="w">circuitos l&oacute;gicos</a>. As duas varia&ccedil;&otilde;es s&atilde;o chamadas de modelo Mealy de circuitos sequencial e modelo Moore. </p>&#10;<p>No modelo Mealy, os sinais de sa&iacute;da tamb&eacute;m s&atilde;o controlados por sinais de entrada adicionais, enquanto o modelo Moore n&atilde;o possui nenhum controle externos para os sinais de sa&iacute;da gerados.A sa&iacute;da do modelo Moore &eacute; fun&ccedil;&atilde;o apenas do estado atual do <a href="http://en.wikipedia.org/wiki/Flip&shy;flop" id="w">flip&shy;flop</a>. </p>&#10;<p>As sa&iacute;das de um circuito de tipo Moore ser&atilde;o completamente s&iacute;ncronas em rela&ccedil;&atilde;o ao clock do <a href="http://en.wikipedia.org/wiki/Circuito" id="w">circuito</a>, enquanto sa&iacute;das produzidas por um circuito de tipo Mealy podem mudar assincronamente.</p>&#10;<dl><dt><a href="http://en.wikipedia.org/wiki/M%C3%A1quina_de_Moore" id="w">M&aacute;quina de Moore</a></dt><dd>A FSM utiliza apenas a&ccedil;&otilde;es de entrada, i.e. a sa&iacute;da depende somente do estado. A vantagem do modelo de Moore &eacute; a simplifica&ccedil;&atilde;o do comportamento. Consideremos por exemplo uma FSM de Moore de uma porta de elevador com 4 estados &#34&semi;Aberta&#34&semi;, &#34&semi;Fechada&#34&semi;, &#34&semi;Abrindo&#34&semi;, &#34&semi;Fechando&#34&semi;. A m&aacute;quina de estados reconhece dois comandos: &#34&semi;comando_abrir&#34&semi; e &#34&semi;comando_fechar&#34&semi; que disparam a altera&ccedil;&atilde;o de estado. A a&ccedil;&atilde;o de entrada (E:) no estado &#34&semi;Abrindo&#34&semi; liga o motor que abre a porta, a a&ccedil;&atilde;o de entrada no estado &#34&semi;Fechando&#34&semi; liga o motor na outra dire&ccedil;&atilde;o, fechando a porta. Os estados &#34&semi;Aberta&#34&semi; e &#34&semi;Fechada&#34&semi; n&atilde;o desempenham nenhuma a&ccedil;&atilde;o. Eles sinalizam para o mundo externo (e.g. para outras m&aacute;quinas de estado) a situa&ccedil;&atilde;o: &#34&semi;porta est&aacute; aberta&#34&semi; ou &#34&semi;porta est&aacute; fechada&#34&semi;.</dd></dl>&#10;<p><a href="http://en.wikipedia.org/wiki/File:Fsm_mealy_model_door_control.jpg%7Cthumb%7C350px%7Cright" id="w">Fig. 5 FSM transdutor: exemplo do modelo de Mealy</a></p>&#10;<dl><dt><a href="http://en.wikipedia.org/wiki/M%C3%A1quina_de_Mealy" id="w">M&aacute;quina de Mealy</a></dt><dd>A FSM utiliza apenas input actions, i.e. a sa&iacute;da depende da entrada e do estado. O uso de uma FSM de Mealy normalmente leva a uma redu&ccedil;&atilde;o no n&uacute;mero de estados. Por exemplo uma FSM de Mealy implementando o mesmo comportamento visto no exemplo de Moore (o comportamento depende no modelo de execu&ccedil;&atilde;o implementado na FSM e ir&aacute; funcionar e.g. para uma FSM virtual mas n&atilde;o para uma FSM de eventos dirigidos). Existem duas input actions(I:): &ldquo;inicie o motor para fechar a porta se o comando_fechar (<i>sensor_closed</i> na figura 5) chegar&rdquo; e &ldquo;inicie o motor na dire&ccedil;&atilde;o oposta para abrir a porta se o comando_abrir (<i>sensor_opened</i> na figura 5) chegar&rdquo;.</dd></dl>&#10;<p>Na pr&aacute;tica modelos mistos s&atilde;o muito utilizados.</p>&#10;<p>Mais detalhes sobre as diferen&ccedil;as e usos dos modelos de Moore e Mealy, incluindo um exemplo execut&aacute;vel, podem ser encontrados na  nota t&eacute;cnica externa <a class="externallink" href="http://www.stateworks.com/active/content/en/technology/technical_notes.php#tn10" rel="nofollow" title="http://www.stateworks.com/active/content/en/technology/technical_notes.php#tn10">&#34&semi;Modelo de Moore ou Mealy?&#34&semi;</a>(documento em ingl&ecirc;s)</p>&#10;<a id="Determinismo" name="Determinismo"></a><h3> Determinismo </h3>&#10;&#10;<p>Uma distin&ccedil;&atilde;o adicional est&aacute; entre aut&ocirc;mato <b>determin&iacute;stico</b> (<a href="http://en.wikipedia.org/wiki/Aut%C3%B4matos_finitos_determin%C3%ADsticos" id="w">AFD</a>) e <b>n&atilde;o&shy;determin&iacute;stico</b> (<a href="http://en.wikipedia.org/wiki/Aut%C3%B4matos_finitos_n%C3%A3o_determin%C3%ADsticos" id="w">AFN</a>). No aut&ocirc;mato determin&iacute;stico, para cada estado h&aacute; exatamente uma transi&ccedil;&atilde;o para cada entrada poss&iacute;vel. No aut&ocirc;mato n&atilde;o determin&iacute;stico, pode haver nenhuma, uma ou mais de uma transi&ccedil;&atilde;o de um determinado estado para uma entrada poss&iacute;vel.</p>&#10;<p>A FSM com apenas um estado &eacute; chamada de FSM combinat&oacute;ria e utiliza apenas input actions. Este conceito &eacute; &uacute;til quando um n&uacute;mero de FSM devem trabalhar juntas, e onde &eacute; conveniente considerar uma parte puramente combinat&oacute;ria como uma forma de FSM para se adequar &agrave;s ferramentas de projeto.</p>&#10;<a id="Sem%C3%A2nticas_Alternativas" name="Sem%C3%A2nticas_Alternativas"></a><h2> Sem&acirc;nticas Alternativas </h2>&#10;&#10;<p>H&aacute; outros conjuntos de sem&acirc;ntica dispon&iacute;vel para representar m&aacute;quinas de estado. Por exemplo, existem ferramentas para modelagem e l&oacute;gica para projetar controladores incorporados.<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup> Eles combinam m&aacute;quinas de estado hier&aacute;rquico, gr&aacute;ficos de fluxo e tabelas de verdade para uma linguagem, resultando em um diferente formalismo e conjunto de sem&acirc;ntica.<sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup> A Figura 6 ilustra esta mistura de m&aacute;quinas de estado e gr&aacute;ficos de fluxo com um conjunto de estados para representar o estado de um cron&ocirc;metro e um gr&aacute;fico de fluxo para controlar os tiques do rel&oacute;gio. Estes gr&aacute;ficos, como m&aacute;quinas de estado originais de Harel,<sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup> apoiam os estados hierarquicamente aninhados, regi&otilde;es ortogonais, a&ccedil;&otilde;es do estado, e as a&ccedil;&otilde;es de transi&ccedil;&atilde;o.<sup id="_ref&shy;4" class="reference"><a href="#_note&shy;4" title="">[4]</a></sup></p>&#10;<a id="L%C3%B3gica_da_FSM" name="L%C3%B3gica_da_FSM"></a><h2> L&oacute;gica da FSM </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/File:Finite_State_Machine_Logic.svg%7Cthumb%7C200px%7Cright" id="w">Fig. 6 L&oacute;gica da FSM (Mealy)</a></p>&#10;<p>O pr&oacute;ximo estado e a sa&iacute;da de uma FSM s&atilde;o uma fun&ccedil;&atilde;o da entrada e do atual estado. A l&oacute;gica da FSM &eacute; mostrada na figura 6.</p>&#10;<a id="Modelo_matem%C3%A1tico" name="Modelo_matem%C3%A1tico"></a><h2> Modelo matem&aacute;tico </h2>&#10;<p>Dependendo do tipo podem haver v&aacute;rias defini&ccedil;&otilde;es.</p>&#10;<p>Uma m&aacute;quina de estados finitos tipo <b>aceitador</b> &eacute; uma <a href="http://en.wikipedia.org/wiki/Enupla" id="w">qu&iacute;ntupla</a> &#60&semi;<i>&Sigma;</i>, <i>S</i>, <i>s<sub>0</sub></i>, <i>&delta;</i>, <i>F</i>&#62&semi;, onde:&#10;</p>&#10;<ul>&#10;<li><i>&Sigma;</i> &eacute; o alfabeto de entrada (um conjunto de s&iacute;mbolos finitos n&atilde;o vazio),</li>&#10;<li><i>S</i> &eacute; um conjunto finito de estados n&atilde;o vazio,</li>&#10;<li><i>s<sub>0</sub></i> &eacute; o estado inicial, um elemento de <i>S</i>,</li>&#10;<li><i>&delta;</i> &eacute; a fun&ccedil;&atilde;o de transi&ccedil;&atilde;o de estados: <i>&delta;</i>: <i>S</i> x <i>&Sigma;</i> &rarr; <i>S</i> (em um AFN, seria <i>&delta;</i>: <i>S</i> x <i>&Sigma;</i> &rarr; <i>P</i>(<i>S</i>), isto &eacute;, <i>&delta;</i>iria retornar um conjunto de estados),</li>&#10;<li><i>F</i> &eacute; o conjunto de estados finais, um (possivelmente vazio) subconjunto de S.</li></ul>&#10;<p>Para ambos os FSMs determin&iacute;sticas e n&atilde;o&shy;deterministica, &eacute; convencional para permitir <i>&delta;</i> ser uma fun&ccedil;&atilde;o parcial, ou seja, <i>&delta;</i>(q, x) n&atilde;o tem que ser definida para cada combina&ccedil;&atilde;o de q <span class="math"> \isin </span> <i>S</i> e x <span class="math"> \isin </span> <i>&Sigma;</i>. Se uma FSM M est&aacute; em um estado q, o s&iacute;mbolo seguinte &eacute; x e <i>&delta;</i>(q, x) n&atilde;o est&aacute; definida, ent&atilde;o M pode anunciar um erro (ou seja, rejeitar a entrada). Isso &eacute; &uacute;til em defini&ccedil;&otilde;es de m&aacute;quinas de estado em geral, mas menos &uacute;til ao transformar a m&aacute;quina. Alguns algoritmos em sua forma padr&atilde;o podem exigir fun&ccedil;&otilde;es totais.</p>&#10;<p>Uma m&aacute;quina de estados finitos &eacute; uma m&aacute;quina de Turing restrita em que a cabe&ccedil;a s&oacute; pode &#34&semi;ler&#34&semi; as opera&ccedil;&otilde;es, e sempre se move da esquerda para a direita.<sup id="_ref&shy;5" class="reference"><a href="#_note&shy;5" title="">[5]</a></sup></p>&#10;<p>Uma m&aacute;quina de estados finitos tipo <b>transdutor</b> &eacute; uma <a href="http://en.wikipedia.org/wiki/Enupla" id="w">s&ecirc;xtupla</a> &#60&semi;<i>&Sigma;</i>, <i>&Gamma;</i>, <i>S</i>, <i>s<sub>0</sub></i>, <i>&delta;</i>, <i>&omega;</i>&#62&semi;, onde:&#10;</p>&#10;<ul>&#10;<li><i>&Sigma;</i> &eacute; o alfabeto de entrada (um conjunto de s&iacute;mbolos finitos n&atilde;o vazio),</li>&#10;<li><i>&Gamma;</i> &eacute; o alfabeto de sa&iacute;da (um conjunto de s&iacute;mbolos finitos n&atilde;o vazio),</li>&#10;<li><i>S</i> &eacute; um conjunto finito de estados n&atilde;o vazio,</li>&#10;<li><i>s<sub>0</sub></i> &eacute; o estado inicial, um elemento de <i>S</i>,</li>&#10;<li><i>&delta;</i> &eacute; a fun&ccedil;&atilde;o de transi&ccedil;&atilde;o de estados: <i>&delta;</i>: <i>S</i> x <i>&Sigma;</i> &rarr; <i>S</i> (em um AFN, seria <i>&delta;</i>: <i>S</i> x <i>&Sigma;</i> &rarr; <i>P</i>(<i>S</i>), isto &eacute;, <i>&delta;</i>iria retornar um conjunto de estados),</li>&#10;<li><i>&omega;</i> &eacute; a fun&ccedil;&atilde;o de sa&iacute;da.</li></ul>&#10;<p>Se a fun&ccedil;&atilde;o de sa&iacute;da &eacute; uma fun&ccedil;&atilde;o do estado e do alfabeto de entrada (<i>&omega;</i>: <i>S</i> x <i>&Sigma;</i> &rarr; <i>&Gamma;</i> )essa defini&ccedil;&atilde;o corresponde ao <b>modelo de Mealy</b>. Se a fun&ccedil;&atilde;o de sa&iacute;da depende somente do estado (<i>&omega;</i>: <i>S</i> &rarr; <i>&Gamma;</i> ) essa defini&ccedil;&atilde;o corresponde ao <b>modelo de Moore</b>.</p>&#10;<p>Se desconsiderarmos o s&iacute;mbolo primeira sa&iacute;da de uma m&aacute;quina de Moore, <i>&omega;(s<sub>0</sub>)</i>, ent&atilde;o ela pode ser facilmente convertida em uma m&aacute;quina de Mealy de sa&iacute;da equivalente definindo a fun&ccedil;&atilde;o de sa&iacute;da de cada transi&ccedil;&atilde;o da de Mealy (isto &eacute;, rotulando cada extremidade) com o s&iacute;mbolo de sa&iacute;da dado ao estado de destino da de Moore. A transforma&ccedil;&atilde;o inversa &eacute; menos simples, porque um estado da m&aacute;quina de Mealy pode ter r&oacute;tulos de sa&iacute;da diferentes em suas transi&ccedil;&otilde;es de entrada (extremidades). Cada estado tem de ser dividido em v&aacute;rios estados da m&aacute;quina de Moore, uma para cada s&iacute;mbolo de sa&iacute;da incidente.<sup id="_ref&shy;AndersonHead2006_a" class="reference"><a href="#_note&shy;AndersonHead2006" title="">[6]</a></sup></p>&#10;<p> </p>&#10;<a id="Implementa%C3%A7%C3%A3o" name="Implementa%C3%A7%C3%A3o"></a><h2> Implementa&ccedil;&atilde;o </h2>&#10;<a id="Aplica%C3%A7%C3%B5es_de_Hardware" name="Aplica%C3%A7%C3%B5es_de_Hardware"></a><h3> Aplica&ccedil;&otilde;es de Hardware </h3>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:4_bit_counter.svg%7Cright%7Cthumbnail%7C250px" id="w">Fig. 7 O [[diagrama de circuito]] para um &#10;contador TTL de 4bits, um tipo de m&aacute;quina de estadosEm</a> um <a href="http://en.wikipedia.org/wiki/Circuito_digital" id="w">circuito digital</a>, uma FSM pode ser constru&iacute;da utilizando um <a href="http://en.wikipedia.org/wiki/Dispositivo_l%C3%B3gico_program%C3%A1vel" id="w">dispositivo l&oacute;gico program&aacute;vel</a>. Um <a href="http://en.wikipedia.org/wiki/Controlador_l%C3%B3gico_program%C3%A1vel" id="w">controlador l&oacute;gico program&aacute;vel</a>, <a href="http://en.wikipedia.org/wiki/Porta_l%C3%B3gica" id="w">portas l&oacute;gicas</a> e <a href="http://en.wikipedia.org/wiki/Flip&shy;flop" id="w">flip&shy;flops</a> ou <a href="http://en.wikipedia.org/wiki/Relay" id="w">relays</a>. Mais especificamente, a implementa&ccedil;&atilde;o de hardware requer um <a href="http://en.wikipedia.org/wiki/Registrador" id="w">registrador</a> para armazenar o estado das vari&aacute;veis, um bloco de l&oacute;gica combinacional que determina o estado de transi&ccedil;&atilde;o e um segundo bloco de l&oacute;gica combinacional que determina a sa&iacute;da da FSM.&#10;O mais famoso &eacute; o controlador de Richards</p>&#10;<p>M&aacute;quinas de Mealy e de Moore produzem l&oacute;gica com sa&iacute;da ass&iacute;ncrona, porque h&aacute; um atraso de propaga&ccedil;&atilde;o entre o flip&shy;flop e sa&iacute;da. Isso causa frequ&ecirc;ncias mais lentas operando na FSM. Uma m&aacute;quina de Mealy ou de de Moore pode ser convertida para uma FSM tal qual a sa&iacute;da &eacute; diretamente de um flip&shy;flop, o que faz a FSM funcionar em frequ&ecirc;ncias mais altas. Este tipo de FSM &eacute; chamado &agrave;s vezes FSM de Medvedev.<sup id="_ref&shy;7" class="reference"><a href="#_note&shy;7" title="">[7]</a></sup> Um contador &eacute; a forma mais simples desse tipo de FSM.</p>&#10;<a id="Aplica%C3%A7%C3%B5es_de_Software" name="Aplica%C3%A7%C3%B5es_de_Software"></a><h3> Aplica&ccedil;&otilde;es de Software </h3>&#10;&#10;<p>Os seguintes conceitos s&atilde;o comumente usados para construir aplica&ccedil;&otilde;es de software com m&aacute;quinas de estados finitos:&#10;</p>&#10;<ul>&#10;<li>Programa&ccedil;&atilde;o baseada em aut&ocirc;matos</li>&#10;<li>FSM orientada a eventos</li>&#10;<li>FSM Virtual (VFSM)</li></ul>&#10;<a id="Refer%C3%AAncias" name="Refer%C3%AAncias"></a><h2> Refer&ecirc;ncias </h2>&#10;<p> &#10;</p>&#10;<ul>&#10;<li>Timothy Kam, <i>Synthesis of Finite State Machines: Functional Optimization</i>. Kluwer Academic Publishers, Boston 1997, <a class="external text" href="http://www.amazon.com/exec/obidos/ASIN/0792398424" rel="nofollow" title="http://www.amazon.com/exec/obidos/ASIN/0792398424">ISBN 0&shy;7923&shy;9842&shy;4</a></li>&#10;<li>Tiziano Villa, <i>Synthesis of Finite State Machines: Logic Optimization</i>. Kluwer Academic Publishers, Boston 1997, <a class="external text" href="http://www.amazon.com/exec/obidos/ASIN/0792398920" rel="nofollow" title="http://www.amazon.com/exec/obidos/ASIN/0792398920">ISBN 0&shy;7923&shy;9892&shy;0</a></li>&#10;<li>Carroll, J., Long, D. , <i>Theory of Finite Automata with an Introduction to Formal Languages</i>. Prentice Hall. Englewood Cliffs, 1989.</li>&#10;<li>Hopcroft, J.E., Ullman, J.D., <i>Introduction to Automata Theory, Languages and Computation</i>. Addison &shy;Wesley, 1979.</li>&#10;<li>Kohavi, Z., <i>Switching and Finite Automata Theory</i>. McGraw&shy;Hill, 1978.</li>&#10;<li>Gill, A., <i>Introduction to the Theory of Finite&shy;state Machines</i>. McGraw&shy;Hill, 1962.</li>&#10;<li>Cassandras, C., Lafortune, S., &#34&semi;Introduction to Discrete Event Systems&#34&semi;. Kluwer, 1999, <a class="external text" href="http://www.amazon.com/exec/obidos/ASIN/0792386094" rel="nofollow" title="http://www.amazon.com/exec/obidos/ASIN/0792386094">ISBN 0&shy;7923&shy;8609&shy;4</a></li>&#10;<li>Tocci, Ronald J., &#34&semi;Sistemas digitais:Princ&iacute;pios e aplica&ccedil;&otilde;es.&#34&semi;, 10&ordf; edi&ccedil;&atilde;o, 2007</li></ul>&#10;<a id="%7B%7BLinks_externos%7D%7D" name="%7B%7BLinks_externos%7D%7D"></a><h2>   </h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?query=finite+state+machine" rel="nofollow" title="http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?query=finite+state+machine">Description from the Free On&shy;Line Dictionary of Computing</a></li>&#10;<li>NIST Dictionary of Algorithms and Data Structures <a class="externallink" href="http://www.nist.gov/dads/HTML/finiteStateMachine.html" rel="nofollow" title="http://www.nist.gov/dads/HTML/finiteStateMachine.html">entry</a></li>&#10;<li><a class="externallink" href="http://www.eventhelix.com/RealtimeMantra/HierarchicalStateMachine.htm" rel="nofollow" title="http://www.eventhelix.com/RealtimeMantra/HierarchicalStateMachine.htm">Hierarchical State Machines</a></li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Teoria_da_computa%C3%A7%C3%A3o" id="w">Categoria:Teoria da computa&ccedil;&atilde;o</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:M%C3%A9todos_formais" id="w">Categoria:M&eacute;todos formais</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Eletr%C3%B4nica_digital" id="w">Categoria:Eletr&ocirc;nica digital</a></p></body></html>