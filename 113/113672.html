<html><title>Occam (linguagem de programa&ccedil;&atilde;o)</title><body>&#10;<p> &#10; &#10; &#10; </p>&#10;<p><b>occam</b> (de <a href="http://en.wikipedia.org/wiki/William_de_Ockham" id="w">William de Ockham</a>, da <a href="http://en.wikipedia.org/wiki/Navalha_de_Occam" id="w">Navalha de Occam</a>) &eacute; uma <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagem de programa&ccedil;&atilde;o</a> utilizada em <a href="http://en.wikipedia.org/wiki/Computa%C3%A7%C3%A3o_paralela" id="w">computa&ccedil;&atilde;o paralela</a> que constr&oacute;i uma seq&uuml;&ecirc;ncia de processos seq&uuml;enciais de comunica&ccedil;&atilde;o (<a href="http://en.wikipedia.org/wiki/CSP" id="w">CSPs</a>) que compartilham muitas de suas caracter&iacute;sticas<sup id="_ref&shy;oc21refman_a" class="reference"><a href="#_note&shy;oc21refman" title="">[1]</a></sup>. Desta forma, &eacute; uma implementa&ccedil;&atilde;o pr&aacute;tica do CSP.</p>&#9;&#10;<p>Occam &eacute; uma linguagem imperativa processual (como o <a href="http://en.wikipedia.org/wiki/Pascal_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Pascal</a>). Ela foi desenvolvida por David May e outros da INMOS, aconselhada por Tony Hoare, como a l&iacute;ngua nativa de programa&ccedil;&atilde;o para os seus microprocessadores, embora implementa&ccedil;&otilde;es para outras plataformas est&atilde;o dispon&iacute;veis. A vers&atilde;o mais conhecida &eacute; Occam 2&semi; O manual da linguagem de programa&ccedil;&atilde;o Occam 2 foi feito em conjunto por Steven Ericsson&shy;Zenith e outros em INMOS.</p>&#10;<a id="Vis%C3%A3o_geral" name="Vis%C3%A3o_geral"></a><h2> Vis&atilde;o geral </h2>&#10;<p>Nos exemplos a seguir a indenta&ccedil;&atilde;o e a formata&ccedil;&atilde;o s&atilde;o aspectos cr&iacute;ticos para se analisar o c&oacute;digo: express&otilde;es s&atilde;o terminadas por um fim de linha, listas de express&otilde;es precisam estar no mesmo n&iacute;vel de indenta&ccedil;&atilde;o (esse recurso, tamb&eacute;m conhecido como a regra de <i>off&shy;side</i>, tamb&eacute;m &eacute; encontrado em outras linguagens).</p>&#9;&#10;<p>Comunica&ccedil;&atilde;o entre processos trabalham atrav&eacute;s dos chamados <i>canais</i>. Um processo emite sa&iacute;das de dados para um canal atrav&eacute;s de um <b>&#34&semi;!&#34&semi;</b> enquanto outro fornece entradas de dados com um <b>&#34&semi;?&#34&semi;</b>. Entrada e sa&iacute;da ir&atilde;o bloquear at&eacute; que a outra extremidade esteja pronta para aceitar ou oferecer dados. Exemplos (c &eacute; uma vari&aacute;vel):</p>&#10;<pre> keyboard ? c&#10;&#10; screen ! c&#10;</pre>&#10;<p><b>SEQ</b> introduz uma lista de express&otilde;es que s&atilde;o avaliadas sequencialmente. Isto n&atilde;o est&aacute; impl&iacute;cito como na maioria das outras linguagens de programa&ccedil;&atilde;o. Exemplo:</p>&#10;<pre> SEQ&#10;   x := x + 1&#10;   y := x * x&#10;</pre>&#10;<p><b>PAR</b> inicia uma lista de express&otilde;es que podem ser avaliadas concorrentemente. Exemplo:</p>&#10;<pre> PAR&#10;   p()&#10;   q()&#10;</pre>&#10;<p><b>ALT</b> especifica uma lista de comandos <i>guardas</i>. Os <i>guardas</i> s&atilde;o uma combina&ccedil;&atilde;o de condi&ccedil;&otilde;es booleanas e uma express&atilde;o de entrada (ambos opcionais). Cada guarda para o qual tanto a condi&ccedil;&atilde;o &eacute; verdadeira quanto o canal de entrada est&aacute; pronto &eacute; bem sucedido. Uma das alternativas bem sucedidas &eacute; selecionada para a execu&ccedil;&atilde;o. Exemplo:</p>&#10;<pre> ALT&#10;   count1 &#60&semi; 100 &#38&semi; c1 ? data&#10;     SEQ&#10;       count1 := count1 + 1&#10;       merged ! data&#10;   count2 &#60&semi; 100 &#38&semi; c2 ? data&#10;     SEQ&#10;       count2 := count2 + 1&#10;       merged ! data&#10;   status ? request&#10;     SEQ&#10;       out ! count1&#10;       out ! count2&#10;&#9;</pre>&#10;<p>Isto ir&aacute; ler dados a partir de canais C1 ou C2 (dependendo do que est&aacute; pronto) e pass&aacute;&shy;lo em um canal fundido. Se countN alcan&ccedil;ar a 100, leituras do canal correspondente ser&atilde;o desabilitadas. Um pedido sobre a condi&ccedil;&atilde;o do canal &eacute; atendido enviando a contagem de sa&iacute;da para out.</p>&#10;<a id="Revis%C3%B5es_da_linguagem" name="Revis%C3%B5es_da_linguagem"></a><h2> Revis&otilde;es da linguagem </h2>&#10;<a id="occam_1" name="occam_1"></a><h3> occam 1 </h3>&#10;<p><b>occam 1</b><sup id="_ref&shy;oc1refman_a" class="reference"><a href="#_note&shy;oc1refman" title="">[2]</a></sup> (released 1983) foi uma vers&atilde;o preliminar da linguagem. Suportava apenas o tipo de dados VAR , que era um tipo integral correspondente ao comprimento da palavra nativa da arquitetura objeto, e matrizes de apenas uma dimens&atilde;o.</p>&#10;<a id="occam_2" name="occam_2"></a><h3> occam 2 </h3>&#10;<p><b>occam 2</b><sup id="_ref&shy;oc2refman_a" class="reference"><a href="#_note&shy;oc2refman" title="">[3]</a></sup> &eacute; uma extens&atilde;o produzida pela INMOS Ltd, em 1987, que acrescenta suporte a <a href="http://en.wikipedia.org/wiki/Ponto_flutuante" id="w">ponto flutuante</a>, fun&ccedil;&otilde;es, <i>arrays</i> multi&shy;dimensionais e mais tipos de dados, tais como inteiros de tamanhos variados (INT16, Int32) e bytes.</p>&#9; &#9;&#10;<p>Com esta revis&atilde;o, Occam tornou&shy;se uma linguagem capaz de expressar programas &uacute;teis, enquanto que Occam 1 foi mais adequada para an&aacute;lise de algoritmos e explora&ccedil;&atilde;o da nova linguagem (embora deve&shy;se notar que o compilador Occam 1 foi escrito em Occam 1, para que haja uma prova de que se podia escrever programas &uacute;teis em Occam 1, apesar das suas limita&ccedil;&otilde;es).</p>&#10;<a id="Occam_2.1" name="Occam_2.1"></a><h3> Occam 2.1 </h3>&#10;<p><b>occam 2.1</b><sup id="_ref&shy;oc21refman_b" class="reference"><a href="#_note&shy;oc21refman" title="">[1]</a></sup> foi o &uacute;ltimo da s&eacute;rie de desenvolvimentos da linguagem Occam de contribui&ccedil;&atilde;o da INMOS. Definida em 1994, foi influenciada por uma proposta anterior para uma linguagem <i> &#39&semi;Occam 3<b> (tamb&eacute;m referenciada como &#34&semi;occam91&#34&semi; durante os est&aacute;gios iniciais de desenvolvimento) criada por Geoff Barrett na INMOS no in&iacute;cio dos anos 90. Um Manual de Refer&ecirc;ncia revisado descrevendo Occam 3 foi distribu&iacute;do para a comunidade tecer coment&aacute;rios  , mas a linguagem nunca foi plenamente implementada em um compilador.</b></i></p>&#10;<p>occam 2.1 introduziu v&aacute;rios novos recursos na linguagem Occam 2, incluindo:</p>&#10;&#10;<ul>&#10;<li>Tipos de Dados nomeados (DATA TYPE x IS y)</li>&#10;<li>Registros Nomeados</li>&#10;<li>Packed Records</li>&#10;<li>Relaxa&ccedil;&atilde;o de algumas regras do tipo convers&atilde;o</li>&#10;<li>Novos operadores (e.g. BYTESIN)</li>&#10;<li>Channel retyping e channel arrays</li>&#10;<li>Capacidade para retornar arrys de tamanho fixo de uma fun&ccedil;&atilde;o</li></ul>&#10;<p>Para uma lista completa das mudan&ccedil;as ver ap&ecirc;ndice do P <a class="externallink" href="http://www.wotug.org/occam/documentation/oc21refman.pdf" rel="nofollow" title="http://www.wotug.org/occam/documentation/oc21refman.pdf">INMOS occam 2.1 Reference Manual</a>.</p>&#10;<a id="occam&shy;%CF%80" name="occam&shy;%CF%80"></a><h3> occam&shy;&pi; </h3>&#10;<p><b><a href="http://en.wikipedia.org/wiki/Occam&shy;%CF%80" id="w">occam&shy;&pi;</a></b><sup id="_ref&shy;kroc_a" class="reference"><a href="#_note&shy;kroc" title="">[4]</a></sup> &eacute; o nome comum para a variante Occam implementada atrav&eacute;s de vers&otilde;es tardias de <a href="http://en.wikipedia.org/wiki/KRoC" id="w">KRoC</a>, um compilador Occan para Kent. A adi&ccedil;&atilde;o do s&iacute;mbolo &#34&semi;<a href="http://en.wikipedia.org/wiki/Pi" id="w">&pi;</a>&#34&semi; (pi) ao nome de Occan &eacute; uma alus&atilde;oao fato de que o KRoC occam inclui diversas id&eacute;ias inspiradaspelo c&aacute;lculo Pi. Ela cont&eacute;m um n&uacute;mero significativo de extens&otilde;es para o compilador Occam 2.1, por exemplo:</p>&#10;&#10;<ul>&#10;<li>Protocolos aninhados</li>&#10;<li>Cria&ccedil;&atilde;o de processos em Run&shy;time </li>&#10;<li>Canais m&oacute;veis, dados e processos</li>&#10;<li>Recurs&atilde;o</li>&#10;<li>Heran&ccedil;a de protocolos</li></ul>&#10;<p> </p>&#10;<a id="%7B%7BBibliografia%7D%7D" name="%7B%7BBibliografia%7D%7D"></a><h2>   </h2>&#10;&#10;<ul>&#10;<li> </li></ul>&#10;&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o" id="w">Occam</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_concorrentes" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o concorrentes</a></p></body></html>