<html><title>X86</title><body>&#10;<p> </p>&#10;<p> &#10;<a class="internal" href="http://en.wikipedia.org/wiki/Image:KL_Intel_D8086.jpg" title="O Intel 8086."><img src="http://en.wikipedia.org/wiki/KL_Intel_D8086.jpg" alt="O Intel 8086." title="O Intel 8086." class="location&shy;none type&shy;thumb" />&#10;</a>&#10;<div class="thumbcaption">O Intel 8086.</div> &#10;<a class="internal" href="http://en.wikipedia.org/wiki/Image:Core_2_Duo_E6300.jpg" title="Intel Core 2 Duo &shy; Um exemplo de aquitetura x86 compativel com processadores multicore de 64&shy;bit."><img src="http://en.wikipedia.org/wiki/Core_2_Duo_E6300.jpg" alt="Intel Core 2 Duo &shy; Um exemplo de aquitetura x86 compativel com processadores multicore de 64&shy;bit." title="Intel Core 2 Duo &shy; Um exemplo de aquitetura x86 compativel com processadores multicore de 64&shy;bit." class="location&shy;none type&shy;thumb" />&#10;</a>&#10;<div class="thumbcaption">Intel Core 2 Duo &shy; Um exemplo de aquitetura x86 compativel com processadores multicore de 64&shy;bit.</div>&#10;<a class="internal" href="http://en.wikipedia.org/wiki/Image:Slot&shy;A_Athlon.jpg" title="AMD Athlon (primeira vers&atilde;o) &shy; outra implementa&ccedil;&atilde;o x86 tecnicamente diferentes, mas totalmente compat&iacute;vel."><img src="http://en.wikipedia.org/wiki/Slot&shy;A_Athlon.jpg" alt="AMD Athlon (primeira vers&atilde;o) &shy; outra implementa&ccedil;&atilde;o x86 tecnicamente diferentes, mas totalmente compat&iacute;vel." title="AMD Athlon (primeira vers&atilde;o) &shy; outra implementa&ccedil;&atilde;o x86 tecnicamente diferentes, mas totalmente compat&iacute;vel." class="location&shy;none type&shy;thumb" />&#10;</a>&#10;<div class="thumbcaption">AMD Athlon (primeira vers&atilde;o) &shy; outra implementa&ccedil;&atilde;o x86 tecnicamente diferentes, mas totalmente compat&iacute;vel.</div></p>&#10;<p>Em inform&aacute;tica, <b>x86</b> ou <b>80x86</b> &eacute; o nome gen&eacute;rico dada &agrave; fam&iacute;lia (arquitetura) de <a href="http://en.wikipedia.org/wiki/Processador" id="w">processadores</a> baseados no Intel 8086, da <a href="http://en.wikipedia.org/wiki/Intel_Corporation" id="w">Intel Corporation</a>. </p>&#10;<p>A arquitetura &eacute; chamada <i>x86</i> porque os primeiros processadores desta fam&iacute;lia eram identificados somente por n&uacute;meros terminados com a seq&uuml;&ecirc;ncia &#34&semi;86&#34&semi;: o <a href="http://en.wikipedia.org/wiki/Intel_8086" id="w">8086</a>, o <a href="http://en.wikipedia.org/wiki/Intel_80186" id="w">80186</a>, o <a href="http://en.wikipedia.org/wiki/Intel_80286" id="w">80286</a>, o <a href="http://en.wikipedia.org/wiki/Intel_80386" id="w">80386</a> e o <a href="http://en.wikipedia.org/wiki/Intel_80486" id="w">80486</a>. Como n&atilde;o se pode ter uma marca registrada sobre n&uacute;meros, a Intel e a maior parte de seus competidores come&ccedil;aram a usar nomes que pudessem ser registrados como marca, como <a href="http://en.wikipedia.org/wiki/Pentium" id="w">Pentium</a> para as gera&ccedil;&otilde;es de <a href="http://en.wikipedia.org/wiki/Processadores" id="w">processadores</a> posteriores, mas a antiga nomenclatura tinha forjado um termo para toda a <a href="http://en.wikipedia.org/wiki/Fam%C3%ADlia" id="w">fam&iacute;lia</a>. </p>&#10;<p>O termo x86 n&atilde;o &eacute; sin&ocirc;nimo de compatibilidade com IBM PC , pois isso sugere uma infinidade de outros hardwares e sistemas embarcados bem como <a href="http://en.wikipedia.org/wiki/Computadores" id="w">computadores</a> usando chips x86 antes do moderno mercado ser compat&iacute;vel com PC, alguns deles antes mesmo do IBM PC em si.</p>&#10;<p>Houve v&aacute;rias tentativas, dentro da <a href="http://en.wikipedia.org/wiki/Intel" id="w">Intel</a> em si, para quebrar o dom&iacute;nio do mercado da arquitetura x86, que descendia diretamente do simples <a href="http://en.wikipedia.org/wiki/Microprocessadores" id="w">microprocessadores</a> de 8 bits. Exemplos disso s&atilde;o as iAPX 432 (ali&aacute;s Intel 8800 ), o Intel 960 , Intel 860 e Intel e a arquitetura do Hewlett Packard Itanium. No entanto, o aperfei&ccedil;oamento cont&iacute;nuo de 86 micro arquiteturas, circuitos, e fabrica&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Semicondutores" id="w">semicondutores</a> provaria que &eacute; dif&iacute;cil substituir x86 em v&aacute;rios segmentos. O 64, da extens&atilde;o bit da AMD x86 (que a Intel finalmente respondeu, com um <a href="http://en.wikipedia.org/wiki/Design" id="w">design</a> compat&iacute;vel) e a escala de processadores x86, como o eight&shy;core Intel Xeon e 12&shy;core AMD Opteron destaca&shy;se o x86 como um exemplo de cont&iacute;nuo aperfei&ccedil;oamento e como as normas estabelecidas pela <a href="http://en.wikipedia.org/wiki/Ind%C3%BAstria" id="w">ind&uacute;stria</a> pode resistir &agrave; concorr&ecirc;ncia das novas arquiteturas.</p>&#10;<a id="Cronologia" name="Cronologia"></a><h2> Cronologia </h2>&#10;<p>A tabela abaixo mostra as marcas de processadores e <a href="http://en.wikipedia.org/wiki/Microprocessadores" id="w">microprocessadores</a> na <a href="http://en.wikipedia.org/wiki/Hall_da_Fama" id="w">Hall da Fama</a>, agrupados por gera&ccedil;&otilde;es que destacam pontos importantes na <a href="http://en.wikipedia.org/wiki/Hist%C3%B3ria" id="w">hist&oacute;ria</a> do x86. Nota: As gera&ccedil;&otilde;es de CPU n&atilde;o s&atilde;o r&iacute;gidas, cada gera&ccedil;&atilde;o &eacute; marcada por melhoras significativas ou comercialmente bem sucedidos projetos do processador.&#10;</p>&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>Gera&ccedil;&atilde;o</th>&#10;<th>Introduzido inicialmente em</th>&#10;<th>Marcas de CPU proeminentes </th>&#10;<th>Linear / Espa&ccedil;o de endere&ccedil;o f&iacute;sico</th>&#10;<th>Novos recursos</th></tr>&#10;<tr>&#10;<td>1 </td>&#10;<td>1978 </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Intel_8086" id="w">Intel 8086</a>, <a href="http://en.wikipedia.org/wiki/Intel_8088" id="w">Intel 8088</a> </td>&#10;<td rowspan="2"><b>16&shy;bit</b> / 20&shy;bit (<i>segmentados</i>)</td>&#10;<td>Primeiros processadores X86.</td></tr>&#10;<tr>&#10;<td rowspan="2">2 </td>&#10;<td rowspan="2">1982 </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Intel_80186" id="w">Intel 80186</a>, <a href="http://en.wikipedia.org/wiki/Intel_80188" id="w">Intel 80188</a>, <a href="http://en.wikipedia.org/wiki/NEC_V20" id="w">NEC V20</a>/V30 </td>&#10;<td>Hardware para c&aacute;lculos de endere&ccedil;os r&aacute;pidos.</td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/Intel_80286" id="w">Intel 80286</a> </td>&#10;<td><b>16&shy;bit</b> (30&shy;bit <i>virtual</i>) / 24&shy;bit (<i>segmentados</i>)</td>&#10;<td>MMU, para o modo protegido e um maior espa&ccedil;o de endere&ccedil;o.</td></tr>&#10;<tr>&#10;<td>3 (<a href="http://en.wikipedia.org/wiki/IA&shy;32" id="w">IA&shy;32</a>)</td>&#10;<td>1985 </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Intel_80386" id="w">Intel 80386</a>, AMD Am386 </td>&#10;<td rowspan="4"><b>32&shy;bit</b> (46&shy;bit <i>virtual</i>) / Conjunto de instru&ccedil;&otilde;es com 32&shy;bit, MMU com pagina&ccedil;&atilde;o.</td></tr>&#10;<tr>&#10;<td>4 </td>&#10;<td>1989 </td>&#10;<td>Intel486, AMD Am486, Cyrix III&shy;Samuel, <a href="http://en.wikipedia.org/wiki/VIA_C3" id="w">VIA C3</a>&shy;Samuel2 / VIA C3&shy;Ezra (2001) </td>&#10;<td>RISC FPU pipelining, cache integrada, on&shy;chip.</td></tr>&#10;<tr>&#10;<td>5 </td>&#10;<td>1993 </td>&#10;<td>Pentium, <a href="http://en.wikipedia.org/wiki/Pentium_MMX" id="w">Pentium MMX</a> </td>&#10;<td>Superscalar, 64&shy;bit databus, faster FPU, MMX.</td></tr>&#10;<tr>&#10;<td>5/6 </td>&#10;<td>1996 </td>&#10;<td>Cyrix 6x86, Cyrix MII, Cyrix III&shy;Joshua (2000) </td>&#10;<td>Register renaming, speculative execution.</td></tr>&#10;<tr>&#10;<td rowspan="2">6 </td>&#10;<td>1995 </td>&#10;<td K5]],="null" Pro]],="null">Nx586 (1994), Rise <a href="http://en.wikipedia.org/wiki/MP6" id="w">mP6</a> </td>&#10;<td rowspan="5"><i>como acima</i> / <b>36</b>&shy;bit <i>F&iacute;sico</i> (PAE)</td>&#10;<td>transla&ccedil;&atilde;o &mu;&shy;op, PAE Pentium Pro, integrado com cache L2 (Pentium Pro), instru&ccedil;&atilde;o de movimenta&ccedil;&atilde;o condicional.</td></tr>&#10;<tr>&#10;<td>1997 </td>&#10;<td><a href="http://en.wikipedia.org/wiki/AMD_K6" id="w">AMD K6</a>/<a href="http://en.wikipedia.org/wiki/AMD_K6&shy;2" id="w">&shy;2/3</a>, <a href="http://en.wikipedia.org/wiki/Pentium_II" id="w">Pentium II</a>/<a href="http://en.wikipedia.org/wiki/Pentium_III" id="w">III</a>, IDT/<a href="http://en.wikipedia.org/wiki/Centaur_Technology" id="w">Centaur</a>&shy;C6 </td>&#10;<td>cache L3 suportando, 3DNow, SSE.</td></tr>&#10;<tr>&#10;<td rowspan="2">7 </td>&#10;<td>1999 </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Athlon" id="w">Athlon</a>, <a href="http://en.wikipedia.org/wiki/Athlon_XP" id="w">Athlon XP</a> </td>&#10;<td>superscalar FPU, design wide (<i>at&eacute; tr&ecirc;s instru&ccedil;&otilde;es por ciclo de clock</i>)</td></tr>&#10;<tr>&#10;<td>2000 </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Pentium_4" id="w">Pentium 4</a> </td>&#10;<td>Alta conduta, alta frequencia, SSE2, hyper&shy;threading.</td></tr>&#10;<tr>&#10;<td>6&shy;M/7&shy;M </td>&#10;<td rowspan="2">2003 </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Pentium_M" id="w">Pentium M</a>, <a href="http://en.wikipedia.org/wiki/VIA_C7" id="w">VIA C7</a> (2005), <a href="http://en.wikipedia.org/wiki/Intel_Core" id="w">Intel Core</a> (2006) </td>&#10;<td>Otimizados para baixo consumo. </td></tr>&#10;<tr>&#10;<td rowspan="2">8 (<a href="http://en.wikipedia.org/wiki/X86&shy;64" id="w">x86&shy;64</a>) </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Athlon_64" id="w">Athlon 64</a>, <a href="http://en.wikipedia.org/wiki/Opteron" id="w">Opteron</a> </td>&#10;<td rowspan="3"><b>64&shy;bit</b> / <i>40&shy;bit Implementa&ccedil;&atilde;o f&iacute;sica do primeiro processador AMD.</i></td>&#10;<td>Conjunto de instru&ccedil;&otilde;es x86&shy;64, controlador de mem&oacute;ria on&shy;die, hypertransport.</td></tr>&#10;<tr>&#10;<td>2004 </td>&#10;<td>Pentium 4 Prescott </td>&#10;<td>Alta contuta, Alt&iacute;ssima frequencia, SSE], capacidade de 64 bits est&aacute; dispon&iacute;vel somente em soquetes <a href="http://en.wikipedia.org/wiki/LGA_775" id="w">LGA 775</a>.</td></tr>&#10;<tr>&#10;<td>9 </td>&#10;<td>2006 </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Intel_Core_2" id="w">Intel Core 2</a> </td>&#10;<td>baixo consumo, multi&shy;core, menor frequencia de clock, SSE4 (Penryn)</td></tr>&#10;<tr>&#10;<td rowspan="4">10 </td>&#10;<td>2007 </td>&#10;<td>AMD Phenom </td>&#10;<td rowspan="4"><i>como acima / 48&shy;bit processador f&iacute;sico AMD Phenom</i> </td>&#10;<td rowspan="2">monol&iacute;tica quad&shy;core, 128 FPUs bit, SSE4a, HyperTransport 3 ou QuickPath, controlador de mem&oacute;ria nativa, on&shy;die cache L3, design modular.</td></tr>&#10;<tr>&#10;<td rowspan="3">2008 </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Intel_Core_i3" id="w">Intel Core i3</a>, <a href="http://en.wikipedia.org/wiki/Intel_Core_i5" id="w">Intel Core i5</a>, <a href="http://en.wikipedia.org/wiki/Intel_Core_i7" id="w">Intel Core i7</a></td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/Intel_Atom" id="w">Intel Atom</a></td>&#10;<td>Altamente canalisado por&eacute;m com sua pot&ecirc;ncia muito baixa.</td></tr>&#10;<tr>&#10;<td><a href="http://en.wikipedia.org/wiki/VIA_Nano" id="w">VIA Nano</a> </td>&#10;<td>Fora de ordem, superescalar, criptografia baseada em hardware, muito baixa energia, gerenciamento de energia adaptativa.</td></tr>&#10;<tr>&#10;<td>11 </td>&#10;<td>2010 </td>&#10;<td>Intel Sandy Bridge, AMD Bulldozer </td>&#10;<td />&#10;<td>SSE5/AVX, design altamente modular.</td></tr></table></div>&#10;&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2> Hist&oacute;ria </h2>&#10;<a id="Antecedentes" name="Antecedentes"></a><h3> Antecedentes </h3>&#10;&#10;<p>A arquitetura x86 aparece primeiro como o Intel 8086 CPU lan&ccedil;ado em 1978, um projeto totalmente de 16 bits baseado na anterior de 8 bits com base 8008, 8080 e 8085. Apesar de n&atilde;o ser compat&iacute;veis com o <a href="http://en.wikipedia.org/wiki/Bin%C3%A1rio" id="w">bin&aacute;rio</a>, ele foi projetado para permitir que programas escritos em <a href="http://en.wikipedia.org/wiki/Assembly" id="w">linguagem assembly</a> serem mecanicamente traduzidos para o conjunto 8086 equivalente. Isso fez com que o novo processador fosse um caminho de migra&ccedil;&atilde;o tentador, mas n&atilde;o sem uma remodelagem de <a href="http://en.wikipedia.org/wiki/Hardware" id="w">hardware</a> significativa, principalmente devido ao barramento de dados 16&shy;bit externo. Para resolver isso, a <a href="http://en.wikipedia.org/wiki/Intel" id="w">Intel</a> lan&ccedil;ou o 8088 quase id&ecirc;ntico, com um barramento de dados externo de 8&shy;bit, o que permitiu o uso de placas de circuito mais simples e exigiu poucas fichas (1&shy;bit de largura) DRAM. O 8088 tamb&eacute;m pode ser conectado ao j&aacute; estabelecido (ou seja, de baixo custo) de 8 bits do sistema e <a href="http://en.wikipedia.org/wiki/Chips" id="w">chips</a> perif&eacute;ricos mais facilmente. Entre outros fatores n&atilde;o <a href="http://en.wikipedia.org/wiki/T%C3%A9cnico" id="w">t&eacute;cnicos</a>, o que contribuiu para o fato de que a <a href="http://en.wikipedia.org/wiki/IBM" id="w">IBM</a> construisse seu IBM PC usando o 8088, apesar da presen&ccedil;a de microprocessadores de 16 bits da <a href="http://en.wikipedia.org/wiki/Motorola" id="w">Motorola</a>, Zilog, e National Semiconductor. O IBM PC, posteriormente assumiu Z80&shy;based CP/M systems, Apple II, e outros <a href="http://en.wikipedia.org/wiki/Computadores" id="w">computadores</a> populares, e tornou&shy;se um padr&atilde;o de fato dominante, para computadores pessoais, permitindo assim que os 8088 e os seus sucessores dominassem este ramo importante de microprocessadores no mercado.</p>&#10;<a id="iAPX_432_e_a_80286" name="iAPX_432_e_a_80286"></a><h3> iAPX 432 e a 80286 </h3>&#10;<p>Outro fator foi que o <a href="http://en.wikipedia.org/wiki/Intel" id="w">Intel 8800</a> (ali&aacute;s iAPX 432) n&atilde;o compat&iacute;vel com 32 bits, falhou no <a href="http://en.wikipedia.org/wiki/Mercado" id="w">mercado</a> na &eacute;poca que o IBM&shy;PC foi lan&ccedil;ado. O novo e r&aacute;pido 80286 realmente contribuiu para a decep&ccedil;&atilde;o do semi&shy;contempor&acirc;neo 8800 no in&iacute;cio de 1982. (O 80186, lan&ccedil;ado em paralelo com o 80286, foi concebido para sistemas embarcados, e, portanto, teve um grande <a href="http://en.wikipedia.org/wiki/Mercado" id="w">mercado</a> de qualquer maneira.) A falha de mercado dos 32 bits 8800, foi um impulso significativo para a Intel continuar desenvolvendo 8086 compativ&eacute;is mais avan&ccedil;ados, como o 80386 (uma extens&atilde;o de 32 bits do 80286 com bom desempenho).</p>&#10;<a id="Outros_fabricantes" name="Outros_fabricantes"></a><h3> Outros fabricantes </h3>&#10;<p> </p>&#10;<p>Por v&aacute;rias vezes, empresas como IBM, NEC, AMD, TI, STM, Fujitsu, OKI, Siemens, Cyrix, Intersil, C &#38&semi; T, NexGen, e a UMC come&ccedil;aram a fabrica&ccedil;&atilde;o de processadores x86 destinado a computadores pessoais e de sistemas embarcados. Tais implementa&ccedil;&otilde;es x86 raramente s&atilde;o c&oacute;pias simples, e muitas vezes empregam diferentes microarquiteturas internas, bem como diferentes solu&ccedil;&otilde;es ao n&iacute;vel <a href="http://en.wikipedia.org/wiki/Eletr%C3%B4nico" id="w">eletr&ocirc;nico</a> e <a href="http://en.wikipedia.org/wiki/F%C3%ADsico" id="w">f&iacute;sico</a>. Muito naturalmente, os primeiros <a href="http://en.wikipedia.org/wiki/Chips" id="w">chips</a> compat&iacute;veis foram de 16 bits, enquanto os projetos de 32 bits apareceram mais tarde. Para o mercado de computadores pessoais, a quantidade real come&ccedil;ou a aparecer por volta de 1990 com o i386 e o i486, processadores compat&iacute;veis, ent&atilde;o nomeados similarmente como Chip Original <a href="http://en.wikipedia.org/wiki/Intel" id="w">Intel</a>. Outras empresas, que projetaram ou fabricaram processadores x86 ou x87, foram a ITT Corporation, a National Semiconductor, a ULSI System Technology, e a Weitek.</p>&#10;<p>Ap&oacute;s a pipelined i486, a Intel lan&ccedil;ou a marca Pentium para sua nova linha de modelos x86 superescalar. Com o esquema de nomea&ccedil;&atilde;o de 86 agora legalmente seguro, a <a href="http://en.wikipedia.org/wiki/Intel" id="w">Intel</a> fez uma parceria com a IBM para produzir o Cyrix 5x86 e 6x86. Nessa &eacute;poca a AMD, estava projetando e fabricando o 5k86, que internamente, foi baseado no <a href="http://en.wikipedia.org/wiki/Design" id="w">design</a> da AMD RISC 29K, semelhante ao Nx586 NexGen. A AMD usou uma estrat&eacute;gia em que est&aacute;gios da pipeline, decodificavam instru&ccedil;&otilde;es x86 e outros manuseios de micro Opera&ccedil;&otilde;es, um m&eacute;todo muito usado como base para o design do x86, da &eacute;poca.</p>&#10;<p>Algumas vers&otilde;es mais antigas desses chips tiveram problemas de dissipa&ccedil;&atilde;o do <a href="http://en.wikipedia.org/wiki/Quente" id="w">calor</a>. O 6x86 tamb&eacute;m foi afetado por alguns pequenos problemas de compatibilidade, o Nx586 faltava uma unidade de ponto flutuante (FPU) e a compatibilidade de pinos, enquanto o K5 tinha um desempenho um pouco decepcionante, quando foi lan&ccedil;ado. A conscientiza&ccedil;&atilde;o do cliente para a linha Pentium contribu&iacute;u para estes projetos sendo comparativamente melhor, apesar do fato de que o K5 tinha boa compatibilidade com Pentium e 6x86. A AMD conseguiu, mais tarde, estabelecer&shy;se como um grande concorrente com a linha de processadores K6, que deu lugar ao grande sucesso Athlon e Opteron. Houve tamb&eacute;m outros concorrentes, como a Centaur Technology (formerly IDT), a Rise Technology, e a Transmeta. Processadores como o VIA Technologies C3 e C7, que foram projetados pela Centaur, tamb&eacute;m foram vendidos por muitos anos. O mais novo projeto da Centaur, o VIA Nano, &eacute; o primeiro processador com a execu&ccedil;&atilde;o superescalar. Foi interessante, pois foi introduzido na mesma <a href="http://en.wikipedia.org/wiki/&Eacute;poca" id="w">&eacute;poca</a> do processador Intel&#39&semi;s first &#34&semi;in&shy;order&#34&semi; desde o P5 Pentium, o <a href="http://en.wikipedia.org/wiki/Intel" id="w">Intel</a> Atom.</p>&#10;<a id="Extens%C3%B5es_do_tamanho_de_bits" name="Extens%C3%B5es_do_tamanho_de_bits"></a><h3> Extens&otilde;es do tamanho de bits </h3>&#10;<p>A <a href="http://en.wikipedia.org/wiki/Arquitetura" id="w">arquitetura</a> do conjunto de instru&ccedil;&otilde;es foi prorrogado duas vezes para um tamanho maior. Em 1985, a <a href="http://en.wikipedia.org/wiki/Intel" id="w">Intel</a> lan&ccedil;ou o 32 bits 80386 (ou i386), que gradualmente substituiu o <a href="http://en.wikipedia.org/wiki/Chip" id="w">chip</a> de 16 bits em computadores. Durante os anos seguintes, este modelo de <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o" id="w">programa&ccedil;&atilde;o</a> estendida foi originalmente chamado de <a href="http://en.wikipedia.org/wiki/Arquitetura" id="w">arquitetura</a> i386, mas mais tarde apelidou&shy;se de Intel IA&shy;32, antes da sua vers&atilde;o independente, a arquitetura IA&shy;64. Em 1999&shy;2003, a AMD estendeu essa arquitetura de 32 bits para 64 bits e se refere a ele como x86&shy;64 em documentos antigos e mais tarde como AMD64. a <a href="http://en.wikipedia.org/wiki/Intel" id="w">Intel</a> logo adotou extens&otilde;es da arquitetura da AMD, como o nome IA&shy;32e que foi mais tarde renomeado de Intel EM64T e, finalmente, 64. Entre estes cinco nomes, o original x86&shy;64 &eacute; provavelmente o mais utilizado, embora a <a href="http://en.wikipedia.org/wiki/Microsoft" id="w">Microsoft</a> e a Sun Microsystems tamb&eacute;m usam o termo x64.</p>&#10;<a id="Resumo" name="Resumo"></a><h2> Resumo </h2>&#10;<a id="Propriedades_b%C3%A1sicas_da_arquitetura" name="Propriedades_b%C3%A1sicas_da_arquitetura"></a><h3> Propriedades b&aacute;sicas da arquitetura </h3>&#10;<p>A arquitetura x86 &eacute; um comprimento vari&aacute;vel de instru&ccedil;&atilde;o, primeiramente s&atilde;o modelados dois endere&ccedil;os &ldquo;CISC&rdquo; com <a href="http://en.wikipedia.org/wiki/&Ecirc;nfase" id="w">&ecirc;nfase</a> em compatibilidade com vers&otilde;es anteriores. No entanto o conjunto de instru&ccedil;&otilde;es n&atilde;o &eacute; t&iacute;pico CISC, mas, basicamente, uma vers&atilde;o estendida e <a href="http://en.wikipedia.org/wiki/Ortogonal" id="w">ortogonal</a> de simples oito bits, das arquiteturas 8008, 8080 e 8085. O <a href="http://en.wikipedia.org/wiki/Byte" id="w">Byte</a> de endere&ccedil;amento &eacute; suportado e as palavras s&atilde;o armazenadas na mem&oacute;ria com ordem de  little&shy;endian byte. O acesso &agrave; mem&oacute;ria para endere&ccedil;os desalinhados &eacute; permitido em todos os tamanhos de palavras suportadas.&#10;O maior tamanho nativo para <a href="http://en.wikipedia.org/wiki/Aritm%C3%A9tica" id="w">aritm&eacute;tica</a> de inteiros e endere&ccedil;os de mem&oacute;ria (ou deslocamentos) &eacute; de 16, 32 ou 64 bits dependendo da gera&ccedil;&atilde;o da <a href="http://en.wikipedia.org/wiki/Arquitetura" id="w">arquitetura</a> (processadores mais recentes incluem um suporte direto para inteiros menores tamb&eacute;m). V&aacute;rios valores escalares podem ser tratados simultaneamente, atrav&eacute;s da unidade SIMD presente em gera&ccedil;&otilde;es posteriores, conforme descrito abaixo. Compensa&ccedil;&otilde;es imediatas de endere&ccedil;amento e dados de imediato podem ser expressos em quantidades de 8 bits conforme a frequ&ecirc;ncia que ocorrem os casos ou contextos em que o <a href="http://en.wikipedia.org/wiki/Intervalo" id="w">intervalo</a> de 128 .. 127 &eacute; o suficiente. Instru&ccedil;&otilde;es t&iacute;picas s&atilde;o, portanto, de 2 ou 3 <a href="http://en.wikipedia.org/wiki/Bytes" id="w">bytes</a> de comprimento (embora alguns s&atilde;o muito mais longos, e algumas s&atilde;o de <a href="http://en.wikipedia.org/wiki/Byte" id="w">byte</a> &uacute;nico).&#10;Para melhor conservar o espa&ccedil;o de codifica&ccedil;&atilde;o, a maioria dos registros s&atilde;o expressos em opcodes usando tr&ecirc;s bits, e no m&aacute;ximo um operando em uma instru&ccedil;&atilde;o que pode ser um local de mem&oacute;ria (alguns projetos &#34&semi;CISC&#34&semi;  altamente <a href="http://en.wikipedia.org/wiki/Ortogonal" id="w">ortogonais</a>, como o PDP&shy;11, podem utilizar dois). No entanto, esta <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria" id="w">mem&oacute;ria</a> operando tamb&eacute;m pode ser de destina&ccedil;&atilde;o  (ou a combina&ccedil;&atilde;o entre fonte e destina&ccedil;&atilde;o), enquanto o outro operando, a fonte, pode ser tanto registrada quanto imediata. &#10;O <a href="http://en.wikipedia.org/wiki/N%C3%BAmero" id="w">n&uacute;mero</a> relativamente pequeno de registros gerais (tamb&eacute;m herdados de seus antecessores de 8 bits) fez&shy;se endere&ccedil;amento de registro relativo (usando pequenas compensa&ccedil;&otilde;es imediatas) como um importante m&eacute;todo de acesso a operandos, especialmente na <a href="http://en.wikipedia.org/wiki/Pilha" id="w">pilha</a>. Muito trabalho foi, portanto, investido na <a href="http://en.wikipedia.org/wiki/Fabrica%C3%A7%C3%A3o" id="w">fabrica&ccedil;&atilde;o</a> desses acessos de modo t&atilde;o r&aacute;pido como registrar os acessos, ou seja, um ciclo de transfer&ecirc;ncia de instru&ccedil;&atilde;o, na maioria dos casos em que os dados acessados est&atilde;o dispon&iacute;veis no <a href="http://en.wikipedia.org/wiki/Cache" id="w">cache</a> de n&iacute;vel superior.</p>&#10;<a id="Ponto_Flutuante_e_SIMD" name="Ponto_Flutuante_e_SIMD"></a><h2> Ponto Flutuante e SIMD </h2>&#10;<p>Um processador de ponto flutuante dedicado com 80 bits de registros internos, o 8087, foi desenvolvido para o original de 8086. Este <a href="http://en.wikipedia.org/wiki/Chip" id="w">chip</a> foi posteriormente desenvolvido para o estendido 80387 e, mais tarde incorporado a uma vers&atilde;o de processadores compat&iacute;veis a essa funcionalidade no mesmo <a href="http://en.wikipedia.org/wiki/Chip" id="w">chip</a> como no processador principal. Al&eacute;m disso, projetos modernos da x86 tamb&eacute;m incluem uma unidade SIMD em que as instru&ccedil;&otilde;es podem trabalhar em paralelo (uma ou duas) palavras de 128 bits, cada uma contendo 2 ou 4 n&uacute;meros de ponto flutuante (a cada 64 ou 32 bits de largura, respectivamente), ou, alternativamente, 2, 4, 8 ou 16 n&uacute;meros inteiros (a cada 64, 32, 16 ou 8 bits de largura, respectivamente).&#10;Os amplos registradores SIMD significam que os processadores existentes x86 podem carregar ou armazenar at&eacute; 128 bits de dados de <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria" id="w">mem&oacute;ria</a> em uma &uacute;nica instru&ccedil;&atilde;o e tamb&eacute;m podem executar opera&ccedil;&otilde;es bit a bit (embora n&atilde;o a <a href="http://en.wikipedia.org/wiki/Aritm%C3%A9tica" id="w">aritm&eacute;tica</a> de n&uacute;meros inteiros) sobre as quantidades de 128&shy;bits em paralelo. Planejados <a href="http://en.wikipedia.org/wiki/Processadores" id="w">processadores</a> x86 ter&atilde;o opera&ccedil;&otilde;es SIMD de 256 bits (incluindo 256&shy;bit de mem&oacute;ria e armazenamento de carga).</p>&#10;<a id="As_implementa%C3%A7%C3%B5es_atuais" name="As_implementa%C3%A7%C3%B5es_atuais"></a><h2> As implementa&ccedil;&otilde;es atuais </h2>&#10;<p>Durante a execu&ccedil;&atilde;o, processadores x86 atuais empregam uma <a href="http://en.wikipedia.org/wiki/Decodifica%C3%A7%C3%A3o" id="w">decodifica&ccedil;&atilde;o</a> extra para dividir a maioria das instru&ccedil;&otilde;es em peda&ccedil;os menores (micro&shy;opera&ccedil;&otilde;es). Estes s&atilde;o ent&atilde;o entregues a uma unidade de controle que os tamp&otilde;es e os <a href="http://en.wikipedia.org/wiki/Cronograma" id="w">cronogramas</a> est&atilde;o em conformidade de acordo com a x86&shy;sem&acirc;ntica, para que possam ser executadas, parcialmente em paralelo, por uma das v&aacute;rias unidades (mais ou menos especializadas) de execu&ccedil;&atilde;o.&#10;Quando foi introduzida, esta abordagem foi por vezes referida como um &#34&semi;n&uacute;cleo RISC&#34&semi; ou como &#34&semi;tradu&ccedil;&atilde;o RISC&#34&semi;, em parte por raz&otilde;es de <a href="http://en.wikipedia.org/wiki/Marketing" id="w">marketing</a>, mas tamb&eacute;m porque essas micro&shy;opera&ccedil;&otilde;es compartilham algumas propriedades com certos tipos de instru&ccedil;&otilde;es RISC. No entanto, o <a href="http://en.wikipedia.org/wiki/Microc%C3%B3digo" id="w">microc&oacute;digo</a> tradicional (usado desde a <a href="http://en.wikipedia.org/wiki/D%C3%A9cada" id="w">d&eacute;cada</a> de 1950) tamb&eacute;m inerentemente compartilha muitas das mesmas propriedades&semi; a nova abordagem difere, principalmente na medida em que a tradu&ccedil;&atilde;o para micro&shy;opera&ccedil;&otilde;es agora ocorrem de forma <a href="http://en.wikipedia.org/wiki/Ass%C3%ADncrona" id="w">ass&iacute;ncrona</a>. N&atilde;o ter que sincronizar as unidades de execu&ccedil;&atilde;o com as etapas de decodifica&ccedil;&atilde;o abre possibilidades para uma an&aacute;lise mais aprofundada do fluxo de c&oacute;digo (buffer) e, portanto, permite a detec&ccedil;&atilde;o de opera&ccedil;&otilde;es que podem ser executadas em paralelo, alimentando simultaneamente mais de uma unidade de execu&ccedil;&atilde;o.&#10;Os mais recentes <a href="http://en.wikipedia.org/wiki/Processadores" id="w">processadores</a> tamb&eacute;m fazem o oposto quando for o caso, pois eles combinam certas seq&uuml;&ecirc;ncias x86 (como uma compara&ccedil;&atilde;o seguida de um salto condicional) um processo mais complexo de micro&shy;op, que se encaixa no modelo de execu&ccedil;&atilde;o melhor e, portanto, pode ser executado mais r&aacute;pido ou com menos recursos da m&aacute;quina envolvida.&#10;Outra forma de tentar melhorar o desempenho &eacute; o <a href="http://en.wikipedia.org/wiki/Cache" id="w">cache</a> decodificado de micro&shy;opera&ccedil;&otilde;es, de modo que o <a href="http://en.wikipedia.org/wiki/Processador" id="w">processador</a> pode acessar diretamente o <a href="http://en.wikipedia.org/wiki/Decodificado" id="w">decodificado</a> de micro&shy;opera&ccedil;&otilde;es a partir de um cache especial, em vez de descodific&aacute;&shy;lo novamente. A &ldquo;Execution Trace Cache&rdquo; &eacute; encontrada na microarquitetura da <a href="http://en.wikipedia.org/wiki/Intel" id="w">Intel</a> NetBurst (Pentium 4) &eacute; at&eacute; agora o &uacute;nico exemplo generalizado desta t&eacute;cnica.&#10;Transmeta usa um m&eacute;todo completamente diferente em seus <a href="http://en.wikipedia.org/wiki/CPU" id="w">CPUs</a> x86 compat&iacute;veis. Eles usam tradu&ccedil;&atilde;o para converter as instru&ccedil;&otilde;es x86 para instru&ccedil;&otilde;es nativas do <a href="http://en.wikipedia.org/wiki/CPU" id="w">CPU</a>. Transmeta argumenta que sua abordagem permite projetos de energia mais eficientes, uma vez que a CPU pode abandonar a etapa de <a href="http://en.wikipedia.org/wiki/Decodifica%C3%A7%C3%A3o" id="w">decodifica&ccedil;&atilde;o</a> complicada para implementa&ccedil;&otilde;es x86 tradicionais.</p>&#10;<a id="Registradores" name="Registradores"></a><h2> Registradores </h2>&#10;<p>A <a href="http://en.wikipedia.org/wiki/Arquitetura" id="w">arquitetura</a> x86 tem 8 registradores de uso geral (General Purpose Registers &shy; GPR), 6 registradores de segmento, 1 registrador de flags e um Apontador de Execu&ccedil;&atilde;o (Instruction Pointer). (FIXME: no AMD64/EM64T h&aacute; mais de 8 GPRs)</p>&#10;<a id="Registradores_de_Uso_Geral" name="Registradores_de_Uso_Geral"></a><h3> Registradores de Uso Geral </h3>&#10;<p>Os 8 GPRs, ou Registradores de Uso Geral, s&atilde;o os seguintes (por ordem de introdu&ccedil;&atilde;o na <a href="http://en.wikipedia.org/wiki/Pilha" id="w">pilha</a> ao executar a instru&ccedil;&atilde;o PUSHAD):&#10;</p>&#10;<ul>&#10;<li>EAX &shy; <a href="http://en.wikipedia.org/wiki/Acumulador" id="w">Acumulador</a>. Usado em opera&ccedil;&otilde;es <a href="http://en.wikipedia.org/wiki/Aritm%C3%A9tica" id="w">aritm&eacute;ticas</a>.</li>&#10;<li>ECX &shy; <a href="http://en.wikipedia.org/wiki/Contador" id="w">Contador</a>. Usado em <a href="http://en.wikipedia.org/wiki/Loops" id="w">loops</a>.</li>&#10;<li>EDX &shy; Registrador de Dados. Usado em opera&ccedil;&otilde;es de entrada/sa&iacute;da e em <a href="http://en.wikipedia.org/wiki/Multiplica%C3%A7%C3%A3o" id="w">multiplica&ccedil;&otilde;es</a> e <a href="http://en.wikipedia.org/wiki/Divis%C3%A3o" id="w">divis&otilde;es</a>. &Eacute; tamb&eacute;m uma extens&atilde;o do <a href="http://en.wikipedia.org/wiki/Acumulador" id="w">Acumulador</a>.</li>&#10;<li>EBX &shy; Base. Usado para apontar para dados no segmento DS.</li>&#10;<li>ESP &shy; Apontador da <a href="http://en.wikipedia.org/wiki/Pilha" id="w">Pilha</a> (Stack Pointer). Aponta para o topo da pilha (endere&ccedil;o mais baixo dos elementos da pilha).</li>&#10;<li>EBP &shy; Apontador da base do frame. Usado para aceder a argumentos de procedimentos passados pela <a href="http://en.wikipedia.org/wiki/Pilha" id="w">pilha</a>.</li>&#10;<li>ESI &shy; &Iacute;ndice da fonte de dados a copiar (Source Index). Aponta para dados a copiar para DS:EDI.</li>&#10;<li>EDI &shy; &Iacute;ndice do destino de dados a copiar (Destination Index). Aponta para o destino dos dados a copiar de DS:ESI.</li></ul>&#10;<p>Estes 8 registradores t&ecirc;m 32 bits cada um e dizem&shy;se Estendidos. Os 16 bits de ordem mais baixa de cada um dos registradores podem ser acedidos atrav&eacute;s das vers&otilde;es n&atilde;o estendidas destes. As vers&otilde;es de 16 bits t&ecirc;m os mesmo nomes que as de 32 bits, com excep&ccedil;&atilde;o de a letra E ser retirada (ex: EAX &rarr; AX). As <a href="http://en.wikipedia.org/wiki/Vers%C3%A3o" id="w">vers&otilde;es</a> estendidas dos registradoress n&atilde;o existem em <a href="http://en.wikipedia.org/wiki/Gera%C3%A7%C3%B5es" id="w">gera&ccedil;&otilde;es</a> anteriores &agrave; 80386 &#8213; a primeira gera&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Processador" id="w">processadores</a> 32 bits da <a href="http://en.wikipedia.org/wiki/Arquitetura" id="w">arquitetura</a> x86.</p>&#10;<p>As vers&otilde;es n&atilde;o estendidas dos quatro primeiros GPRs dividem&shy;se ainda em dois grupos de 8 bits cada um. O octeto (byte) de ordem mais alta &eacute; acedido trocando o X por um H (exemplo: AX &rarr; AH), e o octeto de ordem mais baixa trocando o X por um L (ex: AX &rarr; AL).</p>&#10;<p>Nota: Nos processadores da arquitectura AMD64/EM64T, os GPRs t&ecirc;m 64 bits e pode aceder&shy;se &agrave; totalidade dos <a href="http://en.wikipedia.org/wiki/Bits" id="w">bits</a> atrav&eacute;s dos nomes RAX, RCX, RDX, etc. Adicionalmente, existem ainda mais oito GPRs, de 64 bits cada um. Isto s&oacute; &eacute; v&aacute;lido se o <a href="http://en.wikipedia.org/wiki/Processador" id="w">processador</a> estiver em Modo Longo.</p>&#10;<a id="Registradores_de_segmento" name="Registradores_de_segmento"></a><h3> Registradores de segmento </h3>&#10;<p>H&aacute; 6 registradores de segmento.&#10;</p>&#10;<ul>&#10;<li>CS &shy; Segmento do C&oacute;digo</li>&#10;<li>DS &shy; Segmento de Dados</li>&#10;<li>ES &shy; Segmento com dados extra</li>&#10;<li>FS &shy; Segmento com mais dados</li>&#10;<li>GS &shy; Segmento com ainda mais dados</li>&#10;<li>SS &shy; Segmento da <a href="http://en.wikipedia.org/wiki/Pilha" id="w">Pilha</a> (Stack)</li></ul>&#10;<p>Os <a href="http://en.wikipedia.org/wiki/Segmentos" id="w">segmentos</a> s&atilde;o uma idiossincrasia da <a href="http://en.wikipedia.org/wiki/Arquitetura" id="w">arquitetura</a> x86, n&atilde;o existindo em praticamente mais nenhuma <a href="http://en.wikipedia.org/wiki/Arquitetura" id="w">arquitetura</a>. Sendo assim, os compiladores de linguagens de alto n&iacute;vel geralmente optam por ignorar os segmentos. Por essa raz&atilde;o, os sistemas operativos modernos para x86 (incluindo o Windows e o Linux) tipicamente fazem todos os registradores de segmento apontar para o mesmo segmento de 4GB. As exce&ccedil;&otilde;es a essa regra s&atilde;o geralmente o FS e o GS, que s&atilde;o usados para isolar as sec&ccedil;&otilde;es de <a href="http://en.wikipedia.org/wiki/Dados" id="w">dados</a> das diferentes threads de um mesmo processo. As outras <a href="http://en.wikipedia.org/wiki/Arquitetura" id="w">arquitetura</a> utilizam registradores especiais chamados registradores de thread para esse efeito, os quais n&atilde;o existem no x86.</p>&#10;<a id="Registro_das_flags" name="Registro_das_flags"></a><h3> Registro das flags </h3>&#10;<p>O registrador das flags &eacute; chamado EFLAGS (Extended Flags) nas <a href="http://en.wikipedia.org/wiki/Arquitetura" id="w">arquitetura</a> de 32 bits, sendo a sua vers&atilde;o de 16 bits chamada simplesmente FLAGS. Tal como com os GPRs, os <a href="http://en.wikipedia.org/wiki/Processador" id="w">processador</a> x86 anteriores ao i386 n&atilde;o possuem a vers&atilde;o de 32 bits. Nos <a href="http://en.wikipedia.org/wiki/Processadores" id="w">processadores</a> de 64 bits, este registrador tamb&eacute;m tem 64 bits e chama&shy;se RFLAGS.</p>&#10;<p>No esquema abaixo, os 16 bits menos significativos aparecem a <a href="http://en.wikipedia.org/wiki/Cinza" id="w">cinza</a>, enquanto que os bits a azul apenas existem em processadores da gera&ccedil;&atilde;o do i386 ou posteriores.&#10;</p>&#10;<table style="text&shy;align: center&semi;" width="100%">&#10;&#10;</table>&#10;<td>31</td>&#10;<p />&#10;<td>30</td>&#10;&#10;<p />&#10;<td>29</td>&#10;<p />&#10;<td>28</td>&#10;<p />&#10;<td>27</td>&#10;<p />&#10;<td>26</td>&#10;<p />&#10;<td>25</td>&#10;<p />&#10;<td>24</td>&#10;<p />&#10;<td>23</td>&#10;<p />&#10;<td>22</td>&#10;<p />&#10;<td>21</td>&#10;&#10;<p />&#10;<td>20</td>&#10;<p />&#10;<td>19</td>&#10;<p />&#10;<td>18</td>&#10;<p />&#10;<td>17</td>&#10;<p />&#10;<td>16</td>&#10;<p />&#10;<p />&#10;<tr style="background&shy;color: rgb(51, 51, 204)&semi; color: white&semi;">&#10;&#10;<td>0</td>&#10;&#10;<td>0</td>&#10;&#10;<td>0</td>&#10;&#10;&#10;<td>0</td>&#10;&#10;<td>0</td>&#10;&#10;<td>0</td>&#10;&#10;<td>0</td>&#10;&#10;<td>0</td>&#10;&#10;<td>0</td>&#10;&#10;<td>0</td>&#10;&#10;<td>ID</td>&#10;&#10;<td>VIP</td>&#10;&#10;&#10;<td>VIF</td>&#10;&#10;<td>AC</td>&#10;&#10;<td>VM</td>&#10;&#10;<td>RF</td>&#10;</tr>&#10;<p />&#10;<tr>&#10;&#10;<th colspan="16">&#160&semi;</th>&#10;</tr>&#10;<p />&#10;<tr>&#10;&#10;<td>15</td>&#10;&#10;<td>14</td>&#10;&#10;&#10;<td>13</td>&#10;&#10;<td>12</td>&#10;&#10;<td>11</td>&#10;&#10;<td>10</td>&#10;&#10;<td>9</td>&#10;&#10;<td>8</td>&#10;&#10;<td>7</td>&#10;&#10;<td>6</td>&#10;&#10;<td>5</td>&#10;&#10;&#10;<td>4</td>&#10;&#10;<td>3</td>&#10;&#10;<td>2</td>&#10;&#10;<td>1</td>&#10;&#10;<td>0</td>&#10;</tr>&#10;<p />&#10;<tr style="background&shy;color: rgb(119, 119, 119)&semi; color: white&semi;">&#10;&#10;<td>0</td>&#10;&#10;<td>NT</td>&#10;&#10;<td colspan="2">IOPL</td>&#10;&#10;&#10;<td>OF</td>&#10;&#10;<td>DF</td>&#10;&#10;<td>IF</td>&#10;&#10;<td>TF</td>&#10;&#10;<td>SF</td>&#10;&#10;<td>ZF</td>&#10;&#10;<td>0</td>&#10;&#10;<td>AF</td>&#10;&#10;<td>0</td>&#10;&#10;&#10;<td>PF</td>&#10;&#10;<td>1</td>&#10;&#10;<td>CF</td>&#10;</tr>&#10;<p />&#10;&#10;<p>Ao carregar um novo valor no EFLAGS, os <a href="http://en.wikipedia.org/wiki/Bits" id="w">bits</a> que aparecem no esquema como 1 ou 0 devem ser carregados como tal, de modo a preservar a compatibilidade do <a href="http://en.wikipedia.org/wiki/Software" id="w">software</a> com gera&ccedil;&otilde;es futuras da <a href="http://en.wikipedia.org/wiki/Arquitetura" id="w">arquitetura</a>.</p>&#10;<p>Note&shy;se que utilizar um m&eacute;todo convencional para aceder a este registrador produz um erro do montador (assembler), uma vez que o x86 n&atilde;o fornece nenhuma forma de aceder directamente ao registrador das flags. Para modificar ou ler o eflags &eacute; necess&aacute;rio utilizar a instru&ccedil;&atilde;o pushf (16 bits) ou pushaf (32 bits).</p>&#10;<a id="O_Apontador_de_Execu%C3%A7%C3%A3o" name="O_Apontador_de_Execu%C3%A7%C3%A3o"></a><h2> O Apontador de Execu&ccedil;&atilde;o </h2>&#10;<p>O apontador de execu&ccedil;&atilde;o, ou Instruction Pointer (genericamente conhecido na <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">ci&ecirc;ncia da computa&ccedil;&atilde;o</a> por Program Counter), do x86 &eacute; um registo interno que aponta para a pr&oacute;xima instru&ccedil;&atilde;o a ser executada.</p>&#10;<p>O seu nome &eacute; EIP e a parte que contem os 16 bits menos significativos denomina&shy;se <a href="http://en.wikipedia.org/wiki/IP" id="w">IP</a>. Tal como no caso do registo das flags, n&atilde;o &eacute; poss&iacute;vel utilizar um m&eacute;todo convencional para aceder ao apontador de Execu&ccedil;&atilde;o. Ele tem de ser introduzido no stack por meio de uma instru&ccedil;&atilde;o call ou semelhante.</p>&#10;<a id="Registradores_x86" name="Registradores_x86"></a><h2> Registradores x86 </h2>&#10;<a id="16_bits" name="16_bits"></a><h3> 16 bits </h3>&#10;<p>O original Intel 8086 e 8088 tem quatorze registros de 16 bits. Quatro deles (AX, BX, CX, DX) s&atilde;o registradores de prop&oacute;sito geral (GPRS, embora cada um possa ter uma finalidade adicional: por exemplo, apenas CX pode ser usado como um <a href="http://en.wikipedia.org/wiki/Contador" id="w">contador</a> com a instru&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Loop" id="w">loop</a>). Cada um pode ser acessado como dois <a href="http://en.wikipedia.org/wiki/Bytes" id="w">bytes</a> separados (da&iacute; o byte mais alto BX pode ser acessado como BH e byte baixo como BL). H&aacute; dois registros de ponteiro: SP, que aponta para o topo da <a href="http://en.wikipedia.org/wiki/Pilha" id="w">pilha</a> e da BP (base pointer) que &eacute; usado para apontar para algum outro lugar na <a href="http://en.wikipedia.org/wiki/Pilha" id="w">pilha</a>, geralmente acima de vari&aacute;veis locais. Dois registros (SI e DI) s&atilde;o para a indexa&ccedil;&atilde;o de matriz.</p>&#10;<p>Quatro registradores de segmento (CS, DS, SS e ES) s&atilde;o usados para formar um endere&ccedil;o de mem&oacute;ria. O registrador de flags cont&eacute;m sinalizadores como de proceder com tais flags, overflow de flag e underflow de flag. Finalmente, o ponteiro de instru&ccedil;&atilde;o (IP) aponta para a pr&oacute;xima instru&ccedil;&atilde;o que ser&aacute; obtida a partir da mem&oacute;ria e depois executados.</p>&#10;<p>Na Intel 80286, tr&ecirc;s registros especiais cont&eacute;m endere&ccedil;os  da tabela descrita (GDTR, LDTR, IDTR), e um registo de quarta tarefa (TR).</p>&#10;<a id="32_bits" name="32_bits"></a><h3> 32 bits </h3>&#10;<p>Com o advento do <a href="http://en.wikipedia.org/wiki/Processador" id="w">processador</a> de 32 bits 80386, os registradores de 16 bits, registradores base, registradores de &iacute;ndice, ponteiro de instru&ccedil;&atilde;o, e registradores de flag, mas n&atilde;o os registradores de segmento, foram ampliados para 32 bits. Este &eacute; representado por um <a href="http://en.wikipedia.org/wiki/Prefixo" id="w">prefixo</a> &#34&semi;E&#34&semi; (para Extended) para registrar os nomes em <a href="http://en.wikipedia.org/wiki/Assembly" id="w">linguagem assembly</a> x86. Assim, o registro AX diferencia o registrador de 16 bits do novo EAX 32&shy;bit, SI corresponde ao menor de 16 bits do ESI, e assim por diante. Os <a href="http://en.wikipedia.org/wiki/Registradores" id="w">registradores</a> de uso geral, registradores de base e registradores de &iacute;ndice podem ser usados como base em modos de endere&ccedil;amento, e todos os registos, exceto o ponteiro de <a href="http://en.wikipedia.org/wiki/Pilha" id="w">pilha</a> pode ser utilizado como <a href="http://en.wikipedia.org/wiki/&Iacute;ndice" id="w">&iacute;ndice</a> de endere&ccedil;amento.</p>&#10;<p>Dois novos registros de segmento (FS e GS) foram adicionados. Com um maior n&uacute;mero de registros, instru&ccedil;&otilde;es e operandos, o formato do binario|c&oacute;digo de <a href="http://en.wikipedia.org/wiki/M%C3%A1quina" id="w">m&aacute;quina</a> foi alargado. Para fornecer compatibilidade com vers&otilde;es anteriores, os <a href="http://en.wikipedia.org/wiki/Segmentos" id="w">segmentos</a> com c&oacute;digo execut&aacute;vel pode ser marcado como contendo ou 16 bits ou 32 bits de instru&ccedil;&otilde;es. Prefixos especiais permitem a inclus&atilde;o de instru&ccedil;&otilde;es de 32 bits em um segmento de 16 bits, ou vice&shy;versa.</p>&#10;<p>Com o 80486 uma unidade de processamento de ponto flutuante (FPU) foi adicionada, com oito registros de 80 bits de largura.</p>&#10;<p>Com o Pentium II, oito <a href="http://en.wikipedia.org/wiki/Registradores" id="w">registradores</a> de 64 bits MMX foram adicionados. Com o Pentium III, um de 32 bits Streaming SIMD Extension (SSE) de controle / registrador de status (mxcsr) e oito de 128 bits SSE <a href="http://en.wikipedia.org/wiki/Registradores" id="w">registradores</a> de ponto flutuante (XMM0.. XMM7) foram adicionados [17].&#10;Com o Pentium III, um Streaming SIMD Extension (SSE) de 32 bits, um registrador de controle (MXCSR) e oito registradores SSE de pontos flutuantes de 128 bits (XMM0..XMM7) foram adicionados.</p>&#10;<a id="64_bits" name="64_bits"></a><h3> 64 bits </h3>&#10;<p>Com o <a href="http://en.wikipedia.org/wiki/Processador" id="w">processador</a> AMD Opteron, a <a href="http://en.wikipedia.org/wiki/Arquitetura" id="w">arquitetura</a> x86 estendeu os registradores de 32 bits para registradores de 64 bits de uma forma similar como a extens&atilde;o de 16 bits para 32 bits foi feita, foram adicionadas oito registradores de 64 bits (R8, R9 R15 ..), entre outras. No entanto, essas extens&otilde;es s&atilde;o apenas utiliz&aacute;veis em modo de 64 bits. Os modos de endere&ccedil;amento n&atilde;o mudaram drasticamente a partir do modo de 32 bits, com exce&ccedil;&atilde;o que a <a href="http://en.wikipedia.org/wiki/Resolu%C3%A7%C3%A3o" id="w">resolu&ccedil;&atilde;o</a> foi estendida para 64 bits, endere&ccedil;os <a href="http://en.wikipedia.org/wiki/Virtual" id="w">virtuais</a> foram estendidos para 64 bits, a fim de impedir endere&ccedil;os <a href="http://en.wikipedia.org/wiki/Virtual" id="w">virtuais</a> que se t&ecirc;m revelado problem&aacute;ticos em outras <a href="http://en.wikipedia.org/wiki/Arquitetura" id="w">arquiteturas</a>, e mais alguns detalhes foram drasticamente reduzidos.</p>&#10;<a id="Diversas_funcionalidades" name="Diversas_funcionalidades"></a><h2> Diversas funcionalidades </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Processadores" id="w">Processadores</a> x86 (come&ccedil;ando com o 80386) tamb&eacute;m incluem registradores especiais, tais como registradores de controle (CR0 a 4, CR8 para 64 bits), registradores de <a href="http://en.wikipedia.org/wiki/Depura%C3%A7%C3%A3o" id="w">depura&ccedil;&atilde;o</a> (DR0 a 3, mais 6 e 7), os registradores de teste (TR3 atrav&eacute;s 7&semi; apenas 80.486), registradores descritores (GDTR, LDTR, IDTR), um registrador de tarefas (TR), e modelo especifico de <a href="http://en.wikipedia.org/wiki/Registrador" id="w">registrador</a> (MSRs, aparecendo com o Pentium).</p>&#10;<a id="Segmenta%C3%A7%C3%A3o" name="Segmenta%C3%A7%C3%A3o"></a><h2> Segmenta&ccedil;&atilde;o </h2>&#10;<p> &#10;Os Minicomputadores durante o final de 1970 estavam em execu&ccedil;&atilde;o contra o 16&shy;bit com limite de at&eacute; 64 KB de endere&ccedil;o. Alguns <a href="http://en.wikipedia.org/wiki/Microcomputadores" id="w">microcomputadores</a> como o PDP&shy;11 utilizavam complexos bancos de <a href="http://en.wikipedia.org/wiki/Comuta%C3%A7%C3%A3o" id="w">comuta&ccedil;&atilde;o</a> de <a href="http://en.wikipedia.org/wiki/Sistemas" id="w">sistemas</a>, ou, no caso da Digital VAX, redesenhado processadores muito mais caro que poderia, isso diretamente com endere&ccedil;amento de 32 bits.O original 8086, desenvolvido a partir do 8085 um <a href="http://en.wikipedia.org/wiki/Microprocessador" id="w">microprocessador</a> simples e principalmente visado muito pequeno e barato, em vez que registradores de segmento simples o que aumentou a largura de endere&ccedil;o de mem&oacute;ria de apenas 4 bits. <a href="http://en.wikipedia.org/wiki/Multiplica%C3%A7%C3%A3o" id="w">Multiplicando</a> um endere&ccedil;o de 64 KB por 16, o endere&ccedil;o de 20 bits poder&aacute; endere&ccedil;ar um total de um <a href="http://en.wikipedia.org/wiki/Megabyte" id="w">megabyte</a>(1.048.576 bytes), que foi uma grande quantidade para um pequeno <a href="http://en.wikipedia.org/wiki/Computador" id="w">computador</a>. O conceito de registradores de segmento n&atilde;o era nova para mainframes que muitas vezes era usado segmenta&ccedil;&atilde;o para registar&shy;se e trocar rapidamente as diferentes tarefas. Na pr&aacute;tica, a 86 era (&eacute;) uma lamenta&ccedil;&atilde;o muito criticada, que complicou muito as muitas tarefas comuns de <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o" id="w">programa&ccedil;&atilde;o</a> e <a href="http://en.wikipedia.org/wiki/Compiladores" id="w">compiladores</a>. Mas, como tamb&eacute;m simplificou projeto de hardware e custo, seria a custos competitivos em seus segmentos de mercado dominante. Com o surgimento de padr&otilde;es como o IBM&shy;PC, os custos de desenvolvimento de <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o" id="w">programa&ccedil;&atilde;o</a> pode ser espalhado sobre a venda de muitas c&oacute;pias de <a href="http://en.wikipedia.org/wiki/Software" id="w">software</a>, e a <a href="http://en.wikipedia.org/wiki/Arquitetura" id="w">arquitetura</a> acabariam evoluindo para 32 total de mem&oacute;ria e at&eacute; mesmo endere&ccedil;amento de 64 bits por volta do s&eacute;culo XXI.</p>&#10;<p>Dados e / ou de c&oacute;digos pode ser administrados dentro de &#34&semi;perto de&#34&semi; nos <a href="http://en.wikipedia.org/wiki/Segmentos" id="w">segmentos</a> de 16 bits dentro deste espa&ccedil;o de endere&ccedil;o de 1 MB, ou um <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compilador</a> poderia operar em um modo &#34&semi;more&#34&semi; (muito) com 32 bits de segmento: offset pares alcan&ccedil;ar (apenas) 1 MB. Enquanto que tamb&eacute;m pode revelar&shy;se bastante limites em meados da d&eacute;cada de 1980, que estava trabalhando para o <a href="http://en.wikipedia.org/wiki/Mercado" id="w">mercado</a> de PC emergentes e que se tornou muito simples para traduzir o <a href="http://en.wikipedia.org/wiki/Software" id="w">software</a> dos antigos 8080, 8085 e Z80 para o novo processador. Em 1985, o modelo de segmento de 16&shy;bit de resolu&ccedil;&atilde;o foi efetivamente fatorado pela introdu&ccedil;&atilde;o de 32&shy;bit registro offset, no projeto 386.</p>&#10;<p>No modo real, a <a href="http://en.wikipedia.org/wiki/Segmento" id="w">segmenta&ccedil;&atilde;o</a> &eacute; obtida mudando o endere&ccedil;o de segmento deixado por 4 bits e adicionando um deslocamento, a fim de receber um endere&ccedil;o de 20 bits no final. Por exemplo, se o DS &eacute; A000h e SI &eacute; 5677h, DS: SI vai apontar para o DS endere&ccedil;o absoluto &times; 10h + SI = A5677h. Assim, o espa&ccedil;o de endere&ccedil;os em modo real &eacute; de 220 bytes, ou 1 MB, uma <a href="http://en.wikipedia.org/wiki/Figura" id="w">figura</a> bastante impressionante para 1978. Todos endere&ccedil;os de mem&oacute;ria consistem em um segmento e offset, cada tipo de acesso (c&oacute;digo, dados ou pilha) tem um <a href="http://en.wikipedia.org/wiki/Segmento" id="w">segmento</a> de registro padr&atilde;o associado com ele (para os dados do cadastro &eacute; geralmente DS, para o c&oacute;digo &eacute; CS, e para a <a href="http://en.wikipedia.org/wiki/Pilha" id="w">pilha</a> &eacute; SS). Para acessar os dados, o registrador de segmento pode ser especificado explicitamente (usando um prefixo substituir segmento) para usar qualquer um dos quatro registradores de <a href="http://en.wikipedia.org/wiki/Segmento" id="w">segmento</a>.</p>&#10;<p>Neste <a href="http://en.wikipedia.org/wiki/Esquema" id="w">esquema</a>, dois segmentos de diferentes pares de deslocamento podem apontar em um &uacute;nico local absoluto. Assim, se o DS &eacute; A111h e SI &eacute; 4567h, DS: SI vai apontar para o A5677h. Este regime torna imposs&iacute;vel a utiliza&ccedil;&atilde;o de mais de quatro segmentos de uma vez. CS e SS s&atilde;o vitais para o funcionamento correto do <a href="http://en.wikipedia.org/wiki/Programa" id="w">programa</a>, de modo que somente DS e ES pode ser usado para apontar para dados segmentos fora do <a href="http://en.wikipedia.org/wiki/Programa" id="w">programa</a> (ou, mais precisamente, fora do segmento em execu&ccedil;&atilde;o atualmente do programa) ou a <a href="http://en.wikipedia.org/wiki/Pilha" id="w">pilha</a>.</p>&#10;<p>No modo protegido, um registrador de segmento, j&aacute; n&atilde;o cont&eacute;m o endere&ccedil;o <a href="http://en.wikipedia.org/wiki/F%C3%ADsico" id="w">f&iacute;sico</a> do in&iacute;cio de um segmento, mas cont&ecirc;m um &#34&semi;selector&#34&semi;, que aponta para uma estrutura em n&iacute;vel de sistema chamado de segmento descritor. Um descritor de segmento cont&eacute;m o endere&ccedil;o <a href="http://en.wikipedia.org/wiki/F%C3%ADsico" id="w">f&iacute;sico</a> do in&iacute;cio do segmento, o comprimento do segmento, e permiss&otilde;es de acesso a esse segmento.</p>&#10;<p>O deslocamento &eacute; verificado em rela&ccedil;&atilde;o ao comprimento do segmento, com deslocamentos referindo&shy;se a localidades fora do segmento que pode causar uma exce&ccedil;&atilde;o. Compensa&ccedil;&otilde;es referindo&shy;se a locais dentro do segmento s&atilde;o combinados com o endere&ccedil;o <a href="http://en.wikipedia.org/wiki/F%C3%ADsico" id="w">f&iacute;sico</a> do in&iacute;cio do segmento a obter o endere&ccedil;o <a href="http://en.wikipedia.org/wiki/F%C3%ADsico" id="w">f&iacute;sico</a> correspondente ao <a href="http://en.wikipedia.org/wiki/Offset" id="w">offset</a>.</p>&#10;<p>A <a href="http://en.wikipedia.org/wiki/Segmenta%C3%A7%C3%A3o" id="w">segmenta&ccedil;&atilde;o</a> da <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o" id="w">programa&ccedil;&atilde;o</a> e <a href="http://en.wikipedia.org/wiki/Design" id="w">design</a> do <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compilador</a> &eacute; dif&iacute;cil, pois o uso de ponteiros afeta o desempenho.</p>&#10;<a id="%7B%7BVer_tamb%C3%A9m%7D%7D" name="%7B%7BVer_tamb%C3%A9m%7D%7D"></a><h2>   </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Intel_Corporation" id="w">Intel Corporation</a></li></ul>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Microprocessadores_x86" id="w"> </a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Arquitetura_de_computadores" id="w">Categoria:Arquitetura de computadores</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Arquitetura_x86" id="w"> </a></p></body></html>