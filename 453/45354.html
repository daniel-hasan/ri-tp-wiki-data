<html><title>Gerenciamento de mem&oacute;ria</title><body>&#10;<p> &#10; &#10;<b>Gerenciamento</b> (ou <b>gest&atilde;o</b>) de <b>mem&oacute;ria</b> &eacute; um complexo campo da <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">ci&ecirc;ncia da computa&ccedil;&atilde;o</a> e s&atilde;o constantemente desenvolvidas v&aacute;rias t&eacute;cnicas para torn&aacute;&shy;la mais eficiente. Em sua forma mais simples, est&aacute; relacionado em duas tarefas essenciais:&#10;</p>&#10;<ul>&#10;<li><b>Aloca&ccedil;&atilde;o</b>: Quando o programa requisita um bloco de <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria" id="w">mem&oacute;ria</a>, o gerenciador o disponibiliza para a aloca&ccedil;&atilde;o&semi;</li>&#10;<li><b>Reciclagem</b>: Quando um bloco de mem&oacute;ria foi alocado, mas os dados n&atilde;o foram requisitados por um determinado n&uacute;mero de ciclos ou n&atilde;o h&aacute; nenhum tipo de refer&ecirc;ncia a este bloco pelo programa, esse bloco &eacute; liberado e pode ser reutilizado para outra requisi&ccedil;&atilde;o.</li></ul>&#10;<a id="Ger%C3%AAncia_de_Mem%C3%B3ria" name="Ger%C3%AAncia_de_Mem%C3%B3ria"></a><h2> Ger&ecirc;ncia de Mem&oacute;ria </h2>&#10;<p>A cada dia que passa os programadores necessitam de mais mem&oacute;ria e mais programas rodando simultaneamente para poderem tratar cada vez mais informa&ccedil;&otilde;es. O tratamento necess&aacute;rio da mem&oacute;ria utilizada n&atilde;o &eacute; uma tarefa f&aacute;cil de ser implementada. Existem v&aacute;rios requisitos que devem ser observados para o correto funcionamento, tais como, seguran&ccedil;a, isolamento, performance, entre outros. Para isto a fun&ccedil;&atilde;o de gerenciar a mem&oacute;ria passa a ser do <a href="http://en.wikipedia.org/wiki/Sistema_operacional" id="w">sistema operacional</a> e n&atilde;o mais do aplicativo.</p>&#10;<p>Para que uma mem&oacute;ria funcione de maneira correta, &eacute; necess&aacute;rio que se tome cuidado com v&aacute;rios elementos como seguran&ccedil;a e isolamento, e para isso &eacute; utilizado o gerenciamento de mem&oacute;ria. Este desenvolve sua fun&ccedil;&atilde;o a partir de duas tarefas, a Aloca&ccedil;&atilde;o de Mem&oacute;ria e a Fragmenta&ccedil;&atilde;o:&#10;</p>&#10;<ul>&#10;<li>A Aloca&ccedil;&atilde;o pode ser tanto est&aacute;tica, feita quando o programa &eacute; compilado, e a din&acirc;mica, adiada at&eacute; a execu&ccedil;&atilde;o.</li>&#10;<li>A Fragmenta&ccedil;&atilde;o, desperd&iacute;cio de mem&oacute;ria, por sua vez pode ser interna, sobra na mem&oacute;ria reservada ao programa, e externa que acontece quando ap&oacute;s o termino dos programas s&atilde;o deixadas pequenas lacunas entre as p&aacute;ginas.</li></ul>&#10;<p>Para que a utiliza&ccedil;&atilde;o da mem&oacute;ria seja mais vantajosa, &eacute; utilizada a <a href="http://en.wikipedia.org/wiki/Pagina%C3%A7%C3%A3o" id="w">Pagina&ccedil;&atilde;o</a>, processos virtuais da mem&oacute;ria, aplicados na divis&atilde;o da mem&oacute;ria f&iacute;sica em parti&ccedil;&otilde;es menores, chamadas de <a href="http://en.wikipedia.org/wiki/Frames" id="w">frames</a>. &#10;O conjunto de <a href="http://en.wikipedia.org/wiki/Registradores" id="w">registradores</a> especiais r&aacute;pidos chama&shy;se Translation Lookaside Buffer, estes s&atilde;o subdivididos em chave valor que lhe &eacute; dado em todos os registradores ao mesmo tempo, e valor. </p>&#10;<p>Existe uma t&eacute;cnica de gerencia de mem&oacute;ria chamada <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_virtual" id="w">mem&oacute;ria virtual</a>, que &eacute; onde <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_principal" id="w">mem&oacute;rias principais</a> e secund&aacute;rias juntas criam a ilus&atilde;o de que h&aacute; muito mais mem&oacute;ria, com isso os programas e suas estruturas de dados n&atilde;o se limitam ao tamanho da mem&oacute;ria f&iacute;sica, e assumem endere&ccedil;os na mem&oacute;ria secund&aacute;ria.&#10;O gerenciamento de mem&oacute;ria virtual pode ocasionar vazamento de mem&oacute;ria, ou seja, quando determinada quantia de mem&oacute;ria &eacute; alocada e n&atilde;o liberada mesmo que n&atilde;o sendo utilizada, assim dados perdem a referencia sem ao menos terem usado mem&oacute;ria.&#10;O gerenciamento autom&aacute;tico chama&shy;se <a href="http://en.wikipedia.org/wiki/Coletor_de_lixo_(inform%C3%A1tica)" id="w">Garbage collector</a>. Ele retira os blocos de mem&oacute;ria automaticamente. Seus algoritmos s&atilde;o divididos em duas fam&iacute;lias: a Identifica&ccedil;&atilde;o direta, por contagem de refer&ecirc;ncia, e a Identifica&ccedil;&atilde;o indireta, por varrimento.</p>                             &#10;<a id="Aloca%C3%A7%C3%A3o" name="Aloca%C3%A7%C3%A3o"></a><h3> Aloca&ccedil;&atilde;o </h3>&#10;<p>A aloca&ccedil;&atilde;o de mem&oacute;ria est&aacute; dividida em 3(tr&ecirc;s) partes:&#10;</p>&#10;<ul>&#10;<li>Aloca&ccedil;&atilde;o Est&aacute;tica: Decis&atilde;o tomada quando o programa &eacute; compilado.</li></ul>&#10;<p>Quando o programa &eacute; executado o Sistema operacional o l&ecirc; e cria um processo, sendo o programa uma no&ccedil;&atilde;o est&aacute;tica e o processo o programa em execu&ccedil;&atilde;o, que &eacute; criado em armazenamento prim&aacute;rio e ap&oacute;s isso recebe um espa&ccedil;o na mem&oacute;ria. O espa&ccedil;o de mem&oacute;ria &eacute; dividido em varias partes, uma das partes se chama segmentos de mem&oacute;ria, que armazena dados est&aacute;ticos, e outro se chama segmento de c&oacute;digo que guarda instru&ccedil;&otilde;es do programa. Quando o programa &eacute; executado o registrador <a href="http://en.wikipedia.org/wiki/Contador_de_programa" id="w">PC</a> apontar&aacute; para determinado endere&ccedil;o do segmento de c&oacute;digo do processo, que se chama TEXT. Para que se realize a aloca&ccedil;&atilde;o est&aacute;tica o compilador deve saber o total de mem&oacute;ria que est&aacute; livre, mandar esta informa&ccedil;&atilde;o para o SO para que este crie um segmento de dados.</p>&#10;&#10;<ul>&#10;<li>Aloca&ccedil;&atilde;o Din&acirc;mica: Decis&atilde;o &eacute; adiada at&eacute; a execu&ccedil;&atilde;o. (Permite Swapping)</li></ul>&#10;<p>Os objetos alocados dinamicamente podem ser criados e liberados a qualquer momento, em qualquer ordem, o que difere dos objetos locais das fun&ccedil;&otilde;es, que s&atilde;o criados e destru&iacute;dos em uma ordem espec&iacute;fica. Dado isto, &eacute; preciso organizar a mem&oacute;ria para objetos din&acirc;micos de uma forma que possibilite o gerenciamento do tempo de vida dos objetos por parte do programador. A mem&oacute;ria reservada para objetos din&acirc;mica costuma ser chamada de heap, existem v&aacute;rias formas de organizar um heap. Em linguagens sem gerenciamento autom&aacute;tico (linguagem C), da mem&oacute;ria din&acirc;mica, uma organiza&ccedil;&atilde;o usual do heap &eacute; uma lista encadeada de blocos livres, por&eacute;m este tipo de organiza&ccedil;&atilde;o pode ter problemas devido &agrave; fragmenta&ccedil;&atilde;o dos blocos. J&aacute; em linguagens com gerenciamento autom&aacute;tico de mem&oacute;ria din&acirc;mica (Java), a organiza&ccedil;&atilde;o do heap depende da parte do sistema de tempo de execu&ccedil;&atilde;o encarregada deste gerenciamento. Este componente &eacute; normalmente chamado de <a href="http://en.wikipedia.org/wiki/Coletor_de_lixo_(inform%C3%A1tica)" id="w">coletor de lixo</a>.</p>&#10;&#10;<ul>&#10;<li>Aloca&ccedil;&atilde;o Local:</li></ul>&#10;<p>Este processo de aloca&ccedil;&atilde;o &eacute; usado para vari&aacute;veis que s&atilde;o locais a fun&ccedil;&otilde;es e sub&shy;rotinas. Isso significa que o processo em execu&ccedil;&atilde;o deve manter acess&iacute;vel as vari&aacute;veis locais da fun&ccedil;&atilde;o ou procedimento que est&aacute; executando no momento. Al&eacute;m disso, pelas propriedades do escopo em blocos, tamb&eacute;m devem estar acess&iacute;veis as vari&aacute;veis de blocos mais externos. Em linguagens que permitem a defini&ccedil;&atilde;o de fun&ccedil;&otilde;es aninhadas, acessando as vari&aacute;veis de quaisquer fun&ccedil;&otilde;es definidas externamente &agrave; fun&ccedil;&atilde;o atualmente em execu&ccedil;&atilde;o. Como uma fun&ccedil;&atilde;o pode chamar outras fun&ccedil;&otilde;es, um n&uacute;mero arbitr&aacute;rio de fun&ccedil;&otilde;es pode estar no meio de sua execu&ccedil;&atilde;o em um determinado momento, mesmo que apenas uma esteja realmente sendo executada, isso indica que o contexto de v&aacute;rias fun&ccedil;&otilde;es deve ser mantido enquanto as mesmas n&atilde;o conclu&iacute;ram sua execu&ccedil;&atilde;o.</p>&#10;<a id="Fragmenta%C3%A7%C3%A3o" name="Fragmenta%C3%A7%C3%A3o"></a><h3> Fragmenta&ccedil;&atilde;o </h3>&#10;<p>Desperd&iacute;cio de p&aacute;ginas de mem&oacute;ria alocadas. </p>&#10;<p>Pode ser de dois tipos: interna e externa.</p>&#10;<p>Interna: Ocorre quando o processo n&atilde;o ocupa inteiramente os blocos de mem&oacute;ria (p&aacute;ginas) reservados para ele. Geralmente acontece pois o tamanho do processo n&atilde;o &eacute; um m&uacute;ltiplo do tamanho da p&aacute;gina de mem&oacute;ria, o que acarreta sobra de espa&ccedil;o na &uacute;ltima p&aacute;gina alocada.</p>&#10;<p>Externa: Ocorre &agrave; medida que os programas v&atilde;o terminando e deixando lacunas cada vez menores de espa&ccedil;os entre as p&aacute;ginas. Dependendo do tamanho que precisa ser escrito em mem&oacute;ria, estes espa&ccedil;os podem ser pequenos demais para serem &uacute;teis, e assim ficam inutilizados.</p>&#10;<p>Estrat&eacute;gias para &#34&semi;atacar&#34&semi; o problema com o algoritmos <a href="http://en.wikipedia.org/wiki/First_Fit" id="w">First&shy;fit</a>, <a href="http://en.wikipedia.org/wiki/Best&shy;fit" id="w">Best&shy;fit</a>, <a href="http://en.wikipedia.org/wiki/Worst&shy;fit" id="w">Worst&shy;fit</a> e <a href="http://en.wikipedia.org/wiki/Algoritmo_Next&shy;fit" id="w">Next&shy;fit</a></p>&#10;<a id="Pagina%C3%A7%C3%A3o" name="Pagina%C3%A7%C3%A3o"></a><h3> Pagina&ccedil;&atilde;o </h3>&#10;<p>No contexto dos sistemas operacionais, a <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_paginada" id="w">pagina&ccedil;&atilde;o  da mem&oacute;ria</a> do computador  &eacute; um processo de virtualiza&ccedil;&atilde;o da mem&oacute;ria que consiste na subdivis&atilde;o da mem&oacute;ria f&iacute;sica em pequenas parti&ccedil;&otilde;es (frames), para permitir uma utiliza&ccedil;&atilde;o mais eficiente da mesma. A aloca&ccedil;&atilde;o de mem&oacute;ria &eacute; requisitada por p&aacute;ginas, a menor unidade deste m&eacute;todo. Cada p&aacute;gina &eacute; mapeada num frame de mem&oacute;ria atrav&eacute;s de um processo chamado de pagina&ccedil;&atilde;o.&#10;O sistema operacional pode estar em base do espa&ccedil;o de endere&ccedil;amento, em RAM, ou estar no topo do espa&ccedil;o de endere&ccedil;amento, em ROM, e o restante do sistema mais embaixo, em RAM. O primeiro modelo foi inicialmente empregado em computadores de grande porte e minicomputadores (mas n&atilde;o &eacute; muito usado). O segundo modelo &eacute; utilizado em alguns computadores de m&atilde;o e em sistemas embarcados. O terceiro modelo fez parte dos primeiros computadores pessoais, nos quais a parte do sistema contida em ROM &eacute; denominada BIOS.&#10;Quando o sistema &eacute; organizado dessa maneira, somente um processo pode ser executado a cada instante. T&atilde;o logo um usu&aacute;rio tecle um comando, o sistema operacional carrega o programa solicitado, do disco, para a mem&oacute;ria e o executa. Quando o processo finaliza, o SO coloca na tela um caractere de prompt e espera por um novo comando. Ao receber um novo comando, carregar&aacute; o novo programa na mem&oacute;ria, no espa&ccedil;o de endere&ccedil;amento ocupado pelo programa anterior.</p>&#10;<a id="Translation_Lookaside_Buffer" name="Translation_Lookaside_Buffer"></a><h3> Translation Lookaside Buffer </h3>&#10;<p>A Translation Lookaside Buffer (TLB) &eacute; um conjunto de registradores especiais que s&atilde;o bastante r&aacute;pidos.&#10;Cada registrador tem duas partes: chave e valor. Dada uma chave, busca&shy;se o valor correspondente.&#10;Geralmente, 64 entradas, no m&aacute;ximo, e a busca &eacute; feita em todos os registradores simultaneamente.</p>&#10;<p>Mem&oacute;ria virtual &eacute; uma t&eacute;cnica poderosa e sofisticada de ger&ecirc;ncia de mem&oacute;ria, onde as mem&oacute;rias principal e secund&aacute;ria s&atilde;o combinadas, dando ao usu&aacute;rio a ilus&atilde;o de existir uma mem&oacute;ria muito maior que a capacidade real da mem&oacute;ria principal. O conceito desta t&eacute;cnica fundamenta&shy;se em n&atilde;o vincular o endere&ccedil;amento feito pelo programa aos endere&ccedil;os f&iacute;sicos da mem&oacute;ria principal. Desta forma, programas e suas estruturas de dados deixam de estar limitados ao tamanho da mem&oacute;ria f&iacute;sica dispon&iacute;vel, pois podem possuir endere&ccedil;os associados &agrave; mem&oacute;ria secund&aacute;ria.&#10;</p><a id="Algoritmos_de_Substitui%C3%A7%C3%A3o_de_P%C3%A1gina" name="Algoritmos_de_Substitui%C3%A7%C3%A3o_de_P%C3%A1gina"></a><h3> Algoritmos de Substitui&ccedil;&atilde;o de P&aacute;gina </h3>&#10;<p> &#10;</p>&#10;<ul>&#10;<li>Algoritmo <b>&Oacute;timo</b></li>&#10;<li>Algoritmo N&atilde;o Usada Recentemente</li>&#10;<li>Algoritmo FIFO</li>&#10;<li>Algoritmo Segunda Chance</li>&#10;<li>Algoritmo do rel&oacute;gio</li>&#10;<li>Menos Recentemente Usada</li>&#10;<li>WSClock</li></ul>&#10;<p><b>Gerenciamento de mem&oacute;ria</b>&shy;&shy;<a href="http://en.wikipedia.org/wiki/Especial:Contribui%C3%A7%C3%B5es/200.17.56.9" id="w">200.17.56.9</a> (<a href="http://en.wikipedia.org/wiki/Usu%C3%A1rio(a)_Discuss%C3%A3o:200.17.56.9" id="w">discuss&atilde;o</a>) 11h03min de 19 de setembro de 2013 (UTC)<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup>&#10;Em modelos de gerenciamento manual, podem ocorrer os problemas conhecidos como <i>vazamento de mem&oacute;ria</i>, que acontece quando uma quantidade de mem&oacute;ria &eacute; alocada e n&atilde;o &eacute; liberada ainda que nunca seja utilizada. Isto ocorre quando <a href="http://en.wikipedia.org/wiki/Objeto" id="w">objetos</a> perdem a refer&ecirc;ncia sem terem sido liberados, mantendo o uso do espa&ccedil;o de mem&oacute;ria.</p>&#10;<a id="Garbage_Collector" name="Garbage_Collector"></a><h2> Garbage Collector </h2>&#10;<p>&Eacute; o gerenciamento autom&aacute;tico de mem&oacute;ria, tamb&eacute;m conhecido como <i>coletores</i>, sendo conhecido em Portugal como <i>reciclagem autom&aacute;tica de mem&oacute;ria</i>. Este servi&ccedil;o libera os blocos de mem&oacute;ria que n&atilde;o sejam mais usados por um <a href="http://en.wikipedia.org/wiki/Programa" id="w">programa</a> automaticamente. &Eacute; oposto ao gerenciamento de mem&oacute;ria manual, a aloca&ccedil;&atilde;o explicita e a desaloca&ccedil;&atilde;o dos recursos de mem&oacute;ria do computador.</p>&#10;<p>As vantagens desse tipo de gerenciamento s&atilde;o: </p>&#10;&#10;<ul>&#10;<li>Liberdade do programador: N&atilde;o &eacute; obrigado ficar atento aos detalhes da mem&oacute;ria&semi;</li>&#10;<li>Menos bugs de gerenciamento de mem&oacute;ria: Por se tratar de uma t&eacute;cnica mais confi&aacute;vel&semi;</li>&#10;<li>Gerenciamento autom&aacute;tico: Mais eficiente que o manual&semi;</li></ul>&#10;<p>E entre as desvantagens, podemos citar:</p>&#10;&#10;<ul>&#10;<li>O desenvolvedor tende a estar mais desatento em rela&ccedil;&atilde;o a detalhes de mem&oacute;ria&semi;</li>&#10;<li>O gerenciador autom&aacute;tico ainda apresenta limita&ccedil;&otilde;es.</li></ul>&#10;<p>Quando deixam de existir refer&ecirc;ncias a um objeto, este passa a ser considerado apto a ser &#34&semi;coletado&#34&semi; pelo garbage collector, que significa dizer que ser&aacute; removido da mem&oacute;ria, deixando&shy;a livre para uso por outros objetos.</p>&#10;<p>Os algoritmos de <i>garbage collection</i> operam de um modo que permite classific&aacute;&shy;los em duas grandes fam&iacute;lias:</p>&#10;&#10;<ul>&#10;<li>Identifica&ccedil;&atilde;o Direta: por contagem de refer&ecirc;ncias (<i>reference counting</i>)&semi;</li>&#10;<li>Identifica&ccedil;&atilde;o Indireta: por varrimento (<i>tracing</i>), que pode incluir tamb&eacute;m compacta&ccedil;&atilde;o da mem&oacute;ria livre&semi; c&oacute;pia&semi; ou geracional (utilizado nas m&aacute;quinas virtuais Java e .Net)</li></ul>&#10;<a id="Gerenciamento_de_mem%C3%B3ria_no_DOS" name="Gerenciamento_de_mem%C3%B3ria_no_DOS"></a><h2> Gerenciamento de mem&oacute;ria no DOS </h2>&#10;<p>O IBM PC original foi projetado com uma mem&oacute;ria RAM de 1024KB&#10;</p>&#10;<ul>&#10;<li>640KB &#10;<ul>&#10;<li>Para o <a href="http://en.wikipedia.org/wiki/Sistema_operacional" id="w">sistema operacional</a> e <a href="http://en.wikipedia.org/wiki/Programa" id="w">programa</a>s</li></ul></li>&#10;<li>384KB &shy; <i>&aacute;rea de mem&oacute;ria superior</i> (Upper Memory Area) ou UMA&#10;<ul>&#10;<li>Para os adaptadores diversos como EGA &#38&semi; VGA, MDA, adaptadores CGA, e de redes.</li>&#10;<li>ROM BIOS e Shadow RAM.</li>&#10;<li>E mais tarde, &aacute;rea de pagina&ccedil;&atilde;o de expans&atilde;o de mem&oacute;ria (EMS) vista mais adiante.</li></ul></li></ul>&#10;<p>Logo depois, foi provado que esta quantidade de mem&oacute;ria se tornaria insuficiente para as necessidades futuras.</p>&#10;<p>Entretanto, os sistemas operacionais e aplicativos desenvolvidos at&eacute; ent&atilde;o n&atilde;o seriam capazes de reconhecer um endere&ccedil;o de mem&oacute;ria superior aos 640KB originais, o que levou os projetistas a desenvolverem ferramentas que executariam esta tarefa.</p>&#10;<a id="Emm386.exe" name="Emm386.exe"></a><h3> Emm386.exe </h3>&#10;<p>&Eacute; o dispositivo de instala&ccedil;&atilde;o da <i><a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_expandida" id="w">mem&oacute;ria expandida</a></i> (Expanded Memory) ou EMS. A EMS consistia em toda a mem&oacute;ria acima dos 1024KB (1MB) original, em computadores baseados nas tecnologias dos <a href="http://en.wikipedia.org/wiki/Processador" id="w">processadores</a> 80286, 80386, i486 ou Pentium.&#10;A capacidade m&aacute;xima de endere&ccedil;amento fica limitada a 32MB e seu acesso &eacute; atrav&eacute;s de uma pagina&ccedil;&atilde;o de 64KB na &aacute;rea UMA. Os programas deveriam ser escritos de forma a poderem reconhecer a &aacute;rea EMS.</p>&#10;<p>O nome &#34&semi;EMM&#34&semi; vem do ingl&ecirc;s <i>Extended Memory Manager</i>.</p>&#10;<a id="Himem.sys" name="Himem.sys"></a><h3> Himem.sys </h3>&#10;<p>&Eacute; o dispositivo de instala&ccedil;&atilde;o da <i>&aacute;rea de mem&oacute;ria alta</i> (High Memory Area), conhecida tamb&eacute;m como HMA. Sua principal fun&ccedil;&atilde;o &eacute; controlar o uso da mem&oacute;ria estendida do computador, de modo que dois ou mais aplicativos ou <a href="http://en.wikipedia.org/wiki/Dispositivo" id="w">dispositivos</a> n&atilde;o utilizem o mesmo endere&ccedil;o de mem&oacute;ria ao mesmo tempo. Para as primeiras vers&otilde;es do Windows, o Himem.sys fornecia suporte para que este fosse executado em modo protegido.</p>&#10;<p>O nome Himem vem do ingl&ecirc;s <i>High Memory</i>.</p>&#10;<a id="Smartdrv.exe" name="Smartdrv.exe"></a><h3> Smartdrv.exe </h3>&#10;<p>&Eacute; o gerenciador de mem&oacute;ria cache de disco (no <a href="http://en.wikipedia.org/wiki/Novell_Netware" id="w">Novell</a> <a href="http://en.wikipedia.org/wiki/MS&shy;DOS" id="w">DOS</a> 7, &eacute; chamado de Nwcache.exe). Ambos possuem a mesma fun&ccedil;&atilde;o que &eacute; a de minimizar o acesso ao disco, carregando um bloco de informa&ccedil;&otilde;es na mem&oacute;ria para processamento, ao inv&eacute;s de ir buscar aos poucos no disco. Existiram tamb&eacute;m placas de expans&atilde;o chamadas de <i>Disk Accelerator</i>, que possuem um hardware pr&oacute;prio para esta tarefa, como por exemplo o &#39&semi;Disk Accelerator PROMISE DC4030VL<i>.&#10;Atualmente, esta t&eacute;cnica &eacute; desempenhada por mem&oacute;rias localizadas na placa principal do sistema (</i>cache on&shy;board<i>) resultando, portanto, dois modos de gerenciamento de mem&oacute;ria cache de disco: por </i>software<i> e por </i>hardware<i>.</i></p>&#10;<p>O nome Smartdrv &eacute; uma abrevia&ccedil;&atilde;o do ingl&ecirc;s <i>Smart Drive</i>.</p>&#10;<a id="Multiprograma%C3%A7%C3%A3o_com_Parti%C3%A7%C3%B5es_Fixas" name="Multiprograma%C3%A7%C3%A3o_com_Parti%C3%A7%C3%B5es_Fixas"></a><h2> Multiprograma&ccedil;&atilde;o com Parti&ccedil;&otilde;es Fixas </h2>&#10;<p>&Eacute; usada em sistemas embarcados simples. Muitos dos programas modernos permitem que m&uacute;ltiplos processos executem simult&acirc;neamente, ou seja, quando um processo for bloqueado, outro poder&aacute; usar a CPU aumentando a sua utiliza&ccedil;&atilde;o.&#10;O melhor jeito de realizar a multiprograma&ccedil;&atilde;o consiste em dividir a mem&oacute;ria em n parti&ccedil;&otilde;es de tamanhos diferentes que podem ser criadas manualmente ao iniciar o sistema.&#10;Ao chegar no sistema, um <i>job</i> &eacute; colocado em uma fila de entrada juntamente associada &agrave; menor parti&ccedil;&atilde;o existente, por&eacute;m que seja grande o suficiente para armazen&aacute;&shy;lo e, como o tamanho dessas devidas parti&ccedil;&otilde;es s&atilde;o fixas, todo espa&ccedil;o que n&atilde;o &eacute; usado pelo <i>job</i> na parti&ccedil;&atilde;o ser&aacute; perdido.&#10;Quando <i>jobs</i> est&atilde;o chegando torna&shy;se evidente quando a fila para uma grande parti&ccedil;&atilde;o est&aacute; vazia, mas a fila para uma pequena parti&ccedil;&atilde;o est&aacute; cheia, nesse caso os <i>jobs</i> pequenos ter&atilde;o que esperar para que a mem&oacute;ria seja liberada, mesmo que exista mem&oacute;ria dispon&iacute;vel. O modo correto &eacute; manter uma fila &uacute;nica, sempre que a parti&ccedil;&atilde;o se torna dispon&iacute;vel, o <i>job</i> que se encontra mais pr&oacute;ximo do in&iacute;cio da fila e que caiba na parti&ccedil;&atilde;o pode ser nela executado.  Para que n&atilde;o haja um total desperd&iacute;cio de grandes parti&ccedil;&otilde;es com <i>jobs</i> pequenos, o ideal seria pesquisar em toda a fila de entrada e alocar a parti&ccedil;&atilde;o dispon&iacute;vel ao maior <i>job</i> que nela possa ser carregado. Para que os <i>jobs</i> pequenos possam tamb&eacute;m serem executados sem desperdi&ccedil;ar parti&ccedil;&otilde;es maiores, seria necess&aacute;ria a cria&ccedil;&atilde;o de ao menos uma parti&ccedil;&atilde;o pequena.</p>&#10;<a id="Modelagem_de_Multiprograma%C3%A7%C3%A3o" name="Modelagem_de_Multiprograma%C3%A7%C3%A3o"></a><h2> Modelagem de Multiprograma&ccedil;&atilde;o </h2>&#10;<p>Tem o objetivo de melhorar o desempenho da CPU, se um processo permanecer em execu&ccedil;&atilde;o apenas 20% do tempo em que ocupa a mem&oacute;ria, com cinco processos simultaneamente na mem&oacute;ria a CPU deveria permanecer ocupada nesse intervalo de tempo, esse modelo n&atilde;o &eacute; realista porque os cinco processos nunca poder&atilde;o esperar E/S ao mesmo tempo.&#10;Outro modelo &eacute; supor que um processo gaste uma fra&ccedil;&atilde;o p de seu tempo esperando pela finaliza&ccedil;&atilde;o de sua solicita&ccedil;&atilde;o de E/S, e com os n processos executando ao mesmo tempo em mem&oacute;ria, a probabilidade dos processos estarem aguardando E/S &eacute; p^n. A probabilidade presume como independentes todos os n processos, que sendo assim &eacute; aceit&aacute;vel existirem 5 processos em mem&oacute;ria, sendo que tr&ecirc;s deles executando simultaneamente e dois em estado de espera, mas, como se tem uma &uacute;nica CPU, n&atilde;o pode haver tr&ecirc;s processos executando ao mesmo tempo, de modo que se um processo estiver pronto para a execu&ccedil;&atilde;o, ter&aacute; de esperar enquanto a CPU estiver ocupada com outro processo, portanto observa&shy;se que os processos n&atilde;o s&atilde;o independentes.&#10;Suponha que um computador tenha 32MB de mem&oacute;ria, e um SO que use 16 MB e cada programa empregando 4MB. Com esses tamanhos possibilitam que os programas estejam simultaneamente na mem&oacute;ria, considerando que um processo passa 80% de seu tempo em espera por E/S, o c&aacute;lculo de utiliza&ccedil;&atilde;o da CPU se d&aacute; por 1&shy;(p^n), sendo, nesse caso, n=4 (pois a mem&oacute;ria restante para os programas &eacute; de 16MB e cada programa tem 4MB, ent&atilde;o 16/4) e o p=0,80, portanto tem&shy;se uma utiliza&ccedil;&atilde;o da CPU de 1&shy;0,8^4 (1&shy;p^n), aproximadamente 60%. Se houver a adi&ccedil;&atilde;o de mais 16MB permite que aumente seu grau de multiprograma&ccedil;&atilde;o, aumentara a utiliza&ccedil;&atilde;o da CPU para aproximadamente 83%. Ainda adicionando mais 16 MB, de 83% a utiliza&ccedil;&atilde;o da CPU vai para aproximadamente 93%. O modelo permite que o dono do computador decida que a primeira adi&ccedil;&atilde;o de mem&oacute;ria &eacute; um bom investimento, mas n&atilde;o a segunda que s&oacute; aumentou 12% de sua utiliza&ccedil;&atilde;o.&#10;Um modelo mais real&iacute;stico pode ser baseado na <a href="http://en.wikipedia.org/wiki/Teoria_das_filas" id="w">teoria das filas</a>.</p>&#10;<a id="An%C3%A1lise_de_Desempenho_de_Sistemas_de_Multiprograma%C3%A7%C3%A3o" name="An%C3%A1lise_de_Desempenho_de_Sistemas_de_Multiprograma%C3%A7%C3%A3o"></a><h2> An&aacute;lise de Desempenho de Sistemas de Multiprograma&ccedil;&atilde;o </h2>&#10;<p>O ultimo modelo usado em modelagem de multiprograma&ccedil;&atilde;o pode ser usado para analisar sistemas em lote, por exemplo, digamos que um centro onde <i>jobs</i> gastariam 80% do seu tempo com espera de E/S, em um certo dia quatro desses <i>jobs</i> s&atilde;o submetidos, o primeiro chega &agrave;s dez horas,  requer quatro minutos de tempo da CPU, considerando que os 80% do tempo &eacute; gasto com espera de E/S, o <i>job</i> usar&aacute; apenas 12 segundos de tempo da CPU para cada minuto que estiver rodando na mem&oacute;ria, mesmo que n&atilde;o haja outros <i>jobs</i> competindo com ele pela CPU. Os demais 48 segundos ser&atilde;o gastos esperando pela conclus&atilde;o de E/S, ent&atilde;o o <i>job</i> ter&aacute; de ficar na mem&oacute;ria no m&iacute;nimo 20 segundos para que possa obter quatro minutos de trabalho da CPU, mesmo sem competi&ccedil;&atilde;o de processos.&#10;Desde 10h &agrave;s 10h10, o primeiro <i>job</i> consegue 2 minutos de trabalho da CPU. Quando o segundo <i>job</i> chega &agrave;s 10h10, a utiliza&ccedil;&atilde;o da CPU aumenta de 0,20 para 0,36. No entanto, com o escalonamento round&shy;robin (altern&acirc;ncia circular), cada <i>job</i> consegue metade do tempo da CPU, obtendo 18 minutos de trabalho da CPU realizado para cada minuto de perman&ecirc;ncia na mem&oacute;ria, a entrada do segundo <i>job</i> custa ao primeiro <i>job</i> somente 10% de perda em seu desempenho. Ele passa de 0,20 minutos de CPU para 0,18 para cada minuto de perman&ecirc;ncia em mem&oacute;ria. &#10;&Agrave;s 10h15 chega o terceiro <i>job</i>, at&eacute; esse momento o <i>job</i> 1 tinha recebido 2,9 minutos de CPU e o segundo <i>job</i> 0,9 minutos de CPU. Com uma multiprograma&ccedil;&atilde;o de grau tr&ecirc;s, cada job consegue 0,16 minuto de CPU por minuto de perman&ecirc;ncia na mem&oacute;ria. Das 10h15 &agrave;s 10h20, cada um dos tr&ecirc;s <i>jobs</i> consegue 0,8 minuto de tempo de CPU. &Agrave;s 10h20 chega um quarto <i>job</i> e completa a sequ&ecirc;ncia dos eventos.</p>&#10;<a id="Troca_de_Processos" name="Troca_de_Processos"></a><h2> Troca de Processos </h2>&#10;<p>Em sistemas em lote, a mem&oacute;ria &eacute; organizada em parti&ccedil;&otilde;es fixas.&#10;Em cada parti&ccedil;&atilde;o cada <i>job</i> ou processo &eacute; carregado ao alcan&ccedil;ar o inicio da fila permanecendo at&eacute; a conclus&atilde;o de sua execu&ccedil;&atilde;o. &#10;Para garantir que a CPU esteja ocupada todo tempo &eacute; executado um determinado n&uacute;mero de <i>jobs</i>, assim n&atilde;o necessitando utilizar uma outra t&eacute;cnica mais complicada.&#10;H&aacute; uma diferen&ccedil;a em sistemas com compartilhamento de tempo ou computadores gr&aacute;ficos pessoais, pois nesses casos pode ocorrer &eacute; insuficiente a quantidade mem&oacute;ria principal para todos os processos ativos, sendo necess&aacute;rio armazenar o excedente em discos e trazidos din&acirc;micamente para a mem&oacute;ria quando precisarem ser executados.</p>&#10;<a id="Troca_de_Processos_e_Mem%C3%B3ria_Virtual" name="Troca_de_Processos_e_Mem%C3%B3ria_Virtual"></a><h3> Troca de Processos e Mem&oacute;ria Virtual </h3>&#10;<p>S&atilde;o dois m&eacute;todos usados para gerenciamento de mem&oacute;ria utilizados conforme os recursos de hardware dispon&iacute;veis:</p>&#10;<a id="Troca_de_Processos__(tamb%C3%A9m_chamado_swaping)" name="Troca_de_Processos__(tamb%C3%A9m_chamado_swaping)"></a><h4> Troca de Processos  (tamb&eacute;m chamado swaping) </h4>&#10;<p>Esse m&eacute;todo trabalha trazendo cada processo para mem&oacute;ria, e executa durante um tempo determinado e ent&atilde;o devolve ao disco.</p> &#10;&#10;<ul>&#10;<li>Aloca&ccedil;&atilde;o de espa&ccedil;o para uma &aacute;rea de dados em expans&atilde;o.</li>&#10;<li>Aloca&ccedil;&atilde;o de espa&ccedil;o para uma pilha e uma &aacute;rea de dados, ambos em expans&atilde;o.</li></ul>&#10;<a id="%5B%5BMem%C3%B3ria_virtual%7CMem%C3%B3ria_Virtual%5D%5D" name="%5B%5BMem%C3%B3ria_virtual%7CMem%C3%B3ria_Virtual%5D%5D"></a><h4> [[Mem&oacute;ria virtual|Mem&oacute;ria Virtual]] </h4>&#10;<p>J&aacute; esse m&eacute;todo  permite que programas sejam executados mesmo que estejam apenas parcialmente carregados na mem&oacute;ria principal.</p>&#10;<p>Parti&ccedil;&otilde;es fixas e Parti&ccedil;&otilde;es vari&aacute;veis: &#10;As principais diferen&ccedil;as s&atilde;o o tamanho e a localiza&ccedil;&atilde;o das parti&ccedil;&otilde;es que variam conforme os processos entram e saem da mem&oacute;ria nas parti&ccedil;&otilde;es vari&aacute;veis, enquanto que nas parti&ccedil;&otilde;es fixas os par&acirc;metros s&atilde;o fixos.&#10;Nas trocas de processos quando deixam muitos espa&ccedil;os vazios na mem&oacute;ria, h&aacute; a possibilidade aglutin&aacute;&shy;los em &uacute;nico espa&ccedil;o cont&iacute;guo de mem&oacute;ria, movendo&shy;os o m&aacute;ximo poss&iacute;vel para os endere&ccedil;os mais baixos.&#10;T&eacute;cnica denominada compacta&ccedil;&atilde;o de mem&oacute;ria. No entanto n&atilde;o &eacute; muito utilizada pelo tempo de processamento necess&aacute;rio considerado alto.&#10;Algo que deve ser dado uma devida import&acirc;ncia &eacute; a quantidade de mem&oacute;ria que deve ser alocada a um processo, quando for criado ou trazido do disco para mem&oacute;ria. Se o processo possuir tamanho fixo, inalter&aacute;vel, ent&atilde;o o processo de aloca&ccedil;&atilde;o torna&shy;se simples: o sistema operacional alocar&aacute; o espa&ccedil;o necess&aacute;rio.&#10;No entanto, na &aacute;rea de dados que o processo puder crescer, &eacute; alocado uma &aacute;rea tempor&aacute;ria denominada (heap). Se houver espa&ccedil;o dispon&iacute;vel ao processo, ele poder&aacute; ser alocado a esse determinado processo.&#10;Quando os processos puderem ter duas &aacute;rea de expans&atilde;o, a &aacute;rea de dados sendo usada como &aacute;rea tempor&aacute;ria (heap) para vari&aacute;veis dinamicamente alocadas e liberadas, e uma &aacute;rea de pilha para vari&aacute;veis locais e para endere&ccedil;os de retorno.</p>&#10;<a id="Multiprograma%C3%A7%C3%A3o_com_parti%C3%A7%C3%B5es_vari%C3%A1veis" name="Multiprograma%C3%A7%C3%A3o_com_parti%C3%A7%C3%B5es_vari%C3%A1veis"></a><h3> Multiprograma&ccedil;&atilde;o com parti&ccedil;&otilde;es vari&aacute;veis </h3>&#10;<p>O espa&ccedil;o de endere&ccedil;amento de cada processo precisa ser cont&iacute;guo (i.e. cont&iacute;nuo) para que se possa implementar o mecanismo de prote&ccedil;&atilde;o descrito acima usando os registradores base e limite. </p> &#10;<p>A tend&ecirc;ncia &eacute; de que a mem&oacute;ria apresente v&aacute;rios espa&ccedil;os vazios (buracos) ao longo do tempo.&#10;Compacta&ccedil;&atilde;o de mem&oacute;ria: lento (ainda que em mem&oacute;ria RAM).&#10;A quantidade de mem&oacute;ria exigida por um processo pode crescer durante a sua execu&ccedil;&atilde;o:&#10;</p>&#10;<ul>&#10;<li>Malloc = mem&oacute;ria &#34&semi;heap&#34&semi;.</li>&#10;<li>Pilha do programa = ao executar fun&ccedil;&otilde;es, os endere&ccedil;os de retorno e as vari&aacute;veis locais s&atilde;o armazenadas na pilha do programa.</li></ul>&#10;<p>O SO reserva espa&ccedil;o extra para expans&atilde;o a cada processo ao seu carregado na mem&oacute;ria. Se o espa&ccedil;o previsto for insuficiente:&#10;</p>&#10;<ul>&#10;<li>O processo &eacute; abortado&semi;</li>&#10;<li>O processo &eacute; deslocado para outro espa&ccedil;o livre maior&semi;</li>&#10;<li>Outro processo &eacute; enviado ao disco para liberar a mem&oacute;ria para o processo origin&aacute;rio da demanda.</li></ul>&#10;<a id="Gerenciamento_de_mem%C3%B3ria_com_Mapa_de_bits" name="Gerenciamento_de_mem%C3%B3ria_com_Mapa_de_bits"></a><h2> Gerenciamento de mem&oacute;ria com Mapa de bits </h2>&#10;<p>O SO mant&eacute;m um 1 bit para indicar se cada bloco da mem&oacute;ria (ou unidade de aloca&ccedil;&atilde;o) est&aacute; ocupado (1) ou livre (0). &#10;A Mem&oacute;ria &eacute; dividida em unidades de aloca&ccedil;&atilde;o&#10;Considera&ccedil;&otilde;es sobre o tamanho do bloco de mem&oacute;ria: </p>&#10;&#10;<ul>&#10;<li>Quanto menor a unidade de aloca&ccedil;&atilde;o, maior ser&aacute; o mapa de bits.</li>&#10;<li>Pequeno: necessidade de muitos bits &rArr; uso ineficiente da mem&oacute;ria. </li></ul>&#10;<p>Exemplo: se tamanho do bloco = 1 byte, 1/9 da mem&oacute;ria ser&atilde;o utilizados para o mapa de bits. </p>&#10;&#10;<ul>&#10;<li>Grande: mem&oacute;ria sub&shy;utilizada, pois se o tamanho do processo n&atilde;o for m&uacute;ltiplo do tamanho da unidade de aloca&ccedil;&atilde;o, uma quantidade de mem&oacute;ria consider&aacute;vel ser&aacute; desperdi&ccedil;ada no &uacute;ltimo bloco.</li></ul>&#10;<p>Vantagens do uso de mapa de bits:</p>&#10;&#10;<ul>&#10;<li>simplicidade: o tamanho do mapa depende apenas do tamanho da mem&oacute;ria e das unidades de aloca&ccedil;&atilde;o.</li></ul>&#10;<p>Desvantagens:&#10;</p>&#10;<ul>&#10;<li>Quanto um processo necessita de k unidades de aloca&ccedil;&atilde;o, o gerenciador de mem&oacute;ria deve encontrar uma sequ&ecirc;ncia de k bits 0, o que se constitui um processo lento.</li></ul>&#10;<a id="Gerenciamento_com_Listas_Encadeadas" name="Gerenciamento_com_Listas_Encadeadas"></a><h2> Gerenciamento com Listas Encadeadas </h2>&#10;<p>&Eacute; mantido uma lista encadeada de segmentos alocados e vazios, sendo que cada segmento &eacute; um processo ou um buraco entre dois processos. &#10;A lista apresenta&shy;se em ordem de endere&ccedil;os, e quando um processo termina ou &eacute; enviado para o disco, e a atualiza&ccedil;&atilde;o da lista ocorre da seguinte maneira: cada processo, desde que n&atilde;o seja nem o primeiro nem o &uacute;ltimo da lista, apresenta&shy;se cercado por dois segmentos, que podem ser buracos ou outros processos, o que nos d&aacute; as quatro possibilidades .&#10;O SO mant&eacute;m uma lista ligada para indicar os segmentos de mem&oacute;ria (sequ&ecirc;ncia de blocos) livres (L) ou ocupados (P). Cada n&oacute; cont&eacute;m os seguintes campos:&#10;</p>&#10;<ul>&#10;<li>Segmento de mem&oacute;ria livre (L) ou ocupado (P)&semi;</li>&#10;<li>In&iacute;cio do segmento&semi;</li>&#10;<li>Tamanho do segmento (em n&uacute;mero de blocos)&semi;</li>&#10;<li>Pr&oacute;ximo segmento.</li></ul>&#10;<p>A lista ligada pode estar ordenada pelo campo in&iacute;cio do segmento (vantagem da atualiza&ccedil;&atilde;o r&aacute;pida da lista quando um processo termina):&#10;</p>&#10;<ul>&#10;<li>AXB &rArr; A_B</li>&#10;<li>AX_ &rArr; A_</li>&#10;<li>_XB &rArr; _</li>&#10;<li>_X_ &rArr; _</li></ul>&#10;<p>Os buracos adjacentes devem ser combinados num &uacute;nico.&#10;Para escolher o ponto em que deve ser carregado um processo rec&eacute;m criado ou que veio do disco por uma troca, vamos utilizar alguns algoritmos assumindo que o gerenciador de mem&oacute;ria sabe quanto espa&ccedil;o alocar no processo:</p>&#10;&#10;<ul>&#10;<li>First Fit (primeiro encaixe): percorrer a fila at&eacute; encontrar o primeiro espa&ccedil;o em que caiba o processo. &Eacute; um algoritmo r&aacute;pido.</li>&#10;<li>Next Fit (pr&oacute;ximo encaixe): o mesmo que o algoritmo anterior, s&oacute; que ao inv&eacute;s de procurar sempre a partir do in&iacute;cio da lista, procura a partir do &uacute;ltimo ponto em que encontrou. Desempenho pr&oacute;ximo ao anterior.</li>&#10;<li>Best Fit (melhor encaixe): consiste em verificar toda a lista e procurar o buraco que tiver espa&ccedil;o mais pr&oacute;ximo das necessidades do processo. &Eacute; mais lento, e desempenho pior que o First Fit.</li>&#10;<li>Worst Fit (pior ajuste): pega sempre o maior buraco dispon&iacute;vel. Desempenho ruim.</li></ul>&#10;<p>Esses algoritmos podem ter sua velocidade aumentada pela manuten&ccedil;&atilde;o de duas listas separadas, uma para processos e outra para buracos.&#10;Quando temos duas listas separadas, outro algoritmo &eacute; poss&iacute;vel.&#10;&Eacute; o Quick Fit (ajuste r&aacute;pido), que consiste em manter listas separadas para alguns dos tamanhos mais comuns especificados (ex. uma fila para 2k, outra para 4k, outra para 8k etc). Neste caso, a busca de um buraco com o tamanho requerido, &eacute; extremamente r&aacute;pido, entretanto, quando um processo termina, a libera&ccedil;&atilde;o de seu espa&ccedil;o &eacute; complicada, devido &agrave; necessidade de reagrupar os buracos e modific&aacute;&shy;los de fila.</p>&#10;<p> &#10;</p>&#10;<ul>&#10;<li> </li></ul>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://www.memorymanagement.org/" rel="nofollow" title="http://www.memorymanagement.org/">The Memory Management Reference</a></li>&#10;<li><a class="externallink" href="http://linux&shy;mm.org/" rel="nofollow" title="http://linux&shy;mm.org/">Linux Memory Management</a></li>&#10;<li><a class="externallink" href="http://www.enderunix.org/docs/memory.pdf" rel="nofollow" title="http://www.enderunix.org/docs/memory.pdf">Memory Management For System Programmers</a></li></ul>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Gerenciamento_de_mem%C3%B3ria" id="w"> </a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Tecnologia_dos_sistemas_operacionais" id="w">Categoria:Tecnologia dos sistemas operacionais</a></p></body></html>