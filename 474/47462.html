<html><title>Recursividade</title><body>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Droste.jpg%7Cthumb" id="w">Uma forma visual de recurs&atilde;o conhecida como &#39&semi;&#39&semi;efeito Droste&#39&semi;&#39&semi;.</a></p> &#10;<p><b>Recursividade</b> &eacute; um termo usado de maneira mais geral para descrever o processo de repeti&ccedil;&atilde;o de um objeto de um jeito similar ao que j&aacute; fora mostrado. Um bom exemplo disso s&atilde;o as imagens repetidas que aparecem quando dois espelhos s&atilde;o apontados um para o outro.</p>&#10;<a id="Defini%C3%A7%C3%A3o_formal" name="Defini%C3%A7%C3%A3o_formal"></a><h2> Defini&ccedil;&atilde;o formal </h2>&#10;<p>Na <a href="http://en.wikipedia.org/wiki/Matem%C3%A1tica" id="w">matem&aacute;tica</a> e na <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">ci&ecirc;ncia da computa&ccedil;&atilde;o</a>, a recurs&atilde;o especifica (ou constr&oacute;i) uma classe de objetos ou m&eacute;todos (ou um objeto de uma certa classe) definindo alguns poucos casos base ou m&eacute;todos muito simples (freq&uuml;entemente apenas um), e ent&atilde;o definindo regras para formular casos complexos em termos de casos mais simples.</p>&#10;<p>Por exemplo, segue uma <a href="http://en.wikipedia.org/wiki/Defini%C3%A7%C3%A3o_recursiva" id="w">defini&ccedil;&atilde;o recursiva</a> da ancestralidade de uma pessoa:</p>&#10;&#10;<ul>&#10;<li>Os pais de uma pessoa s&atilde;o seus antepassados (<i>caso base</i>)&semi;</li>&#10;<li>Os pais de qualquer antepassado s&atilde;o tamb&eacute;m antepassados da pessoa em considera&ccedil;&atilde;o (<i>passo recursivo</i>).</li></ul>&#10;<p>&Eacute; conveniente pensar que uma <a href="http://en.wikipedia.org/wiki/Defini%C3%A7%C3%A3o_recursiva" id="w">defini&ccedil;&atilde;o recursiva</a> define objetos em termos de objetos &ldquo;previamente definidos&rdquo; dessa mesma classe que est&aacute; sendo definida.</p>&#10;<p>Defini&ccedil;&otilde;es como esta s&atilde;o frequentemente encontradas na matem&aacute;tica, por exemplo, a defini&ccedil;&atilde;o formal dos <a href="http://en.wikipedia.org/wiki/N%C3%BAmeros_naturais" id="w">n&uacute;meros naturais</a> diz que 0 (zero) &eacute; um n&uacute;mero natural, e todo n&uacute;mero natural tem um sucessor, que &eacute; tamb&eacute;m um n&uacute;mero natural.</p>&#10;<a id="Recurs%C3%A3o_na_linguagem" name="Recurs%C3%A3o_na_linguagem"></a><h2> Recurs&atilde;o na linguagem </h2>&#10;&#10;<p>O uso mais antigo de recurs&atilde;o na <a href="http://en.wikipedia.org/wiki/Ling%C3%BC%C3%ADstica" id="w">ling&uuml;&iacute;stica</a>, e o uso da recurs&atilde;o em geral, remete ao ling&uuml;ista <a href="http://en.wikipedia.org/wiki/P%C4%81%E1%B9%87ini" id="w">PƒÅ&#7751;ini</a> em meados de 500 AC, o qual fez uso da recurs&atilde;o nas regras gramaticais do <a href="http://en.wikipedia.org/wiki/S%C3%A2nscrito" id="w">S&acirc;nscrito</a> (l&iacute;ngua cl&aacute;ssica da <a href="http://en.wikipedia.org/wiki/&Iacute;ndia" id="w">&Iacute;ndia</a> antiga que influenciou praticamente todos os idiomas ocidentais).</p>&#10;<p>O ling&uuml;ista <a href="http://en.wikipedia.org/wiki/Noam_Chomsky" id="w">Noam Chomsky</a> lan&ccedil;ou a teoria de que a extens&atilde;o ilimitada de uma l&iacute;ngua natural &eacute; poss&iacute;vel apenas pelo mecanismo recursivo de encaixar frases em frases. Assim, uma garotinha tagarela pode muito bem dizer, <i>&#34&semi;Dorothy, que encontrou a Bruxa M&aacute; do Oeste na Terra dos Munchkins, onde a bruxa m&aacute; da sua irm&atilde; foi morta, liquidou&shy;a com um balde de &aacute;gua.&rdquo;</i> Claramente, duas frases simples &mdash; <i>&#34&semi;Dorothy encontrou a Bruxa M&aacute; do Oeste na Terra dos Munchkins&#34&semi;</i> e <i>&#34&semi;Sua irm&atilde; foi morta na Terra dos Munchkins&#34&semi;</i> &mdash; podem ser encaixadas em uma terceira frase, <i>&#34&semi;Dorothy liquidou&shy;a com um balde de &aacute;gua&#34&semi;,</i> para obter uma frase exacerbadamente prolixa.</p>&#10;<p>Aqui est&aacute; uma outra maneira, possivelmente mais simples, de se entender processos recursivos:</p>&#10;&#10;<ol>&#10;<li>N&oacute;s j&aacute; terminamos? Se sim, retorne os resultados. Sem uma <i>condi&ccedil;&atilde;o de parada</i> como esta, uma recurs&atilde;o iria se repetir eternamente. </li>&#10;<li>Se n&atilde;o, <i>simplifique</i> o problema, resolva o(s) problema(s) mais simples, e ent&atilde;o encaixe os resultados na solu&ccedil;&atilde;o do problema original. Ent&atilde;o retorne a solu&ccedil;&atilde;o. </li></ol>&#10;<p>Aqui vai uma ilustra&ccedil;&atilde;o mais humor&iacute;stica: <i>&#34&semi;Para entender a recurs&atilde;o, a pessoa deve primeiro entender a recurs&atilde;o.&#34&semi;</i> Ou talvez seja mais adequado o exemplo seguinte criado por <a href="http://en.wikipedia.org/wiki/Andrew_Plotkin" id="w">Andrew Plotkin</a>: <i>&#34&semi;Se voc&ecirc; j&aacute; sabe o que &eacute; a recurs&atilde;o, apenas se lembre da resposta. Caso contr&aacute;rio, encontre algu&eacute;m que esteja mais pr&oacute;ximo de <a href="http://en.wikipedia.org/wiki/Douglas_Hofstadter" id="w">Douglas Hofstadter</a> do que voc&ecirc;&semi; ent&atilde;o pergunte a ele ou a ela o que &eacute; a recurs&atilde;o.&#34&semi;</i></p>&#10;<p>Exemplos de objetos matem&aacute;ticos freq&uuml;entemente definidos recursivamente s&atilde;o <a href="http://en.wikipedia.org/wiki/Fun%C3%A7%C3%B5es" id="w">fun&ccedil;&otilde;es</a>, <a href="http://en.wikipedia.org/wiki/Conjuntos" id="w">conjuntos</a>, e especialmente <a href="http://en.wikipedia.org/wiki/Fractais" id="w">fractais</a>.</p>&#10;<a id="A_recurs%C3%A3o_em_portugu%C3%AAs_claro" name="A_recurs%C3%A3o_em_portugu%C3%AAs_claro"></a><h3> A recurs&atilde;o em portugu&ecirc;s claro </h3>&#10;<p>A <b>recurs&atilde;o</b> &eacute; o processo pelo qual passa um certo procedimento quando um dos passos do procedimento em quest&atilde;o envolve a repeti&ccedil;&atilde;o completa deste mesmo procedimento. Um procedimento que se utiliza da recurs&atilde;o &eacute; dito <b>recursivo</b>. Tamb&eacute;m &eacute; dito <b>recursivo</b> qualquer objeto que seja resultado de um procedimento recursivo.</p>&#10;<p>Para entendermos a recurs&atilde;o, devemos primeiro compreender a diferen&ccedil;a entre um procedimento e a execu&ccedil;&atilde;o de um procedimento. Um procedimento &eacute; um conjunto de passos que devem ser tomados baseados em um conjunto de regras. A execu&ccedil;&atilde;o de um procedimento envolve seguir de fato as regras e executar os passos. Uma analogia para isso &eacute; que um procedimento &eacute; como uma ementa (card&aacute;pio) que nos fornece as op&ccedil;&otilde;es poss&iacute;veis, enquanto a execu&ccedil;&atilde;o de um procedimento &eacute; escolhermos de fato qual refei&ccedil;&atilde;o nos ser&aacute; servida.</p>&#10;<p>Um procedimento &eacute; dito recursivo quando um de seus passos consiste na chamada de uma nova execu&ccedil;&atilde;o do procedimento. Conseq&uuml;entemente, uma refei&ccedil;&atilde;o recursiva com quatro pratos seria uma refei&ccedil;&atilde;o em que a entrada, a salada, o prato principal ou a sobremesa por si pr&oacute;prios j&aacute; consistissem em refei&ccedil;&otilde;es. Ent&atilde;o uma refei&ccedil;&atilde;o recursiva poderia ser feita por pur&ecirc;s de batata, salada verde, frango grelhado, e para sobremesa, uma refei&ccedil;&atilde;o de quatro pratos com bolinhos de bacalhau, salada de legumes, como prato principal uma refei&ccedil;&atilde;o de quatro pratos, e para sobremesa um peda&ccedil;o de bolo de chocolate, e assim sucessivamente at&eacute; que a refei&ccedil;&atilde;o esteja completa.</p>&#10;<p>Um procedimento recursivo deve completar cada um de seus passos. Mesmo se uma nova chamada &eacute; feita, cada execu&ccedil;&atilde;o deve passar por cada um dos passos restantes. O que isso quer dizer &eacute; que, mesmo a salada sendo ela pr&oacute;pria uma refei&ccedil;&atilde;o inteira de quatro pratos, voc&ecirc; ainda dever&aacute; comer o prato principal e a sobremesa.</p>&#10;<a id="Humor_recursivo" name="Humor_recursivo"></a><h3> Humor recursivo </h3>&#10;<p>Uma piada comum de <a href="http://en.wikipedia.org/wiki/Nerd" id="w">nerd</a> (por exemplo, <a class="externallink" href="http://catb.org/~esr/jargon/html/R/recursion.html" rel="nofollow" title="http://catb.org/~esr/jargon/html/R/recursion.html">http://catb.org/~esr/jargon/html/R/recursion.html</a>) &eacute; a seguinte &ldquo;defini&ccedil;&atilde;o&rdquo; de recurs&atilde;o.</p>&#10;<dl><dd><b>Recurs&atilde;o</b></dd></dl><dl><dd><dl><dd>Ver &#34&semi;<a href="http://en.wikipedia.org/wiki/Recurs%C3%A3o#Humor recursivo" id="w">Recursividade</a>&#34&semi;.</dd></dl></dd></dl>&#10;<p>Isso &eacute; uma par&oacute;dia &agrave;s refer&ecirc;ncias encontradas em dicion&aacute;rios, que em alguns casos podem levar a defini&ccedil;&otilde;es circulares. Toda piada tem um elemento de sabedoria e tamb&eacute;m um elemento de mal&shy;entendido. Esse &eacute; tamb&eacute;m o segundo menor exemplo de defini&ccedil;&atilde;o err&ocirc;nea de recurs&atilde;o de um objeto: o erro come&ccedil;a pela aus&ecirc;ncia de uma condi&ccedil;&atilde;o de parada (ou falta de um estado inicial, se visto por outro ponto de vista). Iniciantes em recurs&atilde;o ficam freq&uuml;entemente confusos pela sua aparente circularidade, at&eacute; que eles compreendem que a condi&ccedil;&atilde;o de t&eacute;rmino &eacute; fundamental. Uma vers&atilde;o mais correta seria:</p>&#10;<dl><dd><b>Recurs&atilde;o</b></dd></dl><dl><dd><dl><dd>Se voc&ecirc; ainda n&atilde;o entendeu&semi; Ver: &#34&semi;<a href="http://en.wikipedia.org/wiki/Recurs%C3%A3o#Humor recursivo" id="w">Recursividade</a>&#34&semi;.</dd></dl></dd></dl>&#10;<p>Outros exemplos s&atilde;o os <a href="http://en.wikipedia.org/wiki/Acr%C3%B4nimos_recursivos" id="w">acr&ocirc;nimos recursivos</a>, tais como <a href="http://en.wikipedia.org/wiki/GNU" id="w">GNU</a>, <a href="http://en.wikipedia.org/wiki/PHP" id="w">PHP</a> ou OPO (<a href="http://en.wikipedia.org/wiki/Dilbert" id="w">Dilbert</a>&semi; &#34&semi;O Projeto OPO&#34&semi;).</p>&#10;<p>Outra forma de humor recursivo &eacute; freq&uuml;entemente encontrada em filmes e anima&ccedil;&otilde;es, tal como este exemplo <a class="externallink" href="http://www.post&shy;literate.com/gerpunx/archives/2005/01/prepare_to_lose_your_mind.php" rel="nofollow" title="http://www.post&shy;literate.com/gerpunx/archives/2005/01/prepare_to_lose_your_mind.php">http://www.post&shy;literate.com/gerpunx/archives/2005/01/prepare_to_lose_your_mind.php</a>.</p>&#10;<a id="Recurs%C3%A3o_na_matem%C3%A1tica" name="Recurs%C3%A3o_na_matem%C3%A1tica"></a><h2> Recurs&atilde;o na matem&aacute;tica </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:SierpinskiTriangle.svg%7Cright%7Cthumb%7C250px" id="w">O [[tri&acirc;ngulo de Sierpinski]] &mdash;uma recurs&atilde;o fechada de tri&acirc;ngulos formando uma reticulada geom&eacute;trica.</a></p>&#10;<a id="Conjuntos_definidos_recursivamente" name="Conjuntos_definidos_recursivamente"></a><h3> Conjuntos definidos recursivamente </h3>&#10;&#10;<ul>&#10;<li>Exemplo: os n&uacute;meros naturais.</li></ul>&#10;<p>Um exemplo de conjunto definido recursivamente &eacute; dado pelos <a href="http://en.wikipedia.org/wiki/N%C3%BAmeros_naturais" id="w">n&uacute;meros naturais</a>:</p>&#10;<dl><dd>0 est&aacute; em <b>N</b>&semi;</dd></dl><dl><dd>Se <i>n</i> est&aacute; em <b>N</b>, ent&atilde;o <i>n</i> + 1 est&aacute; em <b>N</b>.</dd></dl><dl><dd>O conjunto dos n&uacute;meros naturais &eacute; o menor conjunto satisfazendo as condi&ccedil;&otilde;es acima.</dd></dl>&#10;&#10;<ul>&#10;<li>Exemplo: o conjunto das proposi&ccedil;&otilde;es verdadeiras alcan&ccedil;&aacute;veis</li></ul>&#10;<p>Outro exemplo interessante &eacute; o conjunto das proposi&ccedil;&otilde;es verdadeiras alcan&ccedil;&aacute;veis em um <a href="http://en.wikipedia.org/wiki/Sistema_axiom%C3%A1tico" id="w">sistema axiom&aacute;tico</a>.</p>&#10;&#10;<ul>&#10;<li>Se uma proposi&ccedil;&atilde;o &eacute; um axioma, ela &eacute; uma proposi&ccedil;&atilde;o verdadeira alcan&ccedil;&aacute;vel. </li>&#10;<li>Se uma proposi&ccedil;&atilde;o pode ser obtida de proposi&ccedil;&otilde;es verdadeiras alcan&ccedil;&aacute;veis por meio de regras de infer&ecirc;ncia, ela &eacute; uma proposi&ccedil;&atilde;o verdadeira alcan&ccedil;&aacute;vel. </li>&#10;<li>O conjunto das proposi&ccedil;&otilde;es verdadeiras alcan&ccedil;&aacute;veis &eacute; o menor conjunto de proposi&ccedil;&otilde;es verdadeiras satisfazendo estas condi&ccedil;&otilde;es. </li></ul>&#10;<p>Esse conjunto &eacute; chamado &#39&semi;proposi&ccedil;&otilde;es verdadeiras alcan&ccedil;&aacute;veis&#39&semi; porque: em aproxima&ccedil;&otilde;es n&atilde;o&shy;construtivas aos fundamentos da matem&aacute;tica, o conjunto das proposi&ccedil;&otilde;es verdadeiras &eacute; maior que o conjunto recursivamente constru&iacute;do a partir de axiomas e regras de infer&ecirc;ncia. Ver tamb&eacute;m <a href="http://en.wikipedia.org/wiki/Teorema_da_incompletude_de_G%C3%B6del" id="w">teorema da incompletude de G&ouml;del</a>.</p>&#10;<p>(Note que determinar se um certo objeto est&aacute; ou n&atilde;o em um conjunto definido recursivamente n&atilde;o &eacute; uma tarefa algor&iacute;tmica.)</p>&#10;<a id="Recurs%C3%A3o_funcional" name="Recurs%C3%A3o_funcional"></a><h3> Recurs&atilde;o funcional </h3>&#10;<p>Uma fun&ccedil;&atilde;o pode ser parcialmente definida em termos de si mesma. Um exemplo conhecido &eacute; a <a href="http://en.wikipedia.org/wiki/Seq%C3%BC%C3%AAncia_de_Fibonacci" id="w">Seq&uuml;&ecirc;ncia de Fibonacci</a>: <i>F</i>(<i>n</i>) = <i>F</i>(<i>n</i> &minus; 1) + <i>F</i>(<i>n</i> &minus; 2). Para que tal defini&ccedil;&atilde;o seja &uacute;til, ela deve convergir para valores que n&atilde;o sejam recursivamente definidos, nesse caso <i>F</i>(0) = 0 e <i>F</i>(1) = 1.</p>&#10;<p>Uma fun&ccedil;&atilde;o recursiva famosa &eacute; a <a href="http://en.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_de_Ackermann" id="w">fun&ccedil;&atilde;o de Ackermann</a> que, ao contr&aacute;rio da seq&uuml;&ecirc;ncia de Fibonacci, &eacute; bem dif&iacute;cil de ser expressa sem o uso da recurs&atilde;o.</p>&#10;<a id="Demonstra%C3%A7%C3%B5es_recursivas" name="Demonstra%C3%A7%C3%B5es_recursivas"></a><h3> Demonstra&ccedil;&otilde;es recursivas </h3>&#10;<p>A maneira padr&atilde;o de se definir novos sistemas de matem&aacute;tica ou l&oacute;gica &eacute; definindo objetos (tais como &ldquo;verdadeiro&rdquo; e &ldquo;falso&rdquo;, ou &ldquo;todos os n&uacute;meros naturais&rdquo;), e ent&atilde;o definindo opera&ccedil;&otilde;es sobre eles. Esses s&atilde;o os casos base. Ap&oacute;s isso, todas as computa&ccedil;&otilde;es v&aacute;lidas no sistema s&atilde;o definidas com o uso de regras. Desta forma, se todos os casos base e regras se demonstrarem calcul&aacute;veis, ent&atilde;o qualquer sistema matem&aacute;tico pode ser tamb&eacute;m calculado.</p>&#10;<p>Isso pode parecer pouco interessante, mas esse tipo de demonstra&ccedil;&atilde;o &eacute; a forma usual de se provar se um c&aacute;lculo &eacute; imposs&iacute;vel. Isso pode economizar um bom tempo. Por exemplo, esse procedimento era usado para provar que a &aacute;rea de um c&iacute;rculo n&atilde;o &eacute; uma simples raz&atilde;o de seu di&acirc;metro, e que nenhum &acirc;ngulo pode ser triseccionado com r&eacute;gua e compasso &ndash; ambos enigmas que fascinaram os antigos.</p>&#10;<a id="Recurs%C3%A3o_em_ci%C3%AAncia_da_computa%C3%A7%C3%A3o" name="Recurs%C3%A3o_em_ci%C3%AAncia_da_computa%C3%A7%C3%A3o"></a><h2> Recurs&atilde;o em ci&ecirc;ncia da computa&ccedil;&atilde;o </h2>&#10;<p> &#10;Um m&eacute;todo comum de simplifica&ccedil;&atilde;o &eacute; dividir o problema em subproblemas do mesmo tipo. Como t&eacute;cnica de programa&ccedil;&atilde;o, este m&eacute;todo &eacute; conhecido como dividir e conquistar e &eacute; a chave para a constru&ccedil;&atilde;o de muitos algoritmos importantes, bem como uma parte fundamental da <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_din%C3%A2mica" id="w">programa&ccedil;&atilde;o din&acirc;mica</a>.</p>&#10;<p>A recurs&atilde;o na programa&ccedil;&atilde;o &eacute; bem exemplificada quando uma fun&ccedil;&atilde;o &eacute; definida em termos de si mesma. Um exemplo da aplica&ccedil;&atilde;o da recurs&atilde;o s&atilde;o os <a href="http://en.wikipedia.org/wiki/Parsers" id="w">parsers</a> (analisadores gramaticais) para linguagens de programa&ccedil;&atilde;o. Uma grande vantagem da recurs&atilde;o &eacute; que um conjunto infinito de senten&ccedil;as poss&iacute;veis, designs ou outros dados podem ser definidos, analisados ou produzidos por um programa de computador finito.</p>&#10;<p>Rela&ccedil;&otilde;es de recorr&ecirc;ncia s&atilde;o equa&ccedil;&otilde;es que definem uma ou mais seq&uuml;&ecirc;ncias recursivamente. Alguns tipos espec&iacute;ficos de rela&ccedil;&otilde;es de recorr&ecirc;ncia podem ser &ldquo;resolvidos&rdquo; para que se obtenha uma defini&ccedil;&atilde;o n&atilde;o&shy;recursiva.</p>&#10;<p>Um exemplo cl&aacute;ssico de recurs&atilde;o &eacute; a defini&ccedil;&atilde;o da <a href="http://en.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_fatorial" id="w">fun&ccedil;&atilde;o fatorial</a>, dada aqui em <a href="http://en.wikipedia.org/wiki/Pseudoc%C3%B3digo" id="w">pseudoc&oacute;digo</a>:</p>&#10;<pre>fun&ccedil;&atilde;o fatorial(n) &#10;{&#10;  se (n &#60&semi;= 1)&#10;    retorne 1&semi;&#10;  sen&atilde;o&#10;    retorne n * fatorial(n&shy;1)&semi;&#10;}&#10;</pre>&#10;<p>A fun&ccedil;&atilde;o chama a si mesma recursivamente em uma vers&atilde;o menor da entrada (n &shy; 1) e multiplica o resultado da chamada por n, at&eacute; que alcance o <a href="http://en.wikipedia.org/wiki/Caso_base" id="w">caso base</a>, de modo an&aacute;logo &agrave; defini&ccedil;&atilde;o matem&aacute;tica de fatorial.</p>&#10;<p>Um exemplo de algoritmo recursivo &eacute; o procedimento que &ldquo;processa&rdquo; (faz alguma coisa com) todos os <a href="http://en.wikipedia.org/wiki/N%C3%B3s_de_uma_%C3%A1rvore" id="w">n&oacute;s de uma &aacute;rvore</a>:</p>&#10;<pre>procedimento ProcessarArvore(no)&#10;{&#10;  ProcessarNo(no)&semi;    // realiza a opera&ccedil;&atilde;o espec&iacute;fica com o n&oacute; primeiramente fornecido&#10;  paracada no_filho de no fa&ccedil;a ProcessarArvore(no_filho)&semi;&#10;}&#10;</pre>&#10;<p>Para processar a &aacute;rvore completa, o procedimento &eacute; chamado com o n&oacute; raiz representando o par&acirc;metro inicial da &aacute;rvore. O procedimento chama a si mesmo recursivamente para todos os n&oacute;s filhos do n&oacute; fornecido (i.e. sub&shy;&aacute;rvores da &aacute;rvore inicial), at&eacute; alcan&ccedil;ar o caso base que &eacute; o n&oacute; que n&atilde;o possui nenhum n&oacute; filho (i.e. &aacute;rvore sem galhos, usualmente chamada &ldquo;folha&rdquo;).</p>&#10;<p>A <a href="http://en.wikipedia.org/wiki/&Aacute;rvore_(estrutura_de_dados)" id="w">&aacute;rvore</a> por si s&oacute; pode ser definida recursivamente (e ent&atilde;o destinada a processos recursivos) como segue:</p>&#10;<pre>estrutura no&#10;{&#10;  no_filho : listar&#60&semi;no&#62&semi;&semi;&#10;  ...&#10;}&#10;&#10;estrutura arvore&#10;{&#10;  raiz : no&semi;&#10;  ...&#10;}&#10;</pre>&#10;<p>A &aacute;rvore &eacute; representada por seu n&oacute; raiz apresentando uma lista de n&oacute;s filhos. Cada n&oacute; filho por sua vez tem sua pr&oacute;pria lista de n&oacute;s filhos (assim como o n&oacute; raiz de uma sub&shy;&aacute;rvore). A &#34&semi;folha&#34&semi; que n&atilde;o possuir uma lista de n&oacute;s filhos ser&aacute; o caso base de no.</p>&#10;<a id="O_teorema_da_recurs%C3%A3o" name="O_teorema_da_recurs%C3%A3o"></a><h2> O teorema da recurs&atilde;o </h2>&#10;<p>Na <a href="http://en.wikipedia.org/wiki/Teoria_dos_conjuntos" id="w">teoria dos conjuntos</a>, este &eacute; um teorema que garante que uma fun&ccedil;&atilde;o definida recursivamente ir&aacute; existir. Dado um conjunto <span class="math">X</span>, um elemento <span class="math">a</span> de <span class="math">X</span> e uma fun&ccedil;&atilde;o <span class="math">f: X \rightarrow X</span>, o teorema indica que h&aacute; uma &uacute;nica fun&ccedil;&atilde;o <span class="math">F: \mathbb{N}_0 \rightarrow X</span> (onde <span class="math">N_0</span> denota o conjunto dos n&uacute;meros naturais) tal que:&#10;</p><dl><dd><span class="math">F(0) = a</span></dd></dl><dl><dd><span class="math">F(n + 1) = f(F(n))</span></dd></dl>&#10;<p>para qualquer n&uacute;mero natural <span class="math">n</span>.</p>&#10;<a id="Demonstra%C3%A7%C3%A3o_de_unicidade" name="Demonstra%C3%A7%C3%A3o_de_unicidade"></a><h3> Demonstra&ccedil;&atilde;o de unicidade </h3>&#10;<p>Pegue duas fun&ccedil;&otilde;es <span class="math">f</span> e <span class="math">g</span> no dom&iacute;nio <span class="math">N</span> e co&shy;dom&iacute;nio <span class="math">A</span> tal que:</p>&#10;<dl><dd><span class="math">f(0) = a</span></dd></dl><dl><dd><span class="math">g(0) = a</span></dd></dl><dl><dd><span class="math">f(n + 1) = F(f(n))</span></dd></dl><dl><dd><span class="math">g(n + 1) = F(g(n))</span></dd></dl>&#10;<p>onde <span class="math">a</span> &eacute; um elemento de <span class="math">A</span>. Queremos provar <span class="math">f = g</span>. Sabemos que duas fun&ccedil;&otilde;es s&atilde;o iguais se elas:</p>&#10;<dl><dd><i>i</i>. pertencem ao mesmo dom&iacute;nio/co&shy;dom&iacute;nio&semi;</dd></dl><dl><dd><i>ii</i>. tem o mesmo gr&aacute;fico.</dd></dl>&#10;<dl><dd><i>i</i>. Feito!</dd></dl><dl><dd><i>ii</i>. Indu&ccedil;&atilde;o matem&aacute;tica: para todo <span class="math">n</span> em <span class="math">N</span>, <span class="math">f(n) = g(n)</span>? (Chamaremos essa condi&ccedil;&atilde;o de <span class="math">Eq(n))</span>:</dd></dl><dl><dd><dl><dd>1.<span class="math">Eq(0)</span> se e apenas se <span class="math">f(0) = g(0)</span> se e apenas se <span class="math">a = a</span>. Feito!</dd></dl></dd></dl><dl><dd><dl><dd>2. Seja <span class="math">n</span> um elemento de <span class="math">N</span>. Assumindo que <span class="math">Eq(n)</span> existe, queremos mostrar que <span class="math">Eq(n + 1)</span> existe tamb&eacute;m, o que &eacute; f&aacute;cil visto que: <span class="math">f(n + 1) = F(f(n)) = F(g(n)) = g(n + 1)</span>. Feito!</dd></dl></dd></dl>&#10;<a id="Demonstra%C3%A7%C3%A3o_de_exist%C3%AAncia" name="Demonstra%C3%A7%C3%A3o_de_exist%C3%AAncia"></a><h3> Demonstra&ccedil;&atilde;o de exist&ecirc;ncia </h3>&#10;&#10;<ul>&#10;<li>Ver Hungerford, &#34&semi;Algebra&#34&semi;, primeiro cap&iacute;tulo na teoria dos conjuntos. </li></ul>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://tecnicasparainformatica.blogspot.com.br/2011/10/o&shy;que&shy;e&shy;uma&shy;funcao&shy;recursiva_5341.html" rel="nofollow" title="http://tecnicasparainformatica.blogspot.com.br/2011/10/o&shy;que&shy;e&shy;uma&shy;funcao&shy;recursiva_5341.html">O que &eacute; fun&ccedil;&atilde;o recursiva em programa&ccedil;&atilde;o</a></li>&#10;<li><a class="externallink" href="http://tecnicasparainformatica.blogspot.com.br/2012/07/fatorial&shy;recursivo&shy;em&shy;java.html" rel="nofollow" title="http://tecnicasparainformatica.blogspot.com.br/2012/07/fatorial&shy;recursivo&shy;em&shy;java.html">Fatorial Recursivo em java</a></li>&#10;<li><a class="externallink" href="http://tecnicasparainformatica.blogspot.com.br/2012/07/algoritimo&shy;torre&shy;de&shy;hanoi&shy;implementado.html" rel="nofollow" title="http://tecnicasparainformatica.blogspot.com.br/2012/07/algoritimo&shy;torre&shy;de&shy;hanoi&shy;implementado.html">Torre de Han&oacute;i implementada em Java usando recursividade</a></li>&#10;<li><a class="externallink" href="http://tecnicasparainformatica.blogspot.com.br/2012/07/algoritimo&shy;torre&shy;de&shy;hanoi&shy;implementado_22.html" rel="nofollow" title="http://tecnicasparainformatica.blogspot.com.br/2012/07/algoritimo&shy;torre&shy;de&shy;hanoi&shy;implementado_22.html">Torre de Han&oacute;i implementada em C# usando recursividade</a></li></ul>&#10;<p><a href="http://en.wikipedia.org/wiki/Recursividade_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">Recursividade (ci&ecirc;ncia da computa&ccedil;&atilde;o)</a></p>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;<p> &#10;</p>&#10;<ul>&#10;<li><a class="externallink" href="http://www.ime.usp.br/~pf/algoritmos/aulas/recu.html" rel="nofollow" title="http://www.ime.usp.br/~pf/algoritmos/aulas/recu.html">Recurs&atilde;o e algoritmos recursivos</a></li></ul>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Autorrefer%C3%AAncia" id="w">Categoria:Autorrefer&ecirc;ncia</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:L%C3%B3gica_matem%C3%A1tica" id="w">Categoria:L&oacute;gica matem&aacute;tica</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Estruturas_de_controle" id="w">Categoria:Estruturas de controle</a></p></body></html>