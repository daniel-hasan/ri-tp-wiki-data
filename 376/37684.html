<html><title>Algoritmo de Borůvka</title><body>&#10;<p> &#10; </p>&#10;<p>O <b>algoritmo de Borůvka</b> (ou <b>Barůvka</b> como tamb&eacute;m &eacute; conhecido) &eacute; um algoritmo para encontrar uma <a href="http://en.wikipedia.org/wiki/&Aacute;rvore_geradora_m%C3%ADnima" id="w">&aacute;rvore geradora m&iacute;nima</a> em um <a href="http://en.wikipedia.org/wiki/Grafo" id="w">grafo</a> para o qual todos os pesos de <a href="http://en.wikipedia.org/wiki/Aresta_(teoria_dos_grafos)" id="w">arestas</a> sejam distintos. </p>&#10;<p>Este algoritmo caracteriza&shy;se pela divis&atilde;o do grafo original em v&aacute;rios subgrafos para os quais &eacute; calculado a <i>Minimum Spanning Tree</i> (&aacute;rvore geradora m&iacute;nima). Ou seja, no fundo, pode ser considerada uma varia&ccedil;&atilde;o de algoritmos como os de <a href="http://en.wikipedia.org/wiki/Algoritmo_de_Prim" id="w">Prim</a> e <a href="http://en.wikipedia.org/wiki/Algoritmo_de_Kruskal" id="w">Kruskal</a>. &Eacute; um algoritmo que, de modo diverso dos algoritmos de Kruskal e Prim, n&atilde;o usa uma fila de prioridades<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup>. </p>&#10;<p>&Eacute; um algoritmo com uma velocidade de converg&ecirc;ncia (ou resolu&ccedil;&atilde;o) bastante r&aacute;pida sendo ideal para implementa&ccedil;&atilde;o em computadores paralelos j&aacute; que a <i>Minimum Spanning Tree</i> de cada um dos subgrafos pode ser calculada numa m&aacute;quina diferente.</p>&#10;<p>Este algoritmo &eacute; <a href="http://en.wikipedia.org/wiki/Recursivo" id="w">recursivo</a> e s&oacute; termina quando existe apenas um v&eacute;rtice.</p>&#10;<p>O algoritmo de Baruvka compreende os seguintes passos:</p>&#10;<p><b>1</b> &shy; para cada <a href="http://en.wikipedia.org/wiki/V%C3%A9rtice_(teoria_dos_grafos)" id="w">v&eacute;rtice</a> escolher o seu <a href="http://en.wikipedia.org/wiki/Aresta_(teoria_dos_grafos)" id="w">arco</a> com peso m&iacute;nimo. Deste passo poder&atilde;o resultar v&aacute;rios <a href="http://en.wikipedia.org/wiki/Subgrafo" id="w">subgrafos</a>.</p>&#10;<p><b>2</b> &shy; caso o passo 1 d&ecirc; origem a grafos n&atilde;o conectados, considere&shy;se cada subgrafo gerado no passo anterior como um v&eacute;rtice do grafo final. Estes v&eacute;rtices do grafo final conter&atilde;o os v&eacute;rtices de cada umdos subgrafos gerados no passo 1. Para cada um dos subgrafos gerados execute&shy;se de novo o passo <b>1</b> (<a href="http://en.wikipedia.org/wiki/Recursividade" id="w">recursividade</a>). Neste momento pode&shy;se, caso existam v&aacute;rias m&aacute;quinas diferentes, correr este algoritmo nas v&aacute;rias m&aacute;quinas sendo que cada m&aacute;quina ir&aacute; ter assignada a si um dos subgrafos gerados no passo <b>1</b> (este tipo de distribui&ccedil;&atilde;o de processamento &eacute; mais conhecido como <a href="http://en.wikipedia.org/wiki/SIMD" id="w">Single Instruction Multiple Data</a> j&aacute; que cada m&aacute;quina vai executar as mesmas instru&ccedil;&otilde;es mas sobre um conjunto de dados diferentes).</p>&#10;<p><b>3</b> &shy; Quando for encontrada a <i>Minimum Spanning Tree</i> para cada um dos grafos gerar um novo grafo onde cada um v&eacute;rtices deste grafo &eacute; um dos subgrafos. O objectivo agora ser&aacute; voltar a executar os passos <b>1</b> a <b>3</b> at&eacute; que existam apenas 2 v&eacute;rtices e um &uacute;nico arco.  </p>&#10;<p><b>A t&iacute;tulo de exemplo</b></p>&#10;<p>Seja <b>V</b> um grafo n&atilde;o <a href="http://en.wikipedia.org/wiki/Grafo_orientado" id="w">orientado</a> cuja representa&ccedil;&atilde;o matricial &eacute; a seguinte:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table align="center" border="1" cellpadding="5" cellspacing="0" style="background:lightcyan&semi; font&shy;weight:bold&semi; text&shy;align:center&semi; width:35%">&#10;<caption><b>Exemplo 1</b></caption>&#10;<tr style="background:paleturquoise">&#10;<th style="width:5%" />&#10;<th style="width:5%">a</th>&#10;<th style="width:5%">b</th>&#10;<th style="width:5%">c</th>&#10;<th style="width:5%">d</th>&#10;<th style="width:5%">e</th>&#10;<th style="width:5%">f</th></tr>&#10;<tr>&#10;<td>a   </td>&#10;<td>0  </td>&#10;<td>4  </td>&#10;<td>2  </td>&#10;<td>0  </td>&#10;<td>0  </td>&#10;<td>0</td></tr>&#10;<tr>&#10;<td>b   </td>&#10;<td>4  </td>&#10;<td>0  </td>&#10;<td>2  </td>&#10;<td>0  </td>&#10;<td>5  </td>&#10;<td>1</td></tr>&#10;<tr>&#10;<td>c  </td>&#10;<td>2  </td>&#10;<td>2  </td>&#10;<td>0  </td>&#10;<td>10  </td>&#10;<td>1  </td>&#10;<td>0</td></tr>&#10;<tr>&#10;<td>d   </td>&#10;<td>0  </td>&#10;<td>0  </td>&#10;<td>10  </td>&#10;<td>0  </td>&#10;<td>15 </td>&#10;<td>0</td></tr>&#10;<tr>&#10;<td>e   </td>&#10;<td>0  </td>&#10;<td>5  </td>&#10;<td>1  </td>&#10;<td>15  </td>&#10;<td>0  </td>&#10;<td>2</td></tr>&#10;<tr>&#10;<td>f  </td>&#10;<td>0  </td>&#10;<td>1  </td>&#10;<td>0  </td>&#10;<td>0  </td>&#10;<td>2  </td>&#10;<td>0</td></tr></table></div>&#10;<p><small><b>Nota</b>: As posi&ccedil;&otilde;es (i,j) e (j,i) da matriz anterior t&ecirc;m os mesmos valores. Isso indica que o grafo em an&aacute;lise &eacute; n&atilde;o orientado.</small></p>&#10;<p>Executando o passo <b>1</b> acima referido sobre esta matriz passar&iacute;amos a ter a seguinte matriz:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table align="center" border="1" cellpadding="5" cellspacing="0" style="background:lightcyan&semi; font&shy;weight:bold&semi; text&shy;align:center&semi; width:35%">&#10;<tr style="background:paleturquoise">&#10;<th style="width:5%" />&#10;<th style="width:5%">a</th>&#10;<th style="width:5%">b</th>&#10;<th style="width:5%">c</th>&#10;<th style="width:5%">d</th>&#10;<th style="width:5%">e</th>&#10;<th style="width:5%">f</th></tr>&#10;<tr>&#10;<td>a </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>2 </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0</td></tr>&#10;<tr>&#10;<td>b </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>1</td></tr>&#10;<tr>&#10;<td>c </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>1 </td>&#10;<td>0</td></tr>&#10;<tr>&#10;<td>d </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>10 </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0</td></tr>&#10;<tr>&#10;<td>e </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0</td></tr>&#10;<tr>&#10;<td>f </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0</td></tr></table></div>&#10;&#10;<p>Analisando esta nova matriz podemos ver que existem duas linhas a zero (<b>e</b> e <b>f</b>), o que claramente indica a exist&ecirc;ncia de dois subgrafos. Como verificar quais os subgrafos? &Eacute; um processo simples de verificar quais as linhas e colunas que se cruzam. Neste caso os novos subgrafos s&atilde;o dados pelas seguintes matrizes:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table align="center" border="1" cellpadding="5" cellspacing="0" style="background:lightcyan&semi; font&shy;weight:bold&semi; text&shy;align:center&semi; width:15%">&#10;<tr style="background:paleturquoise">&#10;<th style="width:5%" />&#10;<th style="width:5%">b</th>&#10;<th style="width:5%">f</th></tr>&#10;<tr>&#10;<td>b </td>&#10;<td>0 </td>&#10;<td>1</td></tr>&#10;<tr>&#10;<td>f </td>&#10;<td>0 </td>&#10;<td>0</td></tr></table></div>&#10;&#10;&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table align="center" border="1" cellpadding="5" cellspacing="0" style="background:lightcyan&semi; font&shy;weight:bold&semi; text&shy;align:center&semi; width:25%">&#10;<tr style="background:paleturquoise">&#10;<th style="width:5%" />&#10;<th style="width:5%">a</th>&#10;<th style="width:5%">c</th>&#10;<th style="width:5%">d</th>&#10;<th style="width:5%">e</th></tr>&#10;<tr>&#10;<td>a </td>&#10;<td>0 </td>&#10;<td>2 </td>&#10;<td>0 </td>&#10;<td>0</td></tr>&#10;<tr>&#10;<td>c </td>&#10;<td>0</td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>1</td></tr>&#10;<tr>&#10;<td>d </td>&#10;<td>0 </td>&#10;<td>10 </td>&#10;<td>0 </td>&#10;<td>0</td></tr>&#10;<tr>&#10;<td>e </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0 </td>&#10;<td>0</td></tr></table></div>&#10;&#10;<p>Notar que &eacute; necess&aacute;rio reter,da matriz original os valores que cruzam os v&eacute;rtices dos diferentes subgrafos gerados no passo 1, ou seja, a arco <b>a&shy;b</b> (com peso 4), o arco <b>c&shy;b</b> (com peso 2), o arco <b>b&shy;e</b> (com peso 5) e o arco <b>e&shy;f</b> (com peso 2). Estes arcos s&atilde;o usados para unir os v&eacute;rtices do arco gerado no passo 3.</p>&#10;<p>Neste exemplo bastante simples, o passo 2 representado pelas duas matrizes anteriores. Deste modo, n&atilde;o &eacute; necess&aacute;rio encontrar a Minimum Spanning Tree para cada uma destas matrizes j&aacute; que quando se executa o passo <b>1</b> estas s&atilde;o encontradas automaticamente (outros exemplos h&aacute; em que &eacute; necess&aacute;rio executar o passo <b>2</b>). Isto leva, ent&atilde;o, &agrave; gera&ccedil;&atilde;o do grafo do passo <b>3</b> em que temos dois v&eacute;rtices (um para cada uma das matrizes anteriores) e que pode ser representado sob a seguinte forma</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table align="center" border="1" cellpadding="5" cellspacing="0" style="background:lightcyan&semi; font&shy;weight:bold&semi; text&shy;align:center&semi; width:15%">&#10;<tr style="background:paleturquoise">&#10;<th style="width:5%" />&#10;<th style="width:5%">bf</th>&#10;<th style="width:5%">acde</th></tr>&#10;<tr>&#10;<td>bf </td>&#10;<td>0 </td>&#10;<td>4/2/2/5 </td></tr>&#10;<tr>&#10;<td>acde </td>&#10;<td>4/2/2/5 </td>&#10;<td>0 </td></tr></table></div>&#10;&#10;<p>Note&shy;se que a diagonal principal da matriz est&aacute; a zero mas a outra diagonal n&atilde;o (&eacute; apenas uma quest&atilde;o de representac&atilde;o. (<a href="http://en.wikipedia.org/wiki/Transpondo" id="w">matriz transposta</a> esta matriz ir&shy;se&shy;ia obter a diagonal principal n&atilde;o nula e a outra diagonal a zero.) Estes valores indicam poss&iacute;veis arcos que ligam os v&eacute;rtices deste grafo. Ent&atilde;o, volta&shy;se a executar o passo <b>1</b> sobre este grafo pelo que se chega &agrave; conclus&atilde;o de que o grafo inicial deu origem a um grafo final cuja representa&ccedil;&atilde;o &eacute; a seguinte:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table align="center" border="1" cellpadding="5" cellspacing="0" style="background:lightcyan&semi; font&shy;weight:bold&semi; text&shy;align:center&semi; width:15%">&#10;<tr style="background:paleturquoise">&#10;<th style="width:5%" />&#10;<th style="width:5%">bf</th>&#10;<th style="width:5%">acde</th></tr>&#10;<tr>&#10;<td>bf </td>&#10;<td>0 </td>&#10;<td>2 </td></tr>&#10;<tr>&#10;<td>acde  </td>&#10;<td>0 </td>&#10;<td>0</td></tr></table></div>&#10;&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2>Ver tamb&eacute;m</h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Otakar_Bor%C5%AFvka" id="w">Otakar Borůvka</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Algoritmo_de_Prim" id="w">algoritmo de Prim</a> </li>&#10;<li><a href="http://en.wikipedia.org/wiki/Algoritmo_de_Kruskal" id="w">algoritmo de Kruskal</a></li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Teoria_dos_grafos" id="w">Categoria:Teoria dos grafos</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos_de_grafos" id="w">Boruvka</a></p></body></html>