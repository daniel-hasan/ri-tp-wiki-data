<html><title>Programa&ccedil;&atilde;o funcional</title><body>&#10;<p>Em <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">ci&ecirc;ncia da computa&ccedil;&atilde;o</a>, <b>programa&ccedil;&atilde;o funcional</b> &eacute; um <a href="http://en.wikipedia.org/wiki/Paradigma_de_programa%C3%A7%C3%A3o" id="w">paradigma de programa&ccedil;&atilde;o</a> que trata a computa&ccedil;&atilde;o como uma avalia&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_matem%C3%A1tica" id="w">fun&ccedil;&otilde;es matem&aacute;ticas</a> e que evita estados ou dados mut&aacute;veis. Ela enfatiza a aplica&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Subrotina" id="w">fun&ccedil;&otilde;es</a>, em contraste da <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_imperativa" id="w">programa&ccedil;&atilde;o imperativa</a>, que enfatiza mudan&ccedil;as no estado do programa<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup>.</p>&#10;<p>Uma fun&ccedil;&atilde;o, neste sentido, pode ter ou n&atilde;o ter <a href="http://en.wikipedia.org/wiki/Par%C3%A2metro_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">par&acirc;metros</a> e um simples valor de retorno. Os par&acirc;metros s&atilde;o os valores de entrada da fun&ccedil;&atilde;o, e o valor de retorno &eacute; o resultado da fun&ccedil;&atilde;o. A defini&ccedil;&atilde;o de uma fun&ccedil;&atilde;o descreve como a fun&ccedil;&atilde;o ser&aacute; avaliada em termos de outras fun&ccedil;&otilde;es. Por exemplo, a fun&ccedil;&atilde;o <span class="math">f(x) = x^2 + 2</span> &eacute; definida em termos de fun&ccedil;&otilde;es de <a href="http://en.wikipedia.org/wiki/Exponencia%C3%A7%C3%A3o" id="w">exponencia&ccedil;&atilde;o</a> e <a href="http://en.wikipedia.org/wiki/Adi%C3%A7%C3%A3o" id="w">adi&ccedil;&atilde;o</a>. Do mesmo modo, a linguagem deve oferecer fun&ccedil;&otilde;es b&aacute;sicas que n&atilde;o requerem defini&ccedil;&otilde;es adicionais.</p>&#10;<p><a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">Linguagens de programa&ccedil;&atilde;o</a> funcionais, especialmente as puramente funcionais, tem sido mais usadas academicamente que no <a href="http://en.wikipedia.org/wiki/Desenvolvimento_de_software" id="w">desenvolvimento comercial de software</a>. Entretanto, algumas linguagens not&aacute;veis usadas na ind&uacute;stria e no com&eacute;rcio incluem <a href="http://en.wikipedia.org/wiki/Erlang_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Erlang</a> (aplica&ccedil;&otilde;es concorrentes)<sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup>, <a href="http://en.wikipedia.org/wiki/R_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">R</a> (estat&iacute;stica), <a href="http://en.wikipedia.org/wiki/Mathematica" id="w">Mathematica</a> (matem&aacute;tica simb&oacute;lica)<sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup> <a href="http://en.wikipedia.org/wiki/J_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">J</a>, <a href="http://en.wikipedia.org/wiki/K_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">K</a> (an&aacute;lise financeira) e <a href="http://en.wikipedia.org/wiki/XSLT" id="w">XSLT</a>.<sup id="_ref&shy;4" class="reference"><a href="#_note&shy;4" title="">[4]</a></sup><sup id="_ref&shy;5" class="reference"><a href="#_note&shy;5" title="">[5]</a></sup> Importantes influ&ecirc;ncias na programa&ccedil;&atilde;o funcional foram o <a href="http://en.wikipedia.org/wiki/C%C3%A1lculo_lambda" id="w">c&aacute;lculo lambda</a>, as linguagens de programa&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/APL" id="w">APL</a> e <a href="http://en.wikipedia.org/wiki/Lisp" id="w">Lisp</a>, e mais recentemente <a href="http://en.wikipedia.org/wiki/ML_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">ML</a>, <a href="http://en.wikipedia.org/wiki/Haskell_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Haskell</a>, <a href="http://en.wikipedia.org/wiki/OCaml" id="w">OCaml</a> e <a href="http://en.wikipedia.org/wiki/F_Sharp" id="w">F#</a>.</p>&#10;<a id="Desenvolvimento" name="Desenvolvimento"></a><h2> Desenvolvimento </h2>&#10;<p>As fun&ccedil;&otilde;es podem ser manipuladas em uma grande variedade de formas em uma <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagem de programa&ccedil;&atilde;o</a> funcional. As fun&ccedil;&otilde;es s&atilde;o tratadas como valores de primeira import&acirc;ncia, o que &eacute; o mesmo que dizer que fun&ccedil;&otilde;es podem ser par&acirc;metros ou valores de entrada para outras fun&ccedil;&otilde;es e podem ser os valores de retorno ou sa&iacute;da de uma fun&ccedil;&atilde;o. Ent&atilde;o podemos entender paradigma funcional como um mapeamento dos valores de entrada nos valores de retorno, atrav&eacute;s de fun&ccedil;&otilde;es. Isso permite que fun&ccedil;&otilde;es como <code>mapcar</code> em <a href="http://en.wikipedia.org/wiki/LISP" id="w">LISP</a> e <code>map</code> em <a href="http://en.wikipedia.org/wiki/Haskell" id="w">Haskell</a> que tomam ambos uma fun&ccedil;&atilde;o e uma <a href="http://en.wikipedia.org/wiki/Lista_encadeada" id="w">lista</a> como entrada e aplicam a fun&ccedil;&atilde;o de entrada a cada elemento da lista. Fun&ccedil;&otilde;es podem ser nomeadas, como em outras linguagens, ou definidas anonimamente (algumas vezes durante a execu&ccedil;&atilde;o do programa) usando uma abstra&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/C%C3%A1lculo_lambda" id="w">lambda</a> e usadas como valores em outras fun&ccedil;&otilde;es. Linguagens funcionais tamb&eacute;m permitem que fun&ccedil;&otilde;es sejam do tipo <i>curry</i>. <i><a href="http://en.wikipedia.org/wiki/Currying" id="w">Currying</a></i> &eacute; uma t&eacute;cnica para reescrita de fun&ccedil;&otilde;es com m&uacute;ltiplos par&acirc;metros como a composi&ccedil;&atilde;o de fun&ccedil;&otilde;es de um par&acirc;metro. A fun&ccedil;&atilde;o do tipo <i>curry</i> pode ser aplicada apenas a um subconjunto de seus par&acirc;metros. O resultado &eacute; uma fun&ccedil;&atilde;o onde os par&acirc;metros neste subconjunto s&atilde;o agora fixados como constantes, e os valores do resto dos par&acirc;metros ainda n&atilde;o s&atilde;o especificados. Esta nova fun&ccedil;&atilde;o pode ser aplicada aos par&acirc;metros restantes para obter o valor da fun&ccedil;&atilde;o final. Por exemplo, uma fun&ccedil;&atilde;o <code>adiciona(x,y) = x + y</code> pode ser do tipo <i>curry</i> de forma que o valor de retorno <code>adiciona(2)</code> &mdash; note que n&atilde;o h&aacute; um par&acirc;metro y &mdash; ser&aacute; uma fun&ccedil;&atilde;o an&ocirc;nima, o que &eacute; equivalente &agrave; fun&ccedil;&atilde;o <code>adiciona2(y) = 2 + y</code>. Esta nova fun&ccedil;&atilde;o tem apenas um par&acirc;metro e corresponde a adicionar 2 a um n&uacute;mero. Novamente, isso &eacute; apenas poss&iacute;vel porque as fun&ccedil;&otilde;es s&atilde;o tratadas como valores de primeira import&acirc;ncia.</p>&#10;<p>O c&aacute;lculo lambda pode ser considerado a primeira linguagem de programa&ccedil;&atilde;o funcional, embora nunca tenha sido projetada para ser realmente executada em um computador. &Eacute; um modelo de computa&ccedil;&atilde;o projetado por <a href="http://en.wikipedia.org/wiki/Alonzo_Church" id="w">Alonzo Church</a> nos <a href="http://en.wikipedia.org/wiki/D%C3%A9cada_de_1930" id="w">anos 1930</a> que oferece um modo muito formal de descrever um c&aacute;lculo de uma fun&ccedil;&atilde;o. A primeira linguagem de programa&ccedil;&atilde;o funcional criada para computadores foi <a href="http://en.wikipedia.org/wiki/LISP" id="w">LISP</a>, desenvolvida por <a href="http://en.wikipedia.org/wiki/John_McCarthy" id="w">John McCarthy</a> no <a href="http://en.wikipedia.org/wiki/Instituto_de_Tecnologia_de_Massachusetts" id="w">Instituto de Tecnologia de Massachusetts</a> (MIT) no fim dos <a href="http://en.wikipedia.org/wiki/Anos_1950" id="w">anos 1950</a>. Mesmo n&atilde;o sendo uma linguagem de programa&ccedil;&atilde;o puramente funcional, LISP introduziu a maioria das caracter&iacute;sticas hoje encontradas nas modernas linguagens de programa&ccedil;&atilde;o funcional. <a href="http://en.wikipedia.org/wiki/Scheme" id="w">Scheme</a> foi uma tentativa posterior de simplificar e melhorar LISP. Nos <a href="http://en.wikipedia.org/wiki/Anos_1970" id="w">anos 1970</a> a linguagem <a href="http://en.wikipedia.org/wiki/ML_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">ML</a> foi criada pela <a href="http://en.wikipedia.org/wiki/Universidade_de_Edimburgo" id="w">Universidade de Edimburgo</a>, e <a href="http://en.wikipedia.org/wiki/David_Turner" id="w">David Turner</a> desenvolveu a linguagem <a href="http://en.wikipedia.org/wiki/Miranda" id="w">Miranda</a> na Universidade de Kent. A linguagem <a href="http://en.wikipedia.org/wiki/Haskell_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Haskell</a> foi lan&ccedil;ada no fim dos <a href="http://en.wikipedia.org/wiki/Anos_1980" id="w">anos 1980</a> em uma tentativa de juntar muitas id&eacute;ias na pesquisa de programa&ccedil;&atilde;o funcional.</p>&#10;<a id="Contraste_com_a_programa%C3%A7%C3%A3o_imperativa" name="Contraste_com_a_programa%C3%A7%C3%A3o_imperativa"></a><h2> Contraste com a programa&ccedil;&atilde;o imperativa </h2>&#10;<p>A programa&ccedil;&atilde;o funcional pode ser contrastada com a <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_imperativa" id="w">programa&ccedil;&atilde;o imperativa</a>. Na programa&ccedil;&atilde;o funcional parecem faltar diversas constru&ccedil;&otilde;es freq&uuml;entemente (embora incorretamente) consideradas essenciais em linguagens imperativas, como <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_C" id="w">C</a> ou <a href="http://en.wikipedia.org/wiki/Pascal_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Pascal</a>. Por exemplo, em uma programa&ccedil;&atilde;o estritamente funcional, n&atilde;o h&aacute; aloca&ccedil;&atilde;o expl&iacute;cita de <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_de_computador" id="w">mem&oacute;ria</a>, nem declara&ccedil;&atilde;o expl&iacute;cita de <a href="http://en.wikipedia.org/wiki/Vari%C3%A1vel_(programa%C3%A7%C3%A3o)" id="w">vari&aacute;veis</a>. No entanto, essas opera&ccedil;&otilde;es podem ocorrer automaticamente quando a fun&ccedil;&atilde;o &eacute; invocada&semi; a aloca&ccedil;&atilde;o de mem&oacute;ria ocorre para criar espa&ccedil;o para os par&acirc;metros e para o valor de retorno, e a declara&ccedil;&atilde;o ocorre para copiar os par&acirc;metros dentro deste espa&ccedil;o rec&eacute;m&shy;alocado e para copiar o valor de retorno de volta para dentro da fun&ccedil;&atilde;o que a chama. Ambas as opera&ccedil;&otilde;es podem ocorrer nos pontos de entrada e na sa&iacute;da da fun&ccedil;&atilde;o, ent&atilde;o efeitos colaterais no c&aacute;lculo da fun&ccedil;&atilde;o s&atilde;o eliminados. Ao n&atilde;o permitir efeitos colaterais em fun&ccedil;&otilde;es, a linguagem oferece transpar&ecirc;ncia referencial. Isso assegura que o resultado da fun&ccedil;&atilde;o ser&aacute; o mesmo para um dado conjunto de par&acirc;metros n&atilde;o importando onde, ou quando, seja avaliada. Transpar&ecirc;ncia referencial facilita muito ambas as tarefas de comprovar a corre&ccedil;&atilde;o do programa e automaticamente identificar computa&ccedil;&otilde;es independentes para execu&ccedil;&atilde;o paralela.</p>&#10;<p>La&ccedil;os, outra constru&ccedil;&atilde;o de programa&ccedil;&atilde;o imperativa, est&atilde;o presentes atrav&eacute;s da constru&ccedil;&atilde;o funcional mais geral de <a href="http://en.wikipedia.org/wiki/Recursividade_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">recursividade</a>. Fun&ccedil;&otilde;es recursivas invocam a si mesmas, permitindo que uma opera&ccedil;&atilde;o seja realizada v&aacute;rias vezes. Na verdade, isso prova que la&ccedil;os s&atilde;o equivalentes a um tipo especial de recursividade chamada recursividade reversa. Recursividade em programa&ccedil;&atilde;o funcional pode assumir v&aacute;rias formas e &eacute; em geral uma t&eacute;cnica mais poderosa que o uso de la&ccedil;os. Por essa raz&atilde;o, quase todas as linguagens imperativas tamb&eacute;m a suportam (sendo <a href="http://en.wikipedia.org/wiki/Fortran" id="w">Fortran 77</a> e <a href="http://en.wikipedia.org/wiki/COBOL" id="w">COBOL</a> exce&ccedil;&otilde;es not&aacute;veis).</p>&#10;<p> &#10;</p>&#10;<ul>&#10;<li>Cousineau, Guy and Michel Mauny. <i>The Functional Approach to Programming</i>. Cambridge, UK: Cambridge University Press, 1998.</li>&#10;<li>Graham, Paul. <i>ANSI Common LISP</i>. Englewood Cliffs, New Jersey: Prentice Hall, 1996.</li>&#10;<li>Hudak, Paul. &#34&semi;Conception, Evolution, and Application of Functional Programming Languages&#34&semi;. <i>ACM Computing Surveys</i> 21, no. 3 (1989): 359&shy;411.</li>&#10;<li>Pratt, Terrence, W. and Marvin V. Zelkowitz. <i>Programming Languages: Design and Implementation</i>. 3rd ed. Englewood Cliffs, New Jersey: Prentice Hall, 1996.</li>&#10;<li>Salus, Peter H. <i>Functional and Logic Programming Languages. Vol. 4 of Handbook of Programming Languages</i>.  Indianapolis, Indiana: Macmillan Technical Publishing, 1998.</li>&#10;<li>Thompson, Simon. <i>Haskell: The Craft of Functional Programming</i>. Harlow, England: Addison&shy;Wesley Longman Limited, 1996.</li></ul>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/C%C3%A1lculo_lambda" id="w">C&aacute;lculo lambda</a></li></ul>&#10;<p> &#10;<a href="http://en.wikipedia.org/wiki/Categoria:Programa%C3%A7%C3%A3o_funcional" id="w"> </a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">Categoria:Ci&ecirc;ncia da computa&ccedil;&atilde;o</a></p></body></html>