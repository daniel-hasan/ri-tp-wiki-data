<html><title>Scheme</title><body>&#10;<p> &#10;<b>Scheme</b> &eacute; uma <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagem de programa&ccedil;&atilde;o</a> <a href="http://en.wikipedia.org/wiki/Multiparadigma" id="w">multiparadigma</a> que suporta <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_funcional" id="w">programa&ccedil;&atilde;o funcional</a> e <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_procedural" id="w">procedural</a>. Foi criada por Guy L. Steele e Gerald Jay Sussman no outono de 1975, a partir da linguagem <a href="http://en.wikipedia.org/wiki/Lisp" id="w">Lisp</a> com o intuito de estudar a teoria dos atores de Carl Hewitt. O modelo de Hewitt era orientado a objeto (e influenciado pelo Smalltalk). Os objetos eram chamados atores e as mensagens eram tamb&eacute;m atores. Sussman e Steele tiveram algum problema no entender algumas das conseq&uuml;&ecirc;ncias do modelo a partir dos artigos de Hewitt e decidiram construir uma implementa&ccedil;&atilde;o de brinquedo de uma linguagem de atores visando experiment&aacute;&shy;la. Escreveram um pequeno interpretador Lisp e adicionaram os mecanismos necess&aacute;rios para a cria&ccedil;&atilde;o de atores e envio de mensagens<sup id="_ref&shy;hoplii_a" class="reference"><a href="#_note&shy;hoplii" title="">[1]</a></sup>. Existem dois padr&otilde;es que definem a linguagem Scheme: o padr&atilde;o oficial <a href="http://en.wikipedia.org/wiki/IEEE" id="w">IEEE</a> e um padr&atilde;o popular chamado <i>&#34&semi;Revised<sup>n</sup> Report on the Algorithmic Language Scheme&#34&semi;</i>, abreviado como RnRS, onde n &eacute; o n&uacute;mero de revis&otilde;es.</p>&#10;<a id="Caracter%C3%ADsticas" name="Caracter%C3%ADsticas"></a><h2> Caracter&iacute;sticas </h2>&#10;<p>Scheme adota uma filosofia minimalista, assim sendo, prov&ecirc; o m&iacute;nimo de no&ccedil;&otilde;es poss&iacute;veis, e, na pr&aacute;tica, qualquer outra no&ccedil;&atilde;o pode ser adicionada via bibliotecas, como todos os dialetos do <a href="http://en.wikipedia.org/wiki/Lisp" id="w">Lisp</a>, possui pouca sintaxe comparado &agrave; maioria das outras linguagens. Devido &agrave; sua sintaxe completamete aninhada, n&atilde;o existem regras de preced&ecirc;ncia de operadores e sua nota&ccedil;&atilde;o parentizada &eacute; usada para todas as chamadas de fun&ccedil;&atilde;o, desta forma n&atilde;o h&aacute; ambig&uuml;idades como as que s&atilde;o encontradas nas linguagens de nota&ccedil;&atilde;o infixa. Por&eacute;m em procedimentos que existam muitos fatores a serem abordados, o programa pode ficar visualmente confuso e necessita ser analisado com mais cuidado.</p>&#10;<p>Exemplos:&#10;</p>&#10;<pre>&#10;(5+3)   seria assim:  (+ 5 3)&#10;(5+3)*2 seria assim:  (* (+ 5 3) 2)&#10;(8/2)   seria assim:  (/ 8 2)&#10;</pre>&#10;&#10;<p>Exemplo de um procedimento composto:&#10;</p>&#10;<pre>&#10;((lambda (x) (+ x x)) (* 3 4))&#10;</pre>&#10;&#10;<p>neste caso:&#10;</p>&#10;<pre>&#10;3*4 = 12&semi;&#10;x = 12&semi;&#10;x + x = 12 + 12 = 24&semi;&#10;</pre>&#10;&#10;<a id="Algumas_nota%C3%A7%C3%B5es_da_Linguagem" name="Algumas_nota%C3%A7%C3%B5es_da_Linguagem"></a><h2> Algumas nota&ccedil;&otilde;es da Linguagem </h2>&#10;&#10;<ul>&#10;<li><code>. + &shy;</code>: s&atilde;o usados em n&uacute;meros e podem ocorrer em qualquer lugar, exceto como primeiro caracter</li>&#10;<li><code>()</code>: parenteses s&atilde;o utilizados para agrupar e listas de dados</li>&#10;<li><code>,</code>: sozinho, &eacute; utilizado para indicar dados literais</li>&#10;<li><code>`</code>: serve para indicar quase todos dados constantes</li>&#10;<li><code>&#34&semi;</code>: delimitador de strings</li>&#10;<li><code>#t #f</code>: constantes boleanas</li>&#10;<li><code> #\</code>: serve para introduzir um caracter constante</li>&#10;<li><code>#e #i #o #d #x</code>: utilizados na nota&ccedil;&atilde;o de n&uacute;meros</li></ul>&#10;<a id="Exemplos_de_c%C3%B3digo_em_Scheme" name="Exemplos_de_c%C3%B3digo_em_Scheme"></a><h2> Exemplos de c&oacute;digo em Scheme </h2>&#10;<a id="Programa_Ol%C3%A1_Mundo" name="Programa_Ol%C3%A1_Mundo"></a><h3> Programa Ol&aacute; Mundo </h3>&#10;<p> </p>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;Scheme&#34&semi;&#62&semi;&#10;(define ola&shy;mundo&#10; (lambda ()&#10;   (display &#34&semi;Ol&aacute;, Mundo!&#34&semi;) &#10;   (newline)))&#10;(ola&shy;mundo)&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<p>ou, simplesmente:</p>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;Scheme&#34&semi;&#62&semi;&#10;(display &#34&semi;Ol&aacute;, Mundo!&#34&semi;)&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="Condicionais" name="Condicionais"></a><h3> Condicionais </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;Scheme&#34&semi;&#62&semi;&#10;(if (teste) (consequencia) (alternativa)) syntax&#10;(if (teste) (consequencia)) syntax&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<p>Syntax: (Teste), (consequencia), e (alternativa) podem ser express&otilde;es arbitr&aacute;rias.</p>&#10;<p>Semantica: uma express&atilde;o if &eacute; validada da sequinte forma: primeiro (teste) &eacute; avaliado, se for verdadeiro, ent&atilde;o (consequencia) &eacute; avaliado e seu valor &eacute; retornado. Caso contr&aacute;rio (alternativa) &eacute; avaliado e seu valor &eacute; retornado. Se o teste n&atilde;o possui (alternativa) especificado, ent&atilde;o o resultado da express&atilde;o n&atilde;o &eacute; especificado.</p>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;Scheme&#34&semi;&#62&semi;&#10;(if (&#62&semi; 3 2) &#39&semi;yes &#39&semi;no)  &shy;&shy;&#62&semi; yes&#10;(if (&#62&semi; 2 3) &#39&semi;yes &#39&semi;no)  &shy;&shy;&#62&semi; no&#10;(if (&#62&semi; 3 2)&#10;(&shy; 3 2)&#10;(+ 3 2)) &shy;&shy;&#62&semi; 1&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="Recursividade" name="Recursividade"></a><h3> Recursividade </h3>&#10;<p>C&aacute;lculo do <a href="http://en.wikipedia.org/wiki/Fatorial" id="w">fatorial</a> de um n&uacute;mero:</p>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;Scheme&#34&semi;&#62&semi;&#10;(define (fatorial n)&#10; (cond ((= n 0)  1)&#10;   (else (* n (fatorial (&shy; n 1))))))</p>&#10;<p>(fatorial 5)&#10;</p><dl><dt><dl><dt>=&#62&semi; 120</dt></dl></dt></dl>&#10;<p>&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="N%C3%BAmeros_Perfeitos" name="N%C3%BAmeros_Perfeitos"></a><h3> N&uacute;meros Perfeitos </h3>&#10;<p>Exemplo de programa que mostra os n primeiros <a href="http://en.wikipedia.org/wiki/N%C3%BAmeros_perfeitos" id="w">n&uacute;meros perfeitos</a>:</p>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;Scheme&#34&semi;&#62&semi;&#10;(define inverteListax&#10; (lambda (lista1 lista2)&#10;   (if (null? lista1) lista2&#10;       (inverteListax (cdr lista1) (cons (car lista1) lista2)))))</p> &#10;<pre>(define inverteLista&#10;  (lambda (lista)&#10;    (inverteListax lista &#39&semi;())))&#10; &#10;(define (perf n)&#10;   (let loop ((i 1)&#10;               (sum 0))&#10;      (cond ((= i n)&#10;             (= sum n))&#10;            (&#10;               (= 0 (modulo n i))&#10;               (loop (+ i 1) (+ sum i)))&#10;            (else&#10;             (loop (+ i 1) sum)))))&#10;  &#10;(define aux&#10;  (lambda (x n l)&#10;    (if (= x 0) l&#10;        (if (perf n) (aux (&shy; x 1) (+ n 1) (cons n l))&#10;                     (aux x (+ n 1) l)))))&#10;  &#10;(define main&#10;  (lambda (x)&#10;    (aux x 1 &#39&semi;())))&#10; &#10;(define perfeitos&#10;  (lambda (n)&#10;    (inverteLista (main n))))</pre>&#10;<p>&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="Compiladores" name="Compiladores"></a><h2> Compiladores </h2>&#10;<p>Alguns compiladores de Scheme:</p>&#10;&#10;<ul>&#10;<li>Bigloo</li>&#10;<li>Chez Scheme</li>&#10;<li>Chicken</li>&#10;<li>Gambit</li>&#10;<li>Gauche</li>&#10;<li>Guile</li>&#10;<li>Ikarus</li>&#10;<li>JScheme</li>&#10;<li>Kawa</li>&#10;<li>Larceny</li>&#10;<li><a class="externallink" href="http://www.gnu.org/software/mit&shy;scheme/" rel="nofollow" title="http://www.gnu.org/software/mit&shy;scheme/">MIT/GNU Scheme</a></li>&#10;<li><a class="externallink" href="http://code.google.com/p/mosh&shy;scheme/" rel="nofollow" title="http://code.google.com/p/mosh&shy;scheme/">Mosh</a></li>&#10;<li><a class="externallink" href="http://www.plt&shy;scheme.org/" rel="nofollow" title="http://www.plt&shy;scheme.org/">PLT Scheme</a></li>&#10;<li>Pvts</li>&#10;<li>RScheme</li>&#10;<li>Scheme 48</li>&#10;<li>SCM</li>&#10;<li>SISC</li>&#10;<li>Stalin</li>&#10;<li>STk</li>&#10;<li>STklos</li>&#10;<li>TinyScheme</li>&#10;<li><a class="externallink" href="http://code.google.com/p/ypsilon/" rel="nofollow" title="http://code.google.com/p/ypsilon/">Ypsilon</a></li></ul>&#10;<p> </p>&#10;<a id="Bibliografia" name="Bibliografia"></a><h2> Bibliografia </h2>&#10;&#10;<ul>&#10;<li> </li>&#10;<li> </li></ul>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Lisp" id="w">Lisp</a></li></ul>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li><a class="externallink" href="http://embed.verite.co/timeline/?source=0AiKv3gqIhXVbdGM2X3c1OEY1MXhfTUJ0TVFiSmFwV0E&#38&semi;font=Bevan&shy;PotanoSans&#38&semi;maptype=toner&#38&semi;lang=en&#38&semi;height=650" rel="nofollow" title="http://embed.verite.co/timeline/?source=0AiKv3gqIhXVbdGM2X3c1OEY1MXhfTUJ0TVFiSmFwV0E&#38&semi;font=Bevan&shy;PotanoSans&#38&semi;maptype=toner&#38&semi;lang=en&#38&semi;height=650">TimeLine</a></li></ul>&#10;<p> </p>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Lisp" id="w">Categoria:Lisp</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_funcionais" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o funcionais</a></p></body></html>