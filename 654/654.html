<html><title>C (linguagem de programa&ccedil;&atilde;o)</title><body>&#10;<p> &#10; &#10;<b>C</b> &eacute; uma <a href="http://en.wikipedia.org/wiki/Linguagem_compilada" id="w">linguagem de programa&ccedil;&atilde;o compilada</a> de prop&oacute;sito geral, <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_estruturada" id="w">estruturada</a>, <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_imperativa" id="w">imperativa</a>, <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_procedural" id="w">procedural</a>, <a href="http://en.wikipedia.org/wiki/Organiza%C3%A7%C3%A3o_Internacional_para_Padroniza%C3%A7%C3%A3o" id="w">padronizada pela ISO</a>, criada em <a href="http://en.wikipedia.org/wiki/1972" id="w">1972</a>, por <a href="http://en.wikipedia.org/wiki/Dennis_Ritchie" id="w">Dennis Ritchie</a>, no <a href="http://en.wikipedia.org/wiki/AT%26amp%3BT" id="w">AT&#38&semi;T</a> <a href="http://en.wikipedia.org/wiki/Bell_Labs" id="w">Bell Labs</a>, para desenvolver o <a href="http://en.wikipedia.org/wiki/Sistema_operativo" id="w">sistema operacional</a> <a href="http://en.wikipedia.org/wiki/Unix" id="w">Unix</a> (que foi originalmente escrito em <a href="http://en.wikipedia.org/wiki/Linguagem_de_montagem" id="w">Assembly</a>).<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup></p>&#10;<p>C &eacute; uma das linguagens de programa&ccedil;&atilde;o mais populares<sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup><sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup> e existem poucas arquiteturas para as quais n&atilde;o existem compiladores para C. C tem influenciado muitas outras linguagens de programa&ccedil;&atilde;o,<sup id="_ref&shy;4" class="reference"><a href="#_note&shy;4" title="">[4]</a></sup> mais notavelmente <a href="http://en.wikipedia.org/wiki/C%2B%2B" id="w">C++</a>, que originalmente come&ccedil;ou como uma extens&atilde;o para C.</p>&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2> Hist&oacute;ria </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Ken_n_dennis.jpg%7C300px%7Cthumb%7C%5B%5BKen_Thompson%5D%5D_e_%5B%5BDennis_Ritchie%5D%5D_(da_esquerda_para_direita)%2C_os_criadores_das_linguagens_%5B%5BB_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">B]] e &#39&semi;&#39&semi;&#39&semi;C&#39&semi;&#39&semi;&#39&semi;, respectivamente.</a>&#10;O desenvolvimento inicial de C ocorreu no AT&#38&semi;T Bell Labs entre <a href="http://en.wikipedia.org/wiki/1969" id="w">1969</a> e <a href="http://en.wikipedia.org/wiki/1973" id="w">1973</a>.<sup id="_ref&shy;dottcl_a" class="reference"><a href="#_note&shy;dottcl" title="">[5]</a></sup> de acordo com Ritchie, o per&iacute;odo mais criativo ocorreu em 1972. A linguagem foi chamada &#34&semi;C&#34&semi;, porque suas caracter&iacute;sticas foram obtidas a partir de uma linguagem anteriormente chamado de &#34&semi;<a href="http://en.wikipedia.org/wiki/B_(linguagem_de_programa%C3%A7%C3%A3o)" id="w"> B</a>&#34&semi;, que de acordo com a <a href="http://en.wikipedia.org/wiki/Ken_Thompson" id="w">Ken Thompson</a> era vers&atilde;o reduzida da linguagem de programa&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/BCPL" id="w">BCPL</a>.<sup id="_ref&shy;6" class="reference"><a href="#_note&shy;6" title="">[6]</a></sup></p>&#10;<p>A vers&atilde;o original PDP&shy;11 do sistema Unix foi desenvolvido em <a href="http://en.wikipedia.org/wiki/Assembly" id="w">assembly</a>.  Em1973, com a adi&ccedil;&atilde;o dos tipos <code>struct</code>, a linguagem C tornou&shy;se poderosa o suficiente para que a maior parte do <i><a href="http://en.wikipedia.org/wiki/Kernel" id="w">kernel</a></i> do <a href="http://en.wikipedia.org/wiki/Unix" id="w">Unix</a> fosse reescrito em C. Este foi um dos primeiros n&uacute;cleos de sistemas operacionais implementadas em uma linguagem diferente da linguagem <i>Assembly</i>. Em 1977, foram feitas novas mudan&ccedil;as por Ritchie e Stephen C. Johnson para facilitar a portabilidade do sistema operacional Unix. O <i>Portable C Compiler</i> de Johnson serviu de base para v&aacute;rias implementa&ccedil;&otilde;es de C em novas plataformas.<sup id="_ref&shy;unixport_a" class="reference"><a href="#_note&shy;unixport" title="">[7]</a></sup></p>&#10;<a id="C_K%26R" name="C_K%26R"></a><h3> C K&#38&semi;R </h3>&#10;<p>A linguagem C n&atilde;o teve sucesso imediato ap&oacute;s sua cria&ccedil;&atilde;o e seu uso ficou restrito a alguns laborat&oacute;rios mas em 1978 Brian Kerningham e Dennis Rithcie lan&ccedil;am o livro <i><a href="http://en.wikipedia.org/wiki/The_C_Programming_Language" id="w">The C Programming Language</a></i>.<sup id="_ref&shy;kernighan_a" class="reference"><a href="#_note&shy;kernighan" title="">[8]</a></sup> que serviu de tutorial e mudou a hist&oacute;ria da programa&ccedil;&atilde;o em C, de fato essa primeira vers&atilde;o da linguagem &eacute; conhecida como &#34&semi;C Kernigham e Ritchie&#34&semi; ou apenas &#34&semi;C K&#38&semi;R&#34&semi;.<sup id="_ref&shy;HICKSON_a" class="reference"><a href="#_note&shy;HICKSON" title="">[9]</a></sup></p>&#10;<p>Esse livro, conhecido pelos programadores de C como &#34&semi;K&#38&semi;R&#34&semi;, serviu durante muitos anos como uma especifica&ccedil;&atilde;o informal da linguagem. A vers&atilde;o da linguagem C que ele descreve &eacute; usualmente referida como &#34&semi;<b>K&#38&semi;R C</b>&#34&semi;. A segunda edi&ccedil;&atilde;o do livro cobriu o padr&atilde;o posterior, o <i>ANSI C</i>. K&#38&semi;R C introduziu as seguintes caracter&iacute;sticas na linguagem:</p>&#10;&#10;<ul>&#10;<li>Biblioteca padr&atilde;o de <a href="http://en.wikipedia.org/wiki/Entrada/sa%C3%ADda" id="w">E/S</a></li>&#10;<li>Tipos de dado <code>struct</code></li>&#10;<li>Tipos de dado <code>long int</code></li>&#10;<li>Tipos de dado <code>unsigned int</code></li>&#10;<li>O operador <code>=+</code> foi alterado para <code>+=</code>, e <code>=&shy;</code> para <code>&shy;=</code> (o <a href="http://en.wikipedia.org/wiki/An%C3%A1lise_l%C3%A9xica" id="w">analisador l&eacute;xico</a> do compilador fazia confus&atilde;o entre <code>i =+ 10</code> e <code>i = +10</code>. O mesmo acontecia com <code>=&shy;</code>)</li></ul>&#10;<p>K&#38&semi;R C &eacute; frequentemente considerado a parte mais b&aacute;sica da linguagem, cujo suporte deve ser assegurado por um <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compilador</a> C. Durante muitos anos, mesmo ap&oacute;s a introdu&ccedil;&atilde;o do padr&atilde;o ANSI C, K&#38&semi;R C foi considerado o &#34&semi;menor denominador comum&#34&semi;, em que programadores de C se apoiavam quando uma <a href="http://en.wikipedia.org/wiki/Portabilidade_(inform%C3%A1tica)" id="w">portabilidade</a> m&aacute;xima era desejada, j&aacute; que nem todos os compiladores eram actualizados o bastante para suportar o padr&atilde;o ANSI C.</p>&#10;<p>Nos anos que se seguiram &agrave; publica&ccedil;&atilde;o do K&#38&semi;R C, algumas caracter&iacute;sticas &#34&semi;n&atilde;o&shy;oficiais&#34&semi; foram adicionadas &agrave; linguagem, suportadas por compiladores da AT&#38&semi;T e de outros vendedores. Estas inclu&iacute;am:</p>&#10;&#10;<ul>&#10;<li>Fun&ccedil;&otilde;es <code>void</code> e tipos de dados <code>void *</code></li>&#10;<li>Fun&ccedil;&otilde;es que retornam tipos <code>struct</code> ou <code>union</code></li>&#10;<li>Campos de nome <code>struct</code> num espa&ccedil;o de nome separado para cada tipo <code>struct</code></li>&#10;<li>Atribui&ccedil;&atilde;o a tipos de dados <code>struct</code></li>&#10;<li>Qualificadores <code>const</code> para criar um objecto s&oacute; de leitura</li>&#10;<li>Biblioteca padr&atilde;o, que incorpora grande parte da funcionalidade implementada por v&aacute;rios vendedores</li>&#10;<li>Enumera&ccedil;&otilde;es</li>&#10;<li>C&aacute;lculos de ponto&shy;flutuante em precis&atilde;o simples (no K&#38&semi;R C, os c&aacute;lculos intermedi&aacute;rios eram feitos sempre em <code>double</code>, porque era mais eficiente na m&aacute;quina onde a primeira implementa&ccedil;&atilde;o do C foi feita)</li></ul>&#10;<p> &#10;</p><a id="ANSI_C_e_ISO_C" name="ANSI_C_e_ISO_C"></a><h3> ANSI C e ISO C </h3>&#10;<p>Durante os finais da <a href="http://en.wikipedia.org/wiki/D%C3%A9cada_de_1970" id="w">d&eacute;cada de 1970</a>, a linguagem C come&ccedil;ou a substituir a linguagem <a href="http://en.wikipedia.org/wiki/BASIC" id="w">BASIC</a> como a linguagem de programa&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Computador_dom%C3%A9stico" id="w">microcomputadores</a> mais usada. Durante a <a href="http://en.wikipedia.org/wiki/D%C3%A9cada_de_1980" id="w">d&eacute;cada de 1980</a>, foi adaptada para uso no PC IBM, e a sua popularidade come&ccedil;ou a aumentar significativamente. Ao mesmo tempo, <a href="http://en.wikipedia.org/wiki/Bjarne_Stroustrup" id="w">Bjarne Stroustrup</a>, juntamente com outros nos laborat&oacute;rios Bell, come&ccedil;ou a trabalhar num projecto onde se adicionavam constru&ccedil;&otilde;es de linguagens de programa&ccedil;&atilde;o orientada por objectos &agrave; linguagem C. A linguagem que eles produziram, chamada <a href="http://en.wikipedia.org/wiki/C%2B%2B" id="w">C++</a>, &eacute; nos dias de hoje a linguagem de programa&ccedil;&atilde;o de aplica&ccedil;&otilde;es mais comum no sistema operativo <a href="http://en.wikipedia.org/wiki/Microsoft_Windows" id="w">Windows</a> da companhia <a href="http://en.wikipedia.org/wiki/Microsoft" id="w">Microsoft</a>&semi; C permanece mais popular no mundo <a href="http://en.wikipedia.org/wiki/Unix" id="w">Unix</a>.</p>&#10;<p>Em <a href="http://en.wikipedia.org/wiki/1983" id="w">1983</a>, o instituto norte&shy;americano de padr&otilde;es (<a href="http://en.wikipedia.org/wiki/American_National_Standards_Institute" id="w">ANSI</a>) formou um comit&eacute;, X3J11, para estabelecer uma especifica&ccedil;&atilde;o do padr&atilde;o da linguagem C. Ap&oacute;s um processo longo e &aacute;rduo, o padr&atilde;o foi completo em <a href="http://en.wikipedia.org/wiki/1989" id="w">1989</a> e ratificado como ANSI X3.159&shy;1989 &#34&semi;Programming Language C&#34&semi;. Esta vers&atilde;o da linguagem &eacute; frequentemente referida como ANSI C. Em <a href="http://en.wikipedia.org/wiki/1990" id="w">1990</a>, o padr&atilde;o ANSI C, ap&oacute;s sofrer umas modifica&ccedil;&otilde;es menores, foi adotado pela <a href="http://en.wikipedia.org/wiki/Organiza%C3%A7%C3%A3o_Internacional_para_Padroniza%C3%A7%C3%A3o" id="w">Organiza&ccedil;&atilde;o Internacional para Padroniza&ccedil;&atilde;o</a> (ISO) como <b>ISO/IEC 9899:1990</b>, tamb&eacute;m conhecido como C89 ou C90. Um dos objetivos do processo de padroniza&ccedil;&atilde;o ANSI C foi o de produzir um sobreconjunto do K&#38&semi;R C, incorporando muitas das caracter&iacute;sticas n&atilde;o&shy;oficiais subsequentemente introduzidas. Entretanto, muitos programas tinham sido escritos e que n&atilde;o compilavam em certas plataformas, ou com um certo compilador, devido ao uso de bibliotecas de fun&ccedil;&otilde;es n&atilde;o&shy;padr&atilde;o e ao fato de alguns compiladores n&atilde;o aderirem ao ANSI C.</p>&#10;<a id="C99" name="C99"></a><h3> C99 </h3>&#10;<p>Ap&oacute;s o processo da padroniza&ccedil;&atilde;o ANSI, as especifica&ccedil;&otilde;es da linguagem C permaneceram relativamente est&aacute;ticas por algum tempo, enquanto a linguagem C++ continuou a evoluir. (em <a href="http://en.wikipedia.org/wiki/1995" id="w">1995</a>, a <i>Normative Amendment 1</i> criou uma vers&atilde;o nova da linguagem C mas esta vers&atilde;o raramente &eacute; tida em conta.) Contudo, o padr&atilde;o foi submetido a uma revis&atilde;o nos finais da <a href="http://en.wikipedia.org/wiki/D%C3%A9cada_de_1990" id="w">d&eacute;cada de 1990</a>, levando &agrave; publica&ccedil;&atilde;o da norma <b>ISO 9899:1999</b> em <a href="http://en.wikipedia.org/wiki/1999" id="w">1999</a>. Este padr&atilde;o &eacute; geralmente referido como &#34&semi;C99&#34&semi;. O padr&atilde;o foi adoptado como um padr&atilde;o ANSI em mar&ccedil;o de <a href="http://en.wikipedia.org/wiki/2000" id="w">2000</a>. As novas caracter&iacute;sticas do C99 incluem:</p>&#10;&#10;<ul>&#10;<li>Fun&ccedil;&otilde;es em linha</li>&#10;<li>Remo&ccedil;&atilde;o de restri&ccedil;&otilde;es sobre a localiza&ccedil;&atilde;o da declara&ccedil;&atilde;o de vari&aacute;veis (como em C++)</li>&#10;<li>Adi&ccedil;&atilde;o de v&aacute;rios tipos de dados novos, incluindo o <code>long long int</code> (para minimizar problemas na transi&ccedil;&atilde;o de 32&shy;bits para 64&shy;bits), um tipo de dado boolean explicito (chamado <i>_Bool</i>) e um tipo <code>complex</code> que representa <a href="http://en.wikipedia.org/wiki/N%C3%BAmero_complexo" id="w">n&uacute;meros complexos</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Array" id="w">Vetores</a> de dados de comprimento vari&aacute;vel (o vetor pode ter um tamanho diferente a cada execu&ccedil;&atilde;o de uma fun&ccedil;&atilde;o, mas n&atilde;o cresce depois de criado)</li>&#10;<li>Suporte oficial para coment&aacute;rios de uma linha iniciados por <code>//</code>, emprestados da linguagem C++</li>&#10;<li>V&aacute;rias fun&ccedil;&otilde;es de biblioteca novas, tais como <code>snprintf()</code></li>&#10;<li>V&aacute;rios ficheiros&shy;cabe&ccedil;alho novos, tais como <code>stdint.h</code></li></ul>&#10;<p>O interesse em suportar as caracter&iacute;sticas novas de C99 parece depender muito das entidades. Apesar do <a href="http://en.wikipedia.org/wiki/GNU_Compiler_Collection" id="w">GCC</a> e v&aacute;rios outros compiladores suportarem grande parte das novas caracter&iacute;sticas do C99, os compiladores mantidos pela Microsoft e pela <a href="http://en.wikipedia.org/wiki/Borland" id="w">Borland</a> suportam pouqu&iacute;ssimos recursos do C99, e estas duas companhias n&atilde;o parecem estar muito interessadas em adicionar tais funcionalidades, ignorando por completo as normas internacionais. A Microsoft parece preferir dar mais &ecirc;nfase ao C++.<sup id="_ref&shy;10" class="reference"><a href="#_note&shy;10" title="">[10]</a></sup></p>&#10;<a id="C11" name="C11"></a><h3> C11 </h3>&#10;<p>Em 2007, se iniciou o trabalho em antecipa&ccedil;&atilde;o de outra revis&atilde;o do padr&atilde;o de C, informalmente chamada de <b>C11</b> ou <b>C1X</b>. O comit&ecirc; dos padr&otilde;es de C adotou regras para limitar a inser&ccedil;&atilde;o de novos recursos que n&atilde;o tenham ainda sido testados por implementa&ccedil;&otilde;es existentes.<sup id="_ref&shy;11" class="reference"><a href="#_note&shy;11" title="">[11]</a></sup></p>&#10;<p>Em dezembro de <a href="http://en.wikipedia.org/wiki/2011" id="w">2011</a> foi publicada a vers&atilde;o est&aacute;vel da especifica&ccedil;&atilde;o, como <b>ISO/IEC 9899:2011</b>.</p>&#10;<a id="Vis%C3%A3o_geral" name="Vis%C3%A3o_geral"></a><h2> Vis&atilde;o geral </h2>&#10;<p>C &eacute; uma linguagem imperativa e procedural, para implementa&ccedil;&atilde;o de sistemas. Seus pontos de design foram para ele ser compilado, fornecendo acesso de <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_baixo_n%C3%ADvel" id="w">baixo n&iacute;vel</a> &agrave; <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_RAM" id="w">mem&oacute;ria</a> e baixos requerimentos do hardware. Tamb&eacute;m foi desenvolvido para ser uma linguagem de alto n&iacute;vel, para maior reaproveitamento do c&oacute;digo. C foi &uacute;til para muitas aplica&ccedil;&otilde;es que foram codificadas originalmente em <a href="http://en.wikipedia.org/wiki/Linguagem_de_montagem" id="w">Assembly</a>.</p>&#10;<p>Essa propriedade n&atilde;o foi acidental&semi; a linguagem C foi criada com o objectivo principal em mente: facilitar a cria&ccedil;&atilde;o de programas extensos com menos erros, recorrendo ao <a href="http://en.wikipedia.org/wiki/Paradigma" id="w">paradigma</a> da <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_procedural" id="w">programa&ccedil;&atilde;o procedural</a>, mas sobrecarregando menos o autor do <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compilador</a>, cujo trabalho complica&shy;se ao ter de realizar as caracter&iacute;sticas complexas da linguagem. Para este fim, a linguagem C possui as seguintes caracter&iacute;sticas:</p>&#10;&#10;<ul>&#10;<li>Uma linguagem extremamente simples, com funcionalidades n&atilde;o&shy;essenciais, tais como fun&ccedil;&otilde;es matem&aacute;ticas ou manuseamento de ficheiros (arquivos), fornecida por um conjunto de <a href="http://en.wikipedia.org/wiki/Biblioteca_(computa%C3%A7%C3%A3o)" id="w">bibliotecas de rotinas</a> padronizada</li>&#10;<li>A focaliza&ccedil;&atilde;o no paradigma de <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_procedural" id="w">programa&ccedil;&atilde;o procedural</a></li>&#10;<li>Um <a href="http://en.wikipedia.org/wiki/Tipo_de_dado" id="w">sistema de tipos</a> simples que evita v&aacute;rias opera&ccedil;&otilde;es que n&atilde;o fazem sentido</li>&#10;<li>Uso de uma linguagem de <a href="http://en.wikipedia.org/wiki/Pr%C3%A9&shy;processador" id="w">pr&eacute;&shy;processamento</a>, o <b>pr&eacute;&shy;processador de C</b>, para tarefas tais como a defini&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Macro" id="w">macros</a> e a inclus&atilde;o de m&uacute;ltiplos ficheiros de <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_fonte" id="w">c&oacute;digo fonte</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Ponteiro_(programa%C3%A7%C3%A3o)" id="w">Ponteiros</a> d&atilde;o maior flexibilidade &agrave; linguagem</li>&#10;<li>Acesso de baixo&shy;n&iacute;vel, atrav&eacute;s de inclus&otilde;es de c&oacute;digo Assembly no meio do programa C</li>&#10;<li>Par&acirc;metros que s&atilde;o sempre passados por valor para as fun&ccedil;&otilde;es e nunca por refer&ecirc;ncia (&Eacute; poss&iacute;vel simular a passagem por refer&ecirc;ncia com o uso de ponteiros)</li>&#10;<li>Defini&ccedil;&atilde;o do alcance lexical de vari&aacute;veis</li>&#10;<li>Estruturas de vari&aacute;veis, (structs), que permitem que dados relacionados sejam combinados e manipulados como um todo</li></ul>&#10;<p>Algumas caracter&iacute;sticas &uacute;teis, que faltam em C, podem ser encontradas em outras linguagens, que incluem:</p>&#10;&#10;<ul>&#10;<li>Seguran&ccedil;a de tipo</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Coletor_de_lixo" id="w">Coletor de lixo</a> (mais comum em <a href="http://en.wikipedia.org/wiki/Linguagem_interpretada" id="w">linguagens interpretadas</a>)</li>&#10;<li>Vetores que crescem automaticamete</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Classe_(programa%C3%A7%C3%A3o)" id="w">Classes</a> ou <a href="http://en.wikipedia.org/wiki/Objeto" id="w">objetos</a> com comportamento <i>(ver <a href="http://en.wikipedia.org/wiki/Orienta%C3%A7%C3%A3o_a_objetos" id="w">Orienta&ccedil;&atilde;o a objetos</a>)</i></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Clausura_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">Clausuras</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Composi%C3%A7%C3%A3o_de_fun%C3%A7%C3%B5es" id="w">fun&ccedil;&otilde;es aninhadas</a></li>&#10;<li>Sobrecarga de operadores</li>&#10;<li>Meta&shy;programa&ccedil;&atilde;o</li>&#10;<li>Apoio nativo de <i>multithreading</i> e comunica&ccedil;&atilde;o por rede</li></ul>&#10;<p>Apesar da lista de caracter&iacute;sticas &uacute;teis que C possui n&atilde;o ser longa, isso n&atilde;o tem sido um impedimento &agrave; sua aceita&ccedil;&atilde;o, pois isso permite que novos compiladores de C sejam escritos rapidamente para novas plataformas, e tamb&eacute;m permite que o programador permane&ccedil;a sempre em controle do que o programa est&aacute; a fazer. Isto &eacute; o que por v&aacute;rias vezes permite o c&oacute;digo de C correr de uma forma mais eficiente que muitas outras linguagens. Tipicamente, s&oacute; c&oacute;digo de Assembly &#34&semi;afinado &agrave; m&atilde;o&#34&semi; &eacute; que corre mais rapidamente, pois possui um controle completo da m&aacute;quina, mas avan&ccedil;os na &aacute;rea de compiladores juntamente com uma nova complexidade nos processadores modernos permitiram que a diferen&ccedil;a tenha sido rapidamente eliminada.&#10;Uma consequ&ecirc;ncia da aceita&ccedil;&atilde;o geral da linguagem C &eacute; que frequentemente os compiladores, bibliotecas e at&eacute; int&eacute;rpretes de outras linguagens de n&iacute;vel maior sejam eles pr&oacute;prios implementados em C.</p>&#10;<p>C tem como ponto forte, a sua efici&ecirc;ncia, e &eacute; a linguagem de programa&ccedil;&atilde;o preferida para o desenvolvimento de sistemas e softwares de base, apesar de tamb&eacute;m ser usada para desenvolver <a href="http://en.wikipedia.org/wiki/Programa_de_computador" id="w">programas de computador</a>. &Eacute; tamb&eacute;m muito usada no ensino de <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">ci&ecirc;ncia da computa&ccedil;&atilde;o</a>, mesmo n&atilde;o tendo sido projetada para estudantes e apresentando algumas dificuldades no seu uso. Outra caracter&iacute;stica importante de C, &eacute; sua proximidade do <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_de_m%C3%A1quina" id="w">c&oacute;digo de m&aacute;quina</a>, que permite que um projetista seja capaz de fazer algumas previs&otilde;es de como o software ir&aacute; se comportar, ao ser executado.</p>&#10;<p>C tem como ponto fraco, a falta de prote&ccedil;&atilde;o que d&aacute; ao programador. Praticamente tudo que se expressa em um programa em C, pode ser executado, como por exemplo, pedir o vig&eacute;simo membro de um vetor com apenas dez membros. Os resultados s&atilde;o muitas vezes totalmente inesperados, e os erros, dif&iacute;ceis de encontrar.</p>&#10;<a id="Tipos_de_dados" name="Tipos_de_dados"></a><h3> Tipos de dados </h3>&#10;<p>C tem um sistema de tipos semelhante ao de alguns descendentes da linguagem <a href="http://en.wikipedia.org/wiki/ALGOL" id="w">ALGOL</a>, tais como <a href="http://en.wikipedia.org/wiki/Pascal_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Pascal</a>. Possui tipos para n&uacute;meros inteiros de v&aacute;rios tamanhos com e sem sinal, <a href="http://en.wikipedia.org/wiki/Ponto_flutuante" id="w">n&uacute;meros de ponto flutuante</a>, caracteres e estruturas (<code>struct</code>s).&#10;C usa extensivamente <a href="http://en.wikipedia.org/wiki/Ponteiro_(programa%C3%A7%C3%A3o)" id="w">ponteiros</a>, um tipo muito simples de <b>refer&ecirc;ncia</b> que guarda o endere&ccedil;o de mem&oacute;ria da vari&aacute;vel. O ponteiro pode ser <i>desreferenciado</i>, uma opera&ccedil;&atilde;o que busca o objecto que se encontra na morada da mem&oacute;ria que o ponteiro possui, morada essa que pode ser manipulada atrav&eacute;s de <a href="http://en.wikipedia.org/wiki/Ponteiro_(programa%C3%A7%C3%A3o)" id="w">aritm&eacute;tica de ponteiros</a>. Durante o <a href="http://en.wikipedia.org/wiki/Tempo_de_execu%C3%A7%C3%A3o" id="w">tempo de execu&ccedil;&atilde;o</a>, o ponteiro &eacute; simplesmente uma morada de m&aacute;quina tais como aquelas manipuladas em <i>Assembly</i>, mas em <a href="http://en.wikipedia.org/wiki/Tempo_de_compila%C3%A7%C3%A3o" id="w">tempo de compila&ccedil;&atilde;o</a> possui um tipo complexo que indica o tipo do objecto para onde ele aponta, permitindo que se verifique o tipo de express&otilde;es, incluindo ponteiros. Os ponteiros s&atilde;o usados extensivamente em C. O tipo linha de texto de C &eacute; simplesmente um ponteiro para um vetor de caracteres e aloca&ccedil;&atilde;o din&acirc;mica de mem&oacute;ria, descrita abaixo, &eacute; efectuada atrav&eacute;s de ponteiros.</p>&#10;<p>Os ponteiros em C possuem um valor reservado especial, <code>NULL</code>, que indica que n&atilde;o est&atilde;o a apontar para uma morada. O uso desse valor como morada &eacute; muito &uacute;til na constru&ccedil;&atilde;o de v&aacute;rias estruturas de dados, mas causa comportamento n&atilde;o&shy;definido (possivelmente uma falha de sistema) ao ser desreferenciado. Um ponteiro que possui o valor <code>NULL</code> &eacute; chamado <i>ponteiro nulo</i>. Os ponteiros s&atilde;o declarados (e desreferenciados) com um <b>*</b> (asterisco), portanto o tipo <i>int*</i> denota um ponteiro para n&uacute;mero(s) inteiro(s). A linguagem C tamb&eacute;m fornece um tipo especial de ponteiros, o <i>void*</i>, que se traduz num ponteiro que aponta para um objecto de tipo desconhecido.</p>&#10;<p>A linguagem C tamb&eacute;m tem apoio a n&iacute;vel de linguagem para vetores est&aacute;ticas (de dimens&atilde;o fixa) de tipos. As disposi&ccedil;&otilde;es de tipos podem parecer ter mais que uma dimens&atilde;o apesar de serem tecnicamente disposi&ccedil;&otilde;es de disposi&ccedil;&otilde;es de tipos. Em mem&oacute;ria, tais estruturas s&atilde;o posicionadas com as linhas uma depois da outra (a alternativa seria armazenar os dados em colunas, usado em outras linguagens). O acesso a disposi&ccedil;&otilde;es de tipos &eacute; feito atrav&eacute;s de ponteiros e aritm&eacute;tica de ponteiros&semi; o nome da disposi&ccedil;&atilde;o &eacute; tratado como se fosse um ponteiro que aponta para o in&iacute;cio da disposi&ccedil;&atilde;o. Em certas aplica&ccedil;&otilde;es n&atilde;o &eacute; razo&aacute;vel usarem&shy;se disposi&ccedil;&otilde;es de tipos de dimens&atilde;o fixa e por isso a aloca&ccedil;&atilde;o din&acirc;mica de mem&oacute;ria pode ser usada para criar disposi&ccedil;&otilde;es de tipos de dimens&atilde;o vari&aacute;vel.</p>&#10;<p>Como a linguagem C &eacute; regularmente usada em programa&ccedil;&atilde;o de baixo&shy;n&iacute;vel de sistemas, h&aacute; casos em que &eacute; necess&aacute;rio tratar um n&uacute;mero inteiro como sendo um ponteiro, um n&uacute;mero de ponto flutuante como sendo um n&uacute;mero inteiro ou um tipo de ponteiro como sendo outro. Para estes casos, a linguagem C fornece a capacidade de &#34&semi;moldagem&#34&semi; (tamb&eacute;m denominado &#34&semi;convers&atilde;o de tipo&#34&semi; ou casting), uma opera&ccedil;&atilde;o que, caso seja poss&iacute;vel, for&ccedil;a a convers&atilde;o de um objecto de um tipo para outro. Apesar de ser por vezes necess&aacute;rio, o uso de convers&otilde;es de tipo sacrifica alguma seguran&ccedil;a oferecida pelo sistema de tipos.</p>&#10;<dl><dt>int</dt></dl>&#10;<p>O tipo de dado <b>int</b> (inteiro) serve para armazenar valores num&eacute;ricos inteiros. Existem v&aacute;rios tipos de inteiros, cada um de um tamanho diferente (dependendo do sistema operacional e/ou arquitetura do processador):</p>&#10;&#10;<ul>&#10;<li><code>int</code>, pode possuir <a href="http://en.wikipedia.org/wiki/16_bit" id="w">16 bits</a>, <a href="http://en.wikipedia.org/wiki/32_bit" id="w">32 bits</a> ou <a href="http://en.wikipedia.org/wiki/64_bit" id="w">64 bit</a>s</li>&#10;<li><code>short int</code>, deve possuir tamanho de no m&iacute;nimo 16 bits e n&atilde;o pode ser maior que <code>int</code></li>&#10;<li><code>long int</code>, deve possuir tamanho m&iacute;nimo de <a href="http://en.wikipedia.org/wiki/32_bit" id="w">32 bit</a>s</li>&#10;<li><code>long long int<code>, deve possuir tamanho m&iacute;nimo de <a href="http://en.wikipedia.org/wiki/64_bit" id="w">64 bit</a>s</code></code></li></ul>&#10;<p>Todos estes tipos de inteiros podem ainda ser declarados precedidos da cl&aacute;usula <i>unsigned</i>, o que faz com que s&oacute; suporte n&uacute;meros positivos. Isto faz com que, com o mesmo tamanho, uma vari&aacute;vel suporte mais n&uacute;meros positivos do que um <i>signed</i> (todos os inteiros s&atilde;o signed por omiss&atilde;o).</p>&#10;<dl><dt>char</dt></dl>&#10;<p>O tipo <b>char</b> ocupa 1 <a href="http://en.wikipedia.org/wiki/Byte" id="w">byte</a>, e serve para armazenar <a href="http://en.wikipedia.org/wiki/Caractere" id="w">caracteres</a> ou <a href="http://en.wikipedia.org/wiki/N%C3%BAmero_inteiro" id="w">inteiros</a>. Isso significa que o programa reserva um espa&ccedil;o de 8 bits na <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_RAM" id="w">mem&oacute;ria RAM</a> ou em <a href="http://en.wikipedia.org/wiki/Registrador" id="w">registradores</a> do processador para armazenar um valor (<b>char</b> de tamanho maior que 8 bits &eacute; permitido pela linguagem, mas os casos s&atilde;o raros). Com vetores do tipo char &eacute; poss&iacute;vel criar <a href="http://en.wikipedia.org/wiki/Cadeia_de_caracteres" id="w">cadeias de caracteres</a> (strings).</p>&#10;<dl><dt>float</dt></dl>&#10;<p>O tipo de dado <b>float</b> serve para armazenar n&uacute;meros de <a href="http://en.wikipedia.org/wiki/Ponto_flutuante" id="w">ponto flutuante</a>, ou seja, com casas decimais. O padr&atilde;o mais utilizado nos &uacute;ltimos 10 anos &eacute; o <a href="http://en.wikipedia.org/wiki/IEEE_754&shy;1985" id="w">IEEE 754&shy;1985</a>.</p>&#10;<dl><dt>double</dt></dl>&#10;<p>O tipo de dado <b>double</b> serve para armazenar n&uacute;meros de ponto flutuante de dupla precis&atilde;o, normalmente tem o dobro do tamanho do float e portanto o dobro da capacidade. O padr&atilde;o mais adotado tamb&eacute;m &eacute; o <a href="http://en.wikipedia.org/wiki/IEEE_754&shy;1985" id="w">IEEE 754&shy;1985</a>.</p>&#10;<dl><dt>struct</dt></dl>&#10;<p>Em C podem ser usadas estruturas (chamados de registos em outras linguagens de programa&ccedil;&atilde;o). As estruturas s&atilde;o grupos de vari&aacute;veis organizadas arbitr&aacute;riamente pelo programador. Uma estrutura pode criar um novo tipo de vari&aacute;vel caso <a href="http://en.wikipedia.org/wiki/Typedef" id="w">typedef</a> seja usado em sua declara&ccedil;&atilde;o.</p>&#10;<a id="Rela%C3%A7%C3%B5es_com_C%2B%2B" name="Rela%C3%A7%C3%B5es_com_C%2B%2B"></a><h2> Rela&ccedil;&otilde;es com C++ </h2>&#10;<p>A linguagem de programa&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/C%2B%2B" id="w">C++</a> foi originalmente derivada do C para suportar programa&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/Orienta%C3%A7%C3%A3o_a_objetos" id="w">orientada a objetos</a>. &Agrave; medida que as linguagens C e C++ foram evoluindo independentemente, a divis&atilde;o entre as duas veio a aumentar.&#10;O padr&atilde;o C99 criou um n&uacute;mero de caracter&iacute;sticas que entram em conflito. Hoje, as principais diferen&ccedil;as entre as duas linguagens s&atilde;o:</p>&#10;&#10;<ul>&#10;<li><b><code>inline</code></b> &shy; em C++, fun&ccedil;&otilde;es em linha encontram&shy;se no espa&ccedil;o global enquanto que em C encontram&shy;se no espa&ccedil;o local. Por outras palavras, isso significa que, em C++, qualquer defini&ccedil;&atilde;o de qualquer fun&ccedil;&atilde;o em linha (sem ser a respeito da sobrecarga de fun&ccedil;&otilde;es de C++) tem de estar em conformidade com a &#34&semi;regra de uma defini&ccedil;&atilde;o&#34&semi; da linguagem C++. Mas em C, a mesma fun&ccedil;&atilde;o em linha pode ser definida de maneira diferente em diferentes arquivos (ou ficheiros)</li>&#10;<li>A palavra&shy;chave <b><code>bool</code></b>, igual &agrave; usada em C++, em C99 necessita que se inclua o ficheiro&shy;cabe&ccedil;alho <code>&#60&semi;stdbool.h&#62&semi;</code> (_Bool est&aacute; sempre dispon&iacute;vel). Padr&otilde;es anteriores de C n&atilde;o definiam um tipo booleano e v&aacute;rios (e incompat&iacute;veis) m&eacute;todos foram usados para simular um tipo booleano</li></ul>&#10;<p>Algumas caracter&iacute;sticas originalmente desenvolvidas em C++ tamb&eacute;m apareceram em C. Entre elas encontram&shy;se:</p>&#10;&#10;<ul>&#10;<li>prot&oacute;tipos de fun&ccedil;&atilde;o (com declara&ccedil;&atilde;o de tipos de par&acirc;metros) e remo&ccedil;&atilde;o do &#34&semi;int&#34&semi; impl&iacute;cito</li>&#10;<li>coment&aacute;rios de linha, indicados por <code>//</code>&semi; coment&aacute;rios de linha terminam com um car&aacute;cter de nova&shy;linha</li>&#10;<li>a palavra&shy;chave <b><code>inline</code></b></li>&#10;<li>tipagem mais forte</li></ul>&#10;<a id="Exemplos" name="Exemplos"></a><h2> Exemplos </h2>&#10;<a id="Programa_Ol%C3%A1_Mundo" name="Programa_Ol%C3%A1_Mundo"></a><h3> Programa Ol&aacute; Mundo </h3>&#10;<p> &#10;A seguinte aplica&ccedil;&atilde;o foi publicada na primeira edi&ccedil;&atilde;o de C de K&#38&semi;R, e tornou&shy;se no programa de introdu&ccedil;&atilde;o padr&atilde;o da maior parte dos livros sobre C. O programa envia o texto &#34&semi;<a href="http://en.wikipedia.org/wiki/Programa_Ol%C3%A1_Mundo" id="w">Ol&aacute;, Mundo!</a>&#34&semi; para a <a href="http://en.wikipedia.org/wiki/Fluxos_padr%C3%A3o#Sa&iacute;da padr&atilde;o (stdout)" id="w">sa&iacute;da padr&atilde;o</a>, que &eacute; normalmente o <a href="http://en.wikipedia.org/wiki/Console_de_comandos" id="w">console</a>, mas que tamb&eacute;m pode ser um ficheiro (ou arquivo), um outro dispositivo qualquer, ou at&eacute; mesmo um <i><a href="http://en.wikipedia.org/wiki/Bit_bucket" id="w">bit bucket</a></i>, dependendo de como a sa&iacute;da&shy;padr&atilde;o &eacute; mapeada na altura em que o programa &eacute; executado.</p>&#10;<p />&#10;&#10;<p>Apesar do programa acima correr corretamente, atualmente origina algumas mensagens de aviso quando compilado como C ANSI. Essas mensagens podem ser eliminadas efectuando umas pequenas altera&ccedil;&otilde;es no programa original:</p>&#10;<p />&#10;&#10;<p>A primeira linha do programa &eacute; uma <a href="http://en.wikipedia.org/wiki/Pr%C3%A9&shy;processador" id="w">diretiva de pr&eacute;&shy;processamento</a> <code>#include</code>, que causa com que o <a href="http://en.wikipedia.org/wiki/Pr%C3%A9&shy;processador" id="w">pr&eacute;&shy;processador</a> substitua aquela linha pela totalidade do conte&uacute;do do arquivo qual diretiva se refere. Neste caso o arquivo padr&atilde;o <code>stdio.h</code> (que cont&eacute;m prot&oacute;tipos de fun&ccedil;&otilde;es para trabalho com entrada e sa&iacute;da) ir&aacute; substituir a linha. Os caracteres <code>&#60&semi;</code> e <code>&#62&semi;</code> indicam que o arquivo stdio.h encontra&shy;se no local em que, quando da configura&ccedil;&atilde;o do compilador, se definiu como padr&atilde;o para localiza&ccedil;&atilde;o dos ficheiros de inclus&atilde;o (<i>header files</i>, geralmente com a extens&atilde;o <i>.h</i>).</p>&#10;<p>A linha (n&atilde;o&shy;vazia) seguinte indica que uma fun&ccedil;&atilde;o denominada <i>main</i> ser&aacute; definida. A fun&ccedil;&atilde;o <i>main</i> tem um significado especial nos programas em C, pois &eacute; a fun&ccedil;&atilde;o que &eacute; inicialmente executada (em ingl&ecirc;s, <i><a href="http://en.wikipedia.org/wiki/Entry_point" id="w">entry point</a></i>). Os caracteres <code>{</code> e <code>}</code> delimitam a extens&atilde;o da fun&ccedil;&atilde;o. O termo <code>int</code> define a fun&ccedil;&atilde;o <i>main</i> como sendo uma fun&ccedil;&atilde;o que retorna um n&uacute;mero inteiro. O termo <code>void</code> indica que a fun&ccedil;&atilde;o n&atilde;o aceita par&acirc;metros. A fun&ccedil;&atilde;o <i>main</i>, normalmente aceita par&acirc;metros, que s&atilde;o passado pela <a href="http://en.wikipedia.org/wiki/Interpretador_de_comandos" id="w">linha de comando</a>. Os compiladores e sistemas operacionais atuais reconhecem as seguintes declara&ccedil;&otilde;es de main:</p>&#10;<p />&#10;&#10;<p>A linha seguinte &#34&semi;chama&#34&semi;, ou executa uma fun&ccedil;&atilde;o chamada <code>puts</code>&semi; o arquivo inclu&iacute;do, <code>stdio.h</code>, cont&eacute;m a informa&ccedil;&atilde;o que descreve a forma como a fun&ccedil;&atilde;o <code>puts</code> deve ser chamada. Nesta chamada, &eacute; passado &agrave; fun&ccedil;&atilde;o <code>printf</code> um &uacute;nico argumento, a linha de texto constante &#34&semi;Ol&aacute;, Mundo!&#34&semi;. A fun&ccedil;&atilde;o <code>puts</code> retorna um valor, um <code>int</code>, mas como n&atilde;o &eacute; usado, &eacute; descartado pelo compilador. O comando <code>return</code> retorna o valor 0 para o sistema, que &eacute; interpretado pelo mesmo como que a fun&ccedil;&atilde;o main() foi executada e encerrada com sucesso (sem erros). Por fim, o caracter <code>}</code> indica o fim da fun&ccedil;&atilde;o <code>main</code>. Note&shy;se que texto rodeado por <code>/*</code> e <code>*/</code> (coment&aacute;rios de texto) &eacute; ignorado pelo compilador. Os compiladores que obedecem &agrave; norma C99 tamb&eacute;m aceitam como coment&aacute;rios as linhas de texto que s&atilde;o precedidos por <code>//</code>.</p>&#10;<a id="Matem%C3%A1tica" name="Matem%C3%A1tica"></a><h3> Matem&aacute;tica </h3>&#10;<p>O seguinte c&oacute;digo realiza seis <a href="http://en.wikipedia.org/wiki/Opera%C3%A7%C3%A3o_(matem%C3%A1tica)" id="w">opera&ccedil;&otilde;es matem&aacute;ticas</a>, <a href="http://en.wikipedia.org/wiki/Adi%C3%A7%C3%A3o" id="w">adi&ccedil;&atilde;o</a>, <a href="http://en.wikipedia.org/wiki/Subtra%C3%A7%C3%A3o" id="w">subtra&ccedil;&atilde;o</a>, <a href="http://en.wikipedia.org/wiki/Multiplica%C3%A7%C3%A3o" id="w">multiplica&ccedil;&atilde;o</a>, <a href="http://en.wikipedia.org/wiki/Divis%C3%A3o" id="w">divis&atilde;o</a>, <a href="http://en.wikipedia.org/wiki/Exponencia%C3%A7%C3%A3o" id="w">exponencia&ccedil;&atilde;o</a> e <a href="http://en.wikipedia.org/wiki/Radicia%C3%A7%C3%A3o" id="w">radicia&ccedil;&atilde;o</a>, e em seguida envia os seus respectivos resultados para a sa&iacute;da padr&atilde;o (normalmente o console).</p>&#10;<p />&#10;&#10;<a id="Estruturas_de_dados" name="Estruturas_de_dados"></a><h3> Estruturas de dados </h3>&#10;<p>No exemplo seguinte, &eacute; criada uma estrutura composta por 3 elementos de tipos diferentes. Ap&oacute;s ser declarada uma vari&aacute;vel &#34&semi;x&#34&semi; do tipo struct &#34&semi;y&#34&semi;, onde &#34&semi;y&#34&semi; &eacute; o nome da estrutura, para se acessar os elementos usa&shy;se a seguinte sintaxe: <code>x.elemento</code>.</p>&#10;<p />&#10;&#10;<p>Ou, equivalente:</p>&#10;<p />&#10;&#10;<a id="Baixo&shy;n%C3%ADvel" name="Baixo&shy;n%C3%ADvel"></a><h2> Baixo&shy;n&iacute;vel </h2>&#10;<p>O exemplo que se segue apresenta c&oacute;digo C de baixo&shy;n&iacute;vel, as fun&ccedil;&otilde;es read e write. Neste programa vamos ler de N para buf, blocos de bufsize neste caso 1024, para O. Quando n for igual a 0, &eacute; porque a leitura acabou, sai do ciclo while e libera a mem&oacute;ria ocupada por buf.</p>&#10;<p />&#10;&#10;<a id="Ferramentas_de_programa%C3%A7%C3%A3o" name="Ferramentas_de_programa%C3%A7%C3%A3o"></a><h2> Ferramentas de programa&ccedil;&atilde;o </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Dev&shy;C%2B%2B" id="w">Bloodshed Dev&shy;C++</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Ambiente_de_desenvolvimento_integrado" id="w">IDE (Ambiente de desenvolvimento integrado)</a>, como <a href="http://en.wikipedia.org/wiki/Code::Blocks" id="w">Code::Blocks</a> e <a href="http://en.wikipedia.org/wiki/NetBeans" id="w">NetBeans</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/GNU_Compiler_Collection" id="w">GNU Compiler Collection</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Automa%C3%A7%C3%A3o_de_compila%C3%A7%C3%A3o" id="w">Automa&ccedil;&atilde;o de compila&ccedil;&atilde;o</a>, como <a href="http://en.wikipedia.org/wiki/Make" id="w">make</a></li></ul>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;<p> &#10;</p>&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/C%2B%2B" id="w">C++</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagem_compilada" id="w">Linguagem compilada</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">Linguagem de programa&ccedil;&atilde;o</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_alto_n%C3%ADvel" id="w">Linguagem de programa&ccedil;&atilde;o de alto n&iacute;vel</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Anexo:Lista_de_linguagens_de_programa%C3%A7%C3%A3o" id="w">Lista de linguagens de programa&ccedil;&atilde;o</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Unix" id="w">Unix</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Compilador" id="w">Compilador</a></li></ul>&#10;<p> </p>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li> </li>&#10;<li> </li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Linguagem_de_programa%C3%A7%C3%A3o_C" id="w"> </a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_procedurais" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o procedurais</a></p></body></html>