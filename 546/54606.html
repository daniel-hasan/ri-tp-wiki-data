<html><title>Casamento de padr&otilde;es</title><body>&#10;<p>Em <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">ci&ecirc;ncia da computa&ccedil;&atilde;o</a>, <b>casamento de padr&otilde;es</b> &eacute; o ato de verifica&ccedil;&atilde;o da presen&ccedil;a de um padr&atilde;o em um conjunto de dados. Em contraste ao <a href="http://en.wikipedia.org/wiki/Reconhecimento_de_padr%C3%B5es" id="w">reconhecimento de padr&otilde;es</a>, o padr&atilde;o &eacute; rigidamente especificado, seja por uma <a href="http://en.wikipedia.org/wiki/Cadeia_de_caracteres" id="w">cadeia de caracteres</a> ou uma <a href="http://en.wikipedia.org/wiki/&Aacute;rvore_(estrutura_de_dados)" id="w">&aacute;rvore</a>. O casamento de padr&otilde;es &eacute; usado para testar se o objeto de estudo possui a estrutura desejada, para ent&atilde;o encontrar a estrutura relevante, encontrar os pontos de alinhamento e substituir a parte do casamento por outra estrutura. Padr&otilde;es de sequ&ecirc;ncia (como cadeias de texto) s&atilde;o geralmente escritos usando <a href="http://en.wikipedia.org/wiki/Express%C3%A3o_regular" id="w">express&otilde;es regulares</a>.</p>&#10;<p>Padr&otilde;es de &aacute;rvores podem ser usados em <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagens de programa&ccedil;&atilde;o</a> como uma ferramenta geral para processar dados baseado em sua estrutura. Algumas <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_funcional" id="w">linguagens de programa&ccedil;&atilde;o funcionais</a> como <a href="http://en.wikipedia.org/wiki/Haskell_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Haskell</a>, <a href="http://en.wikipedia.org/wiki/ML_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">ML</a> e <a href="http://en.wikipedia.org/wiki/Mathematica" id="w">Mathematica</a> possuem uma sintaxe especial para expressar padr&otilde;es de &aacute;rvore e uma constru&ccedil;&atilde;o na linguagem para execu&ccedil;&atilde;o condicional. Por quest&otilde;es de simplicidade e efici&ecirc;ncia, tais padr&otilde;es de &aacute;rvore carecem algumas das funcionalidades dispon&iacute;veis em express&otilde;es regulares.</p>&#10;<a id="Padr%C3%B5es_primitivos" name="Padr%C3%B5es_primitivos"></a><h2> Padr&otilde;es primitivos </h2>&#10;&#10;<p>O padr&atilde;o mais simples em um casamento de padr&otilde;es &eacute; um valor expl&iacute;cito (literal) ou uma <a href="http://en.wikipedia.org/wiki/Vari%C3%A1vel_(programa%C3%A7%C3%A3o)" id="w">vari&aacute;vel</a>. Por exemplo, considerando uma simples defini&ccedil;&atilde;o de fun&ccedil;&atilde;o em Haskell:</p>&#10;<pre>f 0 = 1&#10;</pre>&#10;<p>Aqui, o par&acirc;metro <code>0</code> da fun&ccedil;&atilde;o <code>f</code> &eacute; um padr&atilde;o literal. Sempre que a fun&ccedil;&atilde;o for invocada com o valor <code>0</code> como argumento, o retorno ser&aacute; <code>1</code>. com qualquer outro valor, o casamento (e a fun&ccedil;&atilde;o) ir&aacute; falhar. Pode&shy;se continuar a defini&ccedil;&atilde;o estendendo para argumentos mais gen&eacute;ricos:</p>&#10;<pre>f n = n * f (n&shy;1)&#10;</pre>&#10;<p>Aqui, o argumento <code>n</code> &eacute; um padr&atilde;o de vari&aacute;vel, que ir&aacute; casar com qualquer argumento na invoca&ccedil;&atilde;o da fun&ccedil;&atilde;o, assumindo uma refer&ecirc;ncia do valor. O padr&atilde;o especial <code>_</code> tamb&eacute;m &eacute; usado para casar padr&otilde;es, mas ele n&atilde;o assume a refer&ecirc;ncia do valor, simplesmente ignora.</p>&#10;<a id="Padr%C3%B5es_de_%C3%A1rvore" name="Padr%C3%B5es_de_%C3%A1rvore"></a><h2> Padr&otilde;es de &aacute;rvore </h2>&#10;&#10;<p>Padr&otilde;es mais complexos podem ser constru&iacute;dos a partir de primitivos, geralmente da mesma forma que os valores s&atilde;o constru&iacute;dos ao combinar outros valores. A diferen&ccedil;a &eacute; que o padr&atilde;o n&atilde;o &eacute; constru&iacute;do em um &uacute;nico valor, mas sim um grupo de valores. Um padr&atilde;o de &aacute;rvore descreve uma parte de uma &aacute;rvore ao come&ccedil;ar com um n&oacute; e especificando alguns galhos. Em Haskell, a seguinte linha define um <a href="http://en.wikipedia.org/wiki/Tipo_de_dado" id="w">tipo de dado</a> alg&eacute;brico <code>Color</code> que possui um construtor <code>ColorConstructor</code> que associa um inteiro e uma cadeia de caracteres.</p>&#10;<pre> data Color = ColorConstructor Integer String&#10;</pre>&#10;<p>O construtor &eacute; um n&oacute; em uma &aacute;rvore, o inteiro e a cadeia de caracteres s&atilde;o folhas em galhos. Quando quer&shy;se escrever fun&ccedil;&otilde;es para fazer de <code>Color</code> um tipo de dado abstrato, quer&shy;se escrever fun&ccedil;&otilde;es para criar uma <a href="http://en.wikipedia.org/wiki/Interface" id="w">interface</a> com o tipo de dado, para extrair alguma informa&ccedil;&atilde;o do tipo de dado&semi; no caso, ou o valor inteiro ou a cadeia de caracteres. Logo, para uma fun&ccedil;&atilde;o retornar o valor inteiro de <code>Color</code>, o seguinte padr&atilde;o de &aacute;rvore &eacute; aplicado:</p>&#10;<pre>integerPart (ColorConstructor theInteger _) = theInteger&#10;</pre>&#10;<p>Ou para a cadeia de caracteres:</p>&#10;<pre>stringPart (ColorConstructor _ theString) = theString&#10;&#10;</pre><a id="Relacionamento_com_cadeias_de_caracteres" name="Relacionamento_com_cadeias_de_caracteres"></a><h2> Relacionamento com cadeias de caracteres </h2>&#10;&#10;<p>O uso mais comum de casamento de padr&otilde;es envolve cadeias de caracteres. Em v&aacute;rias linguagens de programa&ccedil;&atilde;o, uma sintaxe particular de cadeias de caracteres &eacute; usada pra representar <a href="http://en.wikipedia.org/wiki/Express%C3%B5es_regulares" id="w">express&otilde;es regulares</a>, que s&atilde;o padr&otilde;es para descrever cadeias de caracteres.</p>&#10;<p>Em linguagens funcionais de modo geral, cadeias de caracteres s&atilde;o representadas como <a href="http://en.wikipedia.org/wiki/Lista" id="w">listas</a> de caracteres. De forma funcional, elas s&atilde;o definidas como uma lista vazia, ou um elemento anexado a uma lista existente. Em Haskell:</p>&#10;<pre>[]      &shy;&shy; uma lista vazia&#10;x:xs    &shy;&shy; um elemento x anexado em uma lista xs&#10;</pre>&#10;<p>A estrutura de uma lista &eacute; ent&atilde;o <code>elemento:resto_da_lista</code>. No casamento de padr&otilde;es &eacute; assegurado que certo peda&ccedil;o de dado &eacute; igual a certo padr&atilde;o. Por exemplo, na seuginte fun&ccedil;&atilde;o:</p>&#10;<pre>primeiro_elemento (elemento:lista) = elemento&#10;</pre>&#10;<p>&eacute; assegurado que o primeiro elemento do argumento de <code>primeiro_elemento</code> &eacute; chamado elemento, e que &eacute; isso que a fun&ccedil;&atilde;o retorna. Sabe&shy;se que &eacute; o primeiro elemento pois &eacute; assim que as listas s&atilde;o definidas (um elemento anexado a uma lista). Uma lista vazia n&atilde;o ir&aacute; casar com o padr&atilde;o, pois n&atilde;o possui primeiro elemento. Como n&atilde;o existe uso para o resto da lista, ent&atilde;o pode&shy;se omit&iacute;&shy;lo do c&oacute;digo, como em:</p>&#10;<pre>primeiro_elemento (elemento:_) = elemento&#10;&#10;</pre><a id="%7B%7BVer_tamb%C3%A9m%7D%7D" name="%7B%7BVer_tamb%C3%A9m%7D%7D"></a><h2>   </h2>&#10;&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Reconhecimento_de_padr%C3%B5es" id="w">Reconhecimento de padr&otilde;es</a></li></ul>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_formais" id="w">Categoria:Linguagens formais</a></p></body></html>