<html><title>Reiser4</title><body>&#10;<p><b>Reiser4</b> &eacute; um <a href="http://en.wikipedia.org/wiki/Sistema_de_arquivo" id="w">sistema de arquivos</a>, uma vers&atilde;o espec&iacute;fica do <a href="http://en.wikipedia.org/wiki/ReiserFS" id="w">ReiserFS</a>, sendo em 2007 a &uacute;ltima vers&atilde;o dispon&iacute;vel do poderoso Reiser.</p>&#10;<a id="Origem" name="Origem"></a><h2> Origem </h2>&#10;<p>Em 2001 criado por Hans Reiser o sistema de arquivos ReiserFS teve sua primeira apari&ccedil;&atilde;o e inicialmente mantido pela empresa (Namesys) para gerenciar os trabalhos do projeto.Esse sistema de arquivo est&aacute; dispon&iacute;vel como padr&atilde;o em muitas das distribui&ccedil;&otilde;es Linux.&#10;O ReiserFS foi o primeiro sistema de arquivos com suporte a &ldquo;journaling&rdquo;( um recurso que ajuda a manter a integridade dos dados em caso de erros no sistema causados por desligamento incorreto ou determinadas falhas de hardware) inclu&iacute;do no n&uacute;cleo Linux 2.4+. S&atilde;o seus patrocinadores as empresas Novell e Linspire, embora a Novell tenha anunciado em Outubro de 2006 que o sistema de arquivos selecionado por omiss&atilde;o no Suse Linux passou a ser o ext3.</p>&#10;<a id="Sem%C3%A2ntica_B%C3%A1sica" name="Sem%C3%A2ntica_B%C3%A1sica"></a><h2> Sem&acirc;ntica B&aacute;sica </h2>&#10;<a id="Ficheiros" name="Ficheiros"></a><h4> Ficheiros </h4>&#10;&#10;<p>Um ficheiro &eacute; algo que tenta parecer com uma sequ&ecirc;ncia de <a href="http://en.wikipedia.org/wiki/Bytes" id="w">bytes</a>.</p>&#10;<p>&Eacute; poss&iacute;vel ler e escrever os bytes, determinar quantos e a partir de onde se podem ler. Tamb&eacute;m pode&shy;se eliminar bytes no fim do ficheiro. A elimina&ccedil;&atilde;o no in&iacute;cio e meio do ficheiro n&atilde;o &eacute; permitida pela sem&acirc;ntica do <a href="http://en.wikipedia.org/wiki/Unix" id="w">Unix</a>.&#10;As interac&ccedil;&otilde;es com os ficheiros s&atilde;o feitas atrav&eacute;s de <a href="http://en.wikipedia.org/wiki/Plugin" id="w">plugins</a> de ficheiros, interfaces que as delimitam.  Para cada ficheiro existe uma pluginid. Cada forma de interagir com uma <i>plugin</i> &eacute; chamada de m&eacute;todo, portanto cada plugin &eacute; composta por tais m&eacute;todos. Cada m&eacute;todo &eacute; composto de fun&ccedil;&otilde;es de <a href="http://en.wikipedia.org/wiki/Bibliotecas" id="w">bibliotecas</a> (<i>library</i>). &#10;Para implementar um ficheiro Unix regular, com a sua Metadata [ver em tipos de items 2.3.1], &eacute; usado um <i>file plugin</i> (unix_file)  para o corpo do ficheiro, um <i>directory plugin</i> (unix_file_dir) para encontrar <i>file plugins</i> para cada Metadata e uma especial <i>file plugin</i> para cada Metadata.</p>&#10;<a id="Nome_e_Objeto" name="Nome_e_Objeto"></a><h4> Nome e Objeto</h4>&#10;&#10;<p>Um nome &eacute; um meio de sele&ccedil;&atilde;o de um objeto. Um Objeto &eacute; algo que atua como se fosse uma simples entidade, dependente do contexto. &#10;<i>Namespace</i> &eacute; o mapeamento de nomes a objetos, como, por exemplo, <a href="http://en.wikipedia.org/wiki/Sistemas_de_ficheiros" id="w">sistemas de ficheiros</a>, bases de dados, motores de busca ou nomes de vari&aacute;veis nas <i>shells</i>. Quanto mais poder tiverem os <i>namespaces</i>, mais poder expressivo ter&aacute; o <a href="http://en.wikipedia.org/wiki/Sistema_Operativo" id="w">Sistema Operativo</a>. </p>&#10;<p>Reiser4 procura criar uma <i>storage layer</i> (camada de armazenagem) eficiente para qualquer, e eventualmente unificado, <i>namespace</i>, e uma <i>semantic layer</i> (camada sem&acirc;ntica) com algumas vantagens sobre <i>state of the art</i>. A <a href="http://en.wikipedia.org/wiki/Namesys" id="w">Namesys</a> prev&ecirc; mais express&atilde;o sem&acirc;ntica na <i>storage layer</i>.&#10;A busca por objectos &eacute; feita por camadas. A camada sem&acirc;ntica pega os nomes e converte&shy;os em chaves (<i>Keys</i>) atrav&eacute;s de objectids. A camada de armazenagem (que cont&eacute;m o c&oacute;digo para correr a &aacute;rvore) pega as chaves e procura os bytes que guardam as partes do objecto. Cada elemento da &aacute;rvore tem uma chave &uacute;nica, apesar de as chaves duplicadas serem permitidas. O seu uso significa que todos os duplicados devem ser examinados e verificado se realmente cont&ecirc;m o que &eacute; procurado. Por isto, s&atilde;o raros nos sistemas que procuram alta performance. Permitindo duplicados, as chaves podem ser mais compactas.&#10;Reiser4 trata apenas nomes hier&aacute;rquicos (<i>Hierarchical names</i>). Os n&atilde;o&shy;hier&aacute;rquicos est&atilde;o planeados para o <a href="http://en.wikipedia.org/wiki/SSN_ReiserFS" id="w">SSN ReiserFS</a>. (Semi&shy;Structured Naming Reiserfs).</p>&#10;<a id="Diret%C3%B3rios" name="Diret%C3%B3rios"></a><h4> Diret&oacute;rios </h4>&#10;&#10;<p>Nomes hier&aacute;rquicos s&atilde;o implementados em Reiser4 pelo uso de diretorios. O 1&ordm; componente &eacute; o nome da diretorio. Os componentes s&atilde;o separados por &#34&semi;/&#34&semi;.  Os seguintes componentes s&atilde;o interpretados e usados para seguir para a sub&shy;directorio seguinte at&eacute; devolver um conjunto de chaves. Em Reiser4, este conjunto cont&eacute;m exactamente um membro, mas em SSN Reiserfs isso poder&aacute; mudar. Reiser4 necessita de interagir com a interface do Unix para os sistemas de ficheiros, da&iacute; a necessidade de existir uma chave que o VFS (<a href="http://en.wikipedia.org/wiki/Sistema_de_ficheiros_virtual" id="w">sistema de ficheiros virtual</a>) compreenda.&#10;As directorias podem devolver uma lista de nomes,  que n&atilde;o precisa de ser a lista de nomes que consegue resolver. &Eacute; poss&iacute;vel ocultar nomes em Reiser4 e as diretorios podem resolver mais nomes do que podem listar, especialmente se forem <i>pseudo files</i> (n&atilde;o existentes na camada de armazenagem).</p>&#10;&#10;<ul>&#10;<li>Ordena&ccedil;&atilde;o das Diretorios </li></ul>&#10;<p>Em Unix, nem a ordem com que os ficheiros s&atilde;o criados nem a ordem lexicogr&aacute;fica se imp&otilde;em &agrave; ordem de listagem. Ap&oacute;s os sistemas de ficheiros os retornarem, s&atilde;o as aplica&ccedil;&otilde;es que os ordenam. Em Reiser4, a plugin ordena os nomes dos ficheiros com menos de 15 letras lexicograficamente, e para os com mais, ordena pelas primeiras 8 letras e depois pelo hash do nome completo. <a href="http://en.wikipedia.org/wiki/Hans_Reiser" id="w">Hans Reiser</a> planeia implementar a ordena&ccedil;&atilde;o pedida pelo utilizador nas pr&oacute;ximas vers&otilde;es.</p>&#10;&#10;<ul>&#10;<li>Diret&oacute;rios tamb&eacute;m s&atilde;o Ficheiros </li></ul>&#10;<p>Em Reiser4, (mas n&atilde;o em <a href="http://en.wikipedia.org/wiki/Reiser" id="w">Reiser3</a>) um objeto tanto pode ser um ficheiro como uma directorio. Se for acedido como ficheiro, devolve uma sequ&ecirc;ncia de bytes&semi; se for acedido como directorio (&#34&semi;/&#34&semi;), devolve o resultado normal (listagem de nomes, ficheiros contidos etc.).</p>&#10;&#10;<ul>&#10;<li>Entradas escondidas</li></ul>&#10;<p>Um ficheiro pode existir e n&atilde;o ser vis&iacute;vel atrav&eacute;s da forma usual. </p>&#10;<pre><font color="#800000">/* First directory item has k_offset component 1. We store &#34&semi;.&#34&semi; and &#34&semi;..&#34&semi;  in one</font></pre>&#10;<pre> item, always, we never split &#34&semi;.&#34&semi; and &#34&semi;..&#34&semi; into differing items. This makes, among&#10; other things, the code for removing directories simpler. */ &#10;&#10;<font color="#0000ff"> struct reiserfs_de_head {</font></pre>&#10;<pre>    <font color="#0000ff">  __le32 deh_offset&semi;</font>&#9;  <font color="#800000"> /* third component of the directory entry key */ </font>&#10;    <font color="#0000ff">  __le32 deh_dir_id&semi;</font>&#9;  <font color="#800000"> /* objectid of the parent directory of the object, that is referenced by directory entry */ </font>&#10;    <font color="#0000ff">  __le32 deh_objectid&semi;</font>  <font color="#800000">  /* objectid of the object, that is referenced by directory entry */ </font>&#10;    <font color="#0000ff">  __le16 deh_location&semi;</font>  <font color="#800000">  /* offset of name in the whole item */ </font>&#10;    <font color="#0000ff">  __le16 deh_state&semi;</font>     <font color="#800000">  /* whether </font></pre>&#10;<pre>                                1) entry contains stat data (for future), and &#10;                                2) whether entry is hidden (unlinked) */ &#10;<font color="#0000ff"> } __attribute__ ((__packed__))&semi;</font>&#10;&#10;</pre><a id="Caracter%C3%ADsticas" name="Caracter%C3%ADsticas"></a><h2> Caracter&iacute;sticas </h2>&#10;&#10;<p>O ReiserFS tem como refer&ecirc;ncia o esquema B+Trees para organizar e localizar os itens que comp&otilde;em, todo o sistema de arquivos, isto &eacute;, os dados em si e as informa&ccedil;&otilde;es associadas (data de cria&ccedil;&atilde;o, permiss&otilde;es de acesso, propriet&aacute;rio, etc). Todos esses itens s&atilde;o classificados em diret&oacute;rios, blocos de dados diretos e indiretos (direct items / indirect items) e inodes (stat data items).&#10;ReiserFS usa &aacute;rvores balanceadas para tornar o processo de busca de arquivos, informa&ccedil;&otilde;es sobre seguran&ccedil;a e outros metadados mais eficientes. Para arquivos muito pequenos, seus dados podem ser armazenados pr&oacute;ximos aos metadados, ent&atilde;o, ambos podem ser recuperados com um pequeno movimento do mecanismo da &#34&semi;cabe&ccedil;a&#34&semi; de leitura do disco. Essa propriedade vai contribuir para um melhor desempenho caso uma aplica&ccedil;&atilde;o necessite abrir muitos arquivos pequenos rapidamente.&#10;No caso de um desligamento incorreto do sistema, o ReiserFS &eacute; capaz de recuperar a consist&ecirc;ncia do sistema de arquivos em pouco tempo e a possibilidade de perda de pastas ou parti&ccedil;&otilde;es &eacute; reduzida.No entanto, os arquivos que eventualmente estiverem sendo gravados no exato momento em que acabou a energia el&eacute;trica ficar&atilde;o com seus dados corrompidos, haver&aacute; acesso aos arquivos normalmente, mas o conte&uacute;do estar&aacute; truncado ou incompleto.</p>&#10;<a id="%C3%81rvores:_Conceitos_b%C3%A1sicos" name="%C3%81rvores:_Conceitos_b%C3%A1sicos"></a><h2> &Aacute;rvores: Conceitos b&aacute;sicos </h2>&#10;<a id="%C3%81rvores%2C_n%C3%B3s_e_Items" name="%C3%81rvores%2C_n%C3%B3s_e_Items"></a><h3> &Aacute;rvores, n&oacute;s e Items </h3>&#10;<a id="%C3%81rvores" name="%C3%81rvores"></a><h3> &Aacute;rvores </h3>&#10;&#10;<p>Um modo de organizar informa&ccedil;&atilde;o &eacute; a inserir em &aacute;rvores.  Reiser4 usa uma &aacute;rvore finita com raiz (<i>root</i>), ac&iacute;clica, com menos um apontadores (1&shy;p) n&oacute;s, e com exactamente um caminho desde a raiz at&eacute; qualquer n&oacute;.  </p>&#10;<a id="Grafos_e_%C3%81rvores" name="Grafos_e_%C3%81rvores"></a><h4> Grafos e &Aacute;rvores </h4>&#10;&#10;<p>Esta &aacute;rvore cont&eacute;m o m&iacute;nimo de apontadores, suficientes para conectar todos os n&oacute;s. Reiser usa <a href="http://en.wikipedia.org/wiki/Grafo" id="w">grafos</a> e &aacute;rvores, sendo as &aacute;rvores usadas para quando o sistema de ficheiros escolhe a organiza&ccedil;&atilde;o na camada de armazenagem e os grafos para a organiza&ccedil;&atilde;o escolhida pelo utilizador na camada sem&acirc;ntica (mais complexa).</p>&#10;<a id="Chaves" name="Chaves"></a><h4> Chaves </h4>&#10;&#10;<p>A cada elemento na &aacute;rvore &eacute; atribu&iacute;da uma chave. O uso de chaves adiciona flexibilidade a como s&atilde;o ordenados os elementos, e se estas forem pequenas, um meio compacto de especificar o suficiente para encontrar o elemento, mas tamb&eacute;m limita que informa&ccedil;&atilde;o pode ser usada para encontrar elementos. Este limites s&atilde;o &uacute;teis, pois a camada de armazenagem escolhe as chaves apenas para organizar o armazenamento de modo a melhorar o desempenho, e a camada sem&acirc;ntica, nomes que tenham significado para o utilizador. Esta abordagem ajuda a adi&ccedil;&atilde;o de melhoramentos em n&iacute;vel de armazenamento, sem comprometer com efeitos colaterais a camada sem&acirc;ntica. </p>&#10;<pre><font color="#800000"> /* Key of an item determines its location in the S+tree, and is composed of 4 components */ </font>&#10;<font color="#0000ff">struct reiserfs_key { </font>&#10;     <font color="#0000ff"> __le32 k_dir_id&semi;&#9;<font color="#800000"> /* packing locality: by default parent  directory object id */ </font></font></pre>&#10;<pre>     <font color="#0000ff"> __le32 k_objectid&semi;&#9;<font color="#800000"> /* object identifier */ </font></font></pre>&#10;<pre>     <font color="#0000ff"> union { </font></pre>&#10;<pre>           struct offset_v1 k_offset_v1&semi;&#10;           struct offset_v2 k_offset_v2&semi;&#10;      } __attribute__ ((__packed__)) u&semi;&#10;} __attribute__ ((__packed__))&semi; &#10;&#10; <font color="#0000ff"> struct in_core_key { </font>&#10;     <font color="#0000ff"> __u32 k_dir_id&semi; </font><font color="#800000">   /* packing locality: by default parent  directory object id */ </font>&#10;     <font color="#0000ff"> __u32 k_objectid&semi; </font><font color="#800000"> /* object identifier */ </font>&#10;     <font color="#0000ff"> __u64 k_offset&semi;</font></pre>&#10;<pre>      __u8 k_type&semi;&#10; }&semi;&#10;&#10;<font color="#0000ff"> struct cpu_key {</font></pre>&#10;<pre>      struct in_core_key on_disk_key&semi;&#10;      int version&semi;&#10;      int key_length&semi; <font color="#800000"> /* 3 in all cases but direct2indirect and indirect2direct conversion */</font>&#10;<font color="#0000ff"> }&semi; &#10;</font>&#10;&#10;</pre><a id="A_escolha_da_sub%C3%A1rvore" name="A_escolha_da_sub%C3%A1rvore"></a><h4> A escolha da sub&aacute;rvore </h4>&#10;&#10;<p>A raiz cont&eacute;m apontadores para as suas sub&aacute;rvores. Para cada apontador a uma sub&aacute;rvore, existe uma chave esquerda delimitadora correspondente. Os apontadores para as sub&aacute;rvores e as sub&aacute;rvores est&atilde;o ordenadas por esta chave. Esta &eacute; igual &agrave; menor chave dos elementos da sub&aacute;rvore. Tamb&eacute;m existe uma chave direita delimitadora que &eacute; superior &agrave; maior chave na sua sub&aacute;rvore e &eacute; a chave esquerda delimitadora na pr&oacute;xima sub&aacute;rvore deste n&oacute;. Se n&atilde;o existirem chaves duplicadas, cada sub&aacute;rvore apenas cont&eacute;m elementos cuja chave &eacute; igual &agrave; chave esquerda delimitadora e menor que a sua chave direita delimitadora, e procurando dentro do n&oacute; por apontadores, &eacute; encontrado o que se procura. Caso existam chaves duplicadas, como j&aacute; foi dito, todos os duplicados devem ser examinados um a um e est&atilde;o ordenados pela ordem de cria&ccedil;&atilde;o.</p>&#10;<a id="N%C3%B3s" name="N%C3%B3s"></a><h3> N&oacute;s </h3>&#10;<a id="Folhas%2C_Pec%C3%ADolos_e_Ramos_(Leaves%2C_Twigs%2C_and_Branches)" name="Folhas%2C_Pec%C3%ADolos_e_Ramos_(Leaves%2C_Twigs%2C_and_Branches)"></a><h4> Folhas, Pec&iacute;olos e Ramos (Leaves, Twigs, and Branches)</h4>&#10;&#10;<p><b>Folhas</b> s&atilde;o os n&oacute;s que n&atilde;o t&ecirc;m filhos. Os n&oacute;s internos s&atilde;o os que t&ecirc;m filhos.</p>&#10;<p>Um n&oacute; que cont&eacute;m itens &eacute; chamado <i>n&oacute; formatado</i> (<i>formatted node</i>).</p>&#10;<p>Se um objecto &eacute; grande, n&atilde;o est&aacute; comprimido e n&atilde;o precisa suportar inser&ccedil;&otilde;es eficientes, ent&atilde;o pode ser guardado mais eficientemente nos n&oacute;s sem qualquer uso de itens. &Eacute; feito por norma para objectos maiores que 16k. &#10;Objectos comprimidos s&atilde;o especiais porque necessitam mudar o uso de espa&ccedil;o quando &eacute; escrito para os seus interiores, pois a compress&atilde;o pode n&atilde;o ser igualmente eficiente para os novos dados.</p>&#10;&#10;<ul>&#10;<li>N&oacute;s n&atilde;o formatados {<i>Unformatted leaves (unfleaves)</i>}  s&atilde;o folhas que cont&ecirc;m apenas dados e nenhum tipo de informa&ccedil;&atilde;o de formato. Apenas as folhas podem conter dados n&atilde;o formatados. Apontadores s&atilde;o guardados em itens, assim como todos os n&oacute;s internos s&atilde;o necessariamente n&oacute;s formatados. Apontadores para unfleaves s&atilde;o diferentes na sua estrutura dos apontadores para n&oacute;s formatados.</li></ul>&#10;&#10;<ul>&#10;<li>Apontadores estendidos  (<i>Extent pointers</i>) apontam para unfleaves. Uma extens&atilde;o (extent) &eacute; um n&uacute;mero grande de blocos consecutivos. Cada extens&atilde;o &eacute; descrita como um triplo, consistindo em: <i>file offset</i>, in&iacute;cio do bloco, tamanho, onde <i>file offset</i> &eacute; o <i>offset</i> do 1&ordm; bloco da extens&atilde;o desde o in&iacute;cio do ficheiro, e tamanho &eacute; o n&uacute;mero de blocos na extens&atilde;o. As extens&otilde;es s&atilde;o alocadas e seguidas como uma &uacute;nica entidade, i.e., um &uacute;nico apontador liga um grupo de blocos. Para grandes ficheiros, aloca&ccedil;&atilde;o por extens&atilde;o &eacute; muito mais eficiente que aloca&ccedil;&atilde;o por bloco.  </li></ul>&#10;&#10;<ul>&#10;<li>Apontadores para n&oacute;s (<i>Node Pointers</i>)  s&atilde;o apontadores para n&oacute;s formatados. Ainda n&atilde;o existe uma vers&atilde;o comprimida destes apontadores. Para os apontadores estendidos n&atilde;o &eacute; categ&oacute;rico guardar as chaves delimitadoras para cada n&oacute; apontado, mas &eacute; preciso para os <i>Node Pointers</i>. </li></ul>&#10;&#10;<ul>&#10;<li><b>Pec&iacute;olos</b> (<i>Twigs</i>)   s&atilde;o os pais das folhas. Os <i>extent Pointers</i> existem apenas nos pec&iacute;olos.  Esta &eacute; uma decis&atilde;o muito controversa.</li></ul>&#10;&#10;<ul>&#10;<li><b>Ramos</b> (<i>Branches</i>) s&atilde;o n&oacute;s internos que n&atilde;o s&atilde;o pec&iacute;olos.</li></ul>&#10;<p>Como a &aacute;rvore cresce para cima, &eacute; &uacute;til numerar as folhas com o n&iacute;vel 1, onde s&atilde;o guardadas os dados. A altura da &aacute;rvore depende de quantos objectos existem e qual &eacute; o fanout rate (n&uacute;mero m&eacute;dio de filhos) dos n&oacute;s internos e dos twigs. A &aacute;rvore tem a altura m&iacute;nima de 2 e a raiz &eacute; sempre um n&oacute; interno.</p>&#10;<a id="Tamanho_dos_n%C3%B3s" name="Tamanho_dos_n%C3%B3s"></a><h4> Tamanho dos n&oacute;s </h4>&#10;&#10;<p>Os n&oacute;s s&atilde;o iguais em tamanho. Torna&shy;se mais f&aacute;cil alocar espa&ccedil;o inutilizado entre os n&oacute;s, pois ser&aacute; sempre um m&uacute;ltiplo do tamanho dos n&oacute;s. Em Reiser4, os n&oacute;s s&atilde;o, normalmente, do tamanho de uma p&aacute;gina, que, no caso de GNU/Linux num Intel, &eacute; de 4k.</p>&#10;<a id="A_partilha_de_blocos_permite_poupar_espa%C3%A7o" name="A_partilha_de_blocos_permite_poupar_espa%C3%A7o"></a><h4> A partilha de blocos permite poupar espa&ccedil;o </h4>&#10;&#10;<p>Para guardar grandes objectos, estes s&atilde;o divididos em menores pe&ccedil;as. A estas pe&ccedil;as chama&shy;se itens. S&atilde;o dimensionadas para estarem  no interior de um &uacute;nico n&oacute;. Em Reiser4, m&uacute;ltiplos itens s&atilde;o encaixados num bloco. A efici&ecirc;ncia espacial ronda os 94% para pequenos ficheiros, diferentemente dos sistemas de ficheiros convencionais, que guardam os ficheiros num &uacute;nico bloco. Os ficheiros maiores que 16k s&atilde;o alinhados a 4k.</p>&#10;<a id="Items" name="Items"></a><h3> Items </h3>&#10;&#10;<p>Os n&oacute;s nas &aacute;rvores s&atilde;o muito menores que alguns objectos que guardam ou maiores que outros, por isso s&atilde;o divididos em itens. Cada item tem uma chave, um offset para onde o corpo come&ccedil;a e o tamanho do corpo do item e um pluginid que indica que tipo de item &eacute;. </p>&#10;<pre><font color="#0000ff"> __u32 k_objectid&semi; </font>&#10;&#10;<font color="#0000ff"> struct item_head { </font>&#10;     <font color="#800000"> /* Everything in the tree is found by searching for it based on its key.*/</font>&#10;     <font color="#0000ff"> struct reiserfs_key ih_key&semi;</font>&#10;     <font color="#0000ff"> union {</font>&#10;<font color="#800000"> /* The free space in the last unformatted node of an indirect item if this is an</font></pre>&#10;<pre>indirect item.  This equals 0xFFFF iff this is a direct item or stat&#10;data item. Note that the key, not this field, is used to determine &#10;the item type, and thus which field this union contains. */&#10;           <font color="#0000ff"> __le16 ih_free_space_reserved&semi;</font>&#10;           <font color="#800000"> /* Iff this is a directory item, this field equals the  number of</font></pre>&#10;<pre>                                     directory entries in the directory item. */&#10;           <font color="#0000ff"> __le16 ih_entry_count&semi;</font>&#10;     <font color="#0000ff"> } __attribute__ ((__packed__)) u&semi;</font>&#10;     <font color="#0000ff"> __le16 ih_item_len&semi;&#9;&#9;</font><font color="#800000"> /* total size of the item body */</font>&#10;     <font color="#0000ff"> __le16 ih_item_location&semi;&#9;</font><font color="#800000"> /* an offset to the item body within the block */</font>&#10;     <font color="#0000ff"> __le16 ih_version&semi;&#9;&#9;</font><font color="#800000"> /* 0 for all old items, 2 for new ones. </font></pre>&#10;<pre>                                   Highest bit is set by fsck temporary, cleaned after all done */&#10;<font color="#0000ff">}</font>&#10;&#10;</pre><a id="Tipos_de_Itens" name="Tipos_de_Itens"></a><h4> Tipos de Itens </h4>&#10; &#10;<p>Reiser4 inclui muitos tipos diferentes de itens desenhados para conter diferentes tipos de informa&ccedil;&atilde;o:&#10;</p>&#10;<ul>&#10;<li><i>static_stat_data</i>: Metadata: guarda o dono, as permiss&otilde;es, a data do &uacute;ltimo acesso, de cria&ccedil;&atilde;o, da &uacute;ltima modifica&ccedil;&atilde;o, tamanho, o n&uacute;mero de links (nomes) a um ficheiro e, se existir, <i>access control lists</i> (ACL).</li>&#10;<li><i>cmpnd_dir_item</i>: guarda as entradas nas directorias e as chaves para onde esses ficheiros se conectam.</li>&#10;<li><i>extent pointers</i>&semi; </li>&#10;<li><i>node pointers</i>&semi;</li>&#10;<li><i>bodies</i>: guarda partes de ficheiros que n&atilde;o s&atilde;o suficientemente grandes para serem guardados em <i>unfleaves</i>.</li></ul>&#10;<a id="Unidades_(Units)" name="Unidades_(Units)"></a><h4> Unidades (Units) </h4>&#10;&#10;<p>&Eacute; o que se deve guardar como um todo num item, sem ter que dividir por m&uacute;ltiplos itens. Atravessar o conte&uacute;do de um item &eacute; conveniente que seja em unidades:&#10;</p>&#10;<ul>&#10;<li>Para o corpo do item, as unidades s&atilde;o bytes</li>&#10;<li>Para itens directorias, as unidades s&atilde;o entradas em directorias. </li>&#10;<li>Para itens extens&otilde;es, as unidades s&atilde;o extens&otilde;es. As extens&otilde;es apenas cont&ecirc;m extens&otilde;es do mesmo ficheiro.</li>&#10;<li>Para static_stat_data, todo o stat data item &eacute; unidade indivis&iacute;vel de tamanho fixado.</li></ul>&#10;<a id="Apar%C3%AAncia_dos_n%C3%B3s_em_ReiserFS_4.0" name="Apar%C3%AAncia_dos_n%C3%B3s_em_ReiserFS_4.0"></a><h4> Apar&ecirc;ncia dos n&oacute;s em ReiserFS 4.0 </h4>&#10;<p>Um unformatted leaf node (n&oacute; unfleaf), que &eacute; o &uacute;nico n&oacute; sem um Node_Header: </p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table border="2" width="100%">&#10;<caption>A estrutura de um <i>Item</i></caption>&#10;<tr>&#10;<td>Item_Body </td>&#10;<td>.. separated .. </td>&#10;<td>Item_Head</td></tr>&#10;<tr>&#10;<td>Item_Key  </td>&#10;<td>Item_Offset </td>&#10;<td>Item_Length  </td>&#10;<td>Item_Plugin_id </td></tr></table></div>&#9;&#10;&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table border="2" width="100%">&#10;<caption>Um <i>formatted leaf node</i></caption>&#10;<tr>&#10;<td>Block_Head</td>&#10;<td>Item_Body0 </td>&#10;<td>Item_Body1 </td>&#10;<td>... </td>&#10;<td>Item_Bodyn </td>&#10;<td>.... Espa&ccedil;o Livre .... </td>&#10;<td>Item_Headn </td>&#10;<td>... </td>&#10;<td>Item_Head1 </td>&#10;<td>Item_Head0</td></tr></table></div>&#10;&#9;&#9;&#9;&#10;&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table border="2" width="100%">&#10;<caption>O n&oacute; <i>twig</i> tem a seguinte estructura: </caption>&#10;<tr>&#10;<td>Block_Head </td>&#10;<td>Item_Body0  Node Pointer0       </td>&#10;<td>Item_Body1  Extent Pointer1     </td>&#10;<td>Item_Body2  Node Pointer2           </td>&#10;<td>Item_Body3  Extent Pointer3                    </td>&#10;<td>... </td>&#10;<td>Item_Bodyn  Node Pointern    </td>&#10;<td>... Free Space ...   </td>&#10;<td>Item_Headn      </td>&#10;<td>&shy;&shy;&shy; </td>&#10;<td>Item_Head1  </td>&#10;<td>Item_Head0</td></tr></table></div>&#10;&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table border="2" width="100%">&#10;<caption>Um ramo tem a estrutura:   </caption>&#10;<tr>&#10;<td>Block_Head</td>&#10;<td>Item_Body0 NodePointer0  </td>&#10;<td />&#10;<td>Item_Bodyn NodePointern</td>&#10;<td>....Espa&ccedil;o Livre ... </td>&#10;<td>Item_Headn</td>&#10;<td />&#10;<td>Item_Head0</td></tr></table></div>&#10;&#10;<a id="Conceitos_de_desenho_de_%C3%81rvore" name="Conceitos_de_desenho_de_%C3%81rvore"></a><h2> Conceitos de desenho de &Aacute;rvore </h2>&#10;<a id="Tr%C3%AAs_princ%C3%ADpios:" name="Tr%C3%AAs_princ%C3%ADpios:"></a><h3> Tr&ecirc;s princ&iacute;pios:</h3>&#10;&#10;&#10;<ul>&#10;<li>O ratio de fanout&semi;</li>&#10;<li>Compacticidade do empacotamento&semi;</li>&#10;<li>A quantidade de itens que se tem que mover na &aacute;rvore de um n&oacute; para outro.</li></ul>&#10;<a id="Fanout" name="Fanout"></a><h4> Fanout </h4>&#10;&#10;<p>O ratio de fanout refere&shy;se a quantos n&oacute;s podem ser apontados por cada n&oacute; num certo n&iacute;vel. Se cada n&oacute; pode apontar para n n&oacute;s no n&iacute;vel abaixo, ent&atilde;o, come&ccedil;ando na raiz, esta aponta para n n&oacute;s internos, e assim sucessivamente at&eacute; o n&iacute;vel m: existem n*m folhas que cont&ecirc;m dados. &#10;Para guardar cada vez mais, &eacute; necess&aacute;rio que aumente as chaves para distinguir os objectos (objectids) e depois seleccionar partes do objecto (offset). Isto significa que as chaves devem ser maiores, o que diminui o fanout (a n&atilde;o ser que se comprima as chaves).</p>&#10;<a id="B%2BTrees" name="B%2BTrees"></a><h4> B+Trees </h4>&#10;<a id="B%2BTrees%2C_e_porque_s%C3%A3o_melhores_que_B&shy;Trees" name="B%2BTrees%2C_e_porque_s%C3%A3o_melhores_que_B&shy;Trees"></a><h5> B+Trees, e porque s&atilde;o melhores que B&shy;Trees </h5>&#10;&#10;<p>Nas B&shy;trees &eacute; poss&iacute;vel guardar n&atilde;o s&oacute; apontadores e chaves nos n&oacute;s internos, como tamb&eacute;m os objectos aos quais as chaves correspondem. </p>&#10;<p>Nas B+trees, apenas apontadores e chaves s&atilde;o guardados nos n&oacute;s internos, e todos os objectos s&atilde;o guardados nas folhas.</p>&#10;<a id="B%2BTrees_t%C3%AAm_maior_fanout_que_as_B&shy;Trees" name="B%2BTrees_t%C3%AAm_maior_fanout_que_as_B&shy;Trees"></a><h5> B+Trees t&ecirc;m maior fanout que as B&shy;Trees </h5>&#10;&#10;<p>O fanout aumenta quando existem apenas apontadores e chaves nos n&oacute;s internos. Aumenta a facilidade de fazer cache de todos os n&oacute;s internos, pois existem menos.</p>&#10;<a id="Princ%C3%ADpios_no_Desenho_da_Cache" name="Princ%C3%ADpios_no_Desenho_da_Cache"></a><h6> Princ&iacute;pios no Desenho da Cache </h6>&#10;&#10;<p><b>Reiser&#39&semi;s Untie The Uncorrelated Principle of Cache Design</b></p>&#10;<p><i>Tying the caching of things whose usage does not strongly correlate is bad</i>.  &shy; Hans Reiser</p>&#10;<p>Agrupando o incorrelacionado &eacute; um erro comum no desenho de caches. Em Reiser4, &eacute; poss&iacute;vel guardar mais de um apontador por n&oacute;. Isso significa que os apontadores n&atilde;o est&atilde;o em caches separados. </p>&#10;<p><b>Reiser&#39&semi;s Maximize The Variance Principle of Cache Design</b></p>&#10;<p><i>If two types of things that are cached and accessed, in units that are aggregates, have different average temperatures, then segregating the two types into separate units helps caching.</i></p>&#10;<p>Para &aacute;rvores equilibradas, estas agrupamentos s&atilde;o n&oacute;s. Este princ&iacute;pio aplica&shy;se &agrave; situa&ccedil;&atilde;o em que &eacute; necess&aacute;rio agrupar elementos em maiores unidades para um acesso eficiente.</p>&#10;&#10;<ol>&#10;<li>Se os dados frequentemente usados forem igualmente dispersos, ent&atilde;o uma cache substancial &eacute; necess&aacute;ria e o caching &eacute; menos eficiente&semi;</li>&#10;<li>Se aumentar a varia&ccedil;&atilde;o da temperatura entre os n&oacute;s, ent&atilde;o aumenta a efic&aacute;cia do uso de uma cache pequena e r&aacute;pida&semi;</li>&#10;<li>Se dois tipos de objectos t&ecirc;m diferentes temperaturas m&eacute;dias, ent&atilde;o, separando&shy;as em diferentes agrupamentos, aumenta a varia&ccedil;&atilde;o da temperatura no sistema&semi; </li></ol>&#10;&#10;<ul>&#10;<li>Conclus&atilde;o: &#9;se dois tipos de objectos estiverem na mesma cache com diferentes temperaturas, ent&atilde;o a segrega&ccedil;&atilde;o ajuda o caching.</li></ul>&#10;<p><b>Pointers To Nodes Have A Higher Average Temperature Than The Nodes They Point To</b></p>&#10;<p>Usando apenas apontadores para n&oacute; e as chaves delimitadoras nos n&oacute;s internos, cria&shy;se uma concentra&ccedil;&atilde;o de apontadores. Como os apontadores tendem a ser mais frequentemente acedidos (por byte), uma alta diferen&ccedil;a de temperatura m&eacute;dia existe entre apontadores e objectos com dados.</p>&#10;&#10;<ol>&#10;<li>BLOB</li></ol>&#10;<p>BLOBs desequilibram uma &aacute;rvore, reduzem a segrega&ccedil;&atilde;o de apontadores e dados e, por isso, reduzem o desempenho.</p>&#10;<p>BLOBs, Binary Large OBjects, s&atilde;o m&eacute;todos de armazenamento de objectos maiores que um n&oacute;, que guardam apontadores para n&oacute; contendo o objecto. Foram usados em Reiser3, mas Reiser4 retorna &agrave; cl&aacute;ssica defini&ccedil;&atilde;o de &aacute;rvore equilibrada pela altura, em que os tamanhos dos caminhos a todas as folhas s&atilde;o iguais. N&atilde;o tenta disfar&ccedil;ar que algumas das folhas est&atilde;o fora da &aacute;rvore, mesmo que a &aacute;rvore guarde apontadores para elas. Como resultado, a RAM necess&aacute;ria para guardar os apontadores para os n&oacute;s &eacute; dramaticamente reduzida.</p>&#10;<a id="Dancing_Trees_s%C3%A3o_mais_r%C3%A1pidas_que_as_Balanced_Trees" name="Dancing_Trees_s%C3%A3o_mais_r%C3%A1pidas_que_as_Balanced_Trees"></a><h4> Dancing Trees s&atilde;o mais r&aacute;pidas que as Balanced Trees </h4>&#10;&#10;<p>&Aacute;rvores equilibradas t&ecirc;m, tradicionalmente, empregado crit&eacute;rios fixos para determinar quais os n&oacute;s que dever&atilde;o ser agrupados para poupar espa&ccedil;o. Este crit&eacute;rio era satisfeito no fim de cada modifica&ccedil;&atilde;o da &aacute;rvore. Este foi o crit&eacute;rio usado em ReiserFS V3 para as folhas.&#10;Em Reiser4 s&atilde;o usadas as dancing trees. Dancing trees agrupam insuficientes n&oacute;s, n&atilde;o a cada modifica&ccedil;&atilde;o, mas sim:</p>&#10;&#10;<ul>&#10;<li>Em resposta a uma descarga para o disco&semi;</li>&#10;<li>Como resultado de uma transa&ccedil;&atilde;o que guarda os n&oacute;s no disco.</li></ul>&#10;<p>&Aacute;rvores equilibradas t&ecirc;m o inerente tradeoff entre o custo de equil&iacute;brio e efici&ecirc;ncia espacial. Se se considera mais n&oacute;s vizinhos para agrupar e libertar um n&oacute;, com cada modifica&ccedil;&atilde;o da &aacute;rvore &eacute; poss&iacute;vel agrupar a &aacute;rvore mais compactamente, com o custo de mover mais dados com cada modifica&ccedil;&atilde;o.</p>&#10;<p>Em contraste, com a &aacute;rvore dan&ccedil;ante pega&shy;se uma grande quantidade de n&oacute;s imediatos (slum), passa&shy;se tudo para o mais &agrave; esquerda poss&iacute;vel e depois liberta&shy;se os n&oacute;s na slum que ficou vazia, quando for para guardar no disco. Representa uma extrema efici&ecirc;ncia espacial quando as slums s&atilde;o consider&aacute;veis, com o custo do movimento de dados, que &eacute; menor do que o invari&aacute;vel crit&eacute;rio das &aacute;rvores equilibradas porque &eacute; feito com menos frequ&ecirc;ncia. Comprimindo apenas quando for guardado no disco, tamb&eacute;m se comprime menos vezes e isso significa que se pode fazer mais profundamente. Comprimindo estes n&oacute;s (dirty) que est&atilde;o na mem&oacute;ria, evita&shy;se que seja efectuada mais I/O como resultado do balanceamento.</p>&#10;<p>3 Procrastination tende para decis&otilde;es mais inteligentes: alocar no despejar.</p>&#10;<p>ReiserFS V3 associava n&uacute;meros dos blocos aos n&oacute;s assim que os criava. XFS &eacute; mais inteligente: espera at&eacute; o &uacute;ltimo momento, mesmo antes de escrever no disco.</p>&#10;<a id="Sistemas_de_Ficheiros_journaled" name="Sistemas_de_Ficheiros_journaled"></a><h2> Sistemas de Ficheiros journaled </h2>&#10;<a id="O_problema_com_os_sistemas_sem_jornal" name="O_problema_com_os_sistemas_sem_jornal"></a><h4> O problema com os sistemas sem jornal </h4>&#10;&#10;<p>Se a corrente el&eacute;ctrica falha ou o computador bloqueia durante um processo de escrita (depois de o ficheiro ser escrito e antes da meta informa&ccedil;&atilde;o ser correctamente adicionada, o sistema de ficheiros perde o ficheiro e cria inconsist&ecirc;ncias. Tamb&eacute;m afecta as directorias, p.ex: durante a actualiza&ccedil;&atilde;o da directoria). Na tentativa de recuperar a informa&ccedil;&atilde;o perdida, sistemas como o Mac OSX e Linux  correr&atilde;o o programa fsck, de modo, a validar todas as entradas no sistema de ficheiros e que todos os blocos est&atilde;o alocados e referenciados correctamente. N&atilde;o existem garantias que os ficheiros corrompidos ser&atilde;o recuperados e &eacute; aqui que o journaled file system (JFS)  pode ajudar. </p>&#10;<a id="A_import%C3%A2ncia_de_Sistemas_de_Ficheiros_journaled" name="A_import%C3%A2ncia_de_Sistemas_de_Ficheiros_journaled"></a><h4> A import&acirc;ncia de Sistemas de Ficheiros journaled </h4>&#10;&#10;<p>Um sistema de ficheiros com jornal / logs, &eacute; um ficheiro que cont&eacute;m o seu pr&oacute;prio backup e capacidade de recupera&ccedil;&atilde;o. Antes dos indexes serem actualizados, a informa&ccedil;&atilde;o sobre as mudan&ccedil;as s&atilde;o gravadas num log. Um JFS mant&eacute;m o log ou jornal de que actividades tomaram lugar nas principais partes do disco. O JFS ou escreve ou rel&ecirc; o jornal. Com as t&eacute;cnicas de bases de dados, o JFS consegue restaurar um sistema de ficheiros em minutos para um estado de consist&ecirc;ncia. Alguns dos sistemas de ficheiros que suportam JSF s&atilde;o:&#10;</p>&#10;<ul>&#10;<li>Apple&#39&semi;s HFS (o journaling &eacute; desligado por defeito)</li>&#10;<li>Linux Ext3, ReiserFS, XFS, e JFS</li>&#10;<li>Solaris UFS</li>&#10;<li>Windows NTFS</li></ul>&#10;<a id="O_interior_de_um_file_systems" name="O_interior_de_um_file_systems"></a><h4> O interior de um file systems </h4>&#10;&#10;<p>Atrav&eacute;s do trabalho de Steve Best, que trabalha para IBM e tem presen&ccedil;a no comit&eacute; open source para o JFS distribu&iacute;do com o Linux, define&shy;se:</p>&#10;<p>Um bloco l&oacute;gico (logical block)  como sendo a mais pequena unidade de armazenagem que pode ser alocada pelo sistema de ficheiros e &eacute; medido em bytes</p>&#10;<p>Um volume l&oacute;gico (logical volume) pode ser um disco f&iacute;sico ou outro tipo de parti&ccedil;&atilde;o do disco f&iacute;sico. </p>&#10;<p>A metadata do sistema de ficheiros &eacute; a sua representa&ccedil;&atilde;o interna estruturada &shy; tudo o que diz respeito ao ficheiro com excep&ccedil;&atilde;o aos dados contidos no ficheiro. A Metadata de um ficheiro &eacute; guardada no inode correspondente.</p>&#10;<p>O Unix file system (UFS) usa um multi&shy;n&iacute;vel index chamado de inode (information node). Um file inode guarda toda a Metadata. Tamb&eacute;m cont&eacute;m apontadores directos, indirectos e duplo e triplamente indirectos para blocos de dados do ficheiro. Cada inode tem um n&uacute;mero &uacute;nico que o distingue. </p>&#10;<p>Um directory inode &eacute; outro tipo especial de ficheiro que simplesmente cont&eacute;m apontadores para outros ficheiros contidos na directoria, mais as permiss&otilde;es, etc...</p>&#10;<p>O superbloco &eacute; a informa&ccedil;&atilde;o da raiz. Fica no offset fixo desde o inicio da parti&ccedil;&atilde;o:&#10; REISERFS_DISK_OFFSET_IN_BYTES = (64*1024) = 65536 &#10; /* definido em reiserfs_fs_sb.h */</p>&#10;<pre>/* ReiserFS leaves the first 64k unused, so that partition labels have enough&#10;  space.  If someone wants to write a fancy bootloader that needs more than 64k,&#10;  let us know, and this will be increased in size.&#10;  This number must be larger than than the largest block size on any platform, or&#10;  code will break. &shy;Hans */&#10;&#10;#define REISERFS_DISK_OFFSET_IN_BYTES (64 * 1024)&#10;&#10;/* this is the on disk super block */&#10;struct reiserfs_super_block {&#10;&#9;struct reiserfs_super_block_v1 s_v1&semi;&#10;&#9;__le32 s_inode_generation&semi;&#10;&#9;__le32 s_flags&semi;&#9;&#9;/* Right now used only by inode&shy;attributes, if&#10;  enabled */&#10;&#9;unsigned char s_uuid[16]&semi;&#9;/* filesystem unique identifier */&#10;&#9;unsigned char s_label[16]&semi;&#9;/* filesystem volume label */&#10;&#9;char s_unused[88]&semi;&#9;/* zero filled by mkreiserfs and&#10;       reiserfs_convert_objectid_map_v1()&#10;&#9;/* so any additions must be updated there as well.  */&#10;  } __attribute__ ((__packed__))&semi;&#10;&#10;</pre><a id="Fixed_Location_Journaling" name="Fixed_Location_Journaling"></a><h4> Fixed Location Journaling </h4>&#10;&#10;<p>Originalmente, os sistemas de ficheiros tinham aplica&ccedil;&otilde;es que corriam depois de cada crash. O problema era:&#10;</p>&#10;<ul>&#10;<li>N&atilde;o lidavam com todas as formas de danos&semi;</li>&#10;<li>Demoravam muito tempo.</li></ul>&#10;<p>A quantidade de dados guardados nos disco aumentava cada vez mais r&aacute;pido do que a transferencia de dados, o que significava que cada vez demoravam mais.</p>&#10;<a id="Em_ReiserFS_V4" name="Em_ReiserFS_V4"></a><h5> Em ReiserFS V4 </h5>&#10;&#10;<p>A solu&ccedil;&atilde;o adoptada para o Reiser4 foi de primeiro escrever cada opera&ccedil;&atilde;o at&oacute;mica para um lugar no jornal, e depois, s&oacute; depois de cada &aacute;tomo ter chegado completamente ao jornal, era escrito no seu lugar pr&oacute;prio. Mas persistia um problema: escrevia&shy;se duas vezes mais. Por um lado, se o workload era dominado por procuras, o fardo era menor. Por outro, se dominavam as escritas, o desempenho era muito diminu&iacute;do. Por esta raz&atilde;o, metadata journaling veio dominar o uso comum, pois garante que todas as opera&ccedil;&otilde;es na sua metadata ser&atilde;o feitas atomicamente. Se um ficheiro est&aacute; a ser escrito, os dados que est&atilde;o a ser escritos podem tornar&shy;se corruptos como resultado de opera&ccedil;&otilde;es n&atilde;o at&oacute;micas, mas o &acirc;mago do sistema de ficheiros ser&aacute; sempre consistente. O ganho no desempenho &eacute; substancial. A vers&atilde;o 3 de reiserFS oferecia metadata e data journaling. Normalmente, data journaling garante que os ficheiros n&atilde;o conter&atilde;o &#34&semi;random garbage&#34&semi;, independentemente do n&uacute;mero de blocos que acabem por ser escritos e de que as aplica&ccedil;&otilde;es vejam o resultado como dados inconsistentes.</p>&#10;<a id="''Wandering_Logs''" name="''Wandering_Logs''"></a><h5> &#39&semi;&#39&semi;Wandering Logs&#39&semi;&#39&semi; </h5>&#10;&#10;<p>Um modo de evitar que se escreva duas vezes &eacute; mudando a defini&ccedil;&atilde;o de onde &eacute; a &aacute;rea de log e onde ser&atilde;o guardados os dados, em vez de mover os dados do log para a &#34&semi;committed area&#34&semi;. </p>&#10;<p>Uma complica&ccedil;&atilde;o que surge &eacute; que &eacute; necess&aacute;rio que um certo n&uacute;mero de apontadores do resto do sistema de ficheiros aponte para os novos dados. Quando a transfer&ecirc;ncia (commit) ocorre, tamb&eacute;m &eacute; necess&aacute;rio  escrever esses apontadores, que tendem a estar muito concentrados. Mas para actualizar estes apontadores, &eacute; necess&aacute;rio fazer um commit at&oacute;mico destes, e assim as ondas repercutem&shy;se pela arvore acima. Quando chega &agrave; raiz, este pode ser escrito atomicamente no superbloco. &Eacute; assim que WAFL funciona. &#34&semi;Empurra&#34&semi; as mudan&ccedil;as para o topo e eficientemente actualiza o sistema de ficheiros.</p>&#10;<a id="Seguran%C3%A7a" name="Seguran%C3%A7a"></a><h2> Seguran&ccedil;a </h2>&#10;<a id="Boa_seguran%C3%A7a_requer_precis%C3%A3o_na_especifica%C3%A7%C3%A3o_de_Seguran%C3%A7a" name="Boa_seguran%C3%A7a_requer_precis%C3%A3o_na_especifica%C3%A7%C3%A3o_de_Seguran%C3%A7a"></a><h4> Boa seguran&ccedil;a requer precis&atilde;o na especifica&ccedil;&atilde;o de Seguran&ccedil;a </h4>&#10;&#10;<p>Um princ&iacute;pio geral de seguran&ccedil;a &eacute; que uma boa seguran&ccedil;a requer precis&atilde;o de permiss&otilde;es. </p>&#10;<a id="Efici%C3%AAncia_Espacial_motiva_Seguran%C3%A7a_Imprecisa" name="Efici%C3%AAncia_Espacial_motiva_Seguran%C3%A7a_Imprecisa"></a><h4> Efici&ecirc;ncia Espacial motiva Seguran&ccedil;a Imprecisa </h4>&#10;&#10;<p>Muitos sistema de ficheiros tornam o uso do espa&ccedil;o ineficiente para guardar pequenos componentes como ficheiros separados pelas mais variadas raz&otilde;es. N&atilde;o sendo ficheiros separados significa que n&atilde;o tem diferentes permiss&otilde;es. </p>&#10;<a id="Agrega%C3%A7%C3%A3o_%C3%A9_melhor_implementada_como_heran%C3%A7a" name="Agrega%C3%A7%C3%A3o_%C3%A9_melhor_implementada_como_heran%C3%A7a"></a><h4> Agrega&ccedil;&atilde;o &eacute; melhor implementada como heran&ccedil;a </h4>&#10;&#10;<p>Para conseguir precis&atilde;o na Seguran&ccedil;a &eacute; necess&aacute;rio haver em Reiser hereditariedade com delimitadores espec&iacute;ficos e suporte para ACL&#39&semi;s.</p>&#10;<a id="Considera%C3%A7%C3%B5es" name="Considera%C3%A7%C3%B5es"></a><h2> Considera&ccedil;&otilde;es </h2>&#10;<p>Reiser4 oferece uma estrutura dramaticamente melhor para criar novas caracter&iacute;sticas. Os ficheiros e directorias tem tudo o que precisam para n&atilde;o necessitarem que os atributos de ficheiros sejam diferentes de ficheiros. A efici&ecirc;ncia desta infra&shy;estrutura &eacute; testada usando uma variedade de caracter&iacute;sticas de Seguran&ccedil;a. A performance foi melhorada pelo uso de &aacute;rvores dan&ccedil;antes, logs errantes, aloca&ccedil;&atilde;o na descarga, pelo repacker e encripta&ccedil;&atilde;o no commit.</p>&#10;<a id="Desvantagens" name="Desvantagens"></a><h2> Desvantagens </h2>&#10;&#10;<p>Por ter um consumo de CPU muito elevado &eacute; uma desvantagem do ReiserFS que utiliza no m&iacute;nimo 7 por cento da CPU, chegando a usar at&eacute; 99 por cento, quando a atividade de disco &eacute; elevada.</p>&#10;<p>No dia 10 de Outubro de 2006 de Hans Reiser, seu criador, foi preso e sua condena&ccedil;&atilde;o em 28 de Abril de 2008 pelo assassinato de sua mulher no in&iacute;cio de Setembro de 2006. Atualmente, devido &agrave; paralisa&ccedil;&atilde;o das atividades da Namesys, o projeto ReiserFS est&aacute; armazenado em kernel.org.</p>&#10;<a id="%7B%7Bver_tamb%C3%A9m%7D%7D" name="%7B%7Bver_tamb%C3%A9m%7D%7D"></a><h2> </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/ReiserFS" id="w">ReiserFS</a></li></ul>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Sistemas_de_ficheiros" id="w">Categoria:Sistemas de ficheiros</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linux" id="w">Categoria:Linux</a></p>&#10;<p><a href="http://de.wikipedia.org/wiki/Reiser_File_System">de:Reiser File System</a></p></body></html>