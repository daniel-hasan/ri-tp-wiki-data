<html><title>Padr&atilde;o de projeto de software</title><body>&#10;<p> &#10;Em <a href="http://en.wikipedia.org/wiki/Engenharia_de_software" id="w">engenharia de software</a>, um <b><a href="http://en.wikipedia.org/wiki/Padr%C3%A3o_de_projeto" id="w">padr&atilde;o de projeto</a></b> ou <b>padr&atilde;o de desenho</b> (do ingl&ecirc;s <b>design pattern</b>) &eacute; uma solu&ccedil;&atilde;o geral reutiliz&aacute;vel para um problema que ocorre com frequ&ecirc;ncia dentro de um determinado contexto no <a href="http://en.wikipedia.org/wiki/Projeto_de_software" id="w">projeto de software</a>. Um padr&atilde;o de projeto n&atilde;o &eacute; um projeto finalizado que pode ser diretamente transformado em c&oacute;digo <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_fonte" id="w">fonte</a> ou de <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_de_m%C3%A1quina" id="w">m&aacute;quina</a>, ele &eacute; uma descri&ccedil;&atilde;o ou modelo (<i>template</i>) de como resolver um problema que pode ser usado em muitas situa&ccedil;&otilde;es diferentes. Padr&otilde;es s&atilde;o <a href="http://en.wikipedia.org/wiki/Boas_pr%C3%A1ticas" id="w">melhores pr&aacute;ticas</a> formalizadas que o programador pode usar para resolver problemas comuns quando projetar uma aplica&ccedil;&atilde;o ou sistema. Padr&otilde;es de projeto <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_orientada_a_objetos" id="w">orientados a objeto</a> normalmente mostram relacionamentos e <a href="http://en.wikipedia.org/wiki/Intera%C3%A7%C3%A3o" id="w">intera&ccedil;&otilde;es</a> entre <a href="http://en.wikipedia.org/wiki/Classe_(programa%C3%A7%C3%A3o)" id="w">classes</a> ou <a href="http://en.wikipedia.org/wiki/Objeto_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">objetos</a>, sem especificar as classes ou objetos da aplica&ccedil;&atilde;o final que est&atilde;o envolvidas. Padr&otilde;es que implicam <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_orientada_a_objetos" id="w">orienta&ccedil;&atilde;o a objetos</a> ou estado mut&aacute;vel mais geral, n&atilde;o s&atilde;o t&atilde;o aplic&aacute;veis em linguagens de <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_funcional" id="w">programa&ccedil;&atilde;o funcional</a>.</p>&#10;<p>Padr&otilde;es de projeto residem no dom&iacute;nio de m&oacute;dulos e interconex&otilde;es. Em um n&iacute;vel mais alto h&aacute; <a href="http://en.wikipedia.org/wiki/Padr%C3%B5es_arquiteturais" id="w">padr&otilde;es arquiteturais</a> que s&atilde;o maiores em escopo, usualmente descrevendo um padr&atilde;o global seguido por um sistema inteiro.<sup id="_ref&shy;R.C.Martin_a" class="reference"><a href="#_note&shy;R.C.Martin" title="">[1]</a></sup></p>&#10;<p>Um padr&atilde;o de projeto define : &#10;</p>&#10;<ul>&#10;<li>seu nome,</li>&#10;<li>o problema, </li>&#10;<li>quando aplicar esta solu&ccedil;&atilde;o e </li>&#10;<li>suas consequ&ecirc;ncias.</li></ul>&#10;<p>Os padr&otilde;es de projeto :&#10;</p>&#10;<ul>&#10;<li>visam facilitar a reutiliza&ccedil;&atilde;o de solu&ccedil;&otilde;es de desenho &shy; isto &eacute;, solu&ccedil;&otilde;es na fase de projeto do software &shy; e</li>&#10;<li>estabelecem um vocabul&aacute;rio comum de desenho, facilitando comunica&ccedil;&atilde;o, documenta&ccedil;&atilde;o e aprendizado dos sistemas de <i>software</i>.</li></ul>&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2> Hist&oacute;ria </h2>&#10;<p><b>Christopher Alexander</b><sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup><sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup><sup id="_ref&shy;4" class="reference"><a href="#_note&shy;4" title="">[4]</a></sup> em seus livros (1977/1979) <i> Notes on the Synthesis of Form</i>, <i> The Timeless Way of Building</i> e <i> A Pattern Language</i>, estabelece que um padr&atilde;o deve ter, idealmente, as seguintes caracter&iacute;sticas:&#10;</p>&#10;<ul>&#10;<li><b>Encapsulamento:</b> um padr&atilde;o encapsula um problema ou solu&ccedil;&atilde;o bem definida. Ele deve ser independente, espec&iacute;fico e formulado de maneira a ficar claro onde ele se aplica.</li>&#10;<li><b>Generalidade:</b> todo padr&atilde;o deve permitir a constru&ccedil;&atilde;o de outras realiza&ccedil;&otilde;es a partir deste padr&atilde;o. </li>&#10;<li><b>Equil&iacute;brio:</b> quando um padr&atilde;o &eacute; utilizado em uma aplica&ccedil;&atilde;o, o equil&iacute;brio d&aacute; a raz&atilde;o, relacionada com cada uma das restri&ccedil;&otilde;es envolvidas, para cada passo do projeto. Uma an&aacute;lise racional que envolva uma abstra&ccedil;&atilde;o de dados emp&iacute;ricos, uma observa&ccedil;&atilde;o da aplica&ccedil;&atilde;o de padr&otilde;es em artefatos tradicionais, uma s&eacute;rie convincente de exemplos e uma an&aacute;lise de solu&ccedil;&otilde;es ruins ou fracassadas pode ser a forma de encontrar este equil&iacute;brio. </li>&#10;<li><b>Abstra&ccedil;&atilde;o:</b> os padr&otilde;es representam abstra&ccedil;&otilde;es da <a href="http://en.wikipedia.org/wiki/Empirismo" id="w">experi&ecirc;ncia emp&iacute;rica</a> ou do conhecimento cotidiano. </li>&#10;<li><b>Abertura:</b> um padr&atilde;o deve permitir a sua extens&atilde;o para n&iacute;veis mais baixos de detalhe.</li>&#10;<li><b>Combinatoriedade:</b> os padr&otilde;es s&atilde;o relacionados hierarquicamente. Padr&otilde;es de alto n&iacute;vel podem ser compostos ou relacionados com padr&otilde;es que endere&ccedil;am problemas de n&iacute;vel mais baixo.</li></ul>&#10;<p>Al&eacute;m da defini&ccedil;&atilde;o das caracter&iacute;sticas de um padr&atilde;o, Alexander definiu o formato que a descri&ccedil;&atilde;o de um padr&atilde;o deve ter. Ele estabeleceu que um padr&atilde;o deve ser descrito em cinco partes:&#10;</p>&#10;<ul>&#10;<li><b>Nome:</b> uma descri&ccedil;&atilde;o da solu&ccedil;&atilde;o, mais do que do problema ou do contexto.</li>&#10;<li><b>Exemplo:</b> uma ou mais figuras, diagramas ou descri&ccedil;&otilde;es que ilustrem um prot&oacute;tipo de aplica&ccedil;&atilde;o.</li>&#10;<li><b>Contexto:</b> a descri&ccedil;&atilde;o das situa&ccedil;&otilde;es sob as quais o padr&atilde;o se aplica. </li>&#10;<li><b>Problema:</b> uma descri&ccedil;&atilde;o das for&ccedil;as e restri&ccedil;&otilde;es envolvidos e como elas interagem.</li>&#10;<li><b>Solu&ccedil;&atilde;o:</b> relacionamentos est&aacute;ticos e regras din&acirc;micas descrevendo como construir artefatos de acordo com o padr&atilde;o, freq&uuml;entemente citando varia&ccedil;&otilde;es e formas de ajustar a solu&ccedil;&atilde;o segundo as circunst&acirc;ncias. Inclui refer&ecirc;ncias a outras solu&ccedil;&otilde;es e o relacionamento com outros padr&otilde;es de n&iacute;vel mais baixo ou mais alto.</li></ul>&#10;<p>Em <a href="http://en.wikipedia.org/wiki/1987" id="w">1987</a>, a partir dos conceitos criados por Alexander, os <a href="http://en.wikipedia.org/wiki/Programador" id="w">programadores</a> <a href="http://en.wikipedia.org/wiki/Kent_Beck" id="w">Kent Beck</a> e <a href="http://en.wikipedia.org/wiki/Ward_Cunningham" id="w">Ward Cunningham</a> propuseram os primeiros padr&otilde;es de projeto para a &aacute;rea da <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">ci&ecirc;ncia da computa&ccedil;&atilde;o</a>. Em um trabalho para a confer&ecirc;ncia <a href="http://en.wikipedia.org/wiki/OOPSLA" id="w">OOPSLA</a>, eles apresentaram alguns padr&otilde;es para a constru&ccedil;&atilde;o de janelas na <a href="http://en.wikipedia.org/wiki/Smalltalk" id="w">linguagem Smalltalk</a>.<sup id="_ref&shy;5" class="reference"><a href="#_note&shy;5" title="">[5]</a></sup> Nos anos seguintes Beck, Cunningham e outros seguiram com o desenvolvimento destas id&eacute;ias.</p>&#10;<p>O movimento ao redor de padr&otilde;es de projeto ganhou popularidade com o livro <i><a href="http://en.wikipedia.org/wiki/Design_Patterns:_Elements_of_Reusable_Object&shy;Oriented_Software" id="w">Design Patterns: Elements of Reusable Object&shy;Oriented Software</a></i>, publicado em <a href="http://en.wikipedia.org/wiki/1995" id="w">1995</a>. Os autores desse livro, <a href="http://en.wikipedia.org/wiki/Erich_Gamma" id="w">Erich Gamma</a>, <a href="http://en.wikipedia.org/wiki/Richard_Helm" id="w">Richard Helm</a>, <a href="http://en.wikipedia.org/wiki/Ralph_Johnson" id="w">Ralph Johnson</a> e <a href="http://en.wikipedia.org/wiki/John_Vlissides" id="w">John Vlissides</a>, s&atilde;o conhecidos como a &#34&semi;<a href="http://en.wikipedia.org/wiki/Gangue_dos_quatro" id="w">Gangue dos Quatro</a>&#34&semi; (Gang of Four) ou simplesmente &#34&semi;<b>GoF</b>&#34&semi;.</p>&#10;<p>Posteriormente, v&aacute;rios outros livros do estilo foram publicados, merecendo destaque <i>Applying UML and Patterns: An Introduction to Object&shy;Oriented Analysis and Design and Iterative Development</i>, que introduziu um conjunto de padr&otilde;es conhecidos como <b>GRASP</b> (<i>General Responsibility Assignment Software Patterns</i>).</p>&#10;<a id="Padr%C3%B5es_GoF" name="Padr%C3%B5es_GoF"></a><h2> Padr&otilde;es GoF </h2>&#10;<p>Os padr&otilde;es &#34&semi;GoF&#34&semi; s&atilde;o organizados em 3 fam&iacute;lias : &#10;</p>&#10;<ul>&#10;<li><b>Padr&otilde;es de cria&ccedil;&atilde;o</b> : relacionados &agrave; cria&ccedil;&atilde;o de objetos</li>&#10;<li><b>Padr&otilde;es estruturais</b> : tratam das associa&ccedil;&otilde;es entre classes e objetos.</li>&#10;<li><b>Padr&otilde;es comportamentais</b> : tratam das intera&ccedil;&otilde;es e divis&otilde;es de responsabilidades entre as classes ou objetos.</li></ul>&#10;<p>Padr&otilde;es &#34&semi;GoF&#34&semi; organizados nas suas 3 fam&iacute;lias:</p>&#10;<a id="Padr%C3%B5es_de_cria%C3%A7%C3%A3o" name="Padr%C3%B5es_de_cria%C3%A7%C3%A3o"></a><h4> Padr&otilde;es de cria&ccedil;&atilde;o </h4>&#10;<p />&#10;<div class="references" style="&shy;moz&shy;column&shy;count:3&semi; column&shy;count:3&semi;">&#10;&#10;<ul>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Abstract_Factory" id="w">Abstract Factory</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Builder" id="w">Builder</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Factory_Method" id="w">Factory Method</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Prototype" id="w">Prototype</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Singleton" id="w">Singleton</a></i></li></ul>&#10;<p /></div>&#10;&#10;<a id="Padr%C3%B5es_estruturais" name="Padr%C3%B5es_estruturais"></a><h4> Padr&otilde;es estruturais </h4>&#10;<p />&#10;<div class="references" style="&shy;moz&shy;column&shy;count:3&semi; column&shy;count:3&semi;">&#10;&#10;<ul>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Adapter" id="w">Adapter</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Bridge_(padr%C3%A3o_de_projeto_de_software)" id="w">Bridge</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Composite" id="w">Composite</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Decorator" id="w">Decorator</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Fa%C3%A7ade" id="w">Fa&ccedil;ade</a></i> (ou <i>Facade</i>)</li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Flyweight" id="w">Flyweight</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Proxy_(padr%C3%B5es_de_projeto)" id="w">Proxy</a></i></li></ul>&#10;<p /></div>&#10;&#10;<a id="Padr%C3%B5es_comportamentais" name="Padr%C3%B5es_comportamentais"></a><h4> Padr&otilde;es comportamentais </h4>&#10;<p />&#10;<div class="references" style="&shy;moz&shy;column&shy;count:3&semi; column&shy;count:3&semi;">&#10;&#10;<ul>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Chain_of_Responsibility" id="w">Chain of Responsibility</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Command" id="w">Command</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Interpreter" id="w">Interpreter</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Iterator" id="w">Iterator</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Mediator" id="w">Mediator</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Memento_(inform%C3%A1tica)" id="w">Memento</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Observer" id="w">Observer</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/State" id="w">State</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Strategy" id="w">Strategy</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Template_Method" id="w">Template Method</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Visitor_pattern" id="w">Visitor</a></i></li></ul>&#10;<p /></div>&#10;&#10;<p>Um padr&atilde;o &#34&semi;GoF&#34&semi; tamb&eacute;m &eacute; classificado segundo o seu escopo em 2 outros grupos : &#10;</p>&#10;<ul>&#10;<li><b>Padr&otilde;es com escopo de classe</b> : definido por relacionamentos de <a href="http://en.wikipedia.org/wiki/Heran%C3%A7a" id="w">heran&ccedil;a</a> e em <a href="http://en.wikipedia.org/wiki/Tempo_de_compila%C3%A7%C3%A3o" id="w">tempo de compila&ccedil;&atilde;o</a>. </li>&#10;<li><b>Padr&otilde;es com escopo de objeto</b> : encontrados no relacionamento entre os objetos definidos em <a href="http://en.wikipedia.org/wiki/Tempo_de_execu%C3%A7%C3%A3o" id="w">tempo de execu&ccedil;&atilde;o</a>.</li></ul>&#10;<a id="Padr%C3%B5es_GRASP" name="Padr%C3%B5es_GRASP"></a><h2> Padr&otilde;es GRASP </h2>&#10;&#10;<p>Os padr&otilde;es GRASP, sigla para <b>General Responsibility Assignment Software Patterns</b> (or <b>Principles</b>), consistem de um conjunto de pr&aacute;ticas para atribui&ccedil;&atilde;o de responsabilidades a classes e objetos em projetos orientados a objeto.</p>&#10;<p>Os padr&otilde;es utilizados pelo GRASP s&atilde;o: Controlador (Controller), Criador (Creator), Indire&ccedil;&atilde;o (Indirection), Especialista na informa&ccedil;&atilde;o (Information expert), Alta coes&atilde;o (High Cohesion), Baixo acoplamento (Loose coupling), Polimorfismo (Polymorphism), Varia&ccedil;&otilde;es protegidas (Protected variations), e Inven&ccedil;&atilde;o pura (Pure fabrication).</p>&#10;<p>Todos esses padr&otilde;es servem para a resolu&ccedil;&atilde;o de problemas comuns e bastante t&iacute;picos de desenvolvimento de software orientado a objeto. Portanto, tais t&eacute;cnicas apenas documentam e normatizam as pr&aacute;ticas j&aacute; consolidadas, testadas e conhecidas no mercado.</p>&#10;<p>Os padr&otilde;es GRASP est&atilde;o mais como uma ferramenta mental ou uma filosofia de design, mas que ainda assim s&atilde;o &uacute;teis para o aprendizado e desenvolvimento de um bom design de software. Note que alguns padr&otilde;es GoF implementam solu&ccedil;&otilde;es correspondentes com padr&otilde;es GRASP.</p>&#10;<p>A principal obra sobre o assunto foi o livro &#34&semi;Utilizando UML e Padr&otilde;es&#34&semi; de autoria de Craig Larman.<sup id="_ref&shy;6" class="reference"><a href="#_note&shy;6" title="">[6]</a></sup></p>&#10;<a id="Padr%C3%B5es" name="Padr%C3%B5es"></a><h3> Padr&otilde;es </h3>&#10;<p />&#10;<div class="references" style="&shy;moz&shy;column&shy;count:3&semi; column&shy;count:3&semi;">&#10;&#10;<ul>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Especialista_na_Informa%C3%A7%C3%A3o" id="w">Especialista na Informa&ccedil;&atilde;o</a></i></li>&#10;<li><i>Criador</i> (ver <a href="http://en.wikipedia.org/wiki/Factory_Method" id="w">Factory Method</a>)</li>&#10;<li><i>Controlador</i> (ver <a href="http://en.wikipedia.org/wiki/Model&shy;view&shy;controller" id="w">Model&shy;view&shy;controller</a>)</li>&#10;<li><i>Acoplamento fraco</i> (ver <a href="http://en.wikipedia.org/wiki/Acoplamento_(programa%C3%A7%C3%A3o_de_computadores)" id="w">Acoplamento</a>))</li>&#10;<li><i>Alta coes&atilde;o</i> (ver <a href="http://en.wikipedia.org/wiki/Coes%C3%A3o" id="w">Coes&atilde;o</a>)</li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Polimorfismo" id="w">Polimorfismo</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Indire%C3%A7%C3%A3o" id="w">Indire&ccedil;&atilde;o</a></i></li>&#10;<li><i><a href="http://en.wikipedia.org/wiki/Varia%C3%A7%C3%B5es_Protegidas" id="w">Varia&ccedil;&otilde;es Protegidas</a></i></li></ul>&#10;<p /></div>&#10;&#10;<a id="Cr%C3%ADticas" name="Cr%C3%ADticas"></a><h2>Cr&iacute;ticas</h2>&#10;&#10;<p>Segundo alguns, alguns &#39&semi;Padr&otilde;es de Projeto&#39&semi; s&atilde;o apenas evid&ecirc;ncias de que alguns recursos est&atilde;o ausentes em uma determinada linguagem de programa&ccedil;&atilde;o (<a href="http://en.wikipedia.org/wiki/Java_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Java</a> ou <a href="http://en.wikipedia.org/wiki/C%2B%2B" id="w">C++</a> por exemplo). Nesta linha, Peter Norvig demonstra que 16 dos 23 padr&otilde;es do livro &#39&semi;Design Patterns&#39&semi; s&atilde;o simplificados ou eliminados nas linguagens Lisp ou Dylan, usando os recursos diretos destas linguagens.<sup id="_ref&shy;Norvig1998_a" class="reference"><a href="#_note&shy;Norvig1998" title="">[7]</a></sup></p>&#10;<p>Segundo outros, excessos nas tentativas de fazer o c&oacute;digo se conformar aos &#39&semi;Padr&otilde;es de Projeto&#39&semi; aumentam desnecessariamente a sua complexidade.<sup id="_ref&shy;CodeComplete2_a" class="reference"><a href="#_note&shy;CodeComplete2" title="">[8]</a></sup></p>&#10;<a id="Bibliografia" name="Bibliografia"></a><h2> Bibliografia </h2>&#10;&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li></ul>&#10;<p> </p>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;<p> &#10;</p>&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Programa%C3%A7%C3%A3o_orientada_a_objetos" id="w">Categoria:Programa&ccedil;&atilde;o orientada a objetos</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Padr%C3%B5es_de_projeto_de_software" id="w"> </a></p></body></html>