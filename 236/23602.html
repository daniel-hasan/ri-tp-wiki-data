<html><title>Algoritmo de Dijkstra</title><body>&#10;<p> &#10; </p>&#10;<p>O <b>algoritmo de Dijkstra</b>, concebido pelo <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">cientista da computa&ccedil;&atilde;o</a> holand&ecirc;s <a href="http://en.wikipedia.org/wiki/Edsger_Dijkstra" id="w">Edsger Dijkstra</a> em 1956 e publicado em 1959<sup id="_ref&shy;Dijkstra Interview_a" class="reference"><a href="#_note&shy;Dijkstra Interview" title="">[1]</a></sup><sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup>, soluciona o <a href="http://en.wikipedia.org/wiki/Problema_do_caminho_mais_curto" id="w">problema do caminho mais curto</a> num <a href="http://en.wikipedia.org/wiki/Grafo_dirigido" id="w">grafo dirigido</a> ou n&atilde;o dirigido com arestas de peso n&atilde;o negativo, em tempo computacional O([m+n]log n) onde m &eacute; o n&uacute;mero de arestas e n &eacute; o n&uacute;mero de v&eacute;rtices. O algoritmo que serve para resolver o mesmo problema em um grafo com pesos negativos &eacute; o <a href="http://en.wikipedia.org/wiki/Algoritmo_de_Bellman&shy;Ford" id="w">algoritmo de Bellman&shy;Ford</a>, que possui maior tempo de execu&ccedil;&atilde;o que o Dijkstra.</p>&#10;<p>O <b>algoritmo de Dijkstra</b> assemelha&shy;se ao <a href="http://en.wikipedia.org/wiki/BFS" id="w">BFS</a>, mas &eacute; um algoritmo guloso, ou seja, toma a decis&atilde;o que parece &oacute;tima no momento. Para a teoria dos grafos uma &#34&semi;estrat&eacute;gia gulosa&#34&semi; &eacute; conveniente j&aacute; que sendo P um menor caminho entre 2 v&eacute;rtices U e V, todo sub&shy;caminho de P &eacute; um menor caminho entre 2 v&eacute;rtices pertencentes ao caminho P, desta forma constru&iacute;mos os melhores caminhos dos v&eacute;rtices alcan&ccedil;&aacute;veis pelo v&eacute;rtice inicial determinando todos os melhores caminhos intermedi&aacute;rios. Nota: diz&shy;se &#39&semi;um menor caminho&#39&semi; pois caso existam 2 &#39&semi;menores caminhos&#39&semi; apenas um ser&aacute; descoberto.</p>&#10;<p>O algoritmo considera um conjunto S de menores caminhos, iniciado com um v&eacute;rtice inicial I. A cada passo do algoritmo busca&shy;se nas adjac&ecirc;ncias dos v&eacute;rtices pertencentes a S aquele v&eacute;rtice com menor dist&acirc;ncia relativa a I e adiciona&shy;o a S e, ent&atilde;o, repetindo os passos at&eacute; que todos os v&eacute;rtices alcan&ccedil;&aacute;veis por I estejam em S. Arestas que ligam v&eacute;rtices j&aacute; pertencentes a S s&atilde;o desconsideradas.</p>&#10;<p>Um exemplo pr&aacute;tico do problema que pode ser resolvido pelo algoritmo de Dijkstra &eacute;: algu&eacute;m precisa se deslocar de uma cidade para outra. Para isso, ela disp&otilde;e de v&aacute;rias estradas, que passam por diversas cidades. Qual delas oferece uma <a href="http://en.wikipedia.org/wiki/Trajet%C3%B3ria" id="w">trajet&oacute;ria</a> de menor caminho?</p>&#10;<a id="Algoritmo_de_Dijkstra" name="Algoritmo_de_Dijkstra"></a><h2> Algoritmo de Dijkstra </h2>&#10;&#10;&#10;<ul>&#10;<li><b>1&ordm; passo:</b> iniciam&shy;se os valores:</li></ul> &#10;<pre>para todo v &isin; V[G]&#10;     d[v]&larr; &infin; &#10;     &pi;[v] &larr; &shy;1&#10;d[s] &larr; 0&#10;</pre>&#10;<p>V[G] &eacute; o conjunto de v&eacute;rtices(v) que formam o Grafo G.&#10;d[v] &eacute; o vetor de dist&acirc;ncias de s at&eacute; cada v.&#10;Admitindo&shy;se a pior estimativa poss&iacute;vel, o caminho infinito.&#10;&pi;[v] identifica o v&eacute;rtice de onde se origina uma conex&atilde;o at&eacute; v de maneira a formar um caminho m&iacute;nimo.</p>&#10;&#10;<ul>&#10;<li><b>2&ordm; passo:</b> temos que usar o conjunto <i>Q</i>, cujos v&eacute;rtices ainda n&atilde;o cont&eacute;m o custo do menor caminho d[v] determinado.</li></ul>&#10;<pre>Q &larr; V[G]&#10;&#10;</pre>&#10;<ul>&#10;<li><b>3&ordm; passo:</b> realizamos uma s&eacute;rie de <b>relaxamentos</b> das arestas, de acordo com o c&oacute;digo:</li></ul>&#10;<pre>enquanto Q &ne; &oslash;&#10;         u &larr; extrair&shy;m&iacute;n(Q)                     //Q &larr; Q &shy; {u}&#10;         para cada v adjacente a u&#10;              se d[v] &#62&semi; d[u] + w(u, v)          //relaxe (u, v)&#10;                 ent&atilde;o d[v] &larr; d[u] + w(u, v)&#10;                       &pi;[v] &larr; u&#10;                       Q &larr; Q &cup; {v}&#10;</pre>&#10;<p>w(u, v) &eacute; o peso(weight) da aresta que vai de u a v.</p>&#10;<p>u e v s&atilde;o v&eacute;rtices quaisquer e s &eacute; o v&eacute;rtice inicial.&#10;ffd&#10;extrair&shy;m&iacute;n(Q), pode usar um <a href="http://en.wikipedia.org/wiki/Heap" id="w">heap</a> de m&iacute;nimo ou uma lista de v&eacute;rtices onde se extrai o elemento u com menor valor d[u].</p>&#10;<p>No final do algoritmo teremos o menor caminho entre <i>s</i> e qualquer outro v&eacute;rtice de G. O algoritmo leva tempo O(m + n log n) caso seja usado um <a href="http://en.wikipedia.org/wiki/Heap_de_Fibonacci" id="w">heap de Fibonacci</a>, O(m log n) caso seja usado um <a href="http://en.wikipedia.org/wiki/Heap_bin%C3%A1rio" id="w">heap bin&aacute;rio</a> e O(n&sup2;) caso seja usado um vetor para armazenar Q.</p>&#10;<a id="Problemas_relacionados" name="Problemas_relacionados"></a><h2> Problemas relacionados </h2>&#10;<p>O algoritmo de Dijkstra n&atilde;o consegue encontrar o menor caminho em um grafo com pesos negativos. Para esse prop&oacute;sito, pode&shy;se usar o <a href="http://en.wikipedia.org/wiki/Algoritmo_de_Floyd&shy;Warshall" id="w">algoritmo de Floyd&shy;Warshall</a>, que consegue descobrir a menor dist&acirc;ncia entre todos os pares de v&eacute;rtices de qualquer grafo sem ciclos com peso negativo em uma complexidade de tempo O(V&sup3;). Se o problema n&atilde;o exigir o c&aacute;lculo da dist&acirc;ncia entre todos os pares de v&eacute;rtices ou se existirem ciclos com peso negativo, pode&shy;se aplicar o algoritmo de Bellman&shy;Ford, com complexidade de tempo O(V*E).&#10;Em uma &aacute;rvore, &eacute; poss&iacute;vel encontrar a dist&acirc;ncia entre um v&eacute;rtice inicial e todos os outros v&eacute;rtices em tempo O(V+E), utilizando <a href="http://en.wikipedia.org/wiki/Busca_em_profundidade" id="w">busca em profundidade</a> (tamb&eacute;m conhecida como DFS). Em um grafo cujas arestas t&ecirc;m todas o mesmo peso, pode&shy;se encontrar a dist&acirc;ncia entre um v&eacute;rtice inicial e todos os outros v&eacute;rtices, para um grafo qualquer, em O(V+E), utilizando <a href="http://en.wikipedia.org/wiki/Busca_em_largura" id="w">busca em largura</a> (tamb&eacute;m conhecida como BFS).&#10;O processo utilizado no algoritmo de Dijkstra &eacute; bastante similar ao processo usado no <a href="http://en.wikipedia.org/wiki/Algoritmo_de_Prim" id="w">algoritmo de Prim</a>. O prop&oacute;sito deste &uacute;ltimo, entretanto, &eacute; encontrar a <a href="http://en.wikipedia.org/wiki/&Aacute;rvore_geradora_m%C3%ADnima" id="w">&aacute;rvore geradora m&iacute;nima</a> que conecta todos os n&oacute;s de um grafo.</p>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Algoritmo_de_Floyd&shy;Warshall" id="w">Algoritmo de Floyd&shy;Warshall</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Algoritmo_de_Bellman&shy;Ford" id="w">Algoritmo de Bellman&shy;Ford</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Algoritmo_A%2A" id="w">Algoritmo A*</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Busca_em_profundidade" id="w">Busca em profundidade</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Busca_em_largura" id="w">Busca em largura</a></li></ul>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://www.inf.ufsc.br/grafos/temas/custo&shy;minimo/dijkstra.html" rel="nofollow" title="http://www.inf.ufsc.br/grafos/temas/custo&shy;minimo/dijkstra.html">Artigo explicativo sobre o algoritmo</a></li>&#10;<li><a class="externallink" href="http://www.vivaolinux.com.br/script/Algoritmo&shy;de&shy;Dijkstra" rel="nofollow" title="http://www.vivaolinux.com.br/script/Algoritmo&shy;de&shy;Dijkstra">Artigo e Implementa&ccedil;&atilde;o do Algoritmo de Dijkstra em C</a></li>&#10;<li>  <a class="externallink" href="http://www.codeproject.com/useritems/Shortest_Path_Problem.asp" rel="nofollow" title="http://www.codeproject.com/useritems/Shortest_Path_Problem.asp">Algoritmo de Dijkstra em C#</a></li>&#10;<li>  <a class="externallink" href="http://www&shy;b2.is.tokushima&shy;u.ac.jp/~ikeda/suuri/dijkstra/Dijkstra.shtml" rel="nofollow" title="http://www&shy;b2.is.tokushima&shy;u.ac.jp/~ikeda/suuri/dijkstra/Dijkstra.shtml">Applet do algoritmo de Dijkstra</a></li>&#10;<li>  <a class="externallink" href="http://optlab&shy;server.sce.carleton.ca/POAnimations2007/DijkstrasAlgo.html" rel="nofollow" title="http://optlab&shy;server.sce.carleton.ca/POAnimations2007/DijkstrasAlgo.html">Simula&ccedil;&atilde;o do algoritmo de Dijkstra</a></li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos_de_grafos" id="w">Dijkstra</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos_de_busca" id="w">Categoria:Algoritmos de busca</a></p></body></html>