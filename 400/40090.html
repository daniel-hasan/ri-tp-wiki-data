<html><title>QNX</title><body>&#10;<p> &#10; &#10;O <b>QNX</b> &eacute; um <a href="http://en.wikipedia.org/wiki/Sistema_operacional" id="w">sistema operacional</a> do <a href="http://en.wikipedia.org/wiki/Sistema_operacional_tipo_Unix" id="w">tipo Unix</a>, de <a href="http://en.wikipedia.org/wiki/Tempo_real" id="w">tempo real</a> e arquitetura <a href="http://en.wikipedia.org/wiki/Micron%C3%BAcleo_(inform%C3%A1tica)" id="w">micron&uacute;cleo</a> inicialmente desenvolvido pela empresa <a href="http://en.wikipedia.org/wiki/QNX_Software_Systems" id="w">QNX Software Systems</a> e destinado sobretudo a <a href="http://en.wikipedia.org/wiki/Sistema_embarcado" id="w">sistemas embarcados</a>. &Eacute; utilizado em processos altamente cr&iacute;ticos como controle de v&ocirc;o, controle de esteiras de f&aacute;bricas, sinais de tr&acirc;nsito, usinas nucleares e equipamentos m&eacute;dicos<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup> <sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup>, &eacute; tamb&eacute;m utilizado como interface gr&aacute;fica em autom&oacute;veis<sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup> e como base do sistema operacional utilizado no <a href="http://en.wikipedia.org/wiki/BlackBerry_PlayBook" id="w">BlackBerry PlayBook</a>.<sup id="_ref&shy;playbook_a" class="reference"><a href="#_note&shy;playbook" title="">[4]</a></sup></p>&#10;<a id="Descri%C3%A7%C3%A3o" name="Descri%C3%A7%C3%A3o"></a><h2> Descri&ccedil;&atilde;o </h2>&#10;<p>O QNX &eacute; um sistema operacional <a href="http://en.wikipedia.org/wiki/Multiusu%C3%A1rio" id="w">multiusu&aacute;rio</a> e <a href="http://en.wikipedia.org/wiki/Multitarefa" id="w">multitarefa</a> utilizado em opera&ccedil;&otilde;es que necessitam de equipamentos com estabilidade total na realiza&ccedil;&atilde;o das tarefas, onde &eacute; prioridade &eacute; a estabilidade e seguran&ccedil;a.<sup id="_ref&shy;5" class="reference"><a href="#_note&shy;5" title="">[5]</a></sup>&#10;QNX &eacute; utilizado em roteadores de rede, instrumentos m&eacute;dicos, unidades telem&aacute;ticas de ve&iacute;culos, sistemas de seguran&ccedil;a e de defesa, rob&oacute;tica industrial e outras aplica&ccedil;&otilde;es de miss&otilde;es cr&iacute;ticas.</p>&#10;<p>O desenvolvimento de aplicativos sob QNX &eacute; realizado atrav&eacute;s do compilador Watcom <a href="http://en.wikipedia.org/wiki/C" id="w">C</a> ou <a href="http://en.wikipedia.org/wiki/C%2B%2B" id="w">C++</a>. Existe, entretanto, uma vers&atilde;o do compilador <a href="http://en.wikipedia.org/wiki/GNU" id="w">GNU</a> C/C++, para o QNX.<sup id="_ref&shy;6" class="reference"><a href="#_note&shy;6" title="">[6]</a></sup> A parte visual do QNX &eacute; realizada pela sua pr&oacute;pria interface gr&aacute;fica, a <a href="http://en.wikipedia.org/wiki/PHOTON" id="w">PHOTON</a>. As atuais vers&otilde;es do QNX j&aacute; vem com diversos aplicativos dispon&iacute;veis, inclusive um navegador para <a href="http://en.wikipedia.org/wiki/Internet" id="w">internet</a> pr&oacute;prio, o &#34&semi;Voyager&#34&semi;.<sup id="_ref&shy;7" class="reference"><a href="#_note&shy;7" title="">[7]</a></sup></p>&#10;<p>Em 2010, a <a href="http://en.wikipedia.org/wiki/Research_In_Motion" id="w">Research In Motion</a> (RIM), fabricante do <a href="http://en.wikipedia.org/wiki/BlackBerry" id="w">BlackBerry</a>, adquiriu o QNX e o implementou em seu primeiro tablet PC, o PlayBook, concorrente direto do iPad, da Apple.<sup id="_ref&shy;playbook_b" class="reference"><a href="#_note&shy;playbook" title="">[4]</a></sup></p>&#10;<a id="Arquitetura_do_N%C3%BAcleo_(Kernel)" name="Arquitetura_do_N%C3%BAcleo_(Kernel)"></a><h2> Arquitetura do N&uacute;cleo (Kernel) </h2>&#10;<p>O n&uacute;cleo do QNX &eacute; de um tipo chamado <a href="http://en.wikipedia.org/wiki/Micron%C3%BAcleo" id="w">micron&uacute;cleo</a>. Ao contr&aacute;rio dos <a href="http://en.wikipedia.org/wiki/N%C3%BAcleo_monol%C3%ADtico" id="w">n&uacute;cleos monol&iacute;ticos</a>, a id&eacute;ia &eacute; desenvolver o m&iacute;nimo de opera&ccedil;&otilde;es necess&aacute;rias dentro do <a href="http://en.wikipedia.org/wiki/N%C3%BAcleo_(inform%C3%A1tica)" id="w">n&uacute;cleo</a>. Os outros servi&ccedil;os s&atilde;o providos atrav&eacute;s de outros processos opcionais. No QNX o n&uacute;cleo chamado de <b>&#34&semi;procnto&#34&semi;</b>.</p>&#10;<p>A id&eacute;ia n&atilde;o &eacute; simplesmente fazer um kernel pequeno, mas sim dar modularidade a ele, o que consequentemente diminuir&aacute; o tamanho. Ele &eacute; utilizado para juntar os m&oacute;dulos do sistema operacional. O kernel foi desenvolvido na <a href="http://en.wikipedia.org/wiki/Linguagem_C" id="w">linguagem C</a>. A alta performance est&aacute; relacionada &agrave;s sucessivas redefini&ccedil;&otilde;es de algoritmos e estruturas de dados. Desde sistemas embarcados com mem&oacute;ria extremamente limitada &agrave; sistemas com gigabytes de mem&oacute;ria rodam o QNX.</p>&#10;<p>A maioria dos servi&ccedil;os de tempo real e threads s&atilde;o implementados diretamente no n&uacute;cleo, o que dispensa m&oacute;dulos adicionais para o acesso a esses servi&ccedil;os. Al&eacute;m disso, v&aacute;rios outros servi&ccedil;os s&atilde;o suportados, como <a href="http://en.wikipedia.org/wiki/Sem%C3%A1foro_(computa%C3%A7%C3%A3o)" id="w">sem&aacute;foros</a> e <a href="http://en.wikipedia.org/wiki/Exclus%C3%A3o_m%C3%BAtua" id="w">mutexes</a>. Opera&ccedil;&otilde;es que exigem mais recursos, s&atilde;o carregadas em processos externos.</p>&#10;<a id="Chamadas_ao_Sistema_(System_Calls)" name="Chamadas_ao_Sistema_(System_Calls)"></a><h2> Chamadas ao Sistema (System Calls) </h2>&#10;<p>O QNX, por se tratar de um sistema micron&uacute;cleo, implementa um sistema de mensageria, o IPC (Interprocess Communication). Estas mensagens s&atilde;o pacotes de <a href="http://en.wikipedia.org/wiki/Byte" id="w">bytes</a> passados de um processo para o outro, que permitem transmitir dados e meios de sincroniza&ccedil;&atilde;o da execu&ccedil;&atilde;o de v&aacute;rios processos.&#10;O IPC supervisiona o roteamento de mensagens e tamb&eacute;m gerencia as mensagens de proxies e sinais.&#10;</p>&#10;<ul>&#10;<li>Mensagens: Fornece comunica&ccedil;&atilde;o s&iacute;ncrona entre processos cooperativos, onde o remetente exige uma prova de recebimento e uma confirma&ccedil;&atilde;o para mensagem.</li>&#10;<li>Proxies: S&atilde;o especialmente adequados para notifica&ccedil;&atilde;o de eventos onde o remetente n&atilde;o precisa interagir com destinat&aacute;rio</li>&#10;<li>Sinais: Usados para suportar comunica&ccedil;&atilde;o ass&iacute;ncrona  entre processos.</li></ul>&#10;<a id="Mensagens" name="Mensagens"></a><h3> Mensagens </h3>&#10;<p>Como o IPC de mensagens espera uma confirma&ccedil;&atilde;o de recebimento, no seu conte&uacute;do ela utiliza fun&ccedil;&otilde;es da <a href="http://en.wikipedia.org/wiki/Linguagem_C" id="w">linguagem C</a>. Quando &eacute; realizada a sincroniza&ccedil;&atilde;o entre processos, s&atilde;o utilizadas as fun&ccedil;&otilde;es SEND(), RECEIVE() e REPLY.  A partir do momento que uma mensagem de sincroniza&ccedil;&atilde;o &eacute; disparada, o processo remetente fica em estado de bloqueio, sendo liberado apenas ao receber o retorno do processo destinat&aacute;rio.</p>&#10;<a id="Proxies" name="Proxies"></a><h3> Proxies </h3>&#10;<p>&Eacute; uma forma de mensagem n&atilde;o bloqueante adequada especialmente para notifica&ccedil;&atilde;o de eventos onde o remetente n&atilde;o precisa interagir com o destinat&aacute;rio. A &uacute;nica fun&ccedil;&atilde;o de um <a href="http://en.wikipedia.org/wiki/Proxy" id="w">proxy</a> &eacute; enviar uma mensagem fixa a um processo especifico que possui o proxy, onde &eacute; poss&iacute;vel enviar a mensagem para um processo, sem que o remetente fique bloqueado ou esperando um retorno.</p>&#10;<a id="Sinais" name="Sinais"></a><h3> Sinais </h3>&#10;<p>S&atilde;o m&eacute;todos tradicionais de comunica&ccedil;&atilde;o ass&iacute;ncrona. Um sinal &eacute; considerado entregue a um processo quando a a&ccedil;&atilde;o deferida por ele &eacute; realizada pelo destinat&aacute;rio. Um processo pode estabelecer um sinal sem nenhuma interven&ccedil;&atilde;o. Nenhum dado &eacute; transmitido com sinal. Entre o tempo que o sinal &eacute; gerado e o tempo que ele &eacute; entregue, ele &eacute; considerado pendente. Os sinais s&atilde;o entregues a um processo quando o processo esta pronto para executar no <a href="http://en.wikipedia.org/wiki/Escalonamento_de_processos" id="w">escalonador</a>.</p>&#10;<p>Se o processo n&atilde;o tomar nenhuma a&ccedil;&atilde;o especial para manipular sinais, a&ccedil;&atilde;o padr&atilde;o &eacute; executada &ndash; finalizar o processo. Se o processo ignorar o sinal, n&atilde;o ocorre nenhum efeito no processo quando ele &eacute; entregue.</p>&#10;<a id="Ger%C3%AAncia_de_Processos_e_Threads" name="Ger%C3%AAncia_de_Processos_e_Threads"></a><h2> Ger&ecirc;ncia de Processos e Threads </h2>&#10;<p>&#34&semi;De forma simplificada uma <a href="http://en.wikipedia.org/wiki/Thread" id="w">thread</a> pode ser definido como uma sub&shy;rotina de um programa que pode ser executada de forma ass&iacute;ncrona, ou seja executada paralelamente ao programa chamador. O programa deve especificar os threads associando&shy;os &agrave;s sub rotinas ass&iacute;ncronas. Desta forma multithreads possibilitam a execu&ccedil;&atilde;o concorrente de sub&shy;rotinas dentro de um mesmo processo&#34&semi;.<sup id="_ref&shy;8" class="reference"><a href="#_note&shy;8" title="">[8]</a></sup></p>&#10;<p>Em ambientes multithread existe um ganho de desempenho, pois s&atilde;o diversas instru&ccedil;&otilde;es em um mesmo processo, ou seja, &eacute; como se diversos processos estivessem sendo executados de forma concorrente, por&eacute;m fazendo uso de apenas um contexto de hardware, dividindo assim o mesmo endere&ccedil;amento, com isso a comunica&ccedil;&atilde;o &eacute; bem mais r&aacute;pida, pois n&atilde;o envolve mecanismos lentos. Tamb&eacute;m n&atilde;o existe a cria&ccedil;&atilde;o, troca e elimina&ccedil;&atilde;o de processos, diminuindo assim o overhead. As threads s&atilde;o escalonadas assim como os processos.</p>&#10;<a id="Threads" name="Threads"></a><h3> Threads </h3>&#10;<p>No QNX, que &eacute; um sistema <a href="http://en.wikipedia.org/wiki/Multitarefa" id="w">multitarefa</a>, o respons&aacute;vel por decidir qual thread deve estar sendo executada em um dado instante &eacute; o <a href="http://en.wikipedia.org/wiki/Kernel" id="w">kernel</a>. Ele tamb&eacute;m &eacute; o respons&aacute;vel por escalonar, efetuar as trocas de contexto e salvar as informa&ccedil;&otilde;es da thread que esta saindo da <a href="http://en.wikipedia.org/wiki/CPU" id="w">CPU</a> nos registradores de controle. Para garantir que duas threads n&atilde;o acessem simultaneamente um recurso compartilhado (se&ccedil;&atilde;o critica), o QNX implementa a t&eacute;cnica de Exclus&atilde;o Mutua com sincroniza&ccedil;&atilde;o condicional (<a href="http://en.wikipedia.org/wiki/Sem%C3%A1foro_(computa%C3%A7%C3%A3o)" id="w">sem&aacute;foros</a>).</p>&#10;<a id="Escalonamento_(Scheduling)" name="Escalonamento_(Scheduling)"></a><h2> Escalonamento (Scheduling) </h2>&#10;<p>As decis&otilde;es de <a href="http://en.wikipedia.org/wiki/Escalonamento" id="w">escalonamento</a> s&atilde;o realizadas pelo microkernel nas seguintes situa&ccedil;&otilde;es: </p>&#10;&#10;<ul>&#10;<li>Quando o processo est&aacute; bloqueado.</li>&#10;<li>O timeslice de um processo em execu&ccedil;&atilde;o esgotou.</li>&#10;<li>Processo em execu&ccedil;&atilde;o sofre preemp&ccedil;&atilde;o.</li></ul>&#10;<p>Todo processo criado no QNX recebe uma prioridade, a qual o escalonador utiliza para selecionar o pr&oacute;ximo processo com maior prioridade que deve estar em no estado ready (pronto), ou seja, podendo utilizar os recursos da CPU.</p>&#10;<p>Os m&eacute;todos de escalonamento podem ser de tr&ecirc;s tipos: escalonamento FIFO, escalonamento <i>Round Robin</i>, e escalonamento adaptativo. Cada processo no sistema operacional pode utilizar qualquer um desses m&eacute;todos, por&eacute;m somente &eacute; aplicado os m&eacute;todos em situa&ccedil;&otilde;es com dois ou mais processos com mesma prioridade e com o estado ready, ou seja , pronto para utilizar os recursos da CPU. Caso um processo com maior prioridade torne&shy;se ready , ent&atilde;o causa a preemp&ccedil;&atilde;o dos processos de baixa prioridade.</p>&#10;<p>No escalonamento FIFO a condi&ccedil;&atilde;o que o m&eacute;todo seja executado &eacute; que o processo renuncie o controle de forma volunt&aacute;ria, n&atilde;o fazendo chamadas ao m&eacute;todo ou atrav&eacute;s de preemp&ccedil;&atilde;o por um processo com maior prioridade.</p>&#10;<p>No escalonamento <i>Round&shy;Robin</i>, a condi&ccedil;&atilde;o para que o m&eacute;todo continue executando &eacute; o mesmo procedimento do escalonamento FIFO , por&eacute;m acrescido de mais um condi&ccedil;&atilde;o onde caso seja esgotado o timeslice do processo ent&atilde;o h&aacute; a preemp&ccedil;&atilde;o e o pr&oacute;ximo processo no estado Ready ter&aacute; o controle.</p>&#10;<p>No escalonamento adaptativo, caso o timeslice do processo termine ent&atilde;o a prioridade do processo &eacute; reduzida em uma unidade, procedimento conhecido como deteriora&ccedil;&atilde;o de prioridade.  Neste caso o processo n&atilde;o &eacute; bloqueado.  A prioridade do processo n&atilde;o cair&aacute; mais que uma unidade, mesmo que o timeslice esgote novamente sem bloquear. Caso o processo seja bloqueado ent&atilde;o retorna para sua prioridade original. O escalonamento adaptativo &eacute; o m&eacute;todo default do criado pelo Shell.</p>&#10;<p> </p>&#10;<a id="Bibliografia" name="Bibliografia"></a><h2> Bibliografia </h2>&#10;<p>DO PRADO, Rodrigo&semi; VICENTE, William. <b>Sistema Operacional QNX.</b> Monografia apresentada para banca na Universidade de Campinas: 1998.</p>&#10;<p>TENENBAUM, Andrew S. <b>Sistemas Operacionais Modernos.</b> 2 ed. S&atilde;o Paulo: Pearson Education do Brasil, 1994. </p>&#10;<p>KRTEN, Rob. <b>QNX Neutrino RTOS.</b> Ottawa: QNX Software Systems GmbH &#38&semi; Co. KG., 2009.</p>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://www.qnx.com" rel="nofollow" title="http://www.qnx.com">P&aacute;gina Oficial</a></li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Sistemas_operacionais_embarcados" id="w">Categoria:Sistemas operacionais embarcados</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Sistemas_Unix&shy;like_leves" id="w">Categoria:Sistemas Unix&shy;like leves</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Micron%C3%BAcleo" id="w">Categoria:Micron&uacute;cleo</a></p></body></html>