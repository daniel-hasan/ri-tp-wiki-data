<html><title>PL/I</title><body>&#10;<p> &#10;<b>PL/I</b> (alternativamente PL/1, l&ecirc;&shy;se <i>p&ecirc;&shy;ele&shy;um</i>) significa Programming Language One e &eacute; uma <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagem de programa&ccedil;&atilde;o</a> desenvolvida pela <a href="http://en.wikipedia.org/wiki/IBM" id="w">IBM</a> em meados de 1960. A previs&atilde;o da IBM era que a linguagem fosse utilizada em <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia" id="w">ci&ecirc;ncias</a>, <a href="http://en.wikipedia.org/wiki/Intelig%C3%AAncia_artificial" id="w">intelig&ecirc;ncia artificial</a> e neg&oacute;cios. Por um per&iacute;odo de tempo foi a principal linguagem ensinada na Universidade de Michigan Dearborn. Entretanto, a popularidade declinou nos anos recentes, devido &agrave; introdu&ccedil;&atilde;o de l&iacute;nguagens de programa&ccedil;&atilde;o mais modernas voltadas para o ambiente Mainframe.&#10;Sua principal func&atilde;o &eacute; o processamento/manipula&ccedil;&atilde;o de dados&semi; suporta recurs&atilde;o e aloca&ccedil;&atilde;o din&acirc;mica.<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup></p>&#10;<a id="Principais_caracter%C3%ADsticas" name="Principais_caracter%C3%ADsticas"></a><h2> Principais caracter&iacute;sticas </h2>&#10;&#10;<ul>&#10;<li>Linguagem de programa&ccedil;&atilde;o imperativa e estruturada, de controle e recursividade do ALGOL 60</li>&#10;<li>Fortemente tipada</li>&#10;<li>Subprogramas e E/S formatadas do FORTRAN</li>&#10;<li>Manipula&ccedil;&atilde;o de arquivos e registros do COBOL</li>&#10;<li>Aloca&ccedil;&atilde;o din&acirc;mica de mem&oacute;ria e estruturas encadeadas do LISP</li>&#10;<li>Opera&ccedil;&otilde;es de arrays do APL</li></ul>&#10;<a id="Contribui%C3%A7%C3%B5es_de_PL/I_para_futuras_linguagens" name="Contribui%C3%A7%C3%B5es_de_PL/I_para_futuras_linguagens"></a><h3> Contribui&ccedil;&otilde;es de PL/I para futuras linguagens </h3>&#10;&#10;<ul>&#10;<li>Tratamento de interrup&ccedil;&atilde;o &shy; execu&ccedil;&atilde;o de procedimentos espec&iacute;ficos quando uma condi&ccedil;&atilde;o excepcional ocorre</li>&#10;<li>Multitarefa &shy; especifica&ccedil;&atilde;o de tarefas que podem ser executadas concorrentemente</li></ul>&#10;<a id="Sintaxe_do_comando_PL/I" name="Sintaxe_do_comando_PL/I"></a><h2> Sintaxe do comando PL/I </h2>&#10;<p>&#60&semi;instru&ccedil;&atilde;o&#62&semi; &semi;</p>&#10;&#10;<ul>&#10;<li>Qualquer comando / coment&aacute;rio PL/I dever&atilde;o ser codificados entre as colunas 2 a 72</li>&#10;<li>O t&eacute;rmino de qualquer comando PL/I &eacute; identificado por ponto e v&iacute;rgula (&semi;)</li>&#10;<li>Um comando PL/I poder&aacute; ser codificado em uma ou mais linhas</li>&#10;<li>N&atilde;o h&aacute; posi&ccedil;&atilde;o nem caracter para indicar a continua&ccedil;&atilde;o de um comando PL/I</li>&#10;<li>O coment&aacute;rio em PL/I dever&aacute; estar codificado entre os caracteres &#34&semi;/*&#34&semi; (abre coment&aacute;rio) e os caracteres &#34&semi;*/&#34&semi; (fecha coment&aacute;rio)</li>&#10;<li>O coment&aacute;rio PL/I poder&aacute; ser condificado em qualquer ponto do fonte e poder&aacute; ser de uma ou mais linhas</li>&#10;<li>N&atilde;o existem palavras reservadas no PL/I</li>&#10;<li>O ponto decimal no PL/I &eacute; sempre o ponto (.)</li></ul>&#10;<a id="Estrutura_padr%C3%A3o" name="Estrutura_padr%C3%A3o"></a><h3> Estrutura padr&atilde;o </h3>&#10;<p />&#10;<pre>&#10;LABEL:     PROC OPTIONS (MAIN) &semi;         Identifica&ccedil;&atilde;o do programa&#10;    DECLARE    arquivos ,                    Declara&ccedil;&atilde;o de vari&aacute;veis&#10;               campos ,&#10;               PICTUREs de edi&ccedil;&atilde;o ,&#10;               tabelas ,&#10;               estruturas ,&#10;               inicializa&ccedil;&otilde;es ,&#10;               redefini&ccedil;&otilde;es ,&#10;               fun&ccedil;&otilde;es (BUILT&shy;IN) ,&#10;               rotinas externas&semi;&#10;    ON CONDITIONS &semi;                          Tratamento de condi&ccedil;&otilde;es&#10;    COMANDOS &semi;                               Comandos / Instru&ccedil;&otilde;es&#10;      movimenta&ccedil;&otilde;es &semi;&#10;      express&otilde;es &semi;&#10;      concatena&ccedil;&atilde;o &semi;&#10;      condi&ccedil;&otilde;es &semi;&#10;      LOOPs &semi;&#10;      manipula&ccedil;&atilde;o de arquivos &semi;&#10;      manipula&ccedil;&atilde;o de banco de dados &semi;&#10;      chamadas de rotinas internas&semi;&#10;      chamadas de rotinas externas&semi;&#10;    COMANDOS &semi;&#10;    ROT&shy;LABEL: PROC &semi;                        Identifica&ccedil;&atilde;o da&#10;                                             Sub&shy;rotina interna&#10;    END ROT&shy;LABEL &semi;                          Finaliza&ccedil;&atilde;o da&#10;                                             Sub&shy;rotina interna&#10;    END LABEL &semi;                              Finaliza&ccedil;&atilde;o do programa&#10;</pre>&#10;&#10;<a id="Operadores_de_compara%C3%A7%C3%A3o" name="Operadores_de_compara%C3%A7%C3%A3o"></a><h3> Operadores de compara&ccedil;&atilde;o </h3>&#10;<p>= &#9;Igual</p>&#10;<p>^=&#9;diferente</p>&#10;<p>&#62&semi;&#9;maior</p>&#10;<p>&#62&semi;=&#9;maior ou igual</p>&#10;<p>&#60&semi;&#9;menor</p>&#10;<p>&#60&semi;=&#9;menor ou igual</p>&#10;<a id="COMANDO_%22SELECT%22" name="COMANDO_%22SELECT%22"></a><h3> COMANDO &#34&semi;SELECT&#34&semi; </h3>&#10;<p />&#10;<pre>&#10;SELECT (&#60&semi;campo&#62&semi;)&semi;&#10;  WHEN (&#60&semi;valor&#62&semi; ou &#60&semi;condi&ccedil;&atilde;o&#62&semi;) &shy;&shy;&#60&semi;comando&#62&semi;&shy;&shy;&semi;&#10;  ...&#10;  WHEN (&#60&semi;valor&#62&semi; ou &#60&semi;condi&ccedil;&atilde;o&#62&semi;) &shy;&shy;&#60&semi;comando&#62&semi;&shy;&shy;&semi;&#10;  OTHERWISE &shy;&shy;&#60&semi;comando&#62&semi;&shy;&shy;&semi;&#10;END&semi;&#10;</pre>&#10;&#10;<a id="COMANDO_%22IF%22" name="COMANDO_%22IF%22"></a><h3> COMANDO &#34&semi;IF&#34&semi; </h3>&#10;<p />&#10;<pre>&#10;IF &shy;&shy;&#60&semi;condi&ccedil;&atilde;o&#62&semi;&shy;&shy; THEN &shy;&shy;&#60&semi;comando&#62&semi;&shy;&shy;&semi;&#10;                 ELSE &shy;&shy;&#60&semi;comando&#62&semi;&shy;&shy;&semi;&#10;</pre>&#10;&#10;<a id="COMANDO_%22WHILE%22" name="COMANDO_%22WHILE%22"></a><h3> COMANDO &#34&semi;WHILE&#34&semi; </h3>&#10;<p />&#10;<pre>&#10;DO WHILE (&shy;&shy;CONDICAO&shy;&shy;)&semi;&#10;  &shy;&shy;COMANDOS&shy;&shy;&semi;&#10;END&semi;&#10;</pre>&#10;&#10;<a id="Nome_de_vari%C3%A1veis" name="Nome_de_vari%C3%A1veis"></a><h2> Nome de vari&aacute;veis </h2>&#10;<p>O compilador PL/I permite usar vari&aacute;veis que s&atilde;o consideradas &#34&semi;reservadas&#34&semi; em outras linguagens (como IF, ELSE, THEN,etc) e usa o mesmo s&iacute;mbolo(&#39&semi;=&#39&semi;) para verificar a igualdade e atribui&ccedil;&atilde;o. Por exemplo:&#10;</p>&#10;<pre>&#10;IF IF = THEN THEN THEN = ELSE&semi; ELSE ELSE = IF&semi;&#10;</pre>&#10;&#10;<a id="Exemplos_de_c%C3%B3digo" name="Exemplos_de_c%C3%B3digo"></a><h2> Exemplos de c&oacute;digo </h2>&#10;<a id="Procura_por_uma_string" name="Procura_por_uma_string"></a><h3> Procura por uma string </h3>&#10;<p />&#10;<pre>&#10;FINDSTRINGS:&#10;PROCEDURE OPTIONS(MAIN)&semi;&#10;  /* READ A STRING, THEN PRINT EVERY */&#10;  /* SUBSEQUENT LINE WITH A MATCH */&#10;&#10;  DECLARE PAT VARYING CHARACTER(100),&#10;          LINEBUF VARYING CHARACTER(100),&#10;          (LINENO, NDFILE, IX) FIXED BINARY&semi;&#10;&#10;  NDFILE = 0&semi;&#10;  ON ENDFILE(SYSIN) NDFILE=1&semi;&#10;  GET EDIT(PAT) (A)&semi;&#10;  LINENO = 1&semi;&#10;  DO WHILE (NDFILE=0)&semi;&#10;    GET EDIT(LINEBUF) (A)&semi;&#10;    IF LENGTH(LINEBUF) &#62&semi; 0&#10;    THEN&#10;      DO&semi;&#10;        IX = INDEX(LINEBUF, PAT)&semi;&#10;        IF IX &#62&semi; 0&#10;        THEN&#10;          DO&semi;&#10;            PUT SKIP EDIT (LINENO,LINEBUF)(F(2),A)&semi;&#10;          END&semi;&#10;      END&semi;&#10;    LINENO = LINENO + 1&semi;&#10;  END&semi;&#10;END FINDSTRINGS&semi;&#10;</pre>&#10;&#10;<a id="Hello_World" name="Hello_World"></a><h3> Hello World </h3>&#10;<p />&#10;<pre>&#10;HELLO:   PROCEDURE OPTIONS (MAIN)&semi;&#10;&#10;             /* A PROGRAM TO OUTPUT HELLO WORLD */&#10;             FLAG = 0&semi;&#10;&#10;LOOP:     DO WHILE (FLAG = 0)&semi;&#10;             PUT SKIP LIST(&#39&semi;HELLO WORLD!&#39&semi;)&semi;&#10;          END&semi;&#10;&#10;END HELLO&semi;&#10;</pre>&#10;&#10;<a id="N&shy;Primeiros_N%C3%BAmeros_Perfeitos" name="N&shy;Primeiros_N%C3%BAmeros_Perfeitos"></a><h3> N&shy;Primeiros N&uacute;meros Perfeitos </h3>&#10;<p />&#10;<pre>&#10; program nperfeitos&#10; declare&#10; n,qtd,soma,contador,i,j: int&semi;&#10; numeros: array[1..40] of int&semi;&#10;&#10; begin&#10;  display(&#39&semi;Valor de N&#39&semi;)&#10;  reply(n)&semi;&#10;  qtd=0&semi;&#10;  i=2&semi;&#10;   while qtd&#60&semi;n do&#10;     begin&#10;     soma=0&semi;&#10;     j=1&semi;&#10;     while j&#60&semi;i do&#10;       begin&#10;     if (i%j=0) then&#10;       begin&#10;         soma=soma+j&semi;&#10;       end&semi;&#10;     else&#10;     j=j+1&semi;&#10;     endif&semi;&#10;     if (soma=i) then&#10;       begin&#10;         numeros[qtd+1]=i&semi;&#10;         qtd=qtd+1&semi;&#10;       end&semi;&#10;     else i=i+1&semi;&#10;     endif&semi;&#10;     for contador=1 to n do&#10;     begin&#10;      display(numeros[contador])&semi;&#10; end&semi;&#10;</pre>&#10;&#10;<a id="Bubble_Sort" name="Bubble_Sort"></a><h3> Bubble Sort </h3>&#10;<p />&#10;<pre>&#10;SHELL:   PROCEDURE OPTIONS (MAIN)&semi;&#10;         DECLARE&#10;           ARRAY(50) FIXED BIN(15),&#10;           (K,N) FIXED BIN(15)&semi;&#10;&#10;         GET LIST(N)&semi;&#10;         GET EDIT((ARRAY(K) DO K = 1 TO N))&semi;&#10;         PUT EDIT((ARRAY(K) DO K = 1 TO N))&semi;&#10;         CALL BUBBLE(ARRAY,N)&semi;&#10;&#10;END BUBBLE&semi;&#10;&#10;BUBBLE:   PROCEDURE(ARRAY,N)&semi; /* BUBBLE SORT*/&#10;          DECLARE (I,J) FIXED BIN(15)&semi;&#10;          DECLARE S BIT(1)&semi;        /* SWITCH */&#10;          DECLARE Y FIXED BIN(15)&semi; /* TEMPO */&#10;          DO I = N&shy;1 BY &shy;1 TO 1&semi;&#10;            S = &#39&semi;1&#39&semi;B&semi;&#10;            DO J = 1 TO I&semi;&#10;              IF X(J)&#62&semi;X(J+1) THEN DO&semi;&#10;                S = &#39&semi;0&#39&semi;B&semi;&#10;                Y = X(J)&semi;&#10;                X(J) = X(J+1)&semi;&#10;                X(J+1) = Y&semi;&#10;                END&semi;&#10;              END&semi;&#10;            IF S THEN RETURN&semi;&#10;            END&semi;&#10;          RETURN&semi;&#10;          END SRT&semi;&#10;</pre>&#10;&#10;<p> </p>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li></ul>&#10;<p> </p>&#10;<p> &#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_procedurais" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o procedurais</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:IBM" id="w">Categoria:IBM</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_criadas_na_d%C3%A9cada_de_1960" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o criadas na d&eacute;cada de 1960</a></p></body></html>