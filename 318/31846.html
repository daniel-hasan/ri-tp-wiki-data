<html><title>C&aacute;lculo lambda</title><body>&#10;<p>Na <a href="http://en.wikipedia.org/wiki/L%C3%B3gica_matem%C3%A1tica" id="w">l&oacute;gica matem&aacute;tica</a> e na <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">ci&ecirc;ncia da computa&ccedil;&atilde;o</a>, <b>c&aacute;lculo lambda</b>, tamb&eacute;m escrito como <b>c&aacute;lculo&shy;&lambda;</b> &eacute; um <a href="http://en.wikipedia.org/wiki/Sistema_formal" id="w">sistema formal</a> que estuda <a href="http://en.wikipedia.org/wiki/Fun%C3%A7%C3%B5es" id="w">fun&ccedil;&otilde;es</a> <a href="http://en.wikipedia.org/wiki/Recurs%C3%A3o" id="w">recursivas</a> <a href="http://en.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_comput%C3%A1vel" id="w">comput&aacute;veis</a>, no que se refere a <a href="http://en.wikipedia.org/wiki/Teoria_da_computabilidade" id="w">teoria da computabilidade</a>, e fen&ocirc;menos relacionados, como <b>vari&aacute;veis ligadas</b> e <a href="http://en.wikipedia.org/wiki/Substitui%C3%A7%C3%A3o_(l%C3%B3gica)" id="w">substitui&ccedil;&atilde;o</a>. Sua principal caracter&iacute;stica s&atilde;o as entidades que podem ser utilizadas como argumentos e retornadas como valores de outras fun&ccedil;&otilde;es.</p>&#10;<p>A parte relevante de c&aacute;lculo lambda para computa&ccedil;&atilde;o ficou conhecida como <b>c&aacute;lculo lambda n&atilde;o&shy;tipado</b>. O <b>c&aacute;lculo lambda tipado</b> e o n&atilde;o&shy;tipado tem suas id&eacute;ias aplicadas nos campos da <a href="http://en.wikipedia.org/wiki/L%C3%B3gica" id="w">l&oacute;gica</a>, <a href="http://en.wikipedia.org/wiki/Teoria_da_recurs%C3%A3o_(computabilidade)" id="w">teoria da recurs&atilde;o (computabilidade)</a> e <a href="http://en.wikipedia.org/wiki/Lingu%C3%ADstica" id="w">lingu&iacute;stica</a>, e tem tido um grande papel no desenvolvimento da <b>teoria de linguagens de programa&ccedil;&atilde;o</b> (com a vers&atilde;o n&atilde;o&shy;tipada sendo a inspira&ccedil;&atilde;o original para <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_funcional" id="w">programa&ccedil;&atilde;o funcional</a>, em particular <a href="http://en.wikipedia.org/wiki/Lisp" id="w">Lisp</a>, e a vers&atilde;o tipada contribuindo para fundamentar modernos <a href="http://en.wikipedia.org/wiki/Sistemas_de_tipos" id="w">sistemas de tipos</a> e linguagens de programa&ccedil;&atilde;o). Neste artigo, a vers&atilde;o n&atilde;o&shy;tipada ser&aacute; discutida largamente.</p>&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2>Hist&oacute;ria</h2>&#10;&#10;<p>C&aacute;lculo lambda foi apresentada por <a href="http://en.wikipedia.org/wiki/Alonzo_Church" id="w">Alonzo Church</a> na <a href="http://en.wikipedia.org/wiki/D%C3%A9cada_de_1930" id="w">d&eacute;cada de 1930</a> como parte da investiga&ccedil;&atilde;o dos <a href="http://en.wikipedia.org/wiki/Fundamentos_da_matem%C3%A1tica" id="w">fundamentos da matem&aacute;tica</a><sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup><sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup>. O sistema original foi demonstrado ser <a href="http://en.wikipedia.org/wiki/Consist%C3%AAncia_(l%C3%B3gica)" id="w">logicamente inconsistente</a> em 1935 quando <a href="http://en.wikipedia.org/wiki/Stephen_Kleene" id="w">Stephen Kleene</a> e <a href="http://en.wikipedia.org/wiki/J._B._Rosser" id="w">J. Barkley Rosser</a> desenvolveram o <a href="http://en.wikipedia.org/wiki/Paradoxo_Kleene&shy;Rosser" id="w">paradoxo Kleene&shy;Rosser</a>.</p>&#10;<p>Em seguida, em 1936, Church isolou e publicou apenas a parte que era relevante para a computa&ccedil;&atilde;o e que depois ficou conhecida como c&aacute;lculo lambda n&atilde;o&shy;tipado.<sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup> Em 1940, ele tamb&eacute;m apresentou uma vers&atilde;o computacionalmente mais fraca, mas com um sistema l&oacute;gico consistente, conhecido como <a href="http://en.wikipedia.org/wiki/C%C3%A1lculo_lambda_simplesmente_tipado" id="w">c&aacute;lculo lambda simplesmente tipado</a>.<sup id="_ref&shy;4" class="reference"><a href="#_note&shy;4" title="">[4]</a></sup></p>&#10;<a id="Descri%C3%A7%C3%A3o_informal" name="Descri%C3%A7%C3%A3o_informal"></a><h2>Descri&ccedil;&atilde;o informal</h2>&#10;<a id="Motiva%C3%A7%C3%A3o" name="Motiva%C3%A7%C3%A3o"></a><h3>Motiva&ccedil;&atilde;o</h3>&#10;<p><a href="http://en.wikipedia.org/wiki/Fun%C3%A7%C3%B5es" id="w">Fun&ccedil;&otilde;es</a> recursivas s&atilde;o um conceito fundamental dentro da <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">ci&ecirc;ncia da computa&ccedil;&atilde;o</a> e da matem&aacute;tica. O c&aacute;lculo&shy;&lambda; prov&ecirc; uma sem&acirc;ntica simples para computa&ccedil;&otilde;es, permitindo que propriedades da computa&ccedil;&atilde;o fossem estudadas formalmente.</p>&#10;<p>Considere os dois exemplos a seguir. A <a href="http://en.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_identidade" id="w">fun&ccedil;&atilde;o identidade</a> &#10;</p><dl><dd><tt>I(x) = x</tt></dd></dl>&#10;<p>recebe uma &uacute;nica entrada, <tt>x</tt>, e imediatamente retorna <tt>x</tt> (ou seja, a identidade n&atilde;o faz nada com sua entrada), enquanto a fun&ccedil;&atilde;o &#10;</p><dl><dd><tt>sqsum(x, y) = x*x + y*y</tt></dd></dl>&#10;<p>recebe um par de entradas, <tt>x</tt> e <tt>y</tt> e retorna a soma de seus quadrados, <tt>x*x + y*y</tt>. Usando estes dois exemplos, podemos fazer algumas observa&ccedil;&otilde;es &uacute;teis que motivam as principais id&eacute;ias em c&aacute;lculo&shy;&lambda;.</p>&#10;<p>A primeira observa&ccedil;&atilde;o &eacute; que fun&ccedil;&otilde;es n&atilde;o precisam ser nomeadas explicitamente. Isto &eacute;, a fun&ccedil;&atilde;o &#10;</p><dl><dd><tt>sqsum(x, y) = x*x + y*y</tt></dd></dl>&#10;<p>pode ser reescrita na <i><a href="http://en.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_an%C3%B4nima" id="w">forma an&ocirc;nima</a></i> como &#10;</p><dl><dd><tt>(x, y) &#8614; x*x + y*y</tt></dd></dl>&#10;<p>(leia&shy;se &ldquo;a tupla <tt>x</tt> e <tt>y</tt> &eacute; mapeada em <tt>x*x + y*y</tt>&rdquo;). Similarmente, &#10;</p><dl><dd><tt>I(x) = x</tt></dd></dl>&#10;<p>pode ser reescrita em sua forma an&ocirc;nima para <tt>x &#8614; x</tt>, onde a entrada &eacute; simplesmente mapeada para si mesma.</p>&#10;<p>A segunda observa&ccedil;&atilde;o &eacute; que a escolha do nome para os argumentos de uma fun&ccedil;&atilde;o &eacute; totalmente irrelevante. Isto &eacute;, &#10;</p><dl><dd><tt>x &#8614; x</tt> e</dd></dl><dl><dd><tt>y &#8614; y</tt></dd></dl>&#10;<p>expressam a mesma fun&ccedil;&atilde;o: a identidade. De forma similar, &#10;</p><dl><dd><tt>(x, y) &#8614; x*x + y*y</tt> e</dd></dl><dl><dd><tt>(u, v) &#8614; u*u + v*v</tt></dd></dl>&#10;<p>tamb&eacute;m expressam a mesma fun&ccedil;&atilde;o.</p>&#10;<p>Finalmente, qualquer fun&ccedil;&atilde;o que recebe duas entradas, como a fun&ccedil;&atilde;o <tt>sqsum</tt> do exemplo, pode ser reelaborada numa fun&ccedil;&atilde;o equivalente que recebe uma &uacute;nica entrada e tem, como sa&iacute;da, uma <i>outra</i> fun&ccedil;&atilde;o, que por sua vez tamb&eacute;m aceita uma &uacute;nica entrada. Por exemplo,  &#10;</p><dl><dd><tt>(x, y) &#8614; x*x + y*y</tt></dd></dl>&#10;<p>pode ser reelaborada para  &#10;</p><dl><dd><tt>x &#8614; (y &#8614; x*x + y*y)</tt></dd></dl>&#10;<p>Esta transforma&ccedil;&atilde;o &eacute; chamada <a href="http://en.wikipedia.org/wiki/Currying" id="w">currying</a>, e pode ser generalizada para fun&ccedil;&otilde;es que aceitam um n&uacute;mero arbitr&aacute;rio de argumentos.</p>&#10;<p>Currying pode ser entendido de forma mais clara atrav&eacute;s de um exemplo. Compare a fun&ccedil;&atilde;o &#10;</p><dl><dd><tt>(x, y) &#8614; x*x + y*y</tt></dd></dl>&#10;<p>com sua forma &#34&semi;curryficada&#34&semi;, &#10;</p><dl><dd><tt>x &#8614; (y &#8614; x*x + y*y)</tt></dd></dl>&#10;<p>Dado dois argumentos, temos:&#10;</p><dl><dd><tt>((x, y) &#8614; x*x + y*y)(5, 2)</tt></dd></dl><dl><dd><tt> = 5*5 + 2*2 = 29</tt></dd></dl>&#10;<p>No entanto, usando currying, temos:&#10;</p><dl><dd><tt>((x &#8614; (y &#8614; x*x + y*y))(5))(2)</tt></dd></dl><dl><dd><tt> = (y &#8614; 5*5 + y*y)(2)</tt></dd></dl><dl><dd><tt> = 5*5 + 2*2 = 29</tt></dd></dl>&#10;<p>e assim vemos que as vers&otilde;es com ou sem currying computam o mesmo resultado. Perceba que x*x se transformou numa constante.</p>&#10;<a id="O_c%C3%A1lculo_lambda" name="O_c%C3%A1lculo_lambda"></a><h3>O c&aacute;lculo lambda</h3>&#10;<p>O c&aacute;lculo lambda consiste de uma linguagem de <b>termos lambda</b> junto com uma teoria equacional (que pode tamb&eacute;m ser entendida operacionalmente).</p>&#10;<p>Como os nomes de fun&ccedil;&otilde;es s&atilde;o uma mera conveni&ecirc;ncia, o c&aacute;lculo lambda n&atilde;o tem interesse em nomear uma fun&ccedil;&atilde;o. J&aacute; que todas as fun&ccedil;&otilde;es esperando mais de um argumento podem ser transformadas em fun&ccedil;&otilde;es equivalentes recebendo uma &uacute;nica entrada (via <a href="http://en.wikipedia.org/wiki/Currying" id="w">Currying</a>), o c&aacute;lculo lambda n&atilde;o tem interesse em criar fun&ccedil;&otilde;es que aceitam mais de um argumento. E como os nomes dos argumentos s&atilde;o irrelevantes, a no&ccedil;&atilde;o nativa de igualdade entre termos lambda se chama <b>equival&ecirc;ncia&shy;alpha</b> e que demonstra este princ&iacute;pio.</p>&#10;<a id="Termos_lambda" name="Termos_lambda"></a><h4>Termos lambda</h4>&#10;<p>A sintaxe de termos lambda &eacute; particularmente simples. Existem tr&ecirc;s maneiras de obt&ecirc;&shy;las:&#10;</p>&#10;<ul>&#10;<li>um termo lambda pode ser uma vari&aacute;vel, <tt>x</tt>&semi;</li>&#10;<li>se <tt>t</tt> &eacute; um termo lambda, e <tt>x</tt> &eacute; uma vari&aacute;vel, ent&atilde;o <tt>&lambda;x.t</tt> &eacute; um termo lambda (chamado <b>abstra&ccedil;&atilde;o lambda</b>)&semi;</li>&#10;<li>se <tt>t</tt> e <tt>s</tt> s&atilde;o termos lambda, ent&atilde;o <tt>ts</tt> &eacute; um termo lambda (chamado <b>aplica&ccedil;&atilde;o</b>).</li></ul>&#10;<p>Nada mais &eacute; termo lambda, apesar de que parenteses podem ser usados para tirar ambiguidades entre termos.</p>&#10;<p>Intuitivamente, uma abstra&ccedil;&atilde;o lambda <tt>&lambda;x.t</tt> representa uma fun&ccedil;&atilde;o an&ocirc;nima que recebe uma &uacute;nica entrada, e o <tt>&lambda;</tt> &eacute; dito <b>ligar</b> <tt>x</tt> em <tt>t</tt>, e uma aplica&ccedil;&atilde;o <tt>ts</tt> representa a aplica&ccedil;&atilde;o da entrada <tt>s</tt> a uma fun&ccedil;&atilde;o <tt>t</tt>. Em c&aacute;lculo lambda, fun&ccedil;&otilde;es s&atilde;o consideradas como valores, ent&atilde;o elas podem servir de entrada para outras fun&ccedil;&otilde;es, e fun&ccedil;&otilde;es podem retornar fun&ccedil;&otilde;es como sa&iacute;da.</p>&#10;<p>Por exemplo, <tt>&lambda;x.x</tt> representa a fun&ccedil;&atilde;o identidade, <tt>x &#8614; x</tt>, e <tt>(&lambda;x.x)y</tt> representa a fun&ccedil;&atilde;o identidade aplicada a <tt>y</tt>. E assim, <tt>(&lambda;x.y)</tt> representa a <b>fun&ccedil;&atilde;o constante</b> <tt>x &#8614; y</tt>, uma fun&ccedil;&atilde;o que sempre retorna y, independentemente da entrada. &Eacute; importante ressaltar que a aplica&ccedil;&atilde;o de fun&ccedil;&otilde;es &eacute; associativa &agrave; esquerda, ent&atilde;o <tt>(&lambda;x.x)y z = ((&lambda;x.x)y)z</tt>.</p>&#10;<p>Termos lambda por si s&oacute; n&atilde;o s&atilde;o particularmente interessantes.&#10;O que os fazem interessantes s&atilde;o as v&aacute;rias no&ccedil;&otilde;es de <b>equival&ecirc;ncia</b> e <b>redu&ccedil;&atilde;o</b> que podem ser definidas sobre eles.</p>&#10;<a id="Alfa&shy;equival%C3%AAncia" name="Alfa&shy;equival%C3%AAncia"></a><h4>Alfa&shy;equival&ecirc;ncia</h4>&#10;<p>Uma forma b&aacute;sica de equival&ecirc;ncia, definida para termos lambda, &eacute; chamada de alfa&shy;equival&ecirc;ncia.&#10;Ela determina que a escolha da vari&aacute;vel ligada, na abstra&ccedil;&atilde;o lambda, n&atilde;o importa (normalmente).&#10;Por exemplo, <tt>&lambda;x.x</tt> e <tt>&lambda;y.y</tt> s&atilde;o termos lambda alfa&shy;equivalentes, representando a mesma fun&ccedil;&atilde;o identidade.&#10;Perceba que os termos <tt>x</tt> e <tt>y</tt> <b>n&atilde;o s&atilde;o</b> alfa&shy;equivalentes, porque eles n&atilde;o est&atilde;o ligados por uma abstra&ccedil;&atilde;o lambda.&#10;Em muitos casos, &eacute; f&aacute;cil de identificar termos lambda equivalentes.</p>&#10;<p>As pr&oacute;ximas defini&ccedil;&otilde;es ser&atilde;o necess&aacute;rias para que a defini&ccedil;&atilde;o de beta&shy;redu&ccedil;&atilde;o seja poss&iacute;vel.</p>&#10;<a id="Vari%C3%A1veis_livres" name="Vari%C3%A1veis_livres"></a><h4>Vari&aacute;veis livres</h4>&#10;<p>As <b>vari&aacute;veis livres</b> de um termo s&atilde;o aquelas vari&aacute;veis que n&atilde;o s&atilde;o ligadas por uma abstra&ccedil;&atilde;o lambda.&#10;Isto &eacute;, as vari&aacute;veis livres de <tt>x</tt> s&atilde;o apenas <tt>x</tt>&semi; as vari&aacute;veis livres de <tt>&lambda;x.t</tt> s&atilde;o as vari&aacute;veis livres de <tt>t</tt>, com <tt>x</tt> removido, e as vari&aacute;veis livres de <tt>ts</tt> s&atilde;o a uni&atilde;o das vari&aacute;veis livres de <tt>t</tt> e <tt>s</tt>.</p>&#10;<p>Por exemplo, o termo lambda representando a fun&ccedil;&atilde;o identidade <tt>&lambda;x.x</tt> n&atilde;o tem vari&aacute;veis livres, mas a fun&ccedil;&atilde;o constante <tt>&lambda;x.y</tt> tem uma &uacute;nica vari&aacute;vel livre, <tt>y</tt>.</p>&#10;<a id="Defini%C3%A7%C3%A3o_formal" name="Defini%C3%A7%C3%A3o_formal"></a><h2>Defini&ccedil;&atilde;o formal</h2>&#10;&#10;<p>Express&otilde;es lambda s&atilde;o compostas por&#10;</p><dl><dd>vari&aacute;veis v<sub>1</sub>, v<sub>2</sub>, &hellip;, v<sub>n</sub></dd></dl><dl><dd>s&iacute;mbolos abstratos &lambda; (lambda) e . (ponto)</dd></dl><dl><dd>par&ecirc;nteses ( )</dd></dl>&#10;<p>Considerando um n&uacute;mero infinito de identificadores: {a, b, c, &hellip;, x, y, z, x1, x2, &hellip;}, o conjunto de todas as express&otilde;es do lambda pode ent&atilde;o ser descrito pela seguinte <a href="http://en.wikipedia.org/wiki/Gram%C3%A1tica_livre_de_contexto" id="w">gram&aacute;tica livre de contexto</a> na <a href="http://en.wikipedia.org/wiki/Formalismo_de_Backus&shy;Naur" id="w">forma normal de Backus</a>:&#10;</p><dl><dd>&#60&semi;express&atilde;o&#62&semi; ::= &#60&semi;identificador&#62&semi;</dd></dl><dl><dd>&#60&semi;express&atilde;o&#62&semi; ::= (&lambda;&#60&semi;identificador&#62&semi;. &#60&semi;express&atilde;o&#62&semi;)</dd></dl><dl><dd>&#60&semi;express&atilde;o&#62&semi; ::= (&#60&semi;express&atilde;o&#62&semi; &#60&semi;express&atilde;o&#62&semi;)</dd></dl>&#10;<p>Os ajustes de lambda, &Lambda;, podem ser definidas recursivamente:&#10;</p>&#10;<ol>&#10;<li>se x &eacute; uma vari&aacute;vel, ent&atilde;o x &isin; &Lambda;</li>&#10;<li>se x &eacute; uma vari&aacute;vel e M &isin; &Lambda;, ent&atilde;o (&lambda;x.M) &isin; &Lambda;</li>&#10;<li>se M, N &isin; &Lambda;, ent&atilde;o (M N) &isin; &Lambda;</li></ol>&#10;<p>Inst&acirc;ncias da regra 2 s&atilde;o conhecidas como <b>abstra&ccedil;&otilde;es</b> e inst&acirc;ncias de regra 3 s&atilde;o conhecidas como <b>aplica&ccedil;&otilde;es</b>.</p>&#10;<a id="Outras_linguagens_''puras''" name="Outras_linguagens_''puras''"></a><h2> Outras linguagens &#39&semi;&#39&semi;puras&#39&semi;&#39&semi; </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Haskell" id="w">Haskell</a></li></ul>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2>Ver tamb&eacute;m</h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/C%C3%A1lculo_lambda_simplesmente_tipificado" id="w">C&aacute;lculo lambda simplesmente tipificado</a></li></ul>&#10;<a id="Refer%C3%AAncias" name="Refer%C3%AAncias"></a><h2>Refer&ecirc;ncias</h2>&#10;<p /><ol class="references">&#10;<li id="_note&shy;1"><b><a href="#_ref&shy;1" title="">&uarr&semi;</a></b> A. Church, &#34&semi;A set of postulates for the foundation of logic&#34&semi;, <i>Annals of Mathematics</i>, Series 2, 33:346&ndash;366 (1932).</li><li id="_note&shy;2"><b><a href="#_ref&shy;2" title="">&uarr&semi;</a></b> Para saber a hist&oacute;ria completa, veja &#34&semi;History of Lambda&shy;calculus and Combinatory Logic&#34&semi; (2006), de Cardone e Hindley.</li><li id="_note&shy;3"><b><a href="#_ref&shy;3" title="">&uarr&semi;</a></b> A. Church, &#34&semi;An unsolvable problem of elementary number theory&#34&semi;, <i>American Journal of Mathematics</i>, Volume 58, No. 2. (Apr., 1936), pp. 345&shy;363.</li><li id="_note&shy;4"><b><a href="#_ref&shy;4" title="">&uarr&semi;</a></b> A. Church, &#34&semi;A Formulation of the Simple Theory of Types&#34&semi;, <i>Journal of Symbolic Logic</i>, Volume 5 (1940).</li></ol></body></html>