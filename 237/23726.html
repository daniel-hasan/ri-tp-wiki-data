<html><title>Lisp</title><body>&#10;<p> </p>&#10;<p><b>Lisp</b> &eacute; uma fam&iacute;lia de linguagens de programa&ccedil;&atilde;o concebida por <a href="http://en.wikipedia.org/wiki/John_McCarthy" id="w">John McCarthy</a> em <a href="http://en.wikipedia.org/wiki/1958" id="w">1958</a>. Num c&eacute;lebre artigo, ele mostra que &eacute; poss&iacute;vel usar exclusivamente fun&ccedil;&otilde;es matem&aacute;ticas como estruturas de dados elementares (o que &eacute; poss&iacute;vel a partir do momento em que h&aacute; um mecanismo formal para manipular fun&ccedil;&otilde;es: o <a href="http://en.wikipedia.org/wiki/C%C3%A1lculo_Lambda" id="w">C&aacute;lculo Lambda</a> de <a href="http://en.wikipedia.org/wiki/Alonzo_Church" id="w">Alonzo Church</a>). A linguagem Lisp foi projetada primariamente para o processamento de dados simb&oacute;licos.<sup id="_ref&shy;manual_a" class="reference"><a href="#_note&shy;manual" title="">[1]</a></sup> Ela &eacute; uma linguagem formal matem&aacute;tica.<sup id="_ref&shy;manual_b" class="reference"><a href="#_note&shy;manual" title="">[1]</a></sup>  Durante os anos de <a href="http://en.wikipedia.org/wiki/1970" id="w">1970</a> e <a href="http://en.wikipedia.org/wiki/1980" id="w">1980</a>, Lisp se tornou a principal linguagem da comunidade de intelig&ecirc;ncia artificial, tendo sido pioneiro em aplica&ccedil;&otilde;es como <a href="http://en.wikipedia.org/wiki/Coletor_de_lixo" id="w">administra&ccedil;&atilde;o autom&aacute;tica de armazenamento</a>, <a href="http://en.wikipedia.org/wiki/Interpretador" id="w">linguagens interpretadas</a> e <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_funcional" id="w">programa&ccedil;&atilde;o funcional</a>.</p>&#10;<p>O seu nome vem de <b>LISt Processing</b> (a <a href="http://en.wikipedia.org/wiki/Lista" id="w">lista</a> &eacute; a <a href="http://en.wikipedia.org/wiki/Estrutura_de_dados" id="w">estrutura de dados</a> fundamental desta linguagem).  Tanto os <a href="http://en.wikipedia.org/wiki/Dados" id="w">dados</a> como o <a href="http://en.wikipedia.org/wiki/Programa" id="w">programa</a> s&atilde;o representados como listas, o que permite que a linguagem manipule o <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_fonte" id="w">c&oacute;digo fonte</a> como qualquer outro tipo de dados.</p>&#10;<p>Existem diversos dialetos de Lisp, sendo os mais conhecidos o <a href="http://en.wikipedia.org/wiki/Common_Lisp" id="w">Common Lisp</a> e o <a href="http://en.wikipedia.org/wiki/Scheme" id="w">Scheme</a>.<sup id="_ref&shy;little_a" class="reference"><a href="#_note&shy;little" title="">[2]</a></sup></p>&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2> Hist&oacute;ria </h2>&#10;<p>Lisp &eacute; uma fam&iacute;lia de linguagens que possui uma longa hist&oacute;ria. As primeiras id&eacute;ias&shy;chave para a linguagem foram desenvolvidas por <a href="http://en.wikipedia.org/wiki/John_McCarthy" id="w">John McCarthy</a> em 1956, durante um projeto de pesquisa em intelig&ecirc;ncia artificial. A primeira implementa&ccedil;&atilde;o da linguagem se d&aacute; no inverno de 1958.<sup id="_ref&shy;hoplii_a" class="reference"><a href="#_note&shy;hoplii" title="">[3]</a></sup> A motiva&ccedil;&atilde;o de McCarthy surgiu da id&eacute;ia de desenvolver uma linguagem alg&eacute;brica para processamento de listas para trabalho em IA (intelig&ecirc;ncia artificial). Esfor&ccedil;os para a implementa&ccedil;&atilde;o de seus primeiros dialetos foram empreendidos no <a href="http://en.wikipedia.org/wiki/IBM" id="w">IBM</a> 704, IBM 7090, DEC PDP&shy;1, DEC PDP&shy;6 e DEC PDP&shy;10. O dialeto principal entre 1960 e 1965 foi o Lisp 1.5.No in&iacute;cio dos anos 1970, houve outros dois dialetos predominantes, desenvolvidos atrav&eacute;s de esfor&ccedil;os anteriores: MacLisp e Interlisp.</p>&#10;<p>Apesar das primeiras implementa&ccedil;&otilde;es do Lisp terem sido realizados nos IBM 704 e 7090, trabalhos posteriores concentraram&shy;se nos DEC PDP&shy;6 e PDP&shy;10, este &uacute;ltimo sendo o baluarte do Lisp e das pesquisas em IA (intelig&ecirc;ncia artificial) em lugares como o MIT (Massachussets Institute of Tecnology) e as Universidades de Stanford e Carnegie&shy;Mellon at&eacute; metade dos anos 1970. O computador PDP&shy;10 e seu antecessor, o PDP&shy;6 eram por defini&ccedil;&atilde;o, especialmente adequados para o Lisp, por possuirem palavras de 36 bits e endere&ccedil;os de 18 bits. Esta arquitetura permitia um registro de um cons cell (par pontuado) em uma &uacute;nica palavra de mem&oacute;ria, em instru&ccedil;&otilde;es simples extra&iacute;am o seu car e cdr. Esses computadores possu&iacute;am tamb&eacute;m poderosas instru&ccedil;&otilde;es de pilha, que proporcionavam r&aacute;pida chamada a fun&ccedil;&otilde;es&semi; por&eacute;m suas limita&ccedil;&otilde;es em 1973 eram evidentes: suportavam um pequeno n&uacute;mero de pesquisadores utilizando o Lisp e seu endere&ccedil;amento em 18 bits limitava o espa&ccedil;o dos programas. Uma resposta para o problema de endere&ccedil;amento foi o desenvolvimento do &#34&semi;Lisp Machine&#34&semi;,um computador dedicado especialmente &agrave; tarefa de trabalhar com a linguagem. Outra solu&ccedil;&atilde;o foi a utiliza&ccedil;&atilde;o de computadores de uso geral com maior capacidade de endere&ccedil;amento, como o DEC VAX e o S1 Mark IIA.</p>&#10;<a id="Dialetos_historicamente_significativos" name="Dialetos_historicamente_significativos"></a><h3>Dialetos historicamente significativos</h3>&#10;&#10;<ul>&#10;<li>LISP 1<sup id="_ref&shy;4" class="reference"><a href="#_note&shy;4" title="">[4]</a></sup> &ndash; Primeira Implementa&ccedil;&atilde;o.</li>&#10;<li>LISP 1.5<sup id="_ref&shy;5" class="reference"><a href="#_note&shy;5" title="">[5]</a></sup> &ndash; Primeira vers&atilde;o amplamente distribu&iacute;da, desenvolvida por McCarthy e outros do MIT. Assim chamada porque continha v&aacute;rias melhorias no interpretador &#34&semi;LISP 1&#34&semi; original, mas n&atilde;o foi uma grande reestrutura&ccedil;&atilde;o como planejado que fosse ser o <a href="http://en.wikipedia.org/wiki/LISP_2" id="w">LISP 2</a>.</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Stanford_LISP" id="w">Stanford LISP</a> 1.6<sup id="_ref&shy;6" class="reference"><a href="#_note&shy;6" title="">[6]</a></sup> &ndash; Este foi uma sucessora para o LISP 1.5 desenvolvida no <a href="http://en.wikipedia.org/wiki/Stanford_AI_Lab" id="w">Stanford AI Lab</a>, e amplamente distribu&iacute;da para sistemas <a href="http://en.wikipedia.org/wiki/PDP&shy;10" id="w">PDP&shy;10</a> rodando o sistema operacional <a href="http://en.wikipedia.org/wiki/TOPS&shy;10" id="w">TOPS&shy;10</a>. Se tornou obsoleta com o advento do Maclisp e do InterLisp.</li></ul>&#10;<a id="Aplicabilidade" name="Aplicabilidade"></a><h2> Aplicabilidade </h2>&#10;<p>Lisp &eacute; uma linguagem madura, concebida atenciosamente, altamente port&aacute;vel, linguagem de for&ccedil;a industrial com a qual desenvolvedores em todo o mundo contam para:&#10;</p>&#10;<ul>&#10;<li>Ferramenta r&aacute;pida e altamente personaliz&aacute;vel para fazer coisas do dia a dia. </li>&#10;<li>Aplica&ccedil;&otilde;es grandes, complexas e cr&iacute;ticas as quais seriam imposs&iacute;veis desenvolver em outra linguagem. </li>&#10;<li>Prototipa&ccedil;&atilde;o r&aacute;pida e Rapid Application Development (RAD). </li>&#10;<li>Aplica&ccedil;&otilde;es de alta disponibilidade, principalmente aquelas que necessitam de mudan&ccedil;as ap&oacute;s a etapa inicial. </li></ul>&#10;<p>A linguagem teve um grande sucesso em software do ramo de neg&oacute;cios, engenharia, processamento de documentos, hiperm&iacute;dia (incluindo a Web), matem&aacute;tica, gr&aacute;ficos e anima&ccedil;&atilde;o (Mirai), intelig&ecirc;ncia artificial e processamento de linguagem natural. Uma das grandes vantagens de Lisp &eacute; que ela trata o programa como dado, possibilitando assim um programa inteiro ser dado como entrada de um outro, coisa que n&atilde;o acontece em outras linguagens como C e Pascal. E usada algumas vezes para definir todos os aspectos de uma aplica&ccedil;&atilde;o, ou apenas o motor de processamento interno, ou apenas a interface do usu&aacute;rio&semi; e ainda &eacute; usada com rotina para prover linguagens de comando interativas, linguagens de macro ou script e linguagens extensoras de sistemas comerciais.</p>&#10;<a id="Caracter%C3%ADsticas_T%C3%A9cnicas" name="Caracter%C3%ADsticas_T%C3%A9cnicas"></a><h2> Caracter&iacute;sticas T&eacute;cnicas </h2>&#10;<p>A linguagem LISP &eacute; interpretada, onde o usu&aacute;rio digita express&otilde;es em uma linguagem formal definida e recebe de volta a avalia&ccedil;&atilde;o de sua express&atilde;o. Deste ponto de vista podemos pensar no LISP como uma calculadora, que ao inv&eacute;s de avaliar express&otilde;es aritm&eacute;ticas avalia express&otilde;es simb&oacute;licas, chamadas de express&otilde;es.<sup id="_ref&shy;Wexelblat_a" class="reference"><a href="#_note&shy;Wexelblat" title="">[7]</a></sup> Cada programa em LISP, &eacute;, portanto, uma express&atilde;o. As express&otilde;es s&atilde;o de tamanho indefinido e tem uma estrutura de &aacute;rvore bin&aacute;ria. &#10;A estrutura de utiliza&ccedil;&atilde;o da mem&oacute;ria dispon&iacute;vel &eacute; na forma de listas, pois livra o programador da necessidade de alocar espa&ccedil;os diferentes para o programa e para os dados, fazendo com que os dados e os programas sejam homog&ecirc;neos, caracter&iacute;stica &uacute;nica da linguagem LISP.&#10;Suas principais caracter&iacute;sticas s&atilde;o:&#10;</p>&#10;<ul>&#10;<li>Tipos de dados: &aacute;tomo e a lista. &Eacute; com apenas esses dois tipos de dados que se constroem as express&otilde;es&shy;S, as estruturas basilares de LISP.</li>&#10;<li>Fraca Tipagem: LISP, em rela&ccedil;&atilde;o a outras linguagens funcionais mais recentes, &eacute; fracamente tipado, o que causa complica&ccedil;&otilde;es, j&aacute; que opera&ccedil;&otilde;es que acessam as suas estruturas de dados s&atilde;o tratadas como fun&ccedil;&otilde;es. </li>&#10;<li>Fun&ccedil;&otilde;es de ordem elevada: Linguagens funcionais tipicamente suportam fun&ccedil;&otilde;es de ordem elevada (exemplo: fun&ccedil;&atilde;o de uma fun&ccedil;&atilde;o de uma fun&ccedil;&atilde;o de uma&hellip;).</li>&#10;<li>Avalia&ccedil;&atilde;o Ociosa: &Eacute; o que ocorre quando uma fun&ccedil;&atilde;o aninhada executa uma computa&ccedil;&atilde;o desnecess&aacute;ria para a avalia&ccedil;&atilde;o da fun&ccedil;&atilde;o que a chama, aumentando o tempo de execu&ccedil;&atilde;o.</li>&#10;<li>Concorr&ecirc;ncia (multitarefa): A concorr&ecirc;ncia nas linguagens imperativas tradicionais &eacute; relativamente complexa&semi; o programador &eacute; o respons&aacute;vel pela sincroniza&ccedil;&atilde;o de todas as tarefas (a multitarefa no paradigma procedural &eacute; t&atilde;o sofisticada quanto um GOTO). Em contraste, as linguagens funcionais intrinsecamente nos oferecem oportunidades para a concorr&ecirc;ncia: A partir do momento em que uma fun&ccedil;&atilde;o tem mais de um par&acirc;metro, estes par&acirc;metros devem em princ&iacute;pio ser avaliados simultaneamente (note que os par&acirc;metros seriam as fun&ccedil;&otilde;es correspondentes &agrave;s tarefas a serem executadas)&semi; A partir deste ponto, a responsabilidade pela sincroniza&ccedil;&atilde;o das tarefas passa do programador para o compilador (as modernas linguagens funcionais orientadas a multitarefa disp&otilde;e de mecanismos atrav&eacute;s dos quais o programador pode guiar o compilador). Todavia, as linguagens funcionais orientadas a multitarefa permitem ao programador trabalhar em um n&iacute;vel muito mais elevado do que as linguagens imperativas destinadas a este mesmo fim.</li>&#10;<li>Um alto n&iacute;vel de abstra&ccedil;&atilde;o, especialmente quando as fun&ccedil;&otilde;es s&atilde;o utilizadas, suprimindo muitos detalhes da programa&ccedil;&atilde;o e minimizando a probabilidade da ocorr&ecirc;ncia de muitas classes de erros&semi;</li>&#10;<li>A n&atilde;o depend&ecirc;ncia das opera&ccedil;&otilde;es de atribui&ccedil;&atilde;o permite aos programas avalia&ccedil;&otilde;es nas mais diferentes ordens. Esta caracter&iacute;stica de avalia&ccedil;&atilde;o independente da ordem torna as linguagens funcionais as mais indicadas para a programa&ccedil;&atilde;o de computadores maci&ccedil;amente paralelos&semi;</li>&#10;<li>A aus&ecirc;ncia de opera&ccedil;&otilde;es de atribui&ccedil;&atilde;o torna os programas funcionais muito mais simples para provas e an&aacute;lises matem&aacute;ticas do que os programas procedurais. </li></ul>&#10;<p>E como desvantagem, destacamos:&#10;</p>&#10;<ul>&#10;<li>Uma menor efici&ecirc;ncia para resolver problemas que envolvam muitas vari&aacute;veis (ex. contas de banco) ou muitas atividades seq&uuml;enciais s&atilde;o muitas vezes mais f&aacute;ceis de se trabalhar com programas procedurais ou programas orientados a objeto. </li></ul>&#10;<p>O Common Lisp permite v&aacute;rias representa&ccedil;&otilde;es diferentes de n&uacute;meros. Estas representa&ccedil;&otilde;es podem ser divididas em 4 tipos: hexadecimais, octais, bin&aacute;rios e decimais. Estes &uacute;ltimos podem ser divididos em 4 categorias: inteiros, racionais, ponto flutuante e complexos.</p>&#10;<a id="Implementa%C3%A7%C3%A3o_das_Listas" name="Implementa%C3%A7%C3%A3o_das_Listas"></a><h2> Implementa&ccedil;&atilde;o das Listas </h2>&#10;<p>Originalmente, em Lisp havia duas estruturas de dados fundamentais: o <a href="http://en.wikipedia.org/wiki/&Aacute;tomo" id="w">&aacute;tomo</a> e a lista&semi; o &aacute;tomo pode ser <a href="http://en.wikipedia.org/wiki/Num%C3%A9rico" id="w">num&eacute;rico</a>, ou <a href="http://en.wikipedia.org/wiki/Alfanum%C3%A9rico" id="w">alfanum&eacute;rico</a>. Exemplos de &aacute;tomos:&#10;<code><b>atomo1</b></code>, <code><b>a</b></code>, <code><b>12</b></code>, <code><b>54</b></code>, <code><b>bola</b></code>, <code><b>nil</b></code>.</p>&#10;<p>O &aacute;tomo <code>nil</code> representa o valor nulo e ao mesmo tempo representa uma lista vazia.&#10;A lista &eacute; a associa&ccedil;&atilde;o de &aacute;tomos ou outras listas (numa lista chamamos de elementos a cada um dos itens) representandos entre par&ecirc;ntesis. Exemplo de lista:</p>&#10;<p><code>(esta lista cont&eacute;m 5 &aacute;tomos)</code></p>&#10;<p><code>((jose (22 solteiro)) (antonio (15 casado)))</code></p>&#10;<p>Normalmente a implementa&ccedil;&atilde;o de uma lista &eacute; um encadeamento de pares em que o ponteiro &agrave; esquerda do par aponta para o elemento correspondente da lista e em que o ponteiro &agrave; direita do par aponta para a restante lista.</p>&#10;<pre>  [   .   ]&#10;    |   |&#10;    |   +&shy;&shy;&shy;&shy; ponteiro para a restante lista (quando for o &uacute;ltimo, aponta para nil)&#10;    +&shy;&shy;&shy;&shy;&shy;&shy;&shy;&shy; ponteiro para o conte&uacute;do do elemento&#10;&#10;  [   .   ] +&rarr;[   .   ] +&rarr;[   .   ] +&rarr;[   .   ] +&rarr;[   .   ]&#10;    |   |   |   |   |   |   |   |   |   |   |   |   |   |&#10;    |   +&shy;&shy;&shy;+   |   +&shy;&shy;&shy;+   |   +&shy;&shy;&shy;+   |   +&shy;&shy;&shy;+   |   +&shy;&shy;&#62&semi; nil&#10;   esta        lista      cont&eacute;m        5         &aacute;tomos&#10;</pre>&#10;<p>Avalia&ccedil;&atilde;o dados: os &aacute;tomos quando avaliados retornam eles mesmos. As listas, quando avaliadas, s&atilde;o fun&ccedil;&otilde;es, onde o primeiro elemento representa o nome da fun&ccedil;&atilde;o e os elementos seguintes s&atilde;o os argumentos para esta fun&ccedil;&atilde;o. &#10;Exemplos de fun&ccedil;&atilde;o:</p>&#10;<p><code>&#10;(+ 3 4) <br/>&#10;&#62&semi; 7 <br/>&#10;(* 5 (+ 2 5)) <br/>&#10;&#62&semi; 35 <br/>&#10;(car (quote (a b)))<br/>&#10;&#62&semi; a <br/>&#10;</code></p>&#10;<p>Normalmente, as implementa&ccedil;&otilde;es de Lisp providenciam um ambiente interactivo de avalia&ccedil;&atilde;o de express&otilde;es.  Os exemplos acima apresentam a interac&ccedil;&atilde;o com uma implementa&ccedil;&atilde;o de Lisp.  Como pode ser visto tamb&eacute;m, um programa Lisp pode confundir um programador inexperiente porque requer o uso de muitos par&ecirc;nteses, o que lhe rendeu um trocadilho angl&oacute;fono para o nome da linguagem: LISP = Lots of Irritating Stupid Parentheses (tradu&ccedil;&atilde;o: Montes de Irritantes Par&ecirc;nteses Est&uacute;pidos), ou ent&atilde;o LISP = Linguagem Infernal Somente de Par&ecirc;nteses.</p>&#10;<p>Existe o mito de que Lisp &eacute; uma linguagem que s&oacute; funciona com um <a href="http://en.wikipedia.org/wiki/Interpretador" id="w">interpretador</a>.  Na realidade, todos os dialetos relevantes de Lisp t&ecirc;m <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compiladores</a>.  Alguns dialetos, o <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compilador</a> &eacute; uma fun&ccedil;&atilde;o que se pode invocar a partir de c&oacute;digo normal para transformar uma lista (que descreve uma fun&ccedil;&atilde;o) numa fun&ccedil;&atilde;o invoc&aacute;vel.  Programas Lisp comerciais s&atilde;o tipicamente compilados por motivos de efici&ecirc;ncia, mas a sem&acirc;ntica do Lisp permite que o programador possa usar programas interpretados e programas compilados ao mesmo tempo.  A maioria dos usos interpretados ocorrem interativamente, para invocar programas compilados a partir de c&oacute;digo escrito por um programador.  H&aacute; exemplos disso acima onde se apresenta o resultado interactivo de invocar fun&ccedil;&otilde;es compiladas.</p>&#10;<a id="Exemplos_de_Fun%C3%A7%C3%B5es" name="Exemplos_de_Fun%C3%A7%C3%B5es"></a><h2> Exemplos de Fun&ccedil;&otilde;es </h2>&#10;<p><code>(<b>quote</b> express&atilde;o)</code><br/>&#10;Retorna a express&atilde;o diretamente, sem tentar qualquer forma da avalia&ccedil;&atilde;o. Ex: <code>(quote jose)</code> retorna <code>jose</code>, e <code>(quote (jose silva))</code> retorna <code>(jose silva)</code>.</p>&#10;<p><code>&#39&semi;express&atilde;o</code><br/>&#10;Significa o mesmo que <code>(<b>quote</b> express&atilde;o)</code>. Ex: <code>&#39&semi;jose</code> retorna <code>jose</code>, e <code>&#39&semi;(jose silva)</code> retorna <code>(jose silva)</code>.</p>&#10;<p><code>(<b>eval</b> express&atilde;o)</code><br/>&#10;for&ccedil;a a avaliar a express&atilde;o. Ex: Embora <code>&#39&semi;(+ 3 4)</code> simplesmente retorna <code>(+ 3 4)</code>, <code>(eval &#39&semi;(+ 3 4))</code> for&ccedil;a a avaliar o <code>(+ 3 4)</code> e portanto retorna <code>7</code>.</p>&#10;<p><code>(<b>car</b> lista)</code><br/>&#10;Retorna o primeiro elemento da lista. Ex: <code>(car &#39&semi;(jose silva))</code> retorna <code>jose</code>. Entre os v&aacute;rios dialetos de Lisp, h&aacute; alguns (por exemplo, <a href="http://en.wikipedia.org/wiki/ISLISP" id="w">ISLISP</a>) que permitem o nome <code><b>first</b></code> como alternativa para <code><b>car</b></code>.</p>&#10;<p><code>(<b>cdr</b> lista)</code><br/>&#10;Retorna a lista sem o primeiro elemento. Ex: <code>(cdr &#39&semi;(jose da silva))</code> retorna <code>(da silva)</code>. H&aacute; dialetos que usam o nome <code><b>rest</b></code> como alternativa para <code><b>cdr</b></code>.</p>&#10;<p><code>(<b>cons</b> atomo lista)</code><br/>&#10;Adiciona &aacute;tomo ao in&iacute;cio da lista. Ex: <code>(cons &#39&semi;jose &#39&semi;(da silva))</code> retorna <code>(jose da silva)</code>.</p>&#10;<p>Fun&ccedil;&otilde;es matem&aacute;ticas:</p>&#10;<p />&#10;<pre>&#10;+ (Adi&ccedil;&atilde;o)&#10;&shy; (Subtra&ccedil;&atilde;o)&#10;* (Multiplica&ccedil;&atilde;o)&#10;/ (Divis&atilde;o)&#10;</pre>&#10;&#10;<a id="Macros" name="Macros"></a><h2> Macros </h2>&#10;<p>O grande diferencial de Lisp s&atilde;o as <a href="http://en.wikipedia.org/wiki/Macros" id="w">macros</a>. As macros s&atilde;o completamente diferentes das que se encontram em C, pois estas somente fazem substitui&ccedil;&atilde;o de texto, enquanto que em Lisp as macros s&atilde;o programas que geram programas.</p>&#10;<a id="Uso_de_Lisp" name="Uso_de_Lisp"></a><h2> Uso de Lisp </h2>&#10;<p>Lisp foi utilizado para desenvolver o primeiro sistema computacional de <a href="http://en.wikipedia.org/wiki/Matem%C3%A1tica_simb%C3%B3lica" id="w">matem&aacute;tica simb&oacute;lica</a>, o <a href="http://en.wikipedia.org/wiki/Macsyma" id="w">Macsyma</a>.</p>&#10;<p>Ele tamb&eacute;m &eacute; utilizado como <a href="http://en.wikipedia.org/wiki/Linguagem_de_extens%C3%A3o" id="w">linguagem de extens&atilde;o</a> do software de <a href="http://en.wikipedia.org/wiki/CAD" id="w">CAD</a> <a href="http://en.wikipedia.org/wiki/AutoCAD" id="w">AutoCAD</a>, desenvolvido pela <a href="http://en.wikipedia.org/wiki/AutoDesk" id="w">AutoDesk</a>. O editor de textos <a href="http://en.wikipedia.org/wiki/Emacs" id="w">Emacs</a> tamb&eacute;m utiliza Lisp como linguagem de extens&atilde;o. Segundo o seu pr&oacute;prio autor, <a href="http://en.wikipedia.org/wiki/Richard_Stallman" id="w">Richard Stallman</a>, Lisp foi o respons&aacute;vel por tornar o <a href="http://en.wikipedia.org/wiki/Emacs" id="w">Emacs</a> t&atilde;o popular, pois o fato da linguagem de extens&atilde;o dele ser t&atilde;o poderosa permite que ele seja estendido muito al&eacute;m do que se imaginava que ele originalmente poderia fazer.</p>&#10;<p>A ITA software desenvolveu um sistema de reserva de passagens chamado Orbitz em LISP, ele &eacute; utilizado por diversas companhias a&eacute;reas. A <a href="http://en.wikipedia.org/wiki/Symbolics" id="w">Symbolics</a> criou um sistema de modelagem 3D que depois foi adquirido pela IZWare e atualmente se chama <a href="http://en.wikipedia.org/wiki/Mirai" id="w">Mirai</a>, ele foi utilizado nos efeitos do filme <a href="http://en.wikipedia.org/wiki/Senhor_dos_An%C3%A9is" id="w">Senhor dos An&eacute;is</a>.</p>&#10;<p>O LISP foi utilizado pelo <a href="http://en.wikipedia.org/wiki/Paul_Graham" id="w">Paul Graham</a> para desenvolver o sistema de <a href="http://en.wikipedia.org/wiki/Com%C3%A9rcio_eletr%C3%B4nico" id="w">e&shy;commerce</a> da <a href="http://en.wikipedia.org/wiki/Viaweb" id="w">Viaweb</a>, que posteriormente foi vendido para o <a href="http://en.wikipedia.org/wiki/Yahoo!" id="w">Yahoo</a> por US$ 40 milh&otilde;es, na &eacute;poca da <a href="http://en.wikipedia.org/wiki/Bolha_da_internet" id="w">bolha da internet</a>.</p>&#10;<a id="Exemplos_de_c%C3%B3digo" name="Exemplos_de_c%C3%B3digo"></a><h2> Exemplos de c&oacute;digo </h2>&#10;<a id="Express%C3%B5es_Lambda" name="Express%C3%B5es_Lambda"></a><h3> Express&otilde;es Lambda </h3>&#10;<p />&#10;&#10;<p>Resultado: 6</p>&#10;<a id="Fatorial" name="Fatorial"></a><h3> Fatorial </h3>&#10;<p><i>Common Lisp:</i></p>&#10;<p />&#10;&#10;<p><i>Scheme:</i></p>&#10;<p />&#10;&#10;<p>Embora as defini&ccedil;&otilde;es acima pare&ccedil;am correctas, para evitar o transbordamento da pilha pode ser prefer&iacute;vel usar as seguintes.</p>&#10;<p><i>Common Lisp:</i></p>&#10;<p />&#10;&#10;<p><i>Scheme:</i></p>&#10;<p />&#10;&#10;<p>Na maioria dos dialetos modernos de Lisp usam&shy;se inteiros de precis&atilde;o num&eacute;rica indefinida:</p>&#10;<p />&#10;&#10;<p>Naqueles dialetos tamb&eacute;m usam&shy;se <a href="http://en.wikipedia.org/wiki/N%C3%BAmero_racional" id="w">n&uacute;meros racionais</a> de precis&atilde;o num&eacute;rica indefinida.  Por exemplo, no Common Lisp se pode ter esta interac&ccedil;&atilde;o:</p>&#10;<p />&#10;&#10;<p> </p>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://www&shy;formal.stanford.edu/jmc/history/lisp/lisp.html" rel="nofollow" title="http://www&shy;formal.stanford.edu/jmc/history/lisp/lisp.html">http://www&shy;formal.stanford.edu/jmc/history/lisp/lisp.html</a></li>&#10;<li><a class="externallink" href="http://www&shy;formal.stanford.edu/jmc/lisp20th/lisp20th.html" rel="nofollow" title="http://www&shy;formal.stanford.edu/jmc/lisp20th/lisp20th.html">http://www&shy;formal.stanford.edu/jmc/lisp20th/lisp20th.html</a></li>&#10;<li><a class="externallink" href="http://www.gigamonkeys.com/book/" rel="nofollow" title="http://www.gigamonkeys.com/book/">http://www.gigamonkeys.com/book/</a></li>&#10;<li><a class="externallink" href="http://www.paulgraham.com/onlisp.html" rel="nofollow" title="http://www.paulgraham.com/onlisp.html">http://www.paulgraham.com/onlisp.html</a></li>&#10;<li><a class="externallink" href="http://www.dca.ufrn.br/~adelardo/lisp/" rel="nofollow" title="http://www.dca.ufrn.br/~adelardo/lisp/">Linguagem LISP</a> (em Common Lisp)</li>&#10;<li><a class="externallink" href="http://www.dca.fee.unicamp.br/courses/EA072/lisp9596/Lisp9596.html" rel="nofollow" title="http://www.dca.fee.unicamp.br/courses/EA072/lisp9596/Lisp9596.html">Introdu&ccedil;&atilde;o &agrave; Linguagem Lisp</a></li>&#10;<li><a class="externallink" href="http://lisp&shy;br.void.cc/" rel="nofollow" title="http://lisp&shy;br.void.cc/">Grupo de usu&aacute;rios no Brasil</a></li>&#10;<li><a class="externallink" href="http://docs.autodesk.com/ACD/2011/ENU/filesALG/WSfacf1429558a55de185c428100849a0ab7&shy;4130.htm" rel="nofollow" title="http://docs.autodesk.com/ACD/2011/ENU/filesALG/WSfacf1429558a55de185c428100849a0ab7&shy;4130.htm">Usando Linguagem AutoLISP</a> (Site em ingl&ecirc;s da Autodesk)</li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Lisp" id="w"> </a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_funcionais" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o funcionais</a></p></body></html>