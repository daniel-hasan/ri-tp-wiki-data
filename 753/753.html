<html><title>Express&atilde;o regular</title><body>&#10;<p>Em <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">ci&ecirc;ncia da computa&ccedil;&atilde;o</a>, uma <b>express&atilde;o regular</b> (ou o <a href="http://en.wikipedia.org/wiki/Estrangeirismo" id="w">estrangeirismo</a> <b><i>regex</i></b>, abrevia&ccedil;&atilde;o do <a href="http://en.wikipedia.org/wiki/L%C3%ADngua_inglesa" id="w">ingl&ecirc;s</a> <i>regular expression</i>) prov&ecirc; uma forma concisa e flex&iacute;vel de identificar <a href="http://en.wikipedia.org/wiki/Cadeia_de_caracteres" id="w">cadeias de caracteres</a> de interesse, como <a href="http://en.wikipedia.org/wiki/Caractere" id="w">caracteres</a> particulares, palavras ou padr&otilde;es de caracteres. Express&otilde;es regulares s&atilde;o escritas numa <a href="http://en.wikipedia.org/wiki/Linguagem_formal" id="w">linguagem formal</a> que pode ser <a href="http://en.wikipedia.org/wiki/Linguagem_interpretada" id="w">interpretada</a> por um processador de express&atilde;o regular, um <a href="http://en.wikipedia.org/wiki/Programa_de_computador" id="w">programa</a> que ou serve um <a href="http://en.wikipedia.org/wiki/Gerador_de_analisador_sint%C3%A1tico" id="w">gerador de analisador sint&aacute;tico</a> ou examina o texto e identifica partes que <a href="http://en.wikipedia.org/wiki/Casamento_de_padr%C3%B5es" id="w">casam</a> com a especifica&ccedil;&atilde;o dada.</p>&#10;<p>O termo deriva do trabalho do <a href="http://en.wikipedia.org/wiki/Matem%C3%A1tico" id="w">matem&aacute;tico</a> <a href="http://en.wikipedia.org/wiki/Estados_Unidos" id="w">norte&shy;americano</a> <a href="http://en.wikipedia.org/wiki/Stephen_Cole_Kleene" id="w">Stephen Cole Kleene</a>, que desenvolveu as express&otilde;es regulares como uma nota&ccedil;&atilde;o ao que ele chamava de <a href="http://en.wikipedia.org/wiki/&Aacute;lgebra_de_Kleene" id="w">&aacute;lgebra de conjuntos regulares</a>. Seu trabalho serviu de base para os primeiros <a href="http://en.wikipedia.org/wiki/Algoritmo_de_busca" id="w">algoritmos computacionais de busca</a>, e depois para algumas das mais antigas ferramentas de tratamento de texto da plataforma <a href="http://en.wikipedia.org/wiki/Unix" id="w">Unix</a>.</p>&#10;<p>O uso atual de express&otilde;es regulares inclui procura e substitui&ccedil;&atilde;o de texto em <a href="http://en.wikipedia.org/wiki/Editor_de_texto" id="w">editores de texto</a> e <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagens de programa&ccedil;&atilde;o</a>, valida&ccedil;&atilde;o de formatos de texto (valida&ccedil;&atilde;o de protocolos ou formatos digitais), <a href="http://en.wikipedia.org/wiki/Realce_de_sintaxe" id="w">realce de sintaxe</a> e filtragem de informa&ccedil;&atilde;o.</p>&#10;<a id="Conceitos_b%C3%A1sicos" name="Conceitos_b%C3%A1sicos"></a><h2> Conceitos b&aacute;sicos </h2>&#10;<p>Uma express&atilde;o regular (ou, um padr&atilde;o) descreve um conjunto de <a href="http://en.wikipedia.org/wiki/Cadeia_de_caracteres" id="w">cadeias de caracteres</a>, de forma concisa, sem precisar listar todos os elementos do conjunto. Por exemplo, um conjunto contendo as cadeias &#34&semi;<i>Handel</i>&#34&semi;, &#34&semi;<i>H&auml;ndel</i>&#34&semi; e &#34&semi;<i>Haendel</i>&#34&semi; pode ser descrito pelo padr&atilde;o <code>H(&auml;|ae?)ndel</code>. A maioria dos formalismos prov&ecirc; pelo menos tr&ecirc;s opera&ccedil;&otilde;es para construir express&otilde;es regulares.</p>&#10;<p>A primeira delas &eacute; a altern&acirc;ncia, em que uma <a href="http://en.wikipedia.org/wiki/Barra_vertical" id="w">barra vertical</a> (<code>|</code>) separa alternativas. Por exemplo, <code>psicad&eacute;lico|psicod&eacute;lico</code> pode casar &#34&semi;<i>psicad&eacute;lico</i>&#34&semi; ou &#34&semi;<i>psicod&eacute;lico</i>&#34&semi;. A segunda opera&ccedil;&atilde;o &eacute; o agrupamento, em que <a href="http://en.wikipedia.org/wiki/Par%C3%AAnteses" id="w">par&ecirc;nteses</a> (<code>(</code>, <code>)</code>) s&atilde;o usados para definir o escopo e a preced&ecirc;ncia de operadores, entre outros usos. Por exemplo, <code>psicad&eacute;lico|psicod&eacute;lico</code> e <code>psic(a|o)d&eacute;lico</code> s&atilde;o equivalentes e ambas descrevem &#34&semi;<i>psicad&eacute;lico</i>&#34&semi; e &#34&semi;<i>psicod&eacute;lico</i>&#34&semi;. Por fim, a terceira opera&ccedil;&atilde;o &eacute; a quantifica&ccedil;&atilde;o (ou repeti&ccedil;&atilde;o). Um quantificador ap&oacute;s um <i><a href="http://en.wikipedia.org/wiki/Token" id="w">token</a></i> (como um caractere) ou um agrupamento especifica a quantidade de vezes que o elemento precedente pode ocorrer. Os quantificadores mais comuns s&atilde;o <code>?</code>, <code>*</code> e <code>+</code>. O <a href="http://en.wikipedia.org/wiki/Ponto_de_interroga%C3%A7%C3%A3o" id="w">ponto de interroga&ccedil;&atilde;o</a> indica que h&aacute; zero ou uma ocorr&ecirc;ncia do elemento precedente. Por exemplo, <code>ac?&ccedil;&atilde;o</code> casa tanto &#34&semi;<i>ac&ccedil;&atilde;o</i>&#34&semi; quanto &#34&semi;<i>a&ccedil;&atilde;o</i>&#34&semi;. J&aacute; o <a href="http://en.wikipedia.org/wiki/Asterisco" id="w">asterisco</a> indica que h&aacute; zero ou mais ocorr&ecirc;ncias do elemento precedente. Por exemplo, <code>ab*c</code> casa &#34&semi;<i>ac</i>&#34&semi;, &#34&semi;<i>abc</i>&#34&semi;, &#34&semi;<i>abbc</i>&#34&semi;, &#34&semi;<i>abbbc</i>&#34&semi;, e assim por diante. Por fim, o <a href="http://en.wikipedia.org/wiki/S%C3%ADmbolos_matem%C3%A1ticos" id="w">sinal de adi&ccedil;&atilde;o</a> indica que h&aacute; uma ou mais ocorr&ecirc;ncias do elemento precedente. Por exemplo, <code>ab+c</code> casa &#34&semi;<i>abc</i>&#34&semi;, &#34&semi;<i>abbc</i>&#34&semi;, &#34&semi;<i>abbbc</i>&#34&semi;, e assim por diante, mas n&atilde;o &#34&semi;<i>ac</i>&#34&semi;.</p>&#10;<p>Essas constru&ccedil;&otilde;es podem ser combinadas arbitrariamente para formar express&otilde;es complexas, assim como express&otilde;es aritm&eacute;ticas com n&uacute;meros e opera&ccedil;&otilde;es de adi&ccedil;&atilde;o, subtra&ccedil;&atilde;o, multiplica&ccedil;&atilde;o e divis&atilde;o. De forma geral, h&aacute; diversas express&otilde;es regulares para descrever um mesmo conjunto de cadeias de caracteres. A sintaxe exata da express&atilde;o regular e os operadores dispon&iacute;veis variam entre as implementa&ccedil;&otilde;es.</p>&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2> Hist&oacute;ria </h2>&#10;<p>A origem das express&otilde;es regulares est&atilde;o na <a href="http://en.wikipedia.org/wiki/Teoria_dos_aut%C3%B4matos" id="w">teoria dos aut&ocirc;matos</a> e na <a href="http://en.wikipedia.org/wiki/Linguagem_formal" id="w">teoria das linguagens formais</a>, e ambas fazem parte da <a href="http://en.wikipedia.org/wiki/Teoria_da_computa%C3%A7%C3%A3o" id="w">teoria da computa&ccedil;&atilde;o</a>. Esses campos estudam modelos de computa&ccedil;&atilde;o (aut&ocirc;matas) e formas de descri&ccedil;&atilde;o e classifica&ccedil;&atilde;o de linguagens formais. Na <a href="http://en.wikipedia.org/wiki/D%C3%A9cada_de_1950" id="w">d&eacute;cada de 1950</a>, o matem&aacute;tico <a href="http://en.wikipedia.org/wiki/Stephen_Cole_Kleene" id="w">Stephen Cole Kleene</a> descreveu tais modelos usando sua nota&ccedil;&atilde;o matem&aacute;tica chamada de &#34&semi;conjuntos regulares&#34&semi;, formando a <a href="http://en.wikipedia.org/wiki/&Aacute;lgebra_de_Kleene" id="w">&aacute;lgebra de Kleene</a>. A linguagem <a href="http://en.wikipedia.org/wiki/SNOBOL" id="w">SNOBOL</a> foi uma implementa&ccedil;&atilde;o pioneira de <a href="http://en.wikipedia.org/wiki/Casamento_de_padr%C3%B5es" id="w">casamento de padr&otilde;es</a>, mas n&atilde;o era id&ecirc;ntica &agrave;s express&otilde;es regulares. <a href="http://en.wikipedia.org/wiki/Ken_Thompson" id="w">Ken Thompson</a> construiu a nota&ccedil;&atilde;o de Kleene no <a href="http://en.wikipedia.org/wiki/Editor_de_texto" id="w">editor de texto</a> <a href="http://en.wikipedia.org/wiki/QED_(software)" id="w">QED</a> como uma forma de casamento de padr&otilde;es em <a href="http://en.wikipedia.org/wiki/Arquivo_de_texto" id="w">arquivos de texto</a>. Posteriormente, ele adicionou essa funcionalidade no editor de texto <a href="http://en.wikipedia.org/wiki/Unix" id="w">Unix</a> <a href="http://en.wikipedia.org/wiki/Ed_(software)" id="w">ed</a>, que resultou no uso de express&otilde;es regulares na popular ferramenta de busca <a href="http://en.wikipedia.org/wiki/Grep" id="w">grep</a>. Desde ent&atilde;o, diversas varia&ccedil;&otilde;es da adapta&ccedil;&atilde;o original de Thompson foram usadas em Unix e derivados, incluindo <a href="http://en.wikipedia.org/wiki/Expr" id="w">expr</a>, <a href="http://en.wikipedia.org/wiki/AWK" id="w">AWK</a>, <a href="http://en.wikipedia.org/wiki/Emacs" id="w">Emacs</a>, <a href="http://en.wikipedia.org/wiki/Vi" id="w">vi</a> e <a href="http://en.wikipedia.org/wiki/Lex" id="w">lex</a>.</p>&#10;<p>As express&otilde;es regulares de <a href="http://en.wikipedia.org/wiki/Perl" id="w">Perl</a> e <a href="http://en.wikipedia.org/wiki/Tcl" id="w">Tcl</a> foram derivadas da biblioteca escrita por <a href="http://en.wikipedia.org/wiki/Henry_Spencer" id="w">Henry Spencer</a>, e no Perl a funcionalidade foi expandida posteriormente.<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup> <a href="http://en.wikipedia.org/wiki/Philip_Hazel" id="w">Philip Hazel</a> desenvolveu a <a href="http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions" id="w">PCRE</a> (Perl Compatible Regular Expressions), uma <a href="http://en.wikipedia.org/wiki/Biblioteca_de_rotinas" id="w">biblioteca</a> usada por diversas ferramentas modernas como <a href="http://en.wikipedia.org/wiki/PHP" id="w">PHP</a> e o <a href="http://en.wikipedia.org/wiki/Servidor_Apache" id="w">servidor Apache</a>. Parte do desenvolvimento do <a href="http://en.wikipedia.org/wiki/Perl_6" id="w">Perl 6</a> foi melhorar a integra&ccedil;&atilde;o das express&otilde;es regulares de Perl, e aumentar seu escopo e funcionalidade para permitir a defini&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Gram%C3%A1tica_de_express%C3%A3o_de_analisadores_sint%C3%A1ticos" id="w">gram&aacute;ticas de express&atilde;o de analisadores sint&aacute;ticos</a>.<sup id="_ref&shy;Apocalypse5_a" class="reference"><a href="#_note&shy;Apocalypse5" title="">[2]</a></sup> O resultado foi uma mini&shy;linguagem, as regras do Perl 6, usada para definir a gram&aacute;tica do Perl 6 assim como fornecer uma ferramenta para programadores da linguagem. Tais regras mantiveram as funcionalidades de express&otilde;es regulares do Perl 5.x, mas tamb&eacute;m permitiram uma defini&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/Formalismo_de_Backus&shy;Naur" id="w">BNF</a> de um <a href="http://en.wikipedia.org/wiki/Analisador_sint%C3%A1tico_descendente_recursivo" id="w">analisador sint&aacute;tico descendente recursivo</a>.</p>&#10;<p>O uso de express&otilde;es regulares em normas de informa&ccedil;&atilde;o estruturada para a modelagem de documentos e <a href="http://en.wikipedia.org/wiki/Banco_de_dados" id="w">bancos de dados</a> come&ccedil;ou na <a href="http://en.wikipedia.org/wiki/D%C3%A9cada_de_1960" id="w">d&eacute;cada de 1960</a>, e expandiu na <a href="http://en.wikipedia.org/wiki/D%C3%A9cada_de_1980" id="w">d&eacute;cada de 1980</a> quando normas como a <a href="http://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language" id="w">ISO SGML</a> foram consolidadas.</p>&#10;<a id="Teoria_de_linguagens_formais" name="Teoria_de_linguagens_formais"></a><h2> Teoria de linguagens formais </h2>&#10;<p>Express&otilde;es regulares podem ser expressas atrav&eacute;s da <a href="http://en.wikipedia.org/wiki/Linguagem_formal" id="w">teoria de linguagens formais</a>. Elas consistem de constantes e operadores que denotam conjuntos de cadeias de caracteres e opera&ccedil;&otilde;es sobre esses conjuntos, respectivamente. Dado um <a href="http://en.wikipedia.org/wiki/Alfabeto" id="w">alfabeto</a> finito &Sigma;, as seguintes constantes s&atilde;o definidas:&#10;</p>&#10;<ul>&#10;<li>(<i><a href="http://en.wikipedia.org/wiki/Conjunto_vazio" id="w">conjunto vazio</a></i>)   denotando o conjunto  </li>&#10;<li>(<i>cadeia de caracteres vazia</i>) &epsilon; denotando o conjunto {&epsilon;}</li>&#10;<li>(<i>literal</i>) <i>a</i> em &Sigma; denotando o conjunto {<i>a</i>}</li></ul>&#10;<p>As seguintes opera&ccedil;&otilde;es s&atilde;o definidas:&#10;</p>&#10;<ul>&#10;<li>(<i>concatena&ccedil;&atilde;o</i>) <i>RS</i> denotando o conjunto { &alpha;&beta; | &alpha; em <i>R</i> e &beta; em <i>S</i> }. Por exemplo, {&#34&semi;<i>ab</i>&#34&semi;, &#34&semi;<i>c</i>&#34&semi;}{&#34&semi;<i>d</i>&#34&semi;, &#34&semi;<i>ef</i>&#34&semi;} = {&#34&semi;<i>abd</i>&#34&semi;, &#34&semi;<i>abef</i>&#34&semi;, &#34&semi;<i>cd</i>&#34&semi;, &#34&semi;<i>cef</i>&#34&semi;}.</li>&#10;<li>(<i>altern&acirc;ncia</i>) <i>R|S</i> denotando o conjunto uni&atilde;o de <i>R</i> e <i>S</i>. Usa&shy;se os s&iacute;mbolos  ,   ou   para altern&acirc;ncia ao inv&eacute;s da barra vertical. Por exemplo, {&#34&semi;<i>ab</i>&#34&semi;, &#34&semi;<i>c</i>&#34&semi;} {&#34&semi;<i>dv</i>&#34&semi;, &#34&semi;<i>ef</i>&#34&semi;} = {&#34&semi;<i>ab</i>&#34&semi;, &#34&semi;<i>c</i>&#34&semi;, &#34&semi;<i>dv</i>&#34&semi;, &#34&semi;<i>ef</i>&#34&semi;}</li>&#10;<li>(<i><a href="http://en.wikipedia.org/wiki/Fecho_de_Kleene" id="w">Fecho de Kleene</a></i>) <i>R</i>* denotando o menor <a href="http://en.wikipedia.org/wiki/Superconjunto" id="w">superconjunto</a> de <i>R</i> que cont&eacute;m &epsilon; e &eacute; <a href="http://en.wikipedia.org/wiki/Fechamento" id="w">fechado</a> sob concatena&ccedil;&atilde;o. Esse &eacute; o conjunto de todas as cadeias de caracteres que podem ser constru&iacute;das ao concatenar zero ou mais cadeias em <i>R</i>. Por exemplo, {&#34&semi;<i>ab</i>&#34&semi;, &#34&semi;<i>c</i>&#34&semi;}* = {&epsilon;, &#34&semi;<i>ab</i>&#34&semi;, &#34&semi;<i>c</i>&#34&semi;, &#34&semi;<i>abab</i>&#34&semi;, &#34&semi;<i>abc</i>&#34&semi;, &#34&semi;<i>cab</i>&#34&semi;, &#34&semi;<i>cc</i>&#34&semi;, &#34&semi;<i>ababab</i>&#34&semi;, &#34&semi;<i>abcab</i>&#34&semi;, ... }.</li></ul>&#10;<p>As constantes e os operadores acima formam a <a href="http://en.wikipedia.org/wiki/&Aacute;lgebra_de_Kleene" id="w">&aacute;lgebra de Kleene</a>.</p>&#10;<p>Para evitar par&ecirc;nteses, &eacute; assumido que o fecho de Kleene possui a maior prioridade, depois a concatena&ccedil;&atilde;o e por fim a altern&acirc;ncia. Se n&atilde;o houver ambiguidades, os par&ecirc;nteses podem ser omitidos. Por exemplo, <code>(ab)c</code> pode ser escrito como <code>abc</code>, e <code>a|(b(c*))</code> pode ser escrito como <code>a|bc*</code>.</p>&#10;<dl><dt>Exemplos</dt><dd /></dl>&#10;<ul>&#10;<li><code>a|b*</code> denota {&epsilon;, <i>a</i>, <i>b</i>, <i>bb</i>, <i>bbb</i>, ...}</li>&#10;<li><code>(a|b)*</code> denota o conjunto de todas as cadeias de caracteres que cont&eacute;m os s&iacute;mbols <i>a</i> e <i>b</i>, incluindo a cadeia vazia: {&epsilon;, <i>a</i>, <i>b</i>, <i>aa</i>, <i>ab</i>, <i>ba</i>, <i>bb</i>, <i>aaa</i>, ...}</li>&#10;<li><code>ab*(c|&epsilon;)</code> denota o conjunto de cadeias de caracteres come&ccedil;ando com <i>a</i>, ent&atilde;o com zero ou mais <i>b</i>s e opcionalmente com um <i>c</i>: {<i>a</i>, <i>ac</i>, <i>ab</i>, <i>abc</i>, <i>abb</i>, ...}</li></ul>&#10;<p>A defini&ccedil;&atilde;o formal de express&otilde;es regulares &eacute; concisa e evita a utiliza&ccedil;&atilde;o dos quantificadores redundantes <code>?</code> e <code>+</code>, que podem ser expressados respectivamente por <code>(a|&epsilon;)</code> e <code>aa*</code>. Por vezes o operador de complemento ~ &eacute; adicionado&semi;  ~<i>R</i> denota o conjunto das cadeias de caracteres de &Sigma;* que n&atilde;o est&atilde;o em <i>R</i>. Esse operador &eacute; redundante, e pode ser expressado usando outros operadores, apesar da computa&ccedil;&atilde;o para tal representa&ccedil;&atilde;o ser complexa.</p>&#10;<p>Express&otilde;es regulares podem expressar <a href="http://en.wikipedia.org/wiki/Linguagem_regular" id="w">linguagens regulares</a>, a classe de linguagens aceita por um <a href="http://en.wikipedia.org/wiki/M%C3%A1quina_de_estado_finito" id="w">aut&ocirc;mato finito</a>. Entretanto, h&aacute; uma diferen&ccedil;a significativa na compacta&ccedil;&atilde;o. Algumas classes de linguagens regulares podem ser descritas somente por aut&ocirc;matos que crescem exponencialmente em tamanho, enquanto o tamanho das express&otilde;es regulares requeridas s&oacute; pode crescer linearmente. Express&otilde;es regulares correspondem ao Tipo&shy;3 das <a href="http://en.wikipedia.org/wiki/Gram%C3%A1tica_formal" id="w">gram&aacute;ticas</a> da <a href="http://en.wikipedia.org/wiki/Hierarquia_de_Chomsky" id="w">Hierarquia de Chomsky</a>. Por outro lado, existe um mapeamento simples de express&otilde;es regulares para m&aacute;quinas de estado finito n&atilde;o&shy;determin&iacute;sticas que n&atilde;o leva ao crescimento desgovernado do tamanho. Por essa raz&atilde;o, essas m&aacute;quinas n&atilde;o determin&iacute;sticas s&atilde;o geralmente usadas como representa&ccedil;&atilde;o alternativa das express&otilde;es regulares.</p>&#10;<p>&Eacute; poss&iacute;vel escrever um <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmo</a> que, para duas express&otilde;es regulares dadas, decide se as linguagens descritas s&atilde;o essencialmente iguais. Reduz&shy;se cada express&atilde;o na m&aacute;quina de estado finito m&iacute;nima, e determina&shy;se se ambas as m&aacute;quinas m&iacute;nimas s&atilde;o <a href="http://en.wikipedia.org/wiki/Isomorfismo" id="w">isom&oacute;rficas</a> (equivalentes).</p>&#10;<p>Vale notar que diversas implementa&ccedil;&otilde;es de express&otilde;es regulares implementam funcionalidades que n&atilde;o podem ser expressadas na &aacute;lgebra de Kleene&semi; ver <a href="http://en.wikipedia.org/wiki/#Padr&otilde;es para linguagens n&atilde;o regulares" id="w">abaixo</a> mais sobre o assunto.</p>&#10;<a id="Sintaxe" name="Sintaxe"></a><h2> Sintaxe </h2>&#10;<a id="POSIX" name="POSIX"></a><h3> POSIX </h3>&#10;<p>De <a href="http://en.wikipedia.org/wiki/1986" id="w">1986</a>, a norma <a href="http://en.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers" id="w">IEEE</a> <a href="http://en.wikipedia.org/wiki/POSIX" id="w">POSIX</a> 1003.2 (POSIX.2) padroniza express&otilde;es regulares, e fornece duas especifica&ccedil;&otilde;es, a saber: o conjunto b&aacute;sico (BRE) e o conjunto estendido (ERE).</p>&#10;<a id="BRE:_express%C3%B5es_regulares_b%C3%A1sicas" name="BRE:_express%C3%B5es_regulares_b%C3%A1sicas"></a><h4> BRE: express&otilde;es regulares b&aacute;sicas </h4>&#10;<p>A sintaxe tradicional de express&otilde;es regulares em Unix seguiu conven&ccedil;&otilde;es comuns, mas diferiu entre as implementa&ccedil;&otilde;es. A norma IEEE POSIX BRE (<i>Basic Regular Expressions</i>, do <a href="http://en.wikipedia.org/wiki/L%C3%ADngua_inglesa" id="w">ingl&ecirc;s</a>, express&otilde;es regulares b&aacute;sicas) foi desenvolvida primordialmente por compatibilidade com a sintaxe tradicional, mas fornecia uma norma comum que desde ent&atilde;o foi adotada por diversas ferramentas.</p>&#10;<p>Na sintaxe de BRE, a maioria dos caracteres s&atilde;o tratados como literais &mdash; eles casam somente com eles pr&oacute;prios (por exemplo, <code>a</code> casa &#34&semi;<i>a</i>&#34&semi;). As exce&ccedil;&otilde;es s&atilde;o chamadas metacaracteres ou metaseq&uuml;&ecirc;ncias, definidos abaixo:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<th>Metacaractere</th>&#10;<th>Descri&ccedil;&atilde;o</th></tr>&#10;<tr>&#10;<th colspan="2">Padr&otilde;es individuais</th></tr>&#10;<tr valign="top">&#10;<td><code>.</code></td>&#10;<td>Casa qualquer caractere. Algumas implementa&ccedil;&otilde;es excluem <a href="http://en.wikipedia.org/wiki/Quebra_de_linha" id="w">quebra de linha</a> e codifica&ccedil;&atilde;o de caracteres. Nas express&otilde;es POSIX de listas de caracteres (ver logo abaixo), o caractere ponto &eacute; tratado como o literal. Por exemplo, <code>a.c</code> casa &#34&semi;<i>abc</i>&#34&semi;, etc., mas <code>[a.c]</code> casa somente &#34&semi;<i>a</i>&#34&semi;, &#34&semi;<i>.</i>&#34&semi; ou &#34&semi;<i>c</i>&#34&semi;.</td></tr>&#10;<tr valign="top">&#10;<td><code>[&#160&semi;]</code></td>&#10;<td>Lista de caracteres. Casa uma ocorr&ecirc;ncia de qualquer caractere contido na lista. Por exemplo, <code>[abc]</code> casa &#34&semi;<i>a</i>&#34&semi;, &#34&semi;<i>b</i>&#34&semi; ou &#34&semi;<i>c</i>&#34&semi;. &Eacute; poss&iacute;vel definir intervalos de caracteres: <code>[a&shy;z]</code> casa qualquer caractere de &#34&semi;<i>a</i>&#34&semi; a &#34&semi;<i>z</i>&#34&semi;, e <code>[0123456789]</code> &eacute; igual a <code>[0&shy;9]</code>. O caractere <code>&shy;</code> &eacute; tratado como literal se for o primeiro ou o &uacute;ltimo da lista, ou se for <a href="http://en.wikipedia.org/wiki/Seq%C3%BC%C3%AAncia_de_escape" id="w">escapado</a>: <code>[abc&shy;]</code>, <code>[&shy;abc]</code> ou <code>[a\&shy;bc]</code>.</td></tr>&#10;<tr valign="top">&#10;<td><code>[^&#160&semi;]</code></td>&#10;<td>Lista negada de caracteres. Casa uma ocorr&ecirc;ncia de qualquer caractere n&atilde;o contido na lista. Por exemplo, <code>[^abc]</code> casa qualquer caractere que n&atilde;o seja &#34&semi;<i>a</i>&#34&semi;, &#34&semi;<i>b</i>&#34&semi; ou &#34&semi;<i>c</i>&#34&semi;. <code>[^a&shy;z]</code> casa qualquer caractere que n&atilde;o esteja em <a href="http://en.wikipedia.org/wiki/Caixa_baixa" id="w">caixa baixa</a>.</td></tr>&#10;<tr>&#10;<th colspan="2">&Acirc;ncoras</th></tr>&#10;<tr valign="top">&#10;<td><code>^</code></td>&#10;<td>Casa o come&ccedil;o da cadeia de caracteres. Numa situa&ccedil;&atilde;o de m&uacute;ltiplas linhas, casa o come&ccedil;o das linhas. Logo percebe&shy;se que as &acirc;ncoras n&atilde;o casam peda&ccedil;os do texto, elas servem apenas como uma refer&ecirc;ncia.</td></tr>&#10;<tr valign="top">&#10;<td><code>$</code></td>&#10;<td>Casa o fim da cadeia de caracteres ou a posi&ccedil;&atilde;o logo antes da quebra de linha do fim da cadeia. Numa situa&ccedil;&atilde;o de m&uacute;ltiplas linhas, casa o fim das linhas.</td></tr>&#10;<tr>&#10;<th colspan="2">Captura de dados</th></tr>&#10;<tr valign="top">&#10;<td> <br/> </td>&#10;<td>Grupo de captura. Marca uma subexpress&atilde;o. A cadeia de caracteres que casa com o conte&uacute;do dentro dos par&ecirc;nteses pode ser chamada posteriormente.</td></tr>&#10;<tr valign="top">&#10;<td><code>\<i>n</i></code></td>&#10;<td>Associado com o item anterior. Casa a n&shy;&eacute;sima subexpress&atilde;o marcada, em que <i>n</i> &eacute; um d&iacute;gito de 1 a 9. Essa constru&ccedil;&atilde;o &eacute; teoricamente irregular e n&atilde;o foi adotada pela sintaxe POSIX ERE. Algumas ferramentas permitem referenciar mais de nove grupos de captura.</td></tr>&#10;<tr>&#10;<th colspan="2">Quantificadores (ou repetidores)</th></tr>&#10;<tr valign="top">&#10;<td><code>*</code></td>&#10;<td>Casa o elemento precedente zero ou mais vezes. Por exemplo, <code>ab*c</code> casa &#34&semi;<i>ac</i>&#34&semi;, &#34&semi;<i>abc</i>&#34&semi;, &#34&semi;<i>abbbc</i>&#34&semi;, etc.. <code>[xyz]*</code> casa &#34&semi;&#34&semi;, &#34&semi;<i>x</i>&#34&semi;, &#34&semi;<i>y</i>&#34&semi;, &#34&semi;<i>z</i>&#34&semi;, &#34&semi;<i>zx</i>&#34&semi;, &#34&semi;<i>zyx</i>&#34&semi;, &#34&semi;<i>xyzzy</i>&#34&semi;, e assim por diante. <code>\(ab\)*</code> casa &#34&semi;&#34&semi;, &#34&semi;<i>ab</i>&#34&semi;, &#34&semi;<i>abab</i>&#34&semi;, &#34&semi;<i>ababab</i>&#34&semi;, e assim por diante.</td></tr>&#10;<tr valign="top">&#10;<td> <br/> </td>&#10;<td>Casa o elemento precedente pelo menos <i>m</i> vezes e n&atilde;o mais que <i>n</i> vezes. Por exemplo, <code>a\{3,5\}</code> casa somente &#34&semi;<i>aaa</i>&#34&semi;, &#34&semi;<i>aaaa</i>&#34&semi;, e &#34&semi;<i>aaaaa</i>&#34&semi;. Esta funcionalidade n&atilde;o &eacute; encontrada em algumas implementa&ccedil;&otilde;es muito antigas. Outras op&ccedil;&otilde;es incluem omitir um dos campos. Por exemplo, <code>a\{3,\}</code> casa pelo menos tr&ecirc;s &#34&semi;a&#34&semi;s. J&aacute; <code>a\{3\}</code> casa somente tr&ecirc;s &#34&semi;a&#34&semi;s. <code>b{0,}</code> &eacute; an&aacute;logo a <code>b*</code>, <code>b{0,1}</code> &eacute; an&aacute;logo a <code>b?</code> (ver o quantificador <code>?</code> abaixo) e <code>b{1,}</code> &eacute; id&ecirc;ntico a <code>b+</code> (ver o quantificador <code>+</code> abaixo).</td></tr></table></div>&#10;&#10;<p>Uma caracter&iacute;stica da BRE &eacute; que os metacaracteres geralmente exigem barras invertidas para serem tratador como tal. Por exemplo, em BRE, <code>a{1,2}</code> &eacute; composto somente por literais, e casar&aacute; somente &#34&semi;<i>a{1,2}</i>&#34&semi;. Para casar entre uma a duas ocorr&ecirc;ncias de &#34&semi;a&#34&semi;, deve&shy;se usar a express&atilde;o regular <code>a\{1,2\}</code>. A motiva&ccedil;&atilde;o desse sistema &eacute; a compatilidade com sistemas antigos, j&aacute; que na &eacute;poca da padroniza&ccedil;&atilde;o j&aacute; havia c&oacute;digo Unix legado que usava chaves como literais.</p>&#10;<a id="ERE:_express%C3%B5es_regulares_estendidas" name="ERE:_express%C3%B5es_regulares_estendidas"></a><h4> ERE: express&otilde;es regulares estendidas </h4>&#10;<p>O significado dos metacaracteres serem <a href="http://en.wikipedia.org/wiki/Seq%C3%BC%C3%AAncia_de_escape" id="w">escapados</a> com a barra invertida &eacute; revertido na sintaxe POSIX ERE (<i>Extended Regular Expression</i>, do <a href="http://en.wikipedia.org/wiki/L%C3%ADngua_inglesa" id="w">ingl&ecirc;s</a>, express&otilde;es regulares estendidas). Isso significa que n&atilde;o s&atilde;o usadas <a href="http://en.wikipedia.org/wiki/Seq%C3%BC%C3%AAncia_de_escape" id="w">barras invertidas</a> para identificar metacaracteres. Pelo contr&aacute;rio, elas servem justamente para transformar metacaracteres em literais. Retomando o exemplo da se&ccedil;&atilde;o anterior, em ERE, <code>a{1,2}</code> casa uma a duas ocorr&ecirc;ncias de &#34&semi;a&#34&semi;, enquanto <code>a\{1,2\}</code> casa o literal &#34&semi;<i>a{1,2}</i>&#34&semi;.</p>&#10;<p>Os seguintes metacaracteres foram adicionados:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table>&#10;<tr>&#10;<th colspan="2">Quantificadores</th></tr>&#10;<tr valign="top">&#10;<td><code>?</code></td>&#10;<td>Casa o elemento precedente zero ou uma vez. Por exemplo, <code>ba?</code> casa &#34&semi;<i>b</i>&#34&semi; ou &#34&semi;<i>ba</i>&#34&semi;.</td></tr>&#10;<tr valign="top">&#10;<td><code>+</code></td>&#10;<td>Casa o elemento precedente uma ou mais vezes. Por exemplo, <code>ba+</code> casa &#34&semi;<i>ba</i>&#34&semi;, &#34&semi;<i>baa</i>&#34&semi;, &#34&semi;<i>baaa</i>&#34&semi;, e assim por diante. Como visto na se&ccedil;&atilde;o de teoria, esse metacaractere pode ser simulado em BRE atrav&eacute;s de <code>aa*</code>.</td></tr>&#10;<tr>&#10;<th colspan="2">Alternadores</th></tr>&#10;<tr valign="top">&#10;<td />&#10;<td Casa="null" Por="null" a="null" exemplo,="null" express&atilde;o="null" ou="null" precede="null" que="null" sucede.="null">def casa &#34&semi;<i>abc</i>&#34&semi; ou &#34&semi;<i>def</i>&#34&semi;.</td></tr></table></div>&#10;&#10;<p>Ferramentas que adotaram a sintaxe incluem <a href="http://en.wikipedia.org/wiki/MySQL" id="w">MySQL</a> e <a href="http://en.wikipedia.org/wiki/PHP" id="w">PHP</a>, esta, que suporta tamb&eacute;m as deriva&ccedil;&otilde;es de Perl no modelo do <a href="http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions" id="w">PCRE</a><sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup>.</p>&#10;<a id="Classes_de_caracteres" name="Classes_de_caracteres"></a><h4> Classes de caracteres </h4>&#10;<p>J&aacute; que diversos grupos de caracteres dependem duma configura&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Locale" id="w">locale</a> espec&iacute;fica, a POSIX define algumas classes (ou categorias) de caracteres para fornecer um m&eacute;todo padr&atilde;o de acesso a alguns grupos espec&iacute;ficos de caracteres bastante utilizados, como mostrado na seguinte tabela:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table>&#10;<tr>&#10;<td><code>[:alnum:]</code></td>&#10;<td>Caracteres alfanum&eacute;ricos, o que no caso de ASCII corresponde a <code>[A&shy;Za&shy;z0&shy;9]</code>.</td></tr>&#10;<tr>&#10;<td><code>[:alpha:]</code></td>&#10;<td>Caracteres alfab&eacute;ticos, o que no caso de ASCII corresponde a <code>[A&shy;Za&shy;z]</code>.</td></tr>&#10;<tr>&#10;<td><code>[:blank:]</code></td>&#10;<td>Espa&ccedil;o e tabula&ccedil;&atilde;o, o que no caso de ASCII corresponde a <code>[ \t]</code>.</td></tr>&#10;<tr>&#10;<td><code>[:cntrl:]</code></td>&#10;<td>Caracteres de controle, o que no caso de ASCII corresponde a <code>[\x00&shy;\x1F\x7F]</code>.</td></tr>&#10;<tr>&#10;<td><code>[:digit:]</code></td>&#10;<td>D&iacute;gitos, o que no caso de ASCII corresponde a <code>[0&shy;9]</code>. O Perl oferece o atalho <code>\d</code>.</td></tr>&#10;<tr>&#10;<td><code>[:graph:]</code></td>&#10;<td>Caracteres vis&iacute;veis, o que no caso de ASCII corresponde a <code>[\x21&shy;\x7E]</code>.</td></tr>&#10;<tr>&#10;<td><code>[:lower:]</code></td>&#10;<td>Caracteres em caixa baixa, o que no caso de ASCII corresponde a <code>[a&shy;z]</code>.</td></tr>&#10;<tr>&#10;<td><code>[:print:]</code></td>&#10;<td>Caracteres vis&iacute;veis e espa&ccedil;os, o que no caso de ASCII corresponde a <code>[\x20&shy;\x7E]</code>.</td></tr>&#10;<tr>&#10;<td><code>[:punct:]</code></td>&#10;<td>Caracteres de pontua&ccedil;&atilde;o, o que no caso de ASCII corresponde a <code>[&shy;!&#34&semi;#$%&#38&semi;&#39&semi;()*+,./:&semi;&#60&semi;=&#62&semi;?@[\\\]_`{|}~]</code>.</td></tr>&#10;<tr>&#10;<td><code>[:space:]</code></td>&#10;<td>Caracteres de espa&ccedil;os em branco, o que no caso de ASCII corresponde a <code>[ \t\r\n\v\f]</code>. O Perl oferece o atalho <code>\s</code>, que, entretanto, n&atilde;o &eacute; exatamente equivalente&semi; diferente do <code>\s</code>, a classe ainda inclui um tabulador vertical, \x11 do ASCII.<sup id="_ref&shy;doc perl_a" class="reference"><a href="#_note&shy;doc perl" title="">[4]</a></sup></td></tr>&#10;<tr>&#10;<td><code>[:upper:]</code></td>&#10;<td>Caracteres em caixa alta, o que no caso de ASCII corresponde a <code>[A&shy;Z]</code>.</td></tr>&#10;<tr>&#10;<td><code>[:xdigit:]</code></td>&#10;<td>D&iacute;gitos hexadecimais, o que no caso de ASCII corresponde a <code>[A&shy;Fa&shy;f0&shy;9]</code>.</td></tr></table></div>&#10;&#10;<p>Notar que as doze classes definidas acima tamb&eacute;m est&atilde;o definidas na <a href="http://en.wikipedia.org/wiki/Biblioteca_padr%C3%A3o_do_C" id="w">biblioteca padr&atilde;o do C</a>, na se&ccedil;&atilde;o de fun&ccedil;&otilde;es de testes de caracteres do cabe&ccedil;alho <code>ctype.h</code>.</p>&#10;<p>Tais classes s&oacute; podem ser usadas dentro de express&otilde;es de listas de caracteres. Diferentes <a href="http://en.wikipedia.org/wiki/Locale" id="w">locales</a> podem fornecer classes adicionais. Uma extens&atilde;o n&atilde;o POSIX difundida &eacute; <code>[:word:]</code> (atalho do Perl <code>\w</code>), geralmente definida como <code>[:alnum:]</code> ou <a href="http://en.wikipedia.org/wiki/Tra%C3%A7o_baixo" id="w">tra&ccedil;o baixo</a> (<code>_</code>) e <code>[:ascii:]</code>, contendo somente caracteres <a href="http://en.wikipedia.org/wiki/ASCII" id="w">ASCII</a> (<code>[\x01&shy;\x7F]</code>).</p>&#10;<p>Pode&shy;se negar uma classe de caracteres precedendo um acento circunflexo ao nome da classe. Por exemplo, para negar <code>[:digit:]</code> usa&shy;se <code>[:^digit:]</code>.<sup id="_ref&shy;doc perl_b" class="reference"><a href="#_note&shy;doc perl" title="">[4]</a></sup></p>&#10;<a id="Limites_de_palavras" name="Limites_de_palavras"></a><h4> Limites de palavras </h4>&#10;<p>A norma POSIX define ainda dois metacaracteres especiais que servem para casar os limites de palavras nas cadeias de caracteres. Nesse contexto da POSIX, uma palavra &eacute; formada por caracteres <code>[:alnum:]</code> ou <a href="http://en.wikipedia.org/wiki/Tra%C3%A7o_baixo" id="w">tra&ccedil;o baixo</a> (<code>_</code>). Assim como as &acirc;ncoras,  esses metacaracteres n&atilde;o casam peda&ccedil;os do texto, elas servem apenas como uma refer&ecirc;ncia. Eles s&atilde;o:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table>&#10;<tr>&#10;<td><code>[[:&#60&semi;:]]</code></td>&#10;<td>Casa o come&ccedil;o de palavras.</td></tr>&#10;<tr>&#10;<td><code>[[:&#62&semi;:]]</code></td>&#10;<td>Casa o fim de palavras.</td></tr></table></div>&#10;&#10;<a id="Perl_e_deriva%C3%A7%C3%B5es" name="Perl_e_deriva%C3%A7%C3%B5es"></a><h3> Perl e deriva&ccedil;&otilde;es </h3>&#10;<p><a href="http://en.wikipedia.org/wiki/Perl" id="w">Perl</a> possui uma sintaxe mais consistente e rica que as normas POSIX BRE e ERE. Um exemplo &eacute; que <code>\</code> sempre escapa um caractere n&atilde;o alfanum&eacute;rico. Devido ao poder de express&atilde;o, outras ferramentas adotaram a sintaxe do Perl, como por exemplo <a href="http://en.wikipedia.org/wiki/Java_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Java</a><sup id="_ref&shy;5" class="reference"><a href="#_note&shy;5" title="">[5]</a></sup>, <a href="http://en.wikipedia.org/wiki/JavaScript" id="w">JavaScript</a>, <a href="http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions" id="w">PCRE</a>, <a href="http://en.wikipedia.org/wiki/Python" id="w">Python</a><sup id="_ref&shy;6" class="reference"><a href="#_note&shy;6" title="">[6]</a></sup>, <a href="http://en.wikipedia.org/wiki/Ruby_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Ruby</a> e <a href="http://en.wikipedia.org/wiki/.NET" id="w">.NET</a><sup id="_ref&shy;7" class="reference"><a href="#_note&shy;7" title="">[7]</a></sup>. Algumas linguagens e ferramentas como <a href="http://en.wikipedia.org/wiki/PHP" id="w">PHP</a> suportam diversos tipos de express&otilde;es regulares.</p>&#10;<p>Um exemplo de funcionalidade poss&iacute;vel em Perl mas n&atilde;o em POSIX &eacute; a quantifica&ccedil;&atilde;o pregui&ccedil;osa. Os quantificadores padr&otilde;es das express&otilde;es regulares s&atilde;o &#34&semi;gananciosos&#34&semi;, isto &eacute;, casam o quanto puderem, <a href="http://en.wikipedia.org/wiki/Backtracking" id="w">voltando atr&aacute;s</a> somente se necess&aacute;rio para casar o resto da express&atilde;o regular. Por exemplo, um novato no assunto tentando encontrar a primeira inst&acirc;ncia de um item entre os s&iacute;mbolos &#60&semi; e &#62&semi; no texto &#34&semi;<i>Outra explos&atilde;o ocorreu em &#60&semi;26 de janeiro&#62&semi; de &#60&semi;2004&#62&semi;</i>&#34&semi; provavelmente usaria o padr&atilde;o <code>&#60&semi;.*&#62&semi;</code>, ou similar. Entretanto, esse padr&atilde;o retornar&aacute; &#34&semi;<i>&#60&semi;26 de janeiro&#62&semi; de &#60&semi;2004&#62&semi;</i>&#34&semi; ao inv&eacute;s de &#34&semi;<i>&#60&semi;26 de janeiro&#62&semi;</i>&#34&semi;, como esperado, pois o quantificador <code>*</code> &eacute; ganancioso &mdash; ele consumir&aacute; a quantidade m&aacute;xima de caracteres, e &#34&semi;<i>26 de janeiro&#62&semi; de &#60&semi;2004</i>&#34&semi; possui mais caracteres que &#34&semi;<i>26 de janeiro</i>&#34&semi;.</p>&#10;<p>Apesar desse problema ser evit&aacute;vel de diferentes formas (por exemplo, especificando o que n&atilde;o casar: <code>&#60&semi;[^&#62&semi;]*&#62&semi;</code>), a maioria das ferramentas permitem que um quantificador seja pregui&ccedil;oso, ou n&atilde;o ganancioso, ao suceder o quantificador com um ponto de interroga&ccedil;&atilde;o. No exemplo anterior, a alternativa seria <code>&#60&semi;.*?&#62&semi;</code>. Seguem os quantificadores n&atilde;o&shy;gulosos:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table>&#10;<tr>&#10;<th colspan="2">Quantificadores n&atilde;o&shy;gulosos</th></tr>&#10;<tr>&#10;<td><code>??</code></td>&#10;<td>Vers&atilde;o n&atilde;o&shy;gulosa de <code>?</code>. Dado o texto &#34&semi;<i>aaa</i>&#34&semi;, <code>a?</code> casa &#34&semi;<i>a</i>&#34&semi; enquanto <code>a??</code> casa &#34&semi;&#34&semi;.</td></tr>&#10;<tr>&#10;<td><code>*?</code></td>&#10;<td>Vers&atilde;o n&atilde;o&shy;gulosa de <code>*</code>. Dado o texto &#34&semi;<i>aaa</i>&#34&semi;, <code>a*</code> casa &#34&semi;<i>aaa</i>&#34&semi; enquanto <code>a*?</code> casa &#34&semi;&#34&semi;.</td></tr>&#10;<tr>&#10;<td><code>+?</code></td>&#10;<td>Vers&atilde;o n&atilde;o&shy;gulosa de <code>+</code>. Dado o texto &#34&semi;<i>aaa</i>&#34&semi;, <code>a+</code> casa &#34&semi;<i>aaa</i>&#34&semi; enquanto <code>a+?</code> casa &#34&semi;<i>a</i>&#34&semi;.</td></tr>&#10;<tr>&#10;<td><code>{m,n}?</code></td>&#10;<td>Vers&atilde;o n&atilde;o&shy;gulosa de <code>{m,n}</code>. Dado o texto &#34&semi;<i>aaa</i>&#34&semi;, <code>a{2,3}</code> casa &#34&semi;<i>aaa</i>&#34&semi; enquanto <code>a{2,3}?</code> casa &#34&semi;<i>aa</i>&#34&semi;.</td></tr></table></div>&#10;&#10;<p>O PERL define algumas <a href="http://en.wikipedia.org/wiki/Seq%C3%BC%C3%AAncia_de_escape" id="w">seq&uuml;&ecirc;ncias de escape</a> que servem como atalhos para certos metacaracteres:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table>&#10;<tr>&#10;<th colspan="2">Padr&otilde;es individuais</th></tr>&#10;<tr valign="top">&#10;<td><code>\s</code></td>&#10;<td>Casa espa&ccedil;os em branco, \n \r ou \t.</td></tr>&#10;<tr valign="top">&#10;<td><code>\S</code></td>&#10;<td>Nega&ccedil;&atilde;o de \s: casa o que n&atilde;o for espa&ccedil;o em branco, \n \r ou \t.</td></tr>&#10;<tr valign="top">&#10;<td><code>\w</code></td>&#10;<td>Casa letras, d&iacute;gitos, ou &#39&semi;_&#39&semi;.</td></tr>&#10;<tr valign="top">&#10;<td><code>\W</code></td>&#10;<td>Nega&ccedil;&atilde;o de \w</td></tr>&#10;<tr valign="top">&#10;<td><code>\d</code></td>&#10;<td>Casa d&iacute;gitos, de 0 a 9.</td></tr>&#10;<tr valign="top">&#10;<td><code>\D</code></td>&#10;<td>Nega&ccedil;&atilde;o de \d</td></tr>&#10;<tr>&#10;<th colspan="2">&Acirc;ncoras</th></tr>&#10;<tr valign="top">&#10;<td><code>\b</code></td>&#10;<td>Casa a separa&ccedil;&atilde;o de palavras, o que inclui tamb&eacute;m o come&ccedil;o (<code>^</code>) e o fim (<code>$</code>) da cadeia de caracteres testada. A defini&ccedil;&atilde;o dos caracteres que formam palavras varia de acordo com a implementa&ccedil;&atilde;o, mas &eacute; seguro assumir pelo menos <code>[a&shy;zA&shy;Z0&shy;9_]</code>. Havendo suporte, o atalho <code>\w</code> &eacute; uma alternativa v&aacute;lida. O <a href="http://en.wikipedia.org/wiki/Java_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Java</a> &eacute; uma not&aacute;vel exce&ccedil;&atilde;o na medida em que suporta <code>\b</code> mas n&atilde;o <code>\w</code>. Notar que apesar de parecida com os limites de palavras definidos pela POSIX, esta sequ&ecirc;ncia de escape n&atilde;o distingue o come&ccedil;o e o final da palavra, somente a separa&ccedil;&atilde;o em si.</td></tr>&#10;<tr valign="top">&#10;<td><code>\B</code></td>&#10;<td>Nega&ccedil;&atilde;o de \b</td></tr>&#10;<tr valign="top">&#10;<td><code>\A</code></td>&#10;<td>Casa o come&ccedil;o da cadeia de caracteres. Numa situa&ccedil;&atilde;o de m&uacute;ltiplas linhas, n&atilde;o casa o come&ccedil;o das linhas seguintes, o que a difere de <code>^</code>. </td></tr>&#10;<tr valign="top">&#10;<td><code>\Z</code></td>&#10;<td>Casa o fim da cadeia de caracteres ou a posi&ccedil;&atilde;o logo antes da quebra de linha do fim da cadeia. Numa situa&ccedil;&atilde;o de m&uacute;ltiplas linhas, n&atilde;o casa o fim das linhas seguintes, o que a difere de <code>$</code>.</td></tr>&#10;<tr valign="top">&#10;<td><code>\z</code></td>&#10;<td>Casa o fim da cadeia de caracteres.</td></tr></table></div>&#10;&#10;<p>Al&eacute;m dos quantificadores pregui&ccedil;osos e das novas seq&uuml;&ecirc;ncias de escape, o Perl tamb&eacute;m adicionou uma forma nova de casamento de padr&otilde;es que estendem a POSIX. S&atilde;o um conjunto de metacaracteres que seguem o padr&atilde;o <code>(?&hellip;)</code>, listados abaixo:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table>&#10;<tr valign="top">&#10;<td><code>(?#&#160&semi;)</code></td>&#10;<td>Adiciona um coment&aacute;rio, ignorado nos casamentos.</td></tr>&#10;<tr valign="top">&#10;<td><code>(?:&#160&semi;)</code></td>&#10;<td>Grupo de captura que n&atilde;o &eacute; salvo para rechamada posterior (<code>\1</code>, <code>\2</code>, <code>\3</code>, ...)</td></tr>&#10;<tr valign="top">&#10;<td><code>(?=&#160&semi;)</code></td>&#10;<td>Casa ocorr&ecirc;ncias do padr&atilde;o atual a partir da posi&ccedil;&atilde;o atual at&eacute; o final. Assim como as &acirc;ncoras (<code>^</code>, <code>$</code>), o padr&atilde;o n&atilde;o &eacute; inclu&iacute;do no casamento, servindo apenas na verifica&ccedil;&atilde;o. Por exemplo, o padr&atilde;o <code>carro(?=azul)</code> aplicado a &#34&semi;<i>Um carro esportivo azul barato.</i>&#34&semi; casar&aacute; &#34&semi;<i>carro</i>&#34&semi;.</td></tr>&#10;<tr valign="top">&#10;<td><code>(?!&#160&semi;)</code></td>&#10;<td>Nega&ccedil;&atilde;o de <code>(?=)</code>, casa a aus&ecirc;ncia do padr&atilde;o atual a partir da posi&ccedil;&atilde;o atual at&eacute; o final, e tamb&eacute;m n&atilde;o inclui o padr&atilde;o no casamento. Por exemplo, o padr&atilde;o <code>carro(?!amarelo)</code> casar&aacute; em &#34&semi;<i>Um carro esportivo azul barato.</i>&#34&semi;, entretanto <code>carro(?!azul)</code> n&atilde;o casar&aacute;.</td></tr>&#10;<tr valign="top">&#10;<td><code>(?&#60&semi;=&#160&semi;)</code></td>&#10;<td>Casa ocorr&ecirc;ncias do padr&atilde;o atual a partir do come&ccedil;o at&eacute; a posi&ccedil;&atilde;o atual, mas n&atilde;o inclui o padr&atilde;o no casamento, servindo apenas na verifica&ccedil;&atilde;o. Por exemplo, o padr&atilde;o <code>(?&#60&semi;=carro)azul</code> aplicado a &#34&semi;<i>Um carro esportivo azul barato.</i>&#34&semi; casar&aacute; &#34&semi;<i>azul</i>&#34&semi;.</td></tr>&#10;<tr valign="top">&#10;<td><code>(?&#60&semi;!&#160&semi;)</code></td>&#10;<td>Nega&ccedil;&atilde;o de <code>(?&#60&semi;=)</code>, casa a aus&ecirc;ncia do padr&atilde;o atual a partir do come&ccedil;o at&eacute; a posi&ccedil;&atilde;o atual, e tamb&eacute;m n&atilde;o inclui o padr&atilde;o no casamento. Por exemplo, o padr&atilde;o <code>(?&#60&semi;!carro)amarelo</code> casar&aacute; em &#34&semi;<i>Um carro esportivo azul barato.</i>&#34&semi;, entretanto <code>(?&#60&semi;!carro)azul</code> n&atilde;o casar&aacute;.</td></tr>&#10;<tr valign="top">&#10;<td><code>(?&#160&semi;)</code></td>&#10;<td>Aplica modificadores a partes da express&atilde;o regular. Os valores aceitos s&atilde;o i (ignora diferen&ccedil;as entre mai&uacute;sculas e min&uacute;sculas), m (texto multilinha), s (texto monolinha) e x (inclus&atilde;o de espa&ccedil;os e coment&aacute;rios).</td></tr>&#10;<tr valign="top">&#10;<td><code>(?(A)B|C)</code></td>&#10;<td>Um <a href="http://en.wikipedia.org/wiki/Opera%C3%A7%C3%A3o_tern%C3%A1ria#Programa&ccedil;&atilde;o" id="w">operador tern&aacute;rio</a>, usado geralmente em conjunto dos grupos de captura. Por exemplo, a escolha duma ou outra subexpress&atilde;o regular depende dum casamento ou n&atilde;o anterior.</td></tr>&#10;<tr valign="top">&#10;<td><code>(?(A)B)</code></td>&#10;<td>Varia&ccedil;&atilde;o bin&aacute;ria da estrutura anterior, em que uma express&atilde;o &eacute; adicionada ao padr&atilde;o <a href="http://en.wikipedia.org/wiki/Se_e_somente_se" id="w">se e somente se</a> a condi&ccedil;&atilde;o &eacute; verdadeira.</td></tr></table></div>&#10;&#10;<a id="Padr%C3%B5es_para_linguagens_n%C3%A3o_regulares" name="Padr%C3%B5es_para_linguagens_n%C3%A3o_regulares"></a><h2> Padr&otilde;es para linguagens n&atilde;o regulares </h2>&#10;<p>Diversas funcionalidades encontradas em bibliotecas atuais de express&otilde;es regulares provem um poder de express&atilde;o que excede as <a href="http://en.wikipedia.org/wiki/Linguagem_regular" id="w">linguagens regulares</a>. Por exemplo, a habilidade de agrupar subexpress&otilde;es com par&ecirc;nteses e chamar novamente o valor casado na mesma express&atilde;o significa que o padr&atilde;o pode casar cadeias de palavras repetidas como &#34&semi;<i>papa</i>&#34&semi; ou &#34&semi;<i>WikiWiki</i>&#34&semi;, os chamados quadrados na teoria de linguagens formais. O padr&atilde;o para essas cadeias &eacute; <code>(.*)\1</code>. Entretanto, a linguagem de quadrados n&atilde;o &eacute; regular, nem <a href="http://en.wikipedia.org/wiki/Linguagem_livre_de_contexto" id="w">livre de contexto</a>. <a href="http://en.wikipedia.org/wiki/Casamento_de_padr%C3%B5es" id="w">Casamento de padr&otilde;es</a> com um n&uacute;mero indeterminado de refer&ecirc;ncias anteriores, como suportado em ferramentas atuais, &eacute; <a href="http://en.wikipedia.org/wiki/NP&shy;dif%C3%ADcil" id="w">NP&shy;dif&iacute;cil</a>.</p>&#10;<p>Entretanto, as ferramentas que fornecem tais constru&ccedil;&otilde;es ainda usam o termo express&otilde;es regulares para os padr&otilde;es, o que leva a uma nomenclatura que difere da teoria das linguagens formais. Por essa raz&atilde;o, algumas pessoas usam o termo <i>regex</i> ou simplesmente <i>padr&atilde;o</i> para descrever esse conceito mais abrangente.</p>&#10;<a id="Implementa%C3%A7%C3%B5es" name="Implementa%C3%A7%C3%B5es"></a><h2> Implementa&ccedil;&otilde;es </h2>&#10;<p>Existem pelo menos dois <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmos</a> fundamentalmente diferentes entre si que decidem se e como uma express&atilde;o regular casa uma cadeia de caracteres.</p>&#10;<p>O mais antigo e mais r&aacute;pido faz uso dum princ&iacute;pio da teoria de linguagens formais que permite a todas as m&aacute;quinas de estado finito n&atilde;o determin&iacute;sticas serem transformadas em m&aacute;quinas de estado finito determin&iacute;sticas. Geralmente chamado de DFA, o algoritmo realiza ou simula tal transforma&ccedil;&atilde;o e ent&atilde;o executa a m&aacute;quina determin&iacute;stica resultante na cadeia de caracteres, um s&iacute;mbolo de cada vez. Esse &uacute;ltimo processo tem <a href="http://en.wikipedia.org/wiki/Complexidade_linear" id="w">complexidade linear</a> relativa ao tamanho da cadeia de caracteres. Mais precisamente, uma cadeia de caracteres de tamanho <i>n</i> pode ser testada numa express&atilde;o regular de tamanho <i>m</i> no tempo <a href="http://en.wikipedia.org/wiki/Grande&shy;O" id="w">&#39&semi;&#39&semi;O&#39&semi;&#39&semi;</a>(<i><span class="math">n+2^m</span></i>) ou <i>O</i>(<i><span class="math">nm</span></i>), dependendo dos detalhes de implementa&ccedil;&atilde;o. Esse algoritmo &eacute; r&aacute;pido, mas pode ser usado somente para casamentos e n&atilde;o para a rechamada de grupos de captura, quantifica&ccedil;&atilde;o pregui&ccedil;osa e diversas outras funcionalidades encontradas nas bibliotecas modernas de express&otilde;es regulares. Tamb&eacute;m &eacute; poss&iacute;vel executar a m&aacute;quina n&atilde;o determin&iacute;stica diretamente, construindo cada estado da m&aacute;quina determin&iacute;stica quando necess&aacute;rio e ent&atilde;o descartando&shy;o no pr&oacute;ximo passo. Isso evita a quantidade exponencial de mem&oacute;ria necess&aacute;ria para a constru&ccedil;&atilde;o completa da m&aacute;quina determin&iacute;stica, ainda que garantindo a busca em tempo linear.<sup id="_ref&shy;8" class="reference"><a href="#_note&shy;8" title="">[8]</a></sup></p>&#10;<p>O outro algoritmo &eacute; casar o padr&atilde;o com a cadeia de caracteres atrav&eacute;s de <i><a href="http://en.wikipedia.org/wiki/Backtracking" id="w">backtracking</a></i>. Geralmente chamado de NFA, Seu tempo de execu&ccedil;&atilde;o pode ser <a href="http://en.wikipedia.org/wiki/Complexidade_exponencial" id="w">exponencial</a>, o que pode acontecer em implementa&ccedil;&otilde;es simples no casamento de express&otilde;es como <code>(a|aa)*b</code>, que for&ccedil;am o algoritmo a considerar um n&uacute;mero exponencial de subcasos. Implementa&ccedil;&otilde;es modernas geralmente identificam tais casos, e aceleram e abortam a execu&ccedil;&atilde;o. Apesar dessas implementa&ccedil;&otilde;es com <i>backtracking</i> garantirem tempo exponencial no pior caso, elas fornecem mais flexibilidade e poder de express&atilde;o.</p>&#10;<a id="Relacionamento_com_Unicode" name="Relacionamento_com_Unicode"></a><h2> Relacionamento com Unicode </h2>&#10;<p>Originalmente, as express&otilde;es regulares eram usadas com caracteres <a href="http://en.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange" id="w">ASCII</a>, mas v&aacute;rias implementa&ccedil;&otilde;es atuais suportam <a href="http://en.wikipedia.org/wiki/Unicode" id="w">Unicode</a>. Na maioria dos casos n&atilde;o h&aacute; diferen&ccedil;a entre conjuntos de caracteres, mas algumas quest&otilde;es s&atilde;o relevantes ao suportar Unicode.</p>&#10;<p>Uma delas &eacute; a codifica&ccedil;&atilde;o suportada, j&aacute; que algumas implementa&ccedil;&otilde;es esperam <a href="http://en.wikipedia.org/wiki/UTF&shy;8" id="w">UTF&shy;8</a>, enquanto outras podem esperar <a href="http://en.wikipedia.org/wiki/UTF&shy;16" id="w">UTF&shy;16</a> ou <a href="http://en.wikipedia.org/wiki/UTF&shy;32" id="w">UTF&shy;32</a>. Outra quest&atilde;o &eacute; estender as funcionalidades dispon&iacute;veis para ASCII no Unicode. Por exemplo, em implementa&ccedil;&otilde;es ASCII, conjuntos de caracteres na forma <code>[x&shy;y]</code> s&atilde;o v&aacute;lidos para quaisquer <i>x</i> e <i>y</i> no intervalo [0x00,0x7F] desde que o c&oacute;digo de <i>x</i> seja menor que o c&oacute;digo de <i>y</i>. A escolha natural seria permitir o mesmo em Unicode no intervalo de c&oacute;digos [0,0x10FFFF], o que n&atilde;o &eacute; poss&iacute;vel pois algumas implementa&ccedil;&otilde;es n&atilde;o permitem que conjuntos de caracteres ultrapassem os blocos de c&oacute;digo dispon&iacute;veis.</p>&#10;<p>Do ponto de vista dos detalhes t&eacute;cnicos do Unicode, tamb&eacute;m surgem quest&otilde;es. Como a normaliza&ccedil;&atilde;o, pois, em Unicode, mais de um c&oacute;digo pode representar o mesmo caractere. Por exemplo, o caractere &#34&semi;<a href="http://en.wikipedia.org/wiki/&Eacute;" id="w">&eacute;</a>&#34&semi; pode ser representado por U+0065 (letra latina &#34&semi;<a href="http://en.wikipedia.org/wiki/E" id="w">e</a>&#34&semi; min&uacute;sculo) combinado com U+0301 (diacr&iacute;tico &#34&semi;<a href="http://en.wikipedia.org/wiki/Acento_agudo" id="w">acento agudo</a>&#34&semi;), mas tamb&eacute;m pode ser representado como U+00E9 (letra latina &#34&semi;e&#34&semi; com diacr&iacute;tico &#34&semi;acento agudo&#34&semi;). Tamb&eacute;m h&aacute; os c&oacute;digos de controle Unicode, as marcas de ordem de byte e as marcas de dire&ccedil;&atilde;o de texto, que devem ser tratados separadamente.</p>&#10;<a id="Uso" name="Uso"></a><h2> Uso </h2>&#10;<p>Express&otilde;es regulares s&atilde;o usadas por diversos <a href="http://en.wikipedia.org/wiki/Editor_de_texto" id="w">editores de texto</a>, <a href="http://en.wikipedia.org/wiki/Utilit%C3%A1rio" id="w">utilit&aacute;rios</a> e <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagens de programa&ccedil;&atilde;o</a> para procurar e manipular texto baseado em padr&otilde;es. Por exemplo, <a href="http://en.wikipedia.org/wiki/Perl" id="w">Perl</a> e <a href="http://en.wikipedia.org/wiki/Tcl" id="w">Tcl</a> possuem suporte a express&otilde;es regulares nativamente. Diversos utilit&aacute;rios de distribui&ccedil;&otilde;es <a href="http://en.wikipedia.org/wiki/Unix" id="w">Unix</a> incluem o editor de texto <a href="http://en.wikipedia.org/wiki/Ed_(software)" id="w">ed</a>, que popularizou o conceito de express&atilde;o regular, e o filtro <a href="http://en.wikipedia.org/wiki/Grep" id="w">grep</a>.</p>&#10;<p>Outro uso &eacute; a valida&ccedil;&atilde;o de formatos de texto (valida&ccedil;&atilde;o de protocolos ou formatos digitais). Por exemplo, ao receber a entrada dum campo de formul&aacute;rio duma aplica&ccedil;&atilde;o que sup&otilde;e receber um endere&ccedil;o de <i><a href="http://en.wikipedia.org/wiki/Email" id="w">email</a></i>, pode&shy;se usar uma express&atilde;o regular para garantir que o que foi recebido de fato &eacute; um endere&ccedil;o de <i>email</i>.</p>&#10;<p>Mais um uso &eacute; a implementa&ccedil;&atilde;o interna dum sistema de <a href="http://en.wikipedia.org/wiki/Realce_de_sintaxe" id="w">realce de sintaxe</a>, como encontrado em <a href="http://en.wikipedia.org/wiki/Ambiente_de_desenvolvimento_integrado" id="w">ambientes de desenvolvimento integrado</a>. Express&otilde;es regulares podem ser usadas para encontrar <a href="http://en.wikipedia.org/wiki/Palavra_reservada" id="w">palavras reservadas</a>, literais e outros tokens espec&iacute;ficos, e para alterar a formata&ccedil;&atilde;o do texto de acordo com o casamento feito.</p>&#10;<p>Um uso difundido de express&otilde;es regulares &eacute; a filtragem de informa&ccedil;&atilde;o em bancos de dados de texto. Por exemplo, num arquivo de texto contendo cadastros de pessoas e suas datas de anivers&aacute;rio como a seguir:</p>&#10;<pre>1954&shy;10&shy;01 Jo&atilde;o Alberto&#10;1976&shy;07&shy;25 Maria Eduarda&#10;1966&shy;10&shy;22 Carlos Silva&#10;</pre>&#10;<p>Pode&shy;se filtrar pessoas que nasceram num determinado ano, m&ecirc;s ou dia. Por exemplo, o uso do padr&atilde;o <code>^[0&shy;9]{4}&shy;10&shy;[0&shy;9]{2} (.*)$</code> identifica o nome das pessoas que nasceram em outubro. Para o cadastro acima seriam retornados dois grupos de captura, <code>\1</code> contendo &#34&semi;<i>Jo&atilde;o Alberto</i>&#34&semi; e <code>\2</code> contendo &#34&semi;<i>Carlos Silva</i>&#34&semi;. Explorando o exemplo anterior e o uso de valida&ccedil;&atilde;o de formatos digitais, &eacute; poss&iacute;vel usar express&otilde;es regulares para validar as datas presentes no arquivo de texto de anivers&aacute;rios acima. O padr&atilde;o <code>(19|20)\d\d([&shy; /.])(0[1&shy;9]|1[012])\2([012][0&shy;9]|3[01])</code> &eacute; usado para validar uma data entre 1900&shy;01&shy;01 e 2099&shy;12&shy;31.<sup id="_ref&shy;9" class="reference"><a href="#_note&shy;9" title="">[9]</a></sup> Atentar que a separa&ccedil;&atilde;o entre ano, m&ecirc;s e dia pode se dar atrav&eacute;s de h&iacute;fen, espa&ccedil;o em branco, barra ou ponto. Mas deve&shy;se usar o mesmo s&iacute;mbolo de separa&ccedil;&atilde;o entre ano e m&ecirc;s e entre m&ecirc;s e dia, o que &eacute; poss&iacute;vel atrav&eacute;s da rechamada do grupo de captura anterior (o trecho <code>\2</code> do padr&atilde;o). Atentar tamb&eacute;m que o padr&atilde;o &eacute; incompleto na medida em que n&atilde;o diferencia a quantidade de dias em cada m&ecirc;s, o que resulta no casamento duma cadeia de caracteres &#34&semi;<i>2000&shy;02&shy;31</i>&#34&semi;, incorreta de acordo com o <a href="http://en.wikipedia.org/wiki/Calend%C3%A1rio_gregoriano" id="w">calend&aacute;rio gregoriano</a>.</p>&#10;<p> &#10;</p>&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li></ul>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;<p> &#10;</p>&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Editor_de_texto" id="w">Editor de texto</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Teoria_da_computa%C3%A7%C3%A3o" id="w">Teoria da computa&ccedil;&atilde;o</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Aut%C3%B4mato" id="w">Aut&ocirc;mato</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagem_regular" id="w">Linguagem regular</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Casamento_de_padr%C3%B5es" id="w">Casamento de padr&otilde;es</a></li></ul>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://guia&shy;er.sourceforge.net" rel="nofollow" title="http://guia&shy;er.sourceforge.net">Manual de Regex</a></li>&#10;<li><a class="externallink" href="http://aurelio.net/er" rel="nofollow" title="http://aurelio.net/er">Portal sobre express&otilde;es regulares</a></li>&#10;<li><a class="externallink" href="http://www.regex.pro.br" rel="nofollow" title="http://www.regex.pro.br">Wiki sobre express&otilde;es regulares</a></li></ul>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_formais" id="w">Categoria:Linguagens formais</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:T%C3%B3picos_em_linguagens_de_programa%C3%A7%C3%A3o" id="w">Categoria:T&oacute;picos em linguagens de programa&ccedil;&atilde;o</a></p></body></html>