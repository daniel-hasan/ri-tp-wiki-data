<html><title>Algoritmo de Bellman&shy;Ford</title><body>&#10;<p>O <b>Algoritmo de Bellman&shy;Ford</b> &eacute; um <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmo</a> de busca de <a href="http://en.wikipedia.org/wiki/Problema_do_caminho_m%C3%ADnimo" id="w">caminho m&iacute;nimo</a> em um <a href="http://en.wikipedia.org/wiki/D%C3%ADgrafo" id="w">d&iacute;grafo</a> ponderado, ou seja, cujas arestas t&ecirc;m peso, inclusive negativo. O <a href="http://en.wikipedia.org/wiki/Algoritmo_de_Dijkstra" id="w">Algoritmo de Dijkstra</a> resolve o mesmo problema, em um tempo menor, por&eacute;m exige que todas as arestas tenham pesos positivos. Portanto, o algoritmo de Bellman&shy;Ford &eacute; normalmente usado apenas quando existem arestas de peso negativo.<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup></p>&#10;<p>O algoritmo de Bellman&shy;Ford executa em tempo <span class="math">O(v \times a)</span> onde <i>v</i> &eacute; o n&uacute;mero de v&eacute;rtices e <i>a</i> o n&uacute;mero de arestas.<sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup><sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup></p>&#10;<p>Este algoritmo, obviamente, s&oacute; funciona assumindo que o grafo n&atilde;o tem ciclo negativo, pois se houvesse, n&atilde;o haveria caminho m&iacute;nimo, basta ficar iterando neste pr&oacute;prio ciclo. Para encontrar o algoritmo, comece Comece denotando por M[i,v] o custo m&iacute;nimo para irmos do n&oacute; v at&eacute; o n&oacute; t usando no m&aacute;ximo i arestas. Agora, veja que, como o grafo n&atilde;o tem ciclo negativo, M[i,v]=M[n&shy;1,v] (para todo i&#62&semi;=n&shy;1), pois tendo n arestas no caminho, h&aacute; algum ciclo nele, mas sabemos que todo ciclo tem peso positivo, ent&atilde;o poder&iacute;amos reduzir o caminho diminuindo o custo, logo, os caminhos ideias ter&atilde;o no m&aacute;ximo n&shy;1 arestas.</p>&#10;<p>Veja que h&aacute; uma recorr&ecirc;ncia simples para M[i,v], pois se o caminho ideal tem no m&aacute;ximo i&shy;1 arestas, a resposta ser&aacute; M[i&shy;1,v], caso contr&aacute;rio (se ele tiver exatamente i arestas), chame de (v,w) a primeira aresta, M[i,v] ser&aacute; igual a o valor do peso da aresta (v,w)+M[i&shy;1,w], assim, temos uma f&oacute;rmula para M[i,v] em fun&ccedil;&atilde;o dos termos anteriores, sendo ela:</p>&#10;<p>M[i,v]=min(M[i&shy;1,v],min(M[i&shy;1,w]+P(v,w))(em w pertencente aos n&oacute;s do grafo)). Mas sabemos os casos iniciais, pois &nbsp;M[0,v] &eacute; infinito para todo v nos n&oacute;s do grafo, exceto o n&oacute; t, que &eacute; o n&oacute; que o objetivo &eacute; chegar, onde M[0,t]=0. Com esta recorr&ecirc;ncia, fica &oacute;bvio um pseudoc&oacute;digo para implementar este algoritmo, como foi implementado, este c&oacute;digo tem complexidade O(n^3).</p>&#10;<p>H&aacute; uma simplifica&ccedil;&atilde;o &oacute;bvia nesta implementa&ccedil;&atilde;o, pois procuramos o m&iacute;nimo em todos os n&oacute;s do grafo, mas basta procurar nos n&oacute;s que v chega, reduzindo a complexidade para O(n*arestas). O que reduz significativamente a complexidade do algoritmo caso o mesmo tenha poucas arestas. Podemos tamb&eacute;m otimizar o espa&ccedil;o usado para implementar o algoritmo, basta que a cada etapa, n&atilde;o salvemos M[i,v] para todo v, mas que atualizemos M a cada etapa, precisando apenas de uma lista, e n&atilde;o uma lista de listas para resolver o problema, o algoritmo fica bem parecido, mudando apenas a recorr&ecirc;ncia para: M[v] = min(M[v],min(M[w]+P(v,w)) (em w pertencente aos n&oacute;s do grafo que v chega)).</p>&#10;<p><big /></p>&#10;<p />&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Teoria_dos_grafos" id="w">Teoria dos grafos</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Problema_do_caminho_m%C3%ADnimo" id="w">Problema do caminho m&iacute;nimo</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Algoritmo_de_Dijkstra" id="w">Algoritmo de Dijkstra</a></li></ul>&#10;<p> &#10; &#10;</p><a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2>Liga&ccedil;&otilde;es externas</h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="https://github.com/xtaci/algorithms/blob/master/include/bellman_ford.h" rel="nofollow" title="https://github.com/xtaci/algorithms/blob/master/include/bellman_ford.h">C&oacute;digo C++</a>  </li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos_de_grafos" id="w">Bellman&shy;Ford</a></p></body></html>