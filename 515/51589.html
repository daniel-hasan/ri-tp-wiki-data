<html><title>Teste de software</title><body>&#10;<p>O <b>teste do software</b>  &eacute; a <a href="http://en.wikipedia.org/wiki/Investiga%C3%A7%C3%A3o" id="w">investiga&ccedil;&atilde;o</a> do <a href="http://en.wikipedia.org/wiki/Software" id="w">software</a> a fim de fornecer informa&ccedil;&otilde;es sobre sua <a href="http://en.wikipedia.org/wiki/Qualidade_de_software" id="w">qualidade</a> em rela&ccedil;&atilde;o ao contexto em que ele deve operar. Isso inclui o processo de utilizar o produto para encontrar seus defeitos.</p>&#10;<p>O teste &eacute; um processo realizado pelo testador de software, que permeia outros processos da <a href="http://en.wikipedia.org/wiki/Engenharia_de_software" id="w">engenharia de software</a>, e que envolve a&ccedil;&otilde;es que v&atilde;o do <a href="http://en.wikipedia.org/wiki/Levantamento_de_requisitos" id="w">levantamento de requisitos</a> at&eacute; a execu&ccedil;&atilde;o do teste propriamente dito.</p>&#10;<a id="Vis%C3%A3o_geral" name="Vis%C3%A3o_geral"></a><h2> Vis&atilde;o geral </h2>&#10;<p>N&atilde;o se pode garantir que todo <a href="http://en.wikipedia.org/wiki/Software" id="w">software</a> funcione corretamente, sem a presen&ccedil;a de erros,<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup> visto que os mesmos muitas vezes possuem um grande n&uacute;mero de estados com f&oacute;rmulas, atividades e <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmos</a> complexos. O tamanho do projeto a ser desenvolvido e a quantidade de pessoas envolvidas no processo aumentam ainda mais a complexidade. Idealmente, toda permuta&ccedil;&atilde;o poss&iacute;vel do software deveria ser testada. Entretanto, isso se torna imposs&iacute;vel para a ampla maioria dos casos devido &agrave; quantidade impratic&aacute;vel de possibilidades. A qualidade do teste acaba se relacionando &agrave; qualidade dos profissionais envolvidos em filtrar as permuta&ccedil;&otilde;es relevantes.<sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup></p>&#10;<p>Falhas podem ser originadas por diversos motivos. Por exemplo, a <a href="http://en.wikipedia.org/wiki/Projeto_de_Software" id="w">especifica&ccedil;&atilde;o</a> pode estar errada ou incompleta, ou pode conter <a href="http://en.wikipedia.org/wiki/Requisito" id="w">requisitos</a> imposs&iacute;veis de serem <a href="http://en.wikipedia.org/wiki/Implementa%C3%A7%C3%A3o" id="w">implementados</a>, devido a limita&ccedil;&otilde;es de <a href="http://en.wikipedia.org/wiki/Hardware" id="w">hardware</a> ou software. A implementa&ccedil;&atilde;o tamb&eacute;m pode estar errada ou incompleta, como um erro de um algoritmo. Portanto, uma falha &eacute; o resultado de um ou mais defeitos em algum aspecto do sistema.</p>&#10;<p>O teste de software pode ser visto como uma parcela do processo de <a href="http://en.wikipedia.org/wiki/Qualidade_de_software" id="w">qualidade de software</a>. A qualidade da aplica&ccedil;&atilde;o pode e, normalmente, varia significativamente de sistema para sistema.</p>&#10;<p>Os atributos qualitativos previstos na norma <a href="http://en.wikipedia.org/wiki/ISO_9126" id="w">ISO 9126</a> s&atilde;o:&#10;</p>&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/ISO_9126#Funcionalidade" id="w">Funcionalidade</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/ISO_9126#Confiabilidade" id="w">Confiabilidade</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/ISO_9126#Usabilidade" id="w">Usabilidade</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/ISO_9126#Efici.C3.AAncia" id="w">Efici&ecirc;ncia</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/ISO_9126#Manutenibilidade" id="w">Manutenibilidade</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/ISO_9126#Portabilidade" id="w">Portabilidade</a></li></ul>&#10;<p>De forma geral, mensurar o bom funcionamento de um software envolve compar&aacute;&shy;lo com elementos como especifica&ccedil;&otilde;es, outros softwares da mesma linha, vers&otilde;es anteriores do mesmo produto, infer&ecirc;ncias pessoais, expectativas do cliente, normas relevantes, leis aplic&aacute;veis, entre outros. Enquanto a especifica&ccedil;&atilde;o do software diz respeito ao processo de verifica&ccedil;&atilde;o do software, a expectativa do cliente diz respeito ao processo de valida&ccedil;&atilde;o do software. Por meio da verifica&ccedil;&atilde;o ser&aacute; analisado se o produto foi feito corretamente, se ele est&aacute; de acordo com os requisitos especificados. Por meio da valida&ccedil;&atilde;o ser&aacute; analisado se foi feito o produto correto, se ele est&aacute; de acordo com as necessidades e expectativas do cliente.</p>&#10;<p>Um <a href="http://en.wikipedia.org/wiki/Desenvolvimento_de_software" id="w">desenvolvimento de software</a> organizado tem como premissa uma <a href="http://en.wikipedia.org/wiki/Metodologia" id="w">metodologia</a> de trabalho. Esta deve ter como base conceitos que visem a constru&ccedil;&atilde;o de um produto de software de forma eficaz. Dentro desta metodologia est&atilde;o definidos os passos necess&aacute;rios para chegar ao produto final esperado.</p>&#10;<p>Assim, quando se segue uma metodologia para o desenvolvimento de um produto de software, espera&shy;se um produto final que melhor agrade tanto aos clientes quanto ao pr&oacute;prio fornecedor, ou seja, a empresa de desenvolvimento. Observando este aspecto, n&atilde;o faz sentido iniciar a constru&ccedil;&atilde;o de um produto de software sem ter uma metodologia de trabalho bem solidificada e que seja do conhecimento de todos os envolvidos no processo. Por&eacute;m, al&eacute;m de uma crescente demanda por softwares de qualidade, as empresas de desenvolvimento de software sofrem cada vez mais press&atilde;o por parte dos clientes para que o produto seja entregue num curto per&iacute;odo de tempo. Este fato pode fazer com que uma s&oacute;lida metodologia de trabalho acabe por se desequilibrar.</p>&#10;<p>Independentemente da metodologia de trabalho empregada no desenvolvimento de um software, para que se obtenha um produto final com um certo n&iacute;vel de qualidade &eacute; imprescind&iacute;vel a melhoria dos processos de engenharia de software.</p>&#10;<p>Uma maneira vi&aacute;vel para se assegurar a melhoria de tais <a href="http://en.wikipedia.org/wiki/Processos" id="w">processos</a> seria tomar como base modelos sugeridos por entidades internacionais respeitadas no assunto. Dentro de uma gama de modelos, sejam eles para situa&ccedil;&otilde;es e ambientes espec&iacute;ficos ou para solu&ccedil;&otilde;es gen&eacute;ricas, existem alguns que s&atilde;o mais utilizados e tidos como eficientes, como por exemplo os <a href="http://en.wikipedia.org/wiki/SW&shy;CMM" id="w">SW&shy;CMM</a>, <a href="http://en.wikipedia.org/wiki/SE&shy;CMM" id="w">SE&shy;CMM</a>, <a href="http://en.wikipedia.org/wiki/ISO/IEC_15504" id="w">ISO/IEC 15504</a> e o mais conhecido <a href="http://en.wikipedia.org/wiki/CMMI" id="w">CMMI</a>.</p>&#10;<p>Outro fator com grande influ&ecirc;ncia sobre a qualidade do software a ser produzido &eacute; o que diz respeito aos testes que ser&atilde;o executados sobre tal produto. Todas as metodologias de desenvolvimento de software t&ecirc;m uma disciplina dedicada aos testes. Atualmente esta &eacute; uma tarefa indispens&aacute;vel, por&eacute;m muitas vezes efetuada de maneira ineficiente, seja pelo subestimar dos que desenvolvem, pela falta de tempo ou mesmo pela falta de recursos humanos e financeiros.</p>&#10;<p>De acordo com um estudo conduzido pelo <a href="http://en.wikipedia.org/wiki/NIST" id="w">NIST</a> em <a href="http://en.wikipedia.org/wiki/2002" id="w">2002</a>, os <a href="http://en.wikipedia.org/wiki/Defeito_de_software" id="w">defeitos</a> resultam num custo anual de 59,5 <a href="http://en.wikipedia.org/wiki/Bilh%C3%A3o" id="w">bilh&otilde;es</a> de <a href="http://en.wikipedia.org/wiki/D%C3%B3lar_americano" id="w">d&oacute;lares</a> &agrave; economia dos <a href="http://en.wikipedia.org/wiki/Estados_Unidos" id="w">Estados Unidos</a>. Mais de um ter&ccedil;o do custo poderia ser evitado com melhorias na <a href="http://en.wikipedia.org/wiki/Infraestrutura" id="w">infraestrutura</a> do teste de software.<sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup></p>&#10;<a id="Princ%C3%ADpios" name="Princ%C3%ADpios"></a><h2> Princ&iacute;pios </h2>&#10;<p>Para Myers (2004), h&aacute; princ&iacute;pios vitais para o teste de software. O <a href="http://en.wikipedia.org/wiki/Caso_de_teste" id="w">caso de teste</a> deve definir a sa&iacute;da esperada, de forma a reduzir a interpreta&ccedil;&atilde;o do crit&eacute;rio de sucesso. A sa&iacute;da da execu&ccedil;&atilde;o do teste deve ser exaustivamente analisada. Os casos de teste devem verificar n&atilde;o somente as condi&ccedil;&otilde;es inv&aacute;lidas de execu&ccedil;&atilde;o, como tamb&eacute;m as condi&ccedil;&otilde;es v&aacute;lidas. Outro conceito apresentado &eacute; utilizar pessoas e organiza&ccedil;&otilde;es diferentes para a implementa&ccedil;&atilde;o e para a verifica&ccedil;&atilde;o. A entidade de teste possui uma vis&atilde;o destrutiva do sistema, em busca de erros, enquanto a entidade de programa&ccedil;&atilde;o possui uma vis&atilde;o construtiva, em busca da implementa&ccedil;&atilde;o de uma especifica&ccedil;&atilde;o.</p>&#10;<p>Myers tamb&eacute;m aborda o esfor&ccedil;o para se construir casos de teste. Deve&shy;se evitar testes descart&aacute;veis, pois a qualidade do teste piora gradualmente com as itera&ccedil;&otilde;es de desenvolvimento. Em contrapartida, h&aacute; o <a href="http://en.wikipedia.org/wiki/Teste_de_regress%C3%A3o" id="w">teste de regress&atilde;o</a>, que permite quantificar a evolu&ccedil;&atilde;o da qualidade de software, mantendo e executando novamente testes realizados anteriormente.</p>&#10;<p>O mesmo autor afirma que, diferente do que se poderia considerar senso comum, a probabilidade de exist&ecirc;ncia de erros num certo trecho de c&oacute;digo &eacute; proporcional &agrave; quantidade de erros j&aacute; encontrada anteriormente. Basicamente, erros aparecem em grupos. Trechos espec&iacute;ficos de c&oacute;digo de um software qualquer est&atilde;o mais propensos a ter erros que outros.</p>&#10;<a id="T%C3%A9cnicas" name="T%C3%A9cnicas"></a><h2> T&eacute;cnicas </h2>&#10;<p>Existem muitas maneiras de se testar um software. Mesmo assim, existem as t&eacute;cnicas que sempre foram muito utilizadas em sistemas desenvolvidos sobre <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_estruturada" id="w">linguagens estruturadas</a> que ainda hoje t&ecirc;m grande valia para os sistemas <a href="http://en.wikipedia.org/wiki/Orienta%C3%A7%C3%A3o_a_objeto" id="w">orientados a objeto</a>. Apesar de os <a href="http://en.wikipedia.org/wiki/Paradigma_de_programa%C3%A7%C3%A3o" id="w">paradigmas de desenvolvimento</a> serem completamente diferentes, o objetivo principal destas t&eacute;cnicas continua a ser o mesmo, encontrar falhas no software. Abaixo est&atilde;o descritas algumas das t&eacute;cnicas mais conhecidas.</p>&#10;<a id="Caixa&shy;branca" name="Caixa&shy;branca"></a><h3> Caixa&shy;branca </h3>&#10;<p> &#10;Tamb&eacute;m chamada de teste estrutural ou orientado &agrave; l&oacute;gica, a t&eacute;cnica de caixa&shy;branca avalia o comportamento interno do <a href="http://en.wikipedia.org/wiki/Componente_de_software" id="w">componente de software</a>. Essa t&eacute;cnica trabalha diretamente sobre o <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_fonte" id="w">c&oacute;digo fonte</a> do componente de software para avaliar aspectos tais como: teste de condi&ccedil;&atilde;o, <a href="http://en.wikipedia.org/wiki/Teste_de_fluxo_de_dados" id="w">teste de fluxo de dados</a>, teste de ciclos, teste de caminhos l&oacute;gicos, c&oacute;digos nunca executados.</p>&#10;<p>Os aspectos avaliados nesta t&eacute;cnica de teste depender&atilde;o da complexidade e da tecnologia que determinarem a constru&ccedil;&atilde;o do componente de software, cabendo portanto avalia&ccedil;&atilde;o de mais aspectos que os citados anteriormente. O testador tem acesso ao c&oacute;digo fonte da aplica&ccedil;&atilde;o e pode construir c&oacute;digos para efetuar a liga&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Biblioteca_de_rotinas" id="w">bibliotecas</a> e componentes. Este tipo de teste &eacute; desenvolvido analisando o c&oacute;digo fonte e elaborando casos de teste que cubram todas as possibilidades do componente de software. Dessa maneira, todas as varia&ccedil;&otilde;es relevantes originadas por estruturas de condi&ccedil;&otilde;es s&atilde;o testadas.</p>&#10;<p>Um exemplo bem pr&aacute;tico desta t&eacute;cnica de teste &eacute; o uso da ferramenta livre <a href="http://en.wikipedia.org/wiki/JUnit" id="w">JUnit</a> para desenvolvimento de classes de teste para testar classes ou m&eacute;todos desenvolvidos em <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_Java" id="w">Java</a>. Tamb&eacute;m se enquadram nessa t&eacute;cnica testes manuais ou testes efetuados com apoio de ferramentas para verifica&ccedil;&atilde;o de ader&ecirc;ncia a boas pr&aacute;ticas de codifica&ccedil;&atilde;o reconhecidas pelo mercado de software. A ader&ecirc;ncia a padr&otilde;es e boas pr&aacute;ticas visa principalmente a diminui&ccedil;&atilde;o da possibilidade de erros de codifica&ccedil;&atilde;o e a busca de utiliza&ccedil;&atilde;o de comandos que gerem o melhor desempenho de execu&ccedil;&atilde;o poss&iacute;vel. Apesar de muitos desenvolvedores alegarem que n&atilde;o h&aacute; ganhos percept&iacute;veis com essa t&eacute;cnica de teste aplicada sobre unidades de software, devemos lembrar que, no ambiente produtivo, cada programa pode vir a ser executado milhares ou milh&otilde;es de vezes em intervalos de tempo pequenos. &Eacute; na realidade de produ&ccedil;&atilde;o que a soma dos aparentes pequenos tempos de execu&ccedil;&atilde;o e consumo de mem&oacute;ria de cada programa poder&aacute; levar o software a deixar de atender aos objetivos esperados. A t&eacute;cnica de teste de caixa&shy;branca &eacute; recomendada para as fases de <a href="http://en.wikipedia.org/wiki/Teste_de_unidade" id="w">teste de unidade</a> e <a href="http://en.wikipedia.org/wiki/Teste_de_integra%C3%A7%C3%A3o" id="w">teste de integra&ccedil;&atilde;o</a>, cuja responsabilidade principal fica a cargo dos desenvolvedores do software, que por sua vez conhecem bem o c&oacute;digo fonte produzido.</p>&#10;<a id="Caixa&shy;preta" name="Caixa&shy;preta"></a><h3> Caixa&shy;preta </h3>&#10;<p> &#10;Tamb&eacute;m chamada de teste funcional, teste comportamental, orientado a dado ou orientado a <a href="http://en.wikipedia.org/wiki/Entrada/sa%C3%ADda" id="w">entrada e sa&iacute;da</a>, a t&eacute;cnica de caixa&shy;preta avalia o comportamento externo do <a href="http://en.wikipedia.org/wiki/Componente_de_software" id="w">componente de software</a>, sem se considerar o comportamento interno do mesmo.<sup id="_ref&shy;4" class="reference"><a href="#_note&shy;4" title="">[4]</a></sup> Dados de entrada s&atilde;o fornecidos, o teste &eacute; executado e o resultado obtido &eacute; comparado a um resultado esperado previamente conhecido. Como detalhes de implementa&ccedil;&atilde;o n&atilde;o s&atilde;o considerados, os <a href="http://en.wikipedia.org/wiki/Caso_de_teste" id="w">casos de teste</a> s&atilde;o todos derivados da especifica&ccedil;&atilde;o.</p>&#10;<p>Quanto mais entradas s&atilde;o fornecidas, mais rico ser&aacute; o teste. Numa situa&ccedil;&atilde;o ideal todas as entradas poss&iacute;veis seriam testadas, mas na ampla maioria dos casos isso &eacute; imposs&iacute;vel.<sup id="_ref&shy;5" class="reference"><a href="#_note&shy;5" title="">[5]</a></sup> Outro problema &eacute; que a especifica&ccedil;&atilde;o pode estar amb&iacute;gua em rela&ccedil;&atilde;o ao sistema produzido, e como resultado as entradas especificadas podem n&atilde;o ser as mesmas aceitas para o teste.<sup id="_ref&shy;Jiantao 1999_a" class="reference"><a href="#_note&shy;Jiantao 1999" title="">[6]</a></sup> Uma abordagem mais realista para o teste de caixa&shy;preta &eacute; escolher um subconjunto de entradas que maximize a riqueza do teste. Pode&shy;se agrupar subconjuntos de entradas poss&iacute;veis que s&atilde;o processadas similarmente, de forma que testar somente um elemento desse subconjunto serve para averiguar a qualidade de todo o subconjunto. Por exemplo, em um sistema que aceita um <a href="http://en.wikipedia.org/wiki/Inteiro_(tipo_de_dado)" id="w">inteiro</a> como entrada, testar todos os casos poss&iacute;veis pode gerar pelo menos dezenas de milhares de casos de testes distintos. Entretanto, a partir da especifica&ccedil;&atilde;o do sistema, pode&shy;se encontrar um subconjunto de inteiros que maximizem a qualidade do teste. Depende do prop&oacute;sito do sistema, mas casos poss&iacute;veis incluem inteiros pares, inteiros &iacute;mpares, zero, inteiros positivos, inteiros negativos, o maior inteiro, o menor inteiro.</p>&#10;<p>Essa t&eacute;cnica &eacute; aplic&aacute;vel a todas as fases de teste &ndash; <a href="http://en.wikipedia.org/wiki/Teste_unit%C3%A1rio" id="w">teste unit&aacute;rio</a>, <a href="http://en.wikipedia.org/wiki/Teste_de_integra%C3%A7%C3%A3o" id="w">teste de integra&ccedil;&atilde;o</a>, <a href="http://en.wikipedia.org/wiki/Teste_de_sistema" id="w">teste de sistema</a> e <a href="http://en.wikipedia.org/wiki/Teste_de_aceita%C3%A7%C3%A3o" id="w">teste de aceita&ccedil;&atilde;o</a>. A aplica&ccedil;&atilde;o de crit&eacute;rios de teste leva o testador a produzir um conjunto de casos de teste (ou situa&ccedil;&otilde;es de teste). A aplica&ccedil;&atilde;o do crit&eacute;rio de Particionamento de Equival&ecirc;ncia (ou uso de <a href="http://en.wikipedia.org/wiki/Classe_de_equival%C3%AAncia" id="w">classes de equival&ecirc;ncia</a>) permite avaliar se a quantidade de casos de teste produzida &eacute; coerente. O Particionamento de Equival&ecirc;ncia se baseia em testar subconjuntos dos dados e n&atilde;o todos os dados poss&iacute;veis &shy; o que seria exaustivo e &agrave;s vezes imposs&iacute;vel &shy;, pode&shy;se assumir que as classes de equival&ecirc;ncia ser&atilde;o tratadas da mesma maneira, pois um &uacute;nico elemento da classe se comporta como um representante dessa classe. A partir das classes de equival&ecirc;ncia identificadas pode&shy;se usar a An&aacute;lise de Valor Limite, o testador construir&aacute; casos de teste que atuem nos limites superiores e inferiores destas classes, de forma que um n&uacute;mero m&iacute;nimo de casos de teste permita a maior cobertura de teste poss&iacute;vel. Outro crit&eacute;rio &eacute; o Grafo Causa&shy;Efeito, que consiste em utilizar a ideia de grafos para transformar entradas de dados em causas e sa&iacute;das de dados em efeitos. Esse grafo &eacute; posteriormente convertido para tabela de decis&atilde;o e este para casos de teste. Por fim, tem&shy;se o crit&eacute;rio de Error&shy;Guessing, que &eacute; uma t&eacute;cnica em que os analistas de teste, por meio da experi&ecirc;ncia e intui&ccedil;&atilde;o, sup&otilde;em tipos prov&aacute;veis de erro.</p>&#10;<p>Uma abordagem no desenvolvimento do teste de caixa&shy;preta &eacute; o teste baseado na especifica&ccedil;&atilde;o, de forma que as funcionalidades s&atilde;o testadas de acordo com os requisitos. Apesar de necess&aacute;rio, esse tipo de teste &eacute; insuficiente para identificar certos riscos num projeto de software.<sup id="_ref&shy;7" class="reference"><a href="#_note&shy;7" title="">[7]</a></sup></p>&#10;<a id="Caixa&shy;cinza" name="Caixa&shy;cinza"></a><h3> Caixa&shy;cinza </h3>&#10;<p>A t&eacute;cnica de teste de caixa&shy;cinza &eacute; uma mescla do uso das t&eacute;cnicas de caixa&shy;preta e de caixa&shy;branca. Isso envolve ter acesso a <a href="http://en.wikipedia.org/wiki/Estrutura_de_dados" id="w">estruturas de dados</a> e <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmos</a> do componente a fim de desenvolver os casos de teste, que s&atilde;o executados como na t&eacute;cnica da caixa&shy;preta. Manipular entradas de dados e formatar a sa&iacute;da n&atilde;o &eacute; considerado caixa&shy;cinza pois a entrada e a sa&iacute;da est&atilde;o claramente fora da caixa&shy;preta. A caixa&shy;cinza pode incluir tamb&eacute;m o uso de <a href="http://en.wikipedia.org/wiki/Engenharia_reversa" id="w">engenharia reversa</a> para determinar por exemplo os limites superiores e inferiores das classes, al&eacute;m de mensagens de erro.</p>&#10;<a id="Regress%C3%A3o" name="Regress%C3%A3o"></a><h3> Regress&atilde;o </h3>&#10;<p> &#10;Essa &eacute; uma t&eacute;cnica de teste aplic&aacute;vel a uma nova vers&atilde;o de software ou &agrave; necessidade de se executar um novo ciclo de teste durante o processo de desenvolvimento. Consiste em se aplicar, a cada nova vers&atilde;o do software ou a cada ciclo, todos os testes que j&aacute; foram aplicados nas vers&otilde;es ou ciclos de teste anteriores do sistema. Inclui&shy;se nesse contexto a observa&ccedil;&atilde;o de fases e t&eacute;cnicas de teste de acordo com o impacto de altera&ccedil;&otilde;es provocado pela nova vers&atilde;o ou ciclo de teste. Para efeito de aumento de produtividade e de viabilidade dos testes, &eacute; recomendada a utiliza&ccedil;&atilde;o de ferramentas de <a href="http://en.wikipedia.org/wiki/Automa%C3%A7%C3%A3o_de_teste" id="w">automa&ccedil;&atilde;o de teste</a>, de forma que, sobre a nova vers&atilde;o ou ciclo de teste, todos os testes anteriores possam ser executados novamente com maior agilidade.</p>&#10;<a id="T%C3%A9cnicas_n%C3%A3o_funcionais" name="T%C3%A9cnicas_n%C3%A3o_funcionais"></a><h3> T&eacute;cnicas n&atilde;o funcionais </h3>&#10;<p>Outras t&eacute;cnicas de teste existem para testar aspectos n&atilde;o&shy;funcionais do software, como por exemplo, a adequa&ccedil;&atilde;o a restri&ccedil;&otilde;es de neg&oacute;cio, adequa&ccedil;&atilde;o a normas, ou restri&ccedil;&otilde;es tecnol&oacute;gicas. Em contraste &agrave;s t&eacute;cnicas funcionais mencionadas acima, que verificam a produ&ccedil;&atilde;o pelo sistema de respostas adequadas de suas opera&ccedil;&otilde;es, de acordo com uma especifica&ccedil;&atilde;o, as t&eacute;cnicas n&atilde;o funcionais verificam atributos de um componente ou sistema que n&atilde;o se relacionam com a funcionalidade (por exemplo, confiabilidade, efici&ecirc;ncia, usabilidade, manutenibilidade e portabilidade)<sup id="_ref&shy;8" class="reference"><a href="#_note&shy;8" title="">[8]</a></sup>.</p>&#10;<p>Uma delas &eacute; o uso conjunto de <a href="http://en.wikipedia.org/wiki/Teste_de_desempenho" id="w">teste de desempenho</a> e <a href="http://en.wikipedia.org/wiki/Teste_de_carga" id="w">teste de carga</a>, que verifica se o software consegue processar grandes quantidades de dados, e nas especifica&ccedil;&otilde;es de tempo de processamento exigidas, o que determina a <a href="http://en.wikipedia.org/wiki/Escalabilidade" id="w">escalabilidade</a> do software. O <a href="http://en.wikipedia.org/wiki/Teste_de_usabilidade" id="w">teste de usabilidade</a> &eacute; necess&aacute;rio para verificar se a <a href="http://en.wikipedia.org/wiki/Interface_de_usu%C3%A1rio" id="w">interface de usu&aacute;rio</a> &eacute; f&aacute;cil de se aprender e utilizar. Entre verifica&ccedil;&otilde;es cab&iacute;veis est&atilde;o a rela&ccedil;&atilde;o da interface com conhecimento do usu&aacute;rio, a compreensibilidade das mensagens de erro e a integridade visual entre diferentes componentes.<sup id="_ref&shy;9" class="reference"><a href="#_note&shy;9" title="">[9]</a></sup> J&aacute; o <a href="http://en.wikipedia.org/wiki/Teste_de_confiabilidade" id="w">teste de confiabilidade</a> &eacute; usado para verificar se o software &eacute; seguro em assegurar o sigilo dos dados armazenados e processados. O <a href="http://en.wikipedia.org/wiki/Teste_de_recupera%C3%A7%C3%A3o" id="w">teste de recupera&ccedil;&atilde;o</a> &eacute; usado para verificar a robustez do software em retornar a um estado est&aacute;vel de execu&ccedil;&atilde;o ap&oacute;s estar em um estado de falha.</p>&#10;<a id="Fases_ou_N%C3%ADveis" name="Fases_ou_N%C3%ADveis"></a><h2> Fases ou N&iacute;veis </h2>&#10;<p />&#10;<div style="float:right">&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table style="width:20em">&#10;<caption><b>Abstra&ccedil;&atilde;o do teste</b></caption>&#10;<tr>&#10;<td rowspan="3" style="text&shy;align: center"><i> </i><br/><a href="http://en.wikipedia.org/wiki/Imagem:Crystal_Clear_action_1downarrow.png" id="w">30px</a></td>&#10;<td style="padding: 10px&semi; margin&shy;bottom: 15px&semi; border: 1px solid #AAA&semi; text&shy;align: center&semi; background&shy;color: #35deff">Sistema</td>&#10;<td rowspan="3" style="text&shy;align: center"><a href="http://en.wikipedia.org/wiki/Imagem:Crystal_Clear_action_1uparrow.png" id="w">30px</a><br/><i> </i></td></tr>&#10;<tr>&#10;<td style="padding: 10px&semi; margin&shy;bottom: 15px&semi; border: 1px solid #AAA&semi; text&shy;align: center&semi; background&shy;color: #57ffff">Integra&ccedil;&atilde;o</td></tr>&#10;<tr>&#10;<td style="padding: 10px&semi; margin&shy;bottom: 15px&semi; border: 1px solid #AAA&semi; text&shy;align: center&semi; background&shy;color: #79ffff">Unidade</td></tr></table></div>&#10;<p /></div>&#10;<p>Uma pr&aacute;tica comum &eacute; testar o software ap&oacute;s uma funcionalidade ser desenvolvida, e antes dela ser implantada no cliente, por um grupo de profissionais diferente da <a href="http://en.wikipedia.org/wiki/Implementa%C3%A7%C3%A3o" id="w">implementa&ccedil;&atilde;o</a>. Essa pr&aacute;tica pode resultar na fase de teste ser usada para compensar atrasos do projeto, comprometendo o tempo devotado ao teste. Outra pr&aacute;tica &eacute; come&ccedil;ar o teste no mesmo momento que o projeto, num processo cont&iacute;nuo at&eacute; o fim do projeto.</p>&#10;<p>Em contrapartida, algumas pr&aacute;ticas emergentes como a <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_extrema" id="w">programa&ccedil;&atilde;o extrema</a> e o <a href="http://en.wikipedia.org/wiki/Desenvolvimento_%C3%A1gil_de_software" id="w">desenvolvimento &aacute;gil</a> focam o modelo de desenvolvimento orientado ao teste. Nesse processo, os testes de unidade s&atilde;o escritos primeiro (<a href="http://en.wikipedia.org/wiki/Test_Driven_Development" id="w">TDD</a>), por engenheiros de software. Antes da implementa&ccedil;&atilde;o da unidade em quest&atilde;o, o teste falha. Ent&atilde;o o c&oacute;digo &eacute; escrito, passando incrementalmente em por&ccedil;&otilde;es maiores dos casos de teste. Os testes s&atilde;o mantidos junto com o resto do c&oacute;digo fonte do software, e geralmente tamb&eacute;m integra o processo de constru&ccedil;&atilde;o do software.</p>&#10;<a id="Teste_de_unidade" name="Teste_de_unidade"></a><h3> Teste de unidade </h3>&#10;<p> &#10;Tamb&eacute;m conhecida como teste unit&aacute;rio ou teste de m&oacute;dulo, &eacute; a fase em que se testam as menores unidades de software desenvolvidas (pequenas partes ou unidades do sistema).<sup id="_ref&shy;10" class="reference"><a href="#_note&shy;10" title="">[10]</a></sup> O universo alvo desse tipo de teste s&atilde;o as <a href="http://en.wikipedia.org/wiki/Subrotina" id="w">subrotinas</a>, m&eacute;todos, classes ou mesmo pequenos trechos de c&oacute;digo. Assim, o objetivo &eacute; o de encontrar falhas de funcionamento dentro de uma pequena parte do sistema funcionando independentemente do todo.</p>&#10;<a id="Teste_de_integra%C3%A7%C3%A3o" name="Teste_de_integra%C3%A7%C3%A3o"></a><h3> Teste de integra&ccedil;&atilde;o </h3>&#10;<p> &#10;Na fase de teste de integra&ccedil;&atilde;o, o objetivo &eacute; encontrar falhas provenientes da integra&ccedil;&atilde;o interna dos componentes de um sistema. Geralmente os tipos de falhas encontradas s&atilde;o de transmiss&atilde;o de dados. Por exemplo, um componente A pode estar aguardando o retorno de um valor X ao executar um m&eacute;todo do componente B&semi; por&eacute;m, B pode retornar um valor Y, gerando uma falha. N&atilde;o faz parte do escopo dessa fase de teste o tratamento de interfaces com outros sistemas (integra&ccedil;&atilde;o entre sistemas). Essas interfaces s&atilde;o testadas na fase de teste de sistema, apesar de, a crit&eacute;rio do gerente de projeto, estas interfaces podem ser testadas mesmo antes de o sistema estar plenamente constru&iacute;do.</p>&#10;<a id="Teste_de_sistema" name="Teste_de_sistema"></a><h3> Teste de sistema </h3>&#10;<p> &#10;Na fase de teste de sistema, o objetivo &eacute; executar o sistema sob ponto de vista de seu usu&aacute;rio final, varrendo as funcionalidades em busca de falhas em rela&ccedil;&atilde;o aos objetivos originais. Os testes s&atilde;o executados em condi&ccedil;&otilde;es similares &ndash; de ambiente, interfaces sist&ecirc;micas e massas de dados &ndash; &agrave;quelas que um usu&aacute;rio utilizar&aacute; no seu dia&shy;a&shy;dia de manipula&ccedil;&atilde;o do sistema. De acordo com a pol&iacute;tica de uma organiza&ccedil;&atilde;o, podem ser utilizadas condi&ccedil;&otilde;es reais de ambiente, interfaces sist&ecirc;micas e massas de dados.</p>&#10;<a id="Teste_de_aceita%C3%A7%C3%A3o" name="Teste_de_aceita%C3%A7%C3%A3o"></a><h3> Teste de aceita&ccedil;&atilde;o </h3>&#10;<p> &#10;Geralmente, os testes de aceita&ccedil;&atilde;o s&atilde;o realizados por um grupo restrito de usu&aacute;rios finais do sistema, que simulam opera&ccedil;&otilde;es de rotina do sistema de modo a verificar se seu comportamento est&aacute; de acordo com o solicitado. Teste formal conduzido para determinar se um sistema satisfaz ou n&atilde;o seus crit&eacute;rios de aceita&ccedil;&atilde;o e para permitir ao cliente determinar se aceita ou n&atilde;o o sistema. Valida&ccedil;&atilde;o de um software pelo comprador, pelo usu&aacute;rio ou por terceira parte, com o uso de dados ou cen&aacute;rios especificados ou reais. Pode incluir testes funcionais, de configura&ccedil;&atilde;o, de recupera&ccedil;&atilde;o de falhas, de seguran&ccedil;a e de desempenho.</p>&#10;<a id="Teste_de_opera%C3%A7%C3%A3o" name="Teste_de_opera%C3%A7%C3%A3o"></a><h3> Teste de opera&ccedil;&atilde;o </h3>&#10;<p> &#10;Nessa fase o teste &eacute; conduzido pelos administradores do ambiente final em que o sistema ou software entrar&aacute; em ambiente produtivo. Vale ressaltar que essa fase &eacute; aplic&aacute;vel somente a sistemas de informa&ccedil;&atilde;o pr&oacute;prios de uma organiza&ccedil;&atilde;o, cujo acesso pode ser feito interna ou externamente a essa organiza&ccedil;&atilde;o. Nessa fase de teste devem ser feitas simula&ccedil;&otilde;es para garantir que a entrada em produ&ccedil;&atilde;o do sistema ser&aacute; bem sucedida. Envolve testes de instala&ccedil;&atilde;o, simula&ccedil;&otilde;es com <a href="http://en.wikipedia.org/wiki/C%C3%B3pia_de_seguran%C3%A7a" id="w">c&oacute;pia de seguran&ccedil;a</a> dos <a href="http://en.wikipedia.org/wiki/Banco_de_dado" id="w">bancos de dados</a>, etc.. Em alguns casos um sistema entrar&aacute; em produ&ccedil;&atilde;o para substituir outro e &eacute; necess&aacute;rio garantir que o novo sistema continuar&aacute; garantindo o suporte ao neg&oacute;cio.</p>&#10;<a id="Testes_alfa_e_beta" name="Testes_alfa_e_beta"></a><h4> Testes alfa e beta </h4>&#10;<p> &#10; &#10;Em casos especiais de processos de desenvolvimento de software &ndash; <a href="http://en.wikipedia.org/wiki/Sistema_operacional" id="w">sistemas operacionais</a>, <a href="http://en.wikipedia.org/wiki/Sistema_gerenciador_de_bancos_de_dados" id="w">sistemas gerenciadores de bancos de dados</a> e outros softwares distribu&iacute;dos em escala nacional e internacional &ndash; os testes requerem fases tamb&eacute;m especiais antes do produto ser disponibilizado a todos os usu&aacute;rios.</p>&#10;<p>O per&iacute;odo entre o t&eacute;rmino do desenvolvimento e a entrega &eacute; conhecido como <a href="http://en.wikipedia.org/wiki/Vers%C3%A3o_alfa" id="w">fase alfa</a> e os testes executados nesse per&iacute;odo, como testes alfa. PRESSMAN<sup id="_ref&shy;11" class="reference"><a href="#_note&shy;11" title="">[11]</a></sup> afirma que o teste alfa &eacute; conduzido pelo cliente no ambiente do desenvolvedor, com este &#34&semi;olhando sobre o ombro&#34&semi; do usu&aacute;rio e registrando erros e problemas de uso.</p>&#10;<p>Completada a fase alfa de testes, s&atilde;o lan&ccedil;adas a grupos restritos de usu&aacute;rios, vers&otilde;es de teste do sistema denominadas <a href="http://en.wikipedia.org/wiki/Vers%C3%A3o_beta" id="w">vers&otilde;es beta</a>. Ele tamb&eacute;m &eacute; um teste de aceita&ccedil;&atilde;o voltado para softwares cuja distribui&ccedil;&atilde;o atingir&aacute; grande n&uacute;mero de usu&aacute;rios de uma ou v&aacute;rias empresas compradoras. PRESSMAN afirma que o teste beta &eacute; conduzido em uma ou mais instala&ccedil;&otilde;es do cliente, pelo usu&aacute;rio final do software. Diferente do teste alfa, o desenvolvedor geralmente n&atilde;o est&aacute; presente. Consequentemente, o teste beta &eacute; uma aplica&ccedil;&atilde;o do software num ambiente que n&atilde;o pode ser controlado pelo desenvolvedor. O cliente registra todos os problemas (reais ou imagin&aacute;rios) que s&atilde;o encontrados durante o teste beta e os relata ao desenvolvedor em intervalos regulares. Com o resultado dos problemas relatados durante os testes beta, os engenheiros de software fazem modifica&ccedil;&otilde;es e depois se preparam para liberar o produto de software para toda a base de clientes.</p>&#10;<p>A comunidade do teste de software usa o termo teste gama de forma sarc&aacute;stica referindo&shy;se aos produtos que s&atilde;o mal testados e s&atilde;o entregues aos usu&aacute;rios finais para que estes encontrem os defeitos j&aacute; em fase de produ&ccedil;&atilde;o.</p>&#10;<a id="Candidato_a_lan%C3%A7amento" name="Candidato_a_lan%C3%A7amento"></a><h4> Candidato a lan&ccedil;amento </h4>&#10;<p>Ultimamente, e principalmente na comunidade de <a href="http://en.wikipedia.org/wiki/Software_livre" id="w">software livre</a>, &eacute; comum utilizar o termo candidato a lan&ccedil;amento (<a href="http://en.wikipedia.org/wiki/Release" id="w">release</a> candidate) para indicar uma vers&atilde;o que &eacute; candidata a ser a vers&atilde;o final, em fun&ccedil;&atilde;o da quantidade de erros encontradas. Tais vers&otilde;es s&atilde;o um passo al&eacute;m do teste beta, sendo divulgadas para toda a comunidade.</p>&#10;<a id="O_Ciclo_de_Vida_dos_Testes" name="O_Ciclo_de_Vida_dos_Testes"></a><h2> O Ciclo de Vida dos Testes </h2>&#10;<p>O Ciclo de Vida dos Testes &eacute; composto de 5 fases: Planejamento, Prepara&ccedil;&atilde;o, Especifica&ccedil;&atilde;o, Execu&ccedil;&atilde;o e Entrega.</p>&#10;<a id="Planejamento" name="Planejamento"></a><h3> Planejamento </h3>&#10;<p>Nesta fase &eacute; elaborada a Estrat&eacute;gia de Teste e o Plano de Teste.</p>&#10;<a id="Prepara%C3%A7%C3%A3o" name="Prepara%C3%A7%C3%A3o"></a><h3> Prepara&ccedil;&atilde;o </h3>&#10;<p>O objetivo desta fase &eacute; preparar o Ambiente de Teste (equipamentos, pessoal, ferramentas de automa&ccedil;&atilde;o, massa de testes) para que os testes sejam executados conforme planejados.</p>&#10;<a id="Especifica%C3%A7%C3%A3o" name="Especifica%C3%A7%C3%A3o"></a><h3> Especifica&ccedil;&atilde;o </h3>&#10;<p>Nesta fase temos as seguintes atividades: Elaborar/ Revisar casos de testes e Elaborar/ Revisar roteiros de testes.</p>&#10;<a id="Execu%C3%A7%C3%A3o" name="Execu%C3%A7%C3%A3o"></a><h3> Execu&ccedil;&atilde;o </h3>&#10;<p>Os testes s&atilde;o executados e registrado os resultados obtidos.</p>&#10;<a id="Entrega" name="Entrega"></a><h3> Entrega </h3>&#10;<p>Esta &eacute; a &uacute;ltima fase do ciclo de vida de testes, onde o projeto &eacute; finalizado e toda documenta&ccedil;&atilde;o &eacute; finalizada e arquivada.</p>&#10;<a id="Pap%C3%A9is" name="Pap%C3%A9is"></a><h2> Pap&eacute;is </h2>&#10;<p>Segue abaixo alguns dos pap&eacute;is que uma pessoa pode desenvolver num projeto de teste de software. Uma pessoa pode acumular mais de um dos pap&eacute;is citados, de acordo com caracter&iacute;sticas e restri&ccedil;&otilde;es de projetos de desenvolvimento de software nas quais estejam inseridas. Nas fases de teste de unidade e de integra&ccedil;&atilde;o, por exemplo, os pap&eacute;is de arquiteto de teste e analista de teste podem ser assumidos pelo analista de sistemas do projeto&semi; o papel de testador pode ser assumido pelo programador ou por um segundo programador que atue num processo de programa&ccedil;&atilde;o em pares. Na fase de teste de sistema, num contexto em que haja uma equipe de teste independente, pode haver profissionais acumulando os pap&eacute;is de arquiteto de teste, analista de teste e testador.</p>&#10;<p>O l&iacute;der (ou gerente) do projeto de testes &eacute; a pessoa respons&aacute;vel pela lideran&ccedil;a de um projeto de teste espec&iacute;fico, normalmente relacionado a um sistema de desenvolvimento, seja um projeto novo ou uma manuten&ccedil;&atilde;o. J&aacute; o engenheiro (ou arquiteto) de teste &eacute; o t&eacute;cnico respons&aacute;vel pelo levantamento de necessidades relacionadas &agrave; montagem da infraestrutura de teste, incluindo&shy;se o ambiente de teste, a arquitetura de solu&ccedil;&atilde;o, as restri&ccedil;&otilde;es tecnol&oacute;gicas, as ferramentas de teste. &Eacute; tamb&eacute;m respons&aacute;vel pela lideran&ccedil;a t&eacute;cnica do trabalho de teste e pela comunica&ccedil;&atilde;o entre a equipe de teste e a equipe de projeto (ou equipe de desenvolvimento).</p>&#10;<p>O analista de teste &eacute; o t&eacute;cnico respons&aacute;vel pela operacionaliza&ccedil;&atilde;o do processo de teste. Deve seguir as orienta&ccedil;&otilde;es do gerente de teste ou do arquiteto de teste para detalhar a forma de execu&ccedil;&atilde;o dos testes e as condi&ccedil;&otilde;es de teste necess&aacute;rias. Tamb&eacute;m deve focar seu trabalho nas t&eacute;cnicas de teste adequadas &agrave; fase de teste trabalhada. Tamb&eacute;m no campo de an&aacute;lise, o analista de ambiente &eacute; o t&eacute;cnico respons&aacute;vel pela configura&ccedil;&atilde;o do ambiente de teste e pela aplica&ccedil;&atilde;o das ferramentas necess&aacute;rias para tal. Esse profissional deve ser especializado em arquiteturas de solu&ccedil;&atilde;o e nos sistemas operacionais e softwares de <a href="http://en.wikipedia.org/wiki/Infraestrutura" id="w">infraestrutura</a> que regem o ambiente. Ele ser&aacute; respons&aacute;vel por tornar dispon&iacute;vel o ambiente de teste.</p>&#10;<p>O testador &eacute; o t&eacute;cnico respons&aacute;vel pela execu&ccedil;&atilde;o de teste. Ele deve observar as condi&ccedil;&otilde;es de teste e respectivos passos de teste documentados pelo analista de teste e evidenciar os resultados de execu&ccedil;&atilde;o. Em casos de execu&ccedil;&otilde;es de teste mal&shy;sucedidas, esse profissional pode tamb&eacute;m registrar ocorr&ecirc;ncias de teste (na maioria das vezes, <a href="http://en.wikipedia.org/wiki/Defeito_de_software" id="w">defeitos</a>) em canais atrav&eacute;s dos quais os desenvolvedores tomar&atilde;o conhecimento das mesmas e tomar&atilde;o as provid&ecirc;ncias de corre&ccedil;&atilde;o ou de esclarecimentos.</p>&#10;<p>Por fim, o automatizador de teste &eacute; o t&eacute;cnico respons&aacute;vel pela <a href="http://en.wikipedia.org/wiki/Automa%C3%A7%C3%A3o_de_teste" id="w">automa&ccedil;&atilde;o de situa&ccedil;&otilde;es de teste</a> em ferramentas. Ele deve observar as condi&ccedil;&otilde;es de teste e respectivos passos de teste documentados pelo analista de teste e automatizar a execu&ccedil;&atilde;o desses testes na ferramenta utilizada. Normalmente s&atilde;o gerados <i><a href="http://en.wikipedia.org/wiki/Script" id="w">scripts</a></i> de teste que permitam a execu&ccedil;&atilde;o de ciclos de teste sempre que se julgar necess&aacute;rio, desde &eacute; claro, que sejam garantidas as mesmas condi&ccedil;&otilde;es iniciais do ciclo de teste (valores de dados, estados dos dados, estados do ambiente, etc..)</p>&#10;<a id="Artefatos" name="Artefatos"></a><h2> Artefatos </h2>&#10;<p>O processo de teste de software pode produzir diversos <a href="http://en.wikipedia.org/wiki/Artefacto_(desenvolvimento_de_software)" id="w">artefatos</a>. O <a href="http://en.wikipedia.org/wiki/Caso_de_teste" id="w">caso de teste</a> geralmente consiste de uma refer&ecirc;ncia a um identificador ou requisito de uma especifica&ccedil;&atilde;o, pr&eacute;&shy;condi&ccedil;&otilde;es, eventos, uma s&eacute;rie de passos a se seguir, uma entrada de dados, uma sa&iacute;da de dados, resultado esperado e resultado obtido. A s&eacute;rie de passos (ou parte dela) pode estar contida num procedimento separado, para que possa ser compartilhada por mais de um caso de teste.</p>&#10;<p>Um <i>script</i> de teste &eacute; a combina&ccedil;&atilde;o de um caso de teste, um procedimento de teste e os dados do teste. Uma cole&ccedil;&atilde;o de casos de teste &eacute; chamada de suite de teste. Geralmente, ela tamb&eacute;m cont&eacute;m instru&ccedil;&otilde;es detalhadas ou objetivos para cada cole&ccedil;&atilde;o de casos de teste, al&eacute;m de uma se&ccedil;&atilde;o para descri&ccedil;&atilde;o da configura&ccedil;&atilde;o do sistema usado.</p>&#10;<p>A especifica&ccedil;&atilde;o de teste &eacute; chamada <a href="http://en.wikipedia.org/wiki/Plano_de_teste" id="w">plano de teste</a>.</p>&#10;<p> </p>&#10;<a id="Bibliografia" name="Bibliografia"></a><h2> Bibliografia </h2>&#10;&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li></ul>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Anexo:Lista_de_institui%C3%A7%C3%B5es_pela_qualidade" id="w">Anexo:Lista de institui&ccedil;&otilde;es pela qualidade</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Qualidade_de_software" id="w">Qualidade de software</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Gest%C3%A3o_da_qualidade" id="w">Gest&atilde;o da qualidade</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Verifica%C3%A7%C3%A3o_formal" id="w">Verifica&ccedil;&atilde;o formal</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Otimiza%C3%A7%C3%A3o_em_engenharia_de_software" id="w">Otimiza&ccedil;&atilde;o em engenharia de software</a>.</li></ul>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://www.ruleworks.co.uk/testguide" rel="nofollow" title="http://www.ruleworks.co.uk/testguide">Guia de gerenciamento de teste</a></li>&#10;<li><a class="externallink" href="http://www.testesdesoftware.blogspot.com" rel="nofollow" title="http://www.testesdesoftware.blogspot.com">Comunidade Testes de Software</a></li>&#10;<li><a class="externallink" href="http://www.testcompanies.com" rel="nofollow" title="http://www.testcompanies.com">Empresas testes de software</a></li></ul>&#10;<p> &#10; &#10; </p>&#10;<p> &#10;<a href="http://en.wikipedia.org/wiki/Categoria:Teste_de_software" id="w"> </a></p>&#10;<p><a href="http://kk.wikipedia.org/wiki/&#1058;%D0%B5%D1%81%D1%82%D1%96%D0%BB%D0%B5%D1%83">kk:&#1058;&#1077;&#1089;&#1090;&#1110;&#1083;&#1077;&#1091;</a></p></body></html>