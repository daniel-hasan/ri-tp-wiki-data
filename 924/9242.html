<html><title>Haskell (linguagem de programa&ccedil;&atilde;o)</title><body>&#10;<p> &#10;<b>Haskell</b> &eacute; uma <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagem de programa&ccedil;&atilde;o</a> puramente <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_funcional" id="w">funcional</a>, de prop&oacute;sito geral, nomeada em homenagem ao l&oacute;gico <a href="http://en.wikipedia.org/wiki/Haskell_Curry" id="w">Haskell Curry</a>. Como uma linguagem funcional, a estrutura de controle prim&aacute;ria &eacute; a <i>fun&ccedil;&atilde;o</i>&semi; a linguagem &eacute; baseada nas observa&ccedil;&otilde;es de Haskell Curry <sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup><sup id="_ref&shy;CurryFeys_paragraph9E_a" class="reference"><a href="#_note&shy;CurryFeys_paragraph9E" title="">[2]</a></sup> e seus descendentes intelectuais.<sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup><sup id="_ref&shy;4" class="reference"><a href="#_note&shy;4" title="">[4]</a></sup> Seu &uacute;ltimo padr&atilde;o semi&shy;oficial &eacute; o Haskell 98, destinado a especificar uma vers&atilde;o m&iacute;nima e port&aacute;vel da linguagem para o ensino e como base para futuras extens&otilde;es.</p>&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2> Hist&oacute;ria </h2>&#10;<p>O conceito de <a href="http://en.wikipedia.org/wiki/Avalia%C3%A7%C3%A3o_pregui%C3%A7osa" id="w">avalia&ccedil;&atilde;o pregui&ccedil;osa</a> j&aacute; estava difundido no meio acad&ecirc;mico desde o final da <a href="http://en.wikipedia.org/wiki/D%C3%A9cada_de_1970" id="w">d&eacute;cada de 1970</a>. Esfor&ccedil;os nessa &aacute;rea inclu&iacute;am t&eacute;cnicas de <a href="http://en.wikipedia.org/wiki/Redu%C3%A7%C3%A3o_de_grafo" id="w">redu&ccedil;&atilde;o de grafo</a> e a possibilidade de uma mudan&ccedil;a radical na <a href="http://en.wikipedia.org/wiki/Arquitetura_de_von_Neumann" id="w">arquitetura de von Neumann</a>.<sup id="_ref&shy;5" class="reference"><a href="#_note&shy;5" title="">[5]</a></sup> Ap&oacute;s o lan&ccedil;amento de <a href="http://en.wikipedia.org/wiki/Miranda_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Miranda</a> em <a href="http://en.wikipedia.org/wiki/1985" id="w">1985</a>, diversas outras linguagens funcionais de sem&acirc;ntica n&atilde;o r&iacute;gida proliferaram, como Lazy ML, Orwell, Alfl, Id, Clean, Ponder e Daisy (um dialeto de <a href="http://en.wikipedia.org/wiki/Lisp" id="w">Lisp</a>). Mesmo ap&oacute;s dois anos, Miranda ainda era a mais usada, mas n&atilde;o estava em dom&iacute;nio p&uacute;blico.</p>&#10;<p>Em setembro 1987 foi realizada  uma confer&ecirc;ncia <i>Functional Programming Languages and Computer Architecture</i> (FPCA &#39&semi;87), em Oregon, o consenso foi a cria&ccedil;&atilde;o de um comit&ecirc; com o objetivo de construir um <a href="http://en.wikipedia.org/wiki/Padr%C3%A3o_aberto" id="w">padr&atilde;o aberto</a> para tais linguagens.<sup id="_ref&shy;6" class="reference"><a href="#_note&shy;6" title="">[6]</a></sup> Isso consolidaria as linguagens existentes, servindo como base para pesquisas futuras no desenvolvimento de linguagens.<sup id="_ref&shy;7" class="reference"><a href="#_note&shy;7" title="">[7]</a></sup> A primeira reuni&atilde;o do comit&ecirc; foi realizada em janeiro de 1988, e algumas das metas da linguagem foram discutidas. A linguagem deveria ser de f&aacute;cil ensino, deveria ser completamente descrita atrav&eacute;s de uma sintaxe e sem&acirc;ntica formal, deveria estar dispon&iacute;vel livremente.</p>&#10;<p>A primeira vers&atilde;o de Haskell foi definida em <a href="http://en.wikipedia.org/wiki/1_de_abril" id="w">1 de abril</a> de <a href="http://en.wikipedia.org/wiki/1990" id="w">1990</a>.<sup id="_ref&shy;8" class="reference"><a href="#_note&shy;8" title="">[8]</a></sup> Seguiu&shy;se a vers&atilde;o 1.1 em agosto de ano seguinte, a vers&atilde;o 1.2 em mar&ccedil;o de 1992, a vers&atilde;o 1.3 em maio de 1996 e a vers&atilde;o 1.4 em abril de 1997.<sup id="_ref&shy;9" class="reference"><a href="#_note&shy;9" title="">[9]</a></sup> Esfor&ccedil;os posteriores culminaram no Haskell 98, publicado em janeiro de 1999 e que especifica uma vers&atilde;o m&iacute;nima, est&aacute;vel e port&aacute;vel da linguagem e a <a href="http://en.wikipedia.org/wiki/Biblioteca_(computa%C3%A7%C3%A3o)" id="w">biblioteca</a> para ensino. Esse padr&atilde;o sofreu uma revis&atilde;o em janeiro de 2003.<sup id="_ref&shy;revis&atilde;o_a" class="reference"><a href="#_note&shy;revis&atilde;o" title="">[10]</a></sup></p>&#10;<p>A linguagem continua evoluindo, sendo as implementa&ccedil;&otilde;es <a href="http://en.wikipedia.org/wiki/Hugs" id="w">Hugs</a> e <a href="http://en.wikipedia.org/wiki/Glasgow_Haskell_Compiler" id="w">GHC</a> consideradas os padr&otilde;es <i><a href="http://en.wikipedia.org/wiki/De_facto" id="w">de facto</a></i>. A partir de 2006 come&ccedil;ou o processo de defini&ccedil;&atilde;o de um sucessor do padr&atilde;o 98, conhecido informalmente por Haskell&prime; (&#34&semi;Haskell Prime&#34&semi;).<sup id="_ref&shy;11" class="reference"><a href="#_note&shy;11" title="">[11]</a></sup></p>&#10;<a id="Caracter%C3%ADsticas" name="Caracter%C3%ADsticas"></a><h2> Caracter&iacute;sticas </h2>&#10;<p>Caracter&iacute;sticas do Haskell incluem o suporte a <a href="http://en.wikipedia.org/wiki/Recursividade" id="w">fun&ccedil;&otilde;es recursivas</a> e <a href="http://en.wikipedia.org/wiki/Tipo_de_dado" id="w">tipos de dados</a>, <a href="http://en.wikipedia.org/wiki/Casamento_de_padr%C3%B5es" id="w">casamento de padr&otilde;es</a>, <i><a href="http://en.wikipedia.org/wiki/List_comprehension" id="w">list comprehensions</a></i>, <i>guard statements</i> e <a href="http://en.wikipedia.org/wiki/Avalia%C3%A7%C3%A3o_pregui%C3%A7osa" id="w">avalia&ccedil;&atilde;o pregui&ccedil;osa</a>, esta, um elo em comum entre os diversos grupos de desenvolvimento da linguagem.<sup id="_ref&shy;12" class="reference"><a href="#_note&shy;12" title="">[12]</a></sup> A combina&ccedil;&atilde;o destas caracter&iacute;sticas pode fazer com que a constru&ccedil;&atilde;o de fun&ccedil;&otilde;es que seriam complexas em uma <a href="http://en.wikipedia.org/wiki/Linguagem_procedimental" id="w">linguagem procedimental</a> de programa&ccedil;&atilde;o tornem&shy;se uma tarefa quase trivial em Haskell. Segundo dados de 2002, &eacute; a linguagem funcional sobre a qual mais pesquisa est&aacute; sendo realizada. Muitas variantes tem sido desenvolvidas: vers&otilde;es paraleliz&aacute;veis do <a href="http://en.wikipedia.org/wiki/MIT" id="w">MIT</a> e <a href="http://en.wikipedia.org/wiki/Glasgow" id="w">Glasgow</a>, ambas chamadas Parallel Haskell, outras vers&otilde;es paralelas e distribu&iacute;das chamadas Distributed Haskell (anteriormente Goffin) e Eden, uma vers&atilde;o chamada Eager Haskell e v&aacute;rias vers&otilde;es orientadas a objetos: Haskell++, O&#39&semi;Haskell e Mondrian.</p>&#10;<p>Uma vers&atilde;o educacional do Haskell chamada Gofer foi desenvolvida por Mark Jones. Ela &eacute; oferecida pelo HUGS.&#10;Existe tamb&eacute;m uma vers&atilde;o do Haskell que permite orienta&ccedil;&atilde;o a aspectos (POA), chamada AspectH.</p>&#10;<a id="Sintaxe" name="Sintaxe"></a><h3> Sintaxe </h3>&#10;<p>Em Haskell existem apenas fun&ccedil;&otilde;es, e todas as fun&ccedil;&otilde;es s&atilde;o un&aacute;rias. O que, em outras linguagens de programa&ccedil;&atilde;o seriam fun&ccedil;&otilde;es bin&aacute;rias, tern&aacute;rias, etc, em Haskell s&atilde;o fun&ccedil;&otilde;es cujo valor de retorno s&atilde;o outras fun&ccedil;&otilde;es &shy; o que se chama <a href="http://en.wikipedia.org/wiki/Currying" id="w">currying</a>, termo derivado de <a href="http://en.wikipedia.org/wiki/Haskell_Curry" id="w">Haskell Curry</a>.</p>&#10;<p>Uma fun&ccedil;&atilde;o que, dados dois n&uacute;meros, retorna sua soma poderia ser declarada como:&#10;</p><dl><dd><code>soma x y =x+y</code></dd></dl>&#10;<p>O que parece ser uma fun&ccedil;&atilde;o bin&aacute;ria &eacute;, logicamente, uma fun&ccedil;&atilde;o un&aacute;ria (<i>soma</i>, cuja entrada &eacute; <i>x</i>) que retorna outra fun&ccedil;&atilde;o. Em outras palavras, <i>soma x</i> &eacute; a fun&ccedil;&atilde;o un&aacute;ria que, dado <i>y</i> retorna <i>x + y</i>, e <i>soma</i> &eacute; a fun&ccedil;&atilde;o un&aacute;ria que, dado <i>x</i>, retorna <i>x +</i>.</p>&#10;<p>Em Haskell n&atilde;o existem vari&aacute;veis globais, apenas fun&ccedil;&otilde;es e vari&aacute;veis locais, definidas dentro do escopo de cada fun&ccedil;&atilde;o.</p>&#10;<p>Tamb&eacute;m n&atilde;o h&aacute; estruturas de loop, ou instru&ccedil;&otilde;es do tipo <i>goto</i>.</p>&#10;<p>O <i>if</i> &eacute; implementado atrav&eacute;s de |, que significa a restri&ccedil;&atilde;o do dom&iacute;nio do argumento da fun&ccedil;&atilde;o.</p>&#10;<p>O exemplo abaixo mostra uma implementa&ccedil;&atilde;o do fatorial que usa a recursividade e o <i>if</i>:</p>&#10;<p />&#10;&#10;<p>Em palavras: a primeira linha diz que o fatorial de zero &eacute; um&semi; a segunda linha diz que o fatorial de um n&uacute;mero <i>n</i> qualquer, desde que <i>n</i> seja maior que zero, pode ser calculado a partir do fatorial de <i>(n&shy;1)</i>. Esta implementa&ccedil;&atilde;o n&atilde;o &eacute; eficiente, mas serve como exemplo did&aacute;tico.</p>&#10;<a id="Listas" name="Listas"></a><h3> Listas </h3>&#10;<p>H&aacute; duas funcionalidades importantes para a constru&ccedil;&atilde;o de listas. A primeira &eacute; a <i><a href="http://en.wikipedia.org/wiki/List_comprehension" id="w">list comprehension</a></i>, que permite construir listas sob forma de conjuntos. Por exemplo, o c&oacute;digo <code>[ x | x &#60&semi;&shy; [0..], x^2&#62&semi;3 ]</code> cria uma lista de elementos <code>x</code> a partir do gerador <code> &#60&semi;&shy; [0..]</code> (o conjunto dos <a href="http://en.wikipedia.org/wiki/N%C3%BAmero_natural" id="w">n&uacute;meros naturais</a>), que atendam o predicado <code>x^2&#62&semi;3</code> (o s&iacute;mbolo &#60&semi;&shy; representa o pertence, <span class="math">\in\,</span>, da teoria dos conjuntos). Pode&shy;se combinar geradores numa mesma <i>list comprehension</i>.</p>&#10;<p>A segunda funcionalidade &eacute; a sequ&ecirc;ncia aritm&eacute;tica, que permite construir listas sob forma de intervalos. Por exemplo, o c&oacute;digo <code>[2..10]</code> cria uma lista de inteiros de 2 a 10. Pode&shy;se omitir o fim do intervalo&semi; <code>[2..]</code> gera uma lista infinita de inteiros a partir de 2.</p>&#10;<p>H&aacute; tr&ecirc;s fun&ccedil;&otilde;es primordiais sobre listas em Haskell, das quais outras fun&ccedil;&otilde;es podem ser combinadas.<sup id="_ref&shy;13" class="reference"><a href="#_note&shy;13" title="">[13]</a></sup> A primeira &eacute; <code>foldl</code>, que adiciona um operador dado entre cada elemento da lista, retornando o resultado da express&atilde;o gerada. Para concatenar uma lista de cadeias de caracteres <code>cadeia = [&#34&semi;Uma&#34&semi;, &#34&semi; &#34&semi;, &#34&semi;cadeia&#34&semi;]</code> pode&shy;se usar <code>foldr1 (++) cadeia</code>. A segunda &eacute; <code>map</code>, que executa uma fun&ccedil;&atilde;o a todos os elementos da lista, retornando uma nova lista. A terceira &eacute; <code>filter</code>, que filtra a lista a partir de um predicado.</p>&#10;<a id="Tipos_de_dado" name="Tipos_de_dado"></a><h3> Tipos de dado </h3>&#10;<p>A tipagem de Haskell &eacute; forte. Cada express&atilde;o possui um tipo, e &eacute; poss&iacute;vel obt&ecirc;&shy;lo em <a href="http://en.wikipedia.org/wiki/Tempo_de_compila%C3%A7%C3%A3o" id="w">tempo de compila&ccedil;&atilde;o</a> atrav&eacute;s de infer&ecirc;ncia de tipo. Os tipos b&aacute;sicos da linguagem incluem:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable" style="font&shy;size: 85%&semi; width: 100%">&#10;<tr>&#10;<th>Tipo de dado </th>&#10;<th>Descri&ccedil;&atilde;o </th>&#10;<th>Classes </th>&#10;<th>Exemplo da sintaxe</th></tr>&#10;<tr>&#10;<td><code>Bool</code> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Enumera%C3%A7%C3%A3o" id="w">Enumera&ccedil;&atilde;o</a> de valores <a href="http://en.wikipedia.org/wiki/Booleano" id="w">booleanos</a>, que permitem certas opera&ccedil;&otilde;es l&oacute;gicas, como <a href="http://en.wikipedia.org/wiki/Conjun%C3%A7%C3%A3o_l%C3%B3gica" id="w">conjun&ccedil;&atilde;o</a> (<code>&#38&semi;&#38&semi;</code>), <a href="http://en.wikipedia.org/wiki/Disjun%C3%A7%C3%A3o_l%C3%B3gica" id="w">disjun&ccedil;&atilde;o</a> (<code>||</code>) e nega&ccedil;&atilde;o (<code>not</code>). </td>&#10;<td>Read, Show, Eq, Ord, Enum, Bounded </td>&#10;<td><code>True</code><br/><code>False</code></td></tr>&#10;<tr>&#10;<td><code>Char</code> </td>&#10;<td>Enumera&ccedil;&atilde;o de caracteres <a href="http://en.wikipedia.org/wiki/16&shy;bit" id="w">16&shy;bit</a>, <a href="http://en.wikipedia.org/wiki/Unicode" id="w">Unicode</a>. A faixa dos primeiro 128 caracteres &eacute; id&ecirc;ntica ao <a href="http://en.wikipedia.org/wiki/ASCII" id="w">ASCII</a>. </td>&#10;<td>Read, Show, Eq, Ord, Enum, and Bounded </td>&#10;<td><code>&#39&semi;a&#39&semi;</code></td></tr>&#10;<tr>&#10;<td><code>Double</code> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Ponto_flutuante" id="w">Ponto flutuante</a> com maior intervalo e precis&atilde;o que <code>Float</code> </td>&#10;<td>RealFloat </td>&#10;<td /></tr>&#10;<tr>&#10;<td><code>Either</code> </td>&#10;<td />&#10;<td>Eq, Ord, Read, Show </td></tr>&#10;<tr>&#10;<td><code>Float</code> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Ponto_flutuante" id="w">Ponto flutuante</a> </td>&#10;<td>RealFloat </td>&#10;<td><code>6553.612</code><br/>321.6e&shy;3</td></tr>&#10;<tr>&#10;<td><code>IO</code> </td>&#10;<td>Tipo abstrato para opera&ccedil;&otilde;es de <a href="http://en.wikipedia.org/wiki/E/S" id="w">E/S</a>, como <code>putStr</code>, <code>print</code>, <code>getChar</code>, <code>getLine</code> e <code>readIO</code>. </td>&#10;<td>Monad, Functor </td></tr>&#10;<tr>&#10;<td><code>IOError</code> </td>&#10;<td>Tipo abstrato para erros nas opera&ccedil;&otilde;es de E/S com <code>IO</code>. </td>&#10;<td>Show, Eq </td></tr>&#10;<tr>&#10;<td><code>Int</code> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Inteiro_(tipo_de_dado)" id="w">Inteiro</a> que cobre, pelo menos, o intervalo de valores [&shy;2^29, 2^29 &shy; 1]. </td>&#10;<td>Integral </td>&#10;<td><code>123</code></td></tr>&#10;<tr>&#10;<td><code>Integer</code> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Inteiro_(tipo_de_dado)" id="w">Inteiro</a> de <a href="http://en.wikipedia.org/wiki/Bigint" id="w">precis&atilde;o ilimitada</a>, com as mesmas fun&ccedil;&otilde;es e operadores de <code>Int</code> </td>&#10;<td>Integral </td>&#10;<td><code>123</code></td></tr>&#10;<tr>&#10;<td><code>Maybe</code> </td>&#10;<td>Lida com valores opcionais ou ilegais sem terminar o programa e sem usar o <code>IOError</code> de <code>IO</code>. </td>&#10;<td>Eq, Ord, Read, Show </td>&#10;<td /></tr>&#10;<tr>&#10;<td><code>Ordering</code> </td>&#10;<td />&#10;<td>Eq, Ord, Bounded, Enum, Read, Show </td>&#10;<td /></tr>&#10;<tr>&#10;<td><code>String</code> </td>&#10;<td><a href="http://en.wikipedia.org/wiki/Cadeia_de_caracteres" id="w">Cadeia de caracteres</a>, representada sob forma de lista de <code>Char</code>. A sintaxe tanto pode ser de lista quanto a abrevia&ccedil;&atilde;o, entre <a href="http://en.wikipedia.org/wiki/Aspas" id="w">aspas</a>. </td>&#10;<td />&#10;<td><code>&#34&semi;Texto&#34&semi;</code><br/><code>[&#39&semi;T&#39&semi;,&#39&semi;e&#39&semi;,&#39&semi;x&#39&semi;,&#39&semi;t&#39&semi;,&#39&semi;o&#39&semi;]</code></td></tr>&#10;<tr>&#10;<td>Tuplas </td>&#10;<td>Tipo de dado alg&eacute;brico de defini&ccedil;&atilde;o de registros heterog&ecirc;neos, <a href="http://en.wikipedia.org/wiki/Tupla" id="w">tuplas</a>. A quantidade m&aacute;xima de elementos depende da implementa&ccedil;&atilde;o, mas a quantidade m&iacute;nima de quinze elementos &eacute; sempre garantida.<sup id="_ref&shy;14" class="reference"><a href="#_note&shy;14" title="">[14]</a></sup> </td>&#10;<td>Eq, Ord, Bounded, Read, Show </td>&#10;<td><code>(&#39&semi;A&#39&semi;,11,True)</code></td></tr>&#10;<tr>&#10;<td>Listas </td>&#10;<td>Tipo de dado alg&eacute;brico de defini&ccedil;&atilde;o de registros homog&ecirc;neos <a href="http://en.wikipedia.org/wiki/Lista" id="w">listas</a>. Entre os operadores dispon&iacute;veis encontra&shy;se <code /></td>&#10;<th>, que retorna o n&shy;&eacute;simo elemento da lista, e <code>++</code>, que <a href="http://en.wikipedia.org/wiki/Concatena%C3%A7%C3%A3o" id="w">concatena</a> duas listas distintas de mesmo tipo. Relacionado a concatena&ccedil;&atilde;o, h&aacute; o operador <code>:</code>, que adiciona um elemento no topo de uma lista. </th>&#10;<td>Eq, Ord </td>&#10;<td><code>[1,2,3,4]</code><br/><code>[1..4]</code><br/><code>(1:(2:(3:(4:[]))))</code></td></tr></table></div>&#10;&#10;<p>A linguagem ainda define diversas classes padr&atilde;o:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable" style="font&shy;size: 85%&semi; width: 100%">&#10;<tr>&#10;<th>Tipo de dado </th>&#10;<th>Descri&ccedil;&atilde;o </th>&#10;<th>Prove</th></tr>&#10;<tr>&#10;<td><code>Bounded</code> </td>&#10;<td>Delimita um tipo de dado </td></tr>&#10;<tr>&#10;<td><code>Enum</code> </td>&#10;<td>Prove opera&ccedil;&otilde;es em tipo sequencialmente ordenados. </td>&#10;<td><code>succ</code>, <code>pred</code>, <code>toEnum</code>, <code>enumFrom</code></td></tr>&#10;<tr>&#10;<td><code>Eq</code> </td>&#10;<td>Prove operadores de igualdade. </td>&#10;<td><code>==</code>, <code>/=</code></td></tr>&#10;<tr>&#10;<td><code>Floating</code> </td>&#10;<td /></tr>&#10;<tr>&#10;<td><code>Fractional</code> </td>&#10;<td /></tr>&#10;<tr>&#10;<td><code>Functor</code> </td>&#10;<td>Usado por tipos que podem ser mapeados. </td></tr>&#10;<tr>&#10;<td><code>Integral</code> </td>&#10;<td /></tr>&#10;<tr>&#10;<td><code>Ord</code> </td>&#10;<td>Prove operadores de ordena&ccedil;&atilde;o. </td>&#10;<td><code>&lArr;</code>, <code>&#60&semi;</code>, <code>&#62&semi;=</code>, <code>&#62&semi;</code></td></tr>&#10;<tr>&#10;<td><code>Monad</code> </td>&#10;<td>Prove opera&ccedil;&otilde;es sobre m&ocirc;nadas. </td></tr>&#10;<tr>&#10;<td><code>MonadPlus</code> </td>&#10;<td /></tr>&#10;<tr>&#10;<td><code>Num</code> </td>&#10;<td /></tr>&#10;<tr>&#10;<td><code>Read</code> </td>&#10;<td /></tr>&#10;<tr>&#10;<td><code>Real</code> </td>&#10;<td /></tr>&#10;<tr>&#10;<td><code>RealFloat</code> </td>&#10;<td /></tr>&#10;<tr>&#10;<td><code>RealFrac</code> </td>&#10;<td /></tr>&#10;<tr>&#10;<td><code>Show</code> </td>&#10;<td /></tr></table></div>&#10;&#10;<a id="Operadores" name="Operadores"></a><h3> Operadores </h3>&#10;<p>Al&eacute;m dos operadores espec&iacute;ficos de certos tipos de dado supracitados, vale notar tamb&eacute;m alguns outros. O operador <code>.</code> realiza a <a href="http://en.wikipedia.org/wiki/Composi%C3%A7%C3%A3o_de_fun%C3%A7%C3%B5es" id="w">composi&ccedil;&atilde;o de fun&ccedil;&otilde;es</a>. Por exemplo, a express&atilde;o <code>((2+).(3*).(4&shy;)) 2</code> retorna <code>8</code>, e significa <span class="math">((4&shy;2)*3)+2</span>.</p>&#10;<p>A potencia&ccedil;&atilde;o pode ser feita atrav&eacute;s do operador <code>**</code>. Entretanto est&atilde;o dispon&iacute;veis tamb&eacute;m duas vers&otilde;es mais eficientes. Para <code>^^</code>, o expoente deve ser um inteiro&semi; para <code>^</code>, o expoente deve ser um inteiro n&atilde;o negativo.</p>&#10;<a id="Aplica%C3%A7%C3%B5es" name="Aplica%C3%A7%C3%B5es"></a><h2> Aplica&ccedil;&otilde;es </h2>&#10;<p>Os pontos fortes da linguagem Haskell t&ecirc;m sido bem aplicados em alguns projetos. &Eacute; cada vez mais utilizada em aplica&ccedil;&otilde;es comerciais.<sup id="_ref&shy;15" class="reference"><a href="#_note&shy;15" title="">[15]</a></sup> O compilador e interpretador <a href="http://en.wikipedia.org/wiki/Pugs" id="w">Pugs</a> criado por <a href="http://en.wikipedia.org/wiki/Audrey_Tang" id="w">Audrey Tang</a> &eacute; uma vers&atilde;o completa da linguagem <a href="http://en.wikipedia.org/wiki/Perl_6" id="w">Perl 6</a>. <a href="http://en.wikipedia.org/wiki/Darcs" id="w">Darcs</a> &eacute; um sistema de controle de vers&otilde;es baseado em mudan&ccedil;as (change&shy;based) com v&aacute;rias caracter&iacute;sticas inovadoras. A <a href="http://en.wikipedia.org/wiki/Linspire" id="w">Linspire</a> GNU / Linux escolheu Haskell para desenvolvimento das ferramentas do sistema .<sup id="_ref&shy;16" class="reference"><a href="#_note&shy;16" title="">[16]</a></sup> <a href="http://en.wikipedia.org/wiki/Xmonad" id="w">Xmonad</a> &eacute; um gerenciador de janelas &#34&semi;tile&shy;based&#34&semi; para o <a href="http://en.wikipedia.org/wiki/X_Window_System" id="w">X Window System</a> escrito inteiramente em Haskell. <a href="http://en.wikipedia.org/wiki/Bluespec_SystemVerilog" id="w">Bluespec SystemVerilog</a> &eacute; uma linguagem feita como uma extens&atilde;o do Haskell.</p>&#10;<a id="Exemplos" name="Exemplos"></a><h2> Exemplos </h2>&#10;<p>O difundido caso do <a href="http://en.wikipedia.org/wiki/Programa_Ol%C3%A1_Mundo" id="w">Programa Ol&aacute; Mundo</a> pode ser exemplificado em Haskell da seguinte forma:</p>&#10;<p />&#10;&#10;<p>A cl&aacute;ssica defini&ccedil;&atilde;o da fun&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/Fatorial" id="w">fatorial</a>:</p>&#10;<p />&#10;&#10;<p>Ou em uma linha:</p>&#10;<p />&#10;&#10;<p>Este artigo descreve o fatorial como uma fun&ccedil;&atilde;o recursiva, terminando com um caso que serve como base. &Eacute; semelhante ao encontrado nas descri&ccedil;&otilde;es de fatoriais em livros did&aacute;ticos de matem&aacute;tica. Grande parte do c&oacute;digo Haskell &eacute; semelhante ao padr&atilde;o da nota&ccedil;&atilde;o matem&aacute;tica na potencialidade expressiva e na sintaxe.&#10;A primeira linha da fun&ccedil;&atilde;o fatorial descreve os tipos desta fun&ccedil;&atilde;o&semi; embora seja opcional, &eacute; considerado bom estilo <sup id="_ref&shy;17" class="reference"><a href="#_note&shy;17" title="">[17]</a></sup> inclu&iacute;&shy;la. Ela pode ser lida como a fun&ccedil;&atilde;o fatorial (fatorial) tem tipo (::) inteiro para inteiro (Integer &shy;&#62&semi; Integer). Ou seja, ele tem um inteiro como um argumento e retorna outro inteiro. O tipo de uma defini&ccedil;&atilde;o &eacute; inferido automaticamente se o programador n&atilde;o forneceu uma nota&ccedil;&atilde;o de tipo.</p>&#10;<p>A segunda linha depende de um casamento de padr&otilde;es (pattern matching), uma caracter&iacute;stica importante do Haskell. Note que os par&acirc;metros da fun&ccedil;&atilde;o s&atilde;o separados por par&ecirc;nteses e n&atilde;o por espa&ccedil;os. Quando o argumento da fun&ccedil;&atilde;o &eacute; 0 (zero) ser&aacute; devolvido o inteiro 1 (um). Para todos os outros casos, a terceira linha &eacute; tentada. Esta &eacute; a recursividade, e executa a fun&ccedil;&atilde;o novamente at&eacute; que um caso que sirva como base seja atingido.</p>&#10;<p>Um &#34&semi;guard&#34&semi; protege a terceira linha de n&uacute;meros negativos, sendo que um fatorial n&atilde;o permite n&uacute;meros negativos, indefinido&shy;o. Sem um &#34&semi;guard&#34&semi; essa fun&ccedil;&atilde;o seria recursiva &#34&semi;fatorando&#34&semi; todos os n&uacute;meros negativos, sem nunca chegar &agrave; base 0. Se um inteiro negativo &eacute; passado para o fatorial funcionar como um argumento, o programa ir&aacute; falhar com um erro &#34&semi;runtime&#34&semi;. De &uacute;ltimo caso, poderia ser tratada esta condi&ccedil;&atilde;o de erro e imprimir uma mensagem de erro adequada em seu lugar.</p>&#10;<p>A descri&ccedil;&atilde;o acima &eacute; parecida com as descri&ccedil;&otilde;es matem&aacute;tica, tais como defini&ccedil;&otilde;es de uma fun&ccedil;&atilde;o <span class="math">f = g \circ h</span> e n&atilde;o como uma atribui&ccedil;&atilde;o de um valor num&eacute;rico para uma vari&aacute;vel.</p>&#10;<p>Uma outra defini&ccedil;&atilde;o da fun&ccedil;&atilde;o fatorial (usando uma nota&ccedil;&atilde;o de lista em Haskell e a fun&ccedil;&atilde;o padr&atilde;o <code>product</code>):</p>&#10;<p />&#10;&#10;<p>A mesma fun&ccedil;&atilde;o mas agora no estilo <i>point&shy;free</i>. Repare&shy;se que os argumentos desaparecem (o ponto significa composi&ccedil;&atilde;o de fun&ccedil;&otilde;es):</p>&#10;<p />&#10;&#10;<p>Uma implementa&ccedil;&atilde;o da fun&ccedil;&atilde;o que retorna o n&shy;&eacute;simo termo na <a href="http://en.wikipedia.org/wiki/Seq%C3%BC%C3%AAncia_de_Fibonacci" id="w">seq&uuml;&ecirc;ncia de Fibonacci</a>:</p>&#10;<p />&#10;&#10;<p>Uma fun&ccedil;&atilde;o que retorna uma lista dos n&uacute;meros de Fibonacci:</p>&#10;<p />&#10;&#10;<p>A fun&ccedil;&atilde;o anterior cria uma lista infinita, que &eacute; poss&iacute;vel gra&ccedil;as a <a href="http://en.wikipedia.org/wiki/Avalia%C3%A7%C3%A3o_pregui%C3%A7osa" id="w">avalia&ccedil;&atilde;o pregui&ccedil;osa</a>.&#10;Poderia&shy;se implementar <code>fib</code> como:</p>&#10;<p />&#10;&#10;<p>O algoritmo <i><a href="http://en.wikipedia.org/wiki/Quicksort" id="w">quicksort</a></i> pode ser elegantemente escrito em Haskell:</p>&#10;<p />&#10;&#10;<p>Uma forma mais compacta desse mesmo algoritmo seria:</p>&#10;<p />&#10;&#10;<dl><dd><b><i>Nota:</i></b><i> Por causa das excessivas c&oacute;pias e concatena&ccedil;&otilde;es de listas, este c&oacute;digo pode ser lento.</i></dd></dl>&#10;<p>Aqui tem um exemplo de N&uacute;meros Perfeitos:</p>&#10;<p />&#10;&#10;<a id="Implementa%C3%A7%C3%B5es" name="Implementa%C3%A7%C3%B5es"></a><h2> Implementa&ccedil;&otilde;es </h2>&#10;<p>As seguintes implementa&ccedil;&otilde;es est&atilde;o totalmente, ou quase, de acordo com o padr&atilde;o Haskell 98. Todas s&atilde;o distribu&iacute;das sob licen&ccedil;as <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_aberto" id="w">c&oacute;digo aberto</a>.&#10;</p>&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/GHC" id="w">GHC</a>. O Glasgow Haskell Compiler gera c&oacute;digo nativo de diferentes arquitecturas e pode tamb&eacute;m gerar c&oacute;digo <a href="http://en.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">C</a>. Ele &eacute; provavelmente o mais popular <a href="http://en.wikipedia.org/wiki/Compilador" id="w">compilador</a> Haskell, e algumas <a href="http://en.wikipedia.org/wiki/Biblioteca_(computa%C3%A7%C3%A3o)" id="w">bibliotecas</a> (como <i>bindings</i> para <a href="http://en.wikipedia.org/wiki/OpenGL" id="w">OpenGL</a>) funcionam apenas com ele.</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Hugs" id="w">Hugs</a> &eacute; um interpretador de <a href="http://en.wikipedia.org/wiki/Bytecode" id="w">bytecode</a>. Oferece r&aacute;pida compila&ccedil;&atilde;o dos programas e razo&aacute;vel velocidade de execu&ccedil;&atilde;o. Tamb&eacute;m disp&otilde;e de uma simples biblioteca gr&aacute;fica. Hugs &eacute; ideal para pessoas que est&atilde;o aprendendo os b&aacute;sicos de Haskell. &Eacute; a mais port&aacute;vel e leve das implementa&ccedil;&otilde;es de Haskell.</li>&#10;<li>nhc98<sup id="_ref&shy;18" class="reference"><a href="#_note&shy;18" title="">[18]</a></sup> &eacute; outro compilador que gera bytecode. O bytecode resultante executa significativamente mais r&aacute;pido do que o equivalente do Hugs. Nhc98 foca na minimiza&ccedil;&atilde;o do uso de mem&oacute;ria, e &eacute; uma boa escolha para m&aacute;quinas velhas/lentas.</li>&#10;<li>HBC &eacute; outro compilador Haskell para c&oacute;digo nativo. Seu desenvolvimento n&atilde;o est&aacute; ativo, mas ele &eacute; funcional.</li>&#10;<li>Helium<sup id="_ref&shy;19" class="reference"><a href="#_note&shy;19" title="">[19]</a></sup> &eacute; um novo dialecto do Haskell. O foco &eacute; na facilidade de aprendizado. Actualmente carece de <i>typeclasses</i>, tornando&shy;o incompat&iacute;vel com muitos programas Haskell.</li></ul>&#10;<a id="Leitura_adicional" name="Leitura_adicional"></a><h2> Leitura adicional </h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://www2.joinville.udesc.br/~coca/index.php/Main/PaginaDoLivroDeHaskell" rel="nofollow" title="http://www2.joinville.udesc.br/~coca/index.php/Main/PaginaDoLivroDeHaskell">P&aacute;gina do livro: &#39&semi;&#39&semi;Haskell: Uma Abordagem Pr&aacute;tica&#39&semi;&#39&semi;</a>, um livro de n&iacute;vel  introdut&oacute;rio a m&eacute;dio sobre a linguagem Haskell, com uma apresenta&ccedil;&atilde;o crescente as principais caracter&iacute;sticas da linguagem.</li></ul>&#10;<p> </p>&#10;<a id="Refer%C3%AAncias_bibliogr%C3%A1ficas" name="Refer%C3%AAncias_bibliogr%C3%A1ficas"></a><h2> Refer&ecirc;ncias bibliogr&aacute;ficas </h2>&#10;<p />&#10;<div class="references&shy;small">&#10;&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li></ul>&#10;<p /></div>&#10;&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;<p> &#10;</p>&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_funcional" id="w">Programa&ccedil;&atilde;o funcional</a></li></ul>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_funcionais" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o funcionais</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_educacionais" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o educacionais</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:1990_na_inform%C3%A1tica" id="w">Categoria:1990 na inform&aacute;tica</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_criadas_em_1990" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o criadas em 1990</a></p></body></html>