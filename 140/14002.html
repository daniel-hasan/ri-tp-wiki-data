<html><title>Heapsort</title><body>&#10;<p> &#10;O <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmo</a> <b>heapsort</b> &eacute; um <a href="http://en.wikipedia.org/wiki/Algoritmo_de_ordena%C3%A7%C3%A3o" id="w">algoritmo de ordena&ccedil;&atilde;o</a> generalista, e faz parte da fam&iacute;lia de algoritmos de <a href="http://en.wikipedia.org/wiki/Ordena%C3%A7%C3%A3o_por_sele%C3%A7%C3%A3o" id="w">ordena&ccedil;&atilde;o por sele&ccedil;&atilde;o</a>. Foi desenvolvido em 1964 por <b>Robert W. Floyd</b> e <b>J.W.J. Williams</b>.</p>&#10;<a id="Defini%C3%A7%C3%A3o" name="Defini%C3%A7%C3%A3o"></a><h2> Defini&ccedil;&atilde;o </h2>&#10;<p>Tem um desempenho em tempo de execu&ccedil;&atilde;o muito bom em conjuntos ordenados aleatoriamente, tem um uso de mem&oacute;ria bem comportado e o seu desempenho em <a href="http://en.wikipedia.org/wiki/Complexidade_Pior_caso" id="w">pior cen&aacute;rio</a> &eacute; praticamente igual ao desempenho em <a href="http://en.wikipedia.org/wiki/Complexidade_Caso_m%C3%A9dio" id="w">cen&aacute;rio m&eacute;dio</a>. Alguns algoritmos de ordena&ccedil;&atilde;o r&aacute;pidos t&ecirc;m desempenhos espectacularmente ruins no pior cen&aacute;rio, quer em tempo de execu&ccedil;&atilde;o, quer no uso da mem&oacute;ria. O Heapsort trabalha no lugar e o tempo de execu&ccedil;&atilde;o em pior cen&aacute;rio para ordenar <i>n</i> elementos &eacute; de <a href="http://en.wikipedia.org/wiki/Nota%C3%A7%C3%A3o_O_mai%C3%BAsculo" id="w">O</a> (<i>n</i> lg <i>n</i>). L&ecirc;&shy;se logaritmo (ou log) de &#34&semi;n&#34&semi; na base 2. Para valores de <i>n</i>, razoavelmente grandes, o termo lg <i>n</i> &eacute; quase constante, de modo que o tempo de ordena&ccedil;&atilde;o &eacute; quase linear com o n&uacute;mero de itens a ordenar.</p>&#10;<a id="Caracter%C3%ADsticas" name="Caracter%C3%ADsticas"></a><h2> Caracter&iacute;sticas </h2>&#10;&#10;<ul>&#10;<li>Compara&ccedil;&otilde;es no pior caso: 2n log<sub>2</sub>n + O(n) &eacute; o mesmo que 2n lgn + O(n)</li>&#10;<li>Trocas no pior caso: n log<sub>2</sub>n + O(n) &eacute; o mesmo que n lgn + O(n)</li>&#10;<li>Melhor e pior caso: O(n log<sub>2</sub>n) &eacute; o mesmo que O(n lgn)</li></ul>&#10;<a id="Estabilidade" name="Estabilidade"></a><h3> Estabilidade </h3>&#10;<p>O Heapsort n&atilde;o &eacute; um algoritmo de <a href="http://en.wikipedia.org/wiki/Ordena%C3%A7%C3%A3o_est%C3%A1vel" id="w">ordena&ccedil;&atilde;o est&aacute;vel</a>. Por&eacute;m, &eacute; poss&iacute;vel adaptar a estrutura a ser ordenada de forma a tornar a ordena&ccedil;&atilde;o est&aacute;vel. Cada elemento da estrutura adaptada deve ficar no formato de um par (elemento original, &iacute;ndice original). Assim, caso dois elementos sejam iguais, o desempate ocorrer&aacute; pelo &iacute;ndice na estrutura original.</p>&#10;<a id="Funcionamento" name="Funcionamento"></a><h2> Funcionamento </h2>&#10;<p>O heapsort utiliza uma estrutura de dados chamada <a href="http://en.wikipedia.org/wiki/Heap" id="w">heap</a>, para ordenar os elementos a medida que os insere na estrutura. Assim, ao final das inser&ccedil;&otilde;es, os elementos podem ser sucessivamente removidos da raiz da heap, na ordem desejada, lembrando&shy;se sempre de manter a propriedade de max&shy;heap.</p>&#10;<p>A heap pode ser representada como uma &aacute;rvore (uma &aacute;rvore bin&aacute;ria com propriedades especiais<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup>) ou como um vetor. Para uma ordena&ccedil;&atilde;o crescente, deve ser constru&iacute;do uma heap m&iacute;nima (o menor elemento fica na raiz). Para uma ordena&ccedil;&atilde;o decrescente, deve ser constru&iacute;do uma heap m&aacute;xima (o maior elemento fica na raiz).</p>&#10;<a id="Implementa%C3%A7%C3%B5es" name="Implementa%C3%A7%C3%B5es"></a><h2> Implementa&ccedil;&otilde;es </h2>&#10;<a id="Assembly_x86&shy;gas&shy;Linux" name="Assembly_x86&shy;gas&shy;Linux"></a><h3> Assembly x86&shy;gas&shy;Linux </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;asm&#34&semi;&#62&semi;&#10;/* void heap_sort_as(int *x, int n)&semi;*/&#10;.globl heap_sort_as&#10;heap_sort_as:&#10;pushl %ebp&#10;movl %esp, %ebp&#10;/* 8(%ebp) &shy;&#62&semi; arranjo*/&#10;/* 12(%ebp) &shy;&#62&semi; num de elementos *4 */&#10;movl 12(%ebp), %eax&#10;movl $4, %ebx&#10;mul %ebx&#10;pushl %eax&#10;pushl 8(%ebp)&#10;call montar_heap_as&#10;addl $4, %esp&#10;popl %eax&#10;subl $4, %eax          /* eax eh (n*4)&shy;4*/&#10;/* faz a troca */&#10;movl 8(%ebp), %ebx     /* tmp = *x */&#10;pushl %eax&#10;movl %ebx, %ecx&#10;addl %eax, %ecx&#10;movl (%ebx), %eax&#10;movl (%ecx), %edx&#10;movl %eax, (%ecx)&#10;movl %edx, (%ebx)&#10;popl %eax              /* eax representa (n*4)&shy;4 */&#10;pushl $0&#10;pushl %eax&#10;pushl 8(%ebp)&#10;heap_sort_as_loop:&#10;cmp $1, %eax&#10;jle heap_sort_as_fim&#10;call man_heap_as&#10;movl 4(%esp), %eax&#10;subl $4, %eax&#10;/* faz a troca */&#10;movl 8(%ebp), %ebx     /* tmp = *x */&#10;pushl %eax&#10;movl %ebx, %ecx&#10;addl %eax, %ecx&#10;movl (%ebx), %eax&#10;movl (%ecx), %edx&#10;movl %eax, (%ecx)&#10;movl %edx, (%ebx)&#10;popl %eax              /* eax representa (n*4)&shy;4 */&#10;movl %eax, 4(%esp&#10;heap_sort_as_fim:&#10;leave&#10;ret&#10;montar_heap_as:&#10;pushl %ebp&#10;movl %esp, %ebp&#10;/* 8(%ebp) &shy;&#62&semi; arranjo*/&#10;/* 12(%ebp) &shy;&#62&semi; num de elementos *4 */&#10;movl 12(%ebp), %eax&#10;movl $2, %ecx&#10;cltd&#10;idivl %ecx&#10;movl $4, %ecx&#10;cltd&#10;idivl %ecx&#10;mul %ecx&#10;subl $4, %eax /* eax eh h*/&#10;pushl %eax&#10;pushl 12(%ebp)&#10;pushl 8(%ebp)&#10;montar_heap_as_whmz:&#10;cmp $0, %eax&#10;jl montar_heap_as_fim&#10;call man_heap_as&#10;movl 8(%esp), %eax&#10;subl $4, %eax&#10;movl %eax, 8(%esp)&#10;jmp montar_heap_as_whmz&#10;montar_heap_as_fim:&#10;leave&#10;ret&#10;man_heap_as:&#10;pushl %ebp&#10;movl %esp, %ebp&#10;/* 8(%ebp) &shy;&#62&semi; arranjo */&#10;/* 12(%ebp) &shy;&#62&semi; num de elementos *4 */&#10;/* 16(%ebp) &shy;&#62&semi; pai *4 */&#10;movl 16(%ebp), %eax&#10;pushl %eax&#10;movl $2, %ebx&#10;mul %ebx&#10;addl $4, %eax             /* agora eax eh f*/&#10;man_heap_as_wfmn:&#10;cmp 12(%ebp), %eax&#10;jge man_heap_as_fim&#10;movl %eax, %ebx&#10;addl $4, %ebx             /* ebx eh f2 */&#10;movl 8(%ebp),%edx&#10;addl %eax, %edx           /* edx aponta p/ x[f] */&#10;movl (%edx), %edx&#10;cmp 12(%ebp), %ebx&#10;jge man_heap_as_testetroca&#10;movl 8(%ebp), %ecx&#10;addl %ebx, %ecx          /* ecx aponta p/ x[f2] */&#10;movl (%ecx), %ecx&#10;cmp %edx, %ecx&#10;jle man_heap_as_testetroca&#10;movl %ebx, %eax          /* f=f2 ou seja maior filho eh f2 */&#10;movl %ecx, %edx          /* movimentacao apenas p/ testar */&#10;man_heap_as_testetroca:&#10;popl %ebx           /* ebx eh p */&#10;movl 8(%ebp), %ecx&#10;addl %ebx, %ecx     /* ecx eh x[p]*/&#10;movl (%ecx), %ecx&#10;cmp %ecx, %edx&#10;jle man_heap_as_fim&#10;/*fazer a troca */&#10;pushl %eax          /* salva f na pilha*/&#10;addl 8(%ebp), %eax&#10;movl %ecx, (%eax)   /* x[f] = x[p] */&#10;addl 8(%ebp), %ebx&#10;movl %edx, (%ebx)   /* x[p] = x[f] */&#10;movl (%esp), %eax&#10;movl $2, %ebx&#10;mul %ebx&#10;addl $4, %eax&#10;jmp man_heap_as_wfmn&#10;man_heap_as_fim:&#10;leave&#10;ret&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="C%C3%B3digo_em_C" name="C%C3%B3digo_em_C"></a><h3> C&oacute;digo em C </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;c&#34&semi;&#62&semi;&#10;void heapsort(tipo a[], int n)&#10;{&#10;  int i = n/2, pai, filho, t&semi;</p>&#10;<pre>  for (&semi;&semi;)&#10;  {&#10;     if (i &#62&semi; 0)&#10;     {&#10;         i&shy;&shy;&semi;&#10;         t = a[i]&semi;&#10;     }&#10;     else&#10;     {&#10;         n&shy;&shy;&semi;&#10;         if (n == 0)&#10;            return&semi;&#10;         t = a[n]&semi;&#10;         a[n] = a[0]&semi;&#10;     }&#10;&#10;     pai = i&semi;&#10;&#10;     //Primeiro ser&aacute; feita a compara&ccedil;&atilde;o com o filho da esquerda.&#10;     filho = i*2&semi;&#10;&#10;     while (filho &#60&semi; n)&#10;     {&#10;        //Se o filho da esquerda for menor do que o filho da direita,ent&atilde;o ser&aacute; feita a troca do filho que ser&aacute; comparado.&#10;         if ((filho + 1 &#60&semi; n)  &#38&semi;&#38&semi;  (a[filho + 1] &#62&semi; a[filho]))&#10;             filho++&semi;&#10;         if (a[filho] &#62&semi; t)&#10;         {&#10;            a[pai] = a[filho]&semi;&#10;            pai = filho&semi;&#10;            filho = pai*2 + 1&semi;&#10;         }&#10;         else&#10;            break&semi;&#10;     }&#10;     a[pai] = t&semi;&#10;  }</pre>&#10;<p>}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="C%C3%B3digo_em_C%2B%2B" name="C%C3%B3digo_em_C%2B%2B"></a><h3> C&oacute;digo em C++ </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;cpp&#34&semi;&#62&semi;&#10;template&#60&semi;class T&#62&semi;&#10;void heap_sort( std::vector&#60&semi;T&#62&semi; &#38&semi;lista )&#10;{&#10;   int tam = static_cast&#60&semi;int&#62&semi;( lista.size() ), i&semi;</p>&#10;<pre>   for( i = tam/2 &shy; 1&semi; i &#62&semi;= 0&semi; &shy;&shy;i )&#10;   {&#10;      maxHeapify(lista, i , tam )&semi;&#10;   }&#10;&#10;   std::vector&#60&semi;T&#62&semi;::reverse_iterator elem&semi;&#10;&#10;   for( elem = lista.rbegin()&semi; elem != lista.rend()&semi; elem++ )&#10;   {&#10;      std::iter_swap( elem, lista.begin() )&semi;&#10;      maxHeapify( lista, 0, &shy;&shy;tam )&semi;&#10;   }</pre>&#10;<p>}</p>&#10;<p>template&#60&semi;class T&#62&semi;&#10;void maxHeapify( std::vector&#60&semi;T&#62&semi; &#38&semi;lista, const int pos, const int n )&#10;{&#10;   int max = 2 * pos + 1&semi;</p>&#10;<pre>   if( max &#60&semi; n )&#10;   {&#10;      if( (max+1) &#60&semi; n &#38&semi;&#38&semi; lista.at(max) &#60&semi; lista.at(max+1) )&#10;      {&#10;         ++max&semi;&#10;      }&#10;      if( lista.at(max) &#62&semi; lista.at(pos) )&#10;      {&#10;         std::swap( lista[max], lista[pos] )&semi;&#10;         maxHeapify( lista, max, n )&semi;&#10;      }&#10;   }</pre>&#10;<p>}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="C%C3%B3digo_em_C%23" name="C%C3%B3digo_em_C%23"></a><h3> C&oacute;digo em C# </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;csharp&#34&semi;&#62&semi;</p>&#10;<pre>       public void heapSort(int[] v)&#10;       {&#10;           buildMaxHeap(v)&semi;&#10;           int n = v.Length&semi;&#10;&#10;           for (int i = v.Length &shy; 1&semi; i &#62&semi; 0&semi; i&shy;&shy;)&#10;           {&#10;               swap(v, i, 0)&semi;&#10;               maxHeapify(v, 0, &shy;&shy;n)&semi;&#10;           }&#10;       }&#10;       private static void buildMaxHeap(int[] v)&#10;       {&#10;           for (int i = v.Length / 2 &shy; 1&semi; i &#62&semi;= 0&semi; i&shy;&shy;)&#10;               maxHeapify(v, i, v.Length)&semi;&#10;       }&#10;       private static void maxHeapify(int[] v, int pos, int n)&#10;       {&#10;           int max = 2 * pos + 1, right = max + 1&semi;&#10;           if (max &#60&semi; n)&#10;           {&#10;               if (right &#60&semi; n &#38&semi;&#38&semi; v[max] &#60&semi; v[right])&#10;                   max = right&semi;&#10;               if (v[max] &#62&semi; v[pos])&#10;               {&#10;                   swap(v, max, pos)&semi;&#10;                   maxHeapify(v, max, n)&semi;&#10;               }&#10;           }&#10;       }&#10;&#10;       public static void swap(int[] v, int j, int aposJ)&#10;       {&#10;           int aux = v[j]&semi;&#10;           v[j] = v[aposJ]&semi;&#10;           v[aposJ] = aux&semi;&#10;       }</pre>&#10;<p>&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="C%C3%B3digo_em_Java" name="C%C3%B3digo_em_Java"></a><h3> C&oacute;digo em Java </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;java&#34&semi;&#62&semi;&#10;      public static void heapSort(int[] v)&#10;      {&#10;        buildMaxHeap(v+1)&semi;&#10;        int n = v.length&semi;</p>&#10;<pre>        for (int i = v.length &shy; 1&semi; i &#62&semi; 0&semi; i&shy;&shy;)&#10;        {&#10;           swap(v, i , 0)&semi;&#10;           maxHeapify(v, 0, &shy;&shy;n)&semi;&#10;        }&#10;      }&#10;      private static void buildMaxHeap(int[] v)&#10;      {&#10;         for (int i = v.length/2 &shy; 1&semi; i &#62&semi;= 0&semi; i&shy;&shy;)&#10;            maxHeapify(v, i , v. length )&semi;&#10;      }&#10;      private static void maxHeapify(int[] v, int pos, int n)&#10;      {&#10;         int maxi&semi;&#10;         int l = 2 * pos + 1&semi;&#10;         int right = 2 * pos + 2&semi;&#10;         if ( (l &#60&semi; n) &#38&semi;&#38&semi; (v[l] &#62&semi; v[pos]) )&#10;         {&#10;            maxi = l&semi;&#10;         }&#10;         else&#10;         {&#10;            maxi = pos&semi;&#10;         }&#10;         if (right &#60&semi; n &#38&semi;&#38&semi; v[right] &#62&semi; v[maxi])&#10;         {&#10;            maxi = right&semi;&#10;         }&#10;         if (maxi != pos)&#10;         {&#10;            swap(v, pos, maxi)&semi;&#10;            maxHeapify(v, maxi, n)&semi;&#10;         }&#10;      }&#10;&#10;      public static void swap ( int[ ] v, int j, int aposJ )&#10;      {&#10;         int aux = v [ j ]&semi;&#10;         v [ j ] = v [ aposJ ]&semi;&#10;         v [ aposJ ] = aux&semi;&#10;      }</pre>&#10;<p>&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="C%C3%B3digo_em_Java_(5.0)" name="C%C3%B3digo_em_Java_(5.0)"></a><h3> C&oacute;digo em Java (5.0) </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;java5&#34&semi;&#62&semi;&#10;   public static &#60&semi;T extends Comparable&#60&semi;? super T&#62&semi;&#62&semi; void heapSort(T[] v) {&#10;       buildMaxHeap(v)&semi;&#10;       int n = v.length&semi;</p>&#10;<pre>       for (int i = v.length &shy; 1&semi; i &#62&semi; 0&semi; i&shy;&shy;) {&#10;           swap(v, i, 0)&semi;&#10;           maxHeapify(v, 0, &shy;&shy;n)&semi;&#10;       }&#10;   }&#10;&#10;   private static &#60&semi;T extends Comparable&#60&semi;? super T&#62&semi;&#62&semi; void buildMaxHeap(T v[]) {&#10;       for (int i = v.length / 2 &shy; 1&semi; i &#62&semi;= 0&semi; i&shy;&shy;)&#10;           maxHeapify(v, i, v.length)&semi;&#10;   }&#10;&#10;   private static &#60&semi;T extends Comparable&#60&semi;? super T&#62&semi;&#62&semi; void maxHeapify(T[] v, int pos,&#10;           int n) {&#10;       int max = 2 * pos + 1, right = max + 1&semi;&#10;       if (max &#60&semi; n) {&#10;           if (right &#60&semi; n &#38&semi;&#38&semi; v[max].compareTo(v[right]) &#60&semi; 0)&#10;               max = right&semi;&#10;           if (v[max].compareTo(v[pos]) &#62&semi; 0) {&#10;               swap(v, max, pos)&semi;&#10;               maxHeapify(v, max, n)&semi;&#10;           }&#10;       }&#10;   }&#10;&#10;   public static void swap(Object[] v, int j, int aposJ) {&#10;       Object aux = v[j]&semi;&#10;       v[j] = v[aposJ]&semi;&#10;       v[aposJ] = aux&semi;&#10;   }</pre>&#10;<p>&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="C%C3%B3digo_em_python" name="C%C3%B3digo_em_python"></a><h3> C&oacute;digo em python </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;python&#34&semi;&#62&semi;&#10;def heapsort(lst):&#10; <b> Heapsort. Note: this function sorts in&shy;place (it mutates the list). </b></p>&#10;&#10;<ol>&#10;<li>in pseudo&shy;code, heapify only called once, so inline it here</li></ol>&#10;<pre> for start in range((len(lst)&shy;2)/2, &shy;1, &shy;1):&#10;   siftdown(lst, start, len(lst)&shy;1)&#10;&#10; for end in range(len(lst)&shy;1, 0, &shy;1):&#10;   lst[end], lst[0] = lst[0], lst[end]&#10;   siftdown(lst, 0, end &shy; 1)&#10; return lst&#10;</pre>&#10;<p>def siftdown(lst, start, end):&#10; root = start&#10; while True:&#10;   child = root * 2 + 1&#10;   if child &#62&semi; end: break&#10;   if child + 1 &#60&semi;= end and lst[child] &#60&semi; lst[child + 1]:&#10;     child += 1&#10;   if lst[root] &#60&semi; lst[child]:&#10;     lst[root], lst[child] = lst[child], lst[root]&#10;     root = child&#10;   else:&#10;     break&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="C%C3%B3digo_em_PHP" name="C%C3%B3digo_em_PHP"></a><h3> C&oacute;digo em PHP </h3>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;php&#34&semi;&#62&semi;&#10;&#60&semi;?php&#10;function buildheap(&#38&semi;$vet, $i, $f)&#10;{&#10;$aux = $vet[$i]&semi;&#10;$j = $i * 2 + 1&semi;</p>&#10;<pre>while ($j &#60&semi;= $f)&#10;{&#10;if($j &#60&semi; $f)&#10;{&#10;if($vet[$j] &#60&semi; $vet[$j + 1]) {&#10;$j = $j + 1&semi;&#10;}&#10;}&#10;if($aux &#60&semi; $vet[$j])&#10;{&#10;$vet[$i] = $vet[$j]&semi;&#10;$i = $j&semi;&#10;$j = 2 * $i + 1&semi;&#10;}&#10;else&#10;{&#10;$j = $f + 1&semi;&#10;}&#10;}&#10;$vet[$i] = $aux&semi;</pre>&#10;<p>}</p>&#10;<p>function heapsort(&#38&semi;$vet)&#10;{&#10;for($i=(int)((count($vet) &shy; 1) / 2)&semi; $i &#62&semi;= 0&semi; $i&shy;&shy;)&#10;{&#10;$count = count($vet) &shy; 1&semi;&#10;buildheap($vet, $i, $count)&semi;&#10;}</p>&#10;<pre>for ($i = (count($vet) &shy; 1)&semi; $i &#62&semi;= 1&semi; $i&shy;&shy;)&#10;{&#10;$aux = $vet[0]&semi;&#10;$vet [0] = $vet [$i]&semi;&#10;$vet [$i] = $aux&semi;&#10;buildheap($vet, 0, $i &shy; 1)&semi;&#10;}</pre>&#10;<p>}&#10;?&#62&semi;&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<p> </p>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://c2.com/cgi/wiki?HeapSort" rel="nofollow" title="http://c2.com/cgi/wiki?HeapSort">HeapSort</a></li>&#10;<li>(<a class="externallink" href="http://www.ime.usp.br/~pf/algoritmos/aulas/hpsrt.html)" rel="nofollow" title="http://www.ime.usp.br/~pf/algoritmos/aulas/hpsrt.html)">http://www.ime.usp.br/~pf/algoritmos/aulas/hpsrt.html)</a></li>&#10;<li><a class="externallink" href="http://www.cs.ubc.ca/spider/harrison/Java/sorting&shy;demo.html" rel="nofollow" title="http://www.cs.ubc.ca/spider/harrison/Java/sorting&shy;demo.html">&#39&semi;&#39&semi;Anima&ccedil;&atilde;o do processo de ordena&ccedil;&atilde;o pelo  Heapsort&#39&semi;&#39&semi;</a></li>&#10;<li><a class="externallink" href="http://www.datastructures.info/what&shy;is&shy;heap&shy;sort&shy;and&shy;how&shy;does&shy;it&shy;work&shy;heap&shy;sort&shy;algorithm/" rel="nofollow" title="http://www.datastructures.info/what&shy;is&shy;heap&shy;sort&shy;and&shy;how&shy;does&shy;it&shy;work&shy;heap&shy;sort&shy;algorithm/">Heapsort in C++</a></li>&#10;<li><a class="externallink" href="http://www.algorithm&shy;code.com/wiki/Heapsort" rel="nofollow" title="http://www.algorithm&shy;code.com/wiki/Heapsort">Heapsort code</a></li></ul>&#10;<p> &#10; </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos_de_ordena%C3%A7%C3%A3o" id="w">Categoria:Algoritmos de ordena&ccedil;&atilde;o</a></p>&#10;<p><a href="http://no.wikipedia.org/wiki/Sorteringsalgoritme">no:Sorteringsalgoritme</a></p></body></html>