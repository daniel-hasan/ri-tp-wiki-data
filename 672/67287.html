<html><title>Tese de Church&shy;Turing</title><body>&#10;<p>Na <a href="http://en.wikipedia.org/wiki/Teoria_da_computabilidade" id="w">teoria da computabilidade</a>, a <i>Tese de Church&shy;Turing</i> ou <i>Tese de Church</i>, assim nomeada em refer&ecirc;ncia a <a href="http://en.wikipedia.org/wiki/Alonzo_Church" id="w">Alonzo Church</a> e <a href="http://en.wikipedia.org/wiki/Alan_Turing" id="w">Alan Turing</a>, &eacute; uma hip&oacute;tese sobre a natureza de artefatos mec&acirc;nicos de c&aacute;lculo, como computadores, e sobre que tipo de <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmos</a> eles podem executar.</p>&#10;<p>Geralmente assume&shy;se que um algoritmo deve satisfazer os seguintes requisitos:&#10;</p>&#10;<ol>&#10;<li>O algoritmo consiste de um conjunto finito de instru&ccedil;&otilde;es simples e precisas, que s&atilde;o descritas com um n&uacute;mero finito de s&iacute;mbolos.</li>&#10;<li>O algoritmo sempre produz resultado em um n&uacute;mero finito de passos.</li>&#10;<li>O algoritmo pode, a princ&iacute;pio, ser executado por um ser humano com apenas papel e l&aacute;pis.</li>&#10;<li>A execu&ccedil;&atilde;o do algoritmo n&atilde;o requer intelig&ecirc;ncia do ser humano al&eacute;m do necess&aacute;rio para entender e executar as instru&ccedil;&otilde;es.</li></ol>&#10;<p>Um exemplo de tal m&eacute;todo &eacute; o <a href="http://en.wikipedia.org/wiki/Algoritmo_de_Euclides" id="w">algoritmo de Euclides</a> para a determina&ccedil;&atilde;o do <a href="http://en.wikipedia.org/wiki/M%C3%A1ximo_divisor_comum" id="w">m&aacute;ximo divisor comum</a> de dois <a href="http://en.wikipedia.org/wiki/N%C3%BAmero_natural" id="w">n&uacute;meros naturais</a>.</p>&#10;<p>A no&ccedil;&atilde;o de algoritmo &eacute; intuitivamente clara mas n&atilde;o &eacute; definida formalmente, pois n&atilde;o est&aacute; claro o que quer dizer &#34&semi;instru&ccedil;&otilde;es simples e precisas&#34&semi;, e o que significa &#34&semi;intelig&ecirc;ncia necess&aacute;ria para executar as instru&ccedil;&otilde;es&#34&semi;.</p>&#10;<p>Informalmente a tese enuncia que nossa no&ccedil;&atilde;o de algoritmo pode ser formalizada,sob a forma de fun&ccedil;&otilde;es comput&aacute;veis, e que computadores podem executar esses algoritmos. Al&eacute;m disso, qualquer computador pode, teoricamente, executar qualquer algoritmo, isto &eacute;, o poder computacional te&oacute;rico de cada computador &eacute; o mesmo e n&atilde;o &eacute; poss&iacute;vel construir um artefato de c&aacute;lculo mais poderoso que um computador e que todos os computadores s&atilde;o &#34&semi;iguais&#34&semi;, variando apenas a capacidade de processamento.</p>&#10;<a id="Tese_de_Church&shy;Turing" name="Tese_de_Church&shy;Turing"></a><h2> Tese de Church&shy;Turing </h2>&#10;&#10;<p>A tese, de acordo com as palavras do pr&oacute;prio Turing, pode ser enunciada como:</p>&#10;<dl><dd><i>Toda &#39&semi;fun&ccedil;&atilde;o que seria naturalmente considerada comput&aacute;vel&#39&semi; pode ser computada por uma <a href="http://en.wikipedia.org/wiki/M%C3%A1quina_de_Turing" id="w">M&aacute;quina de Turing</a>.</i></dd></dl>&#10;<p>Devido &agrave; imprecis&atilde;o do conceito de uma &#34&semi;fun&ccedil;&atilde;o que seria naturalmente considerada comput&aacute;vel&#34&semi;, a tese n&atilde;o pode ser formalmente provada, mas pode ser refutada caso seja descoberta uma m&aacute;quina te&oacute;rica mais poderosa que a m&aacute;quina de turing.</p>&#10;<p>Qualquer programa de computador pode ser traduzido em uma m&aacute;quina de Turing, e qualquer m&aacute;quina de Turing pode ser traduzida para uma <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagem de programa&ccedil;&atilde;o</a> de prop&oacute;sito geral&semi; assim, a tese &eacute; equivalente a dizer que qualquer linguagem de programa&ccedil;&atilde;o de prop&oacute;sito geral &eacute; suficiente para expressar qualquer algoritmo.</p>&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2> Hist&oacute;ria </h2>&#10;<p>A tese leva o nome dos matem&aacute;ticos <a href="http://en.wikipedia.org/wiki/Alonzo_Church" id="w">Alonzo Church</a> e <a href="http://en.wikipedia.org/wiki/Alan_Turing" id="w">Alan Turing</a>. Em seu artigo &#34&semi;On Computable Numbers, with an Application to the <a href="http://en.wikipedia.org/wiki/Entscheidungsproblem" id="w">Entscheidungsproblem</a> &#34&semi;, de <a href="http://en.wikipedia.org/wiki/1936" id="w">1936</a>, Alan Turing tentou capturar a no&ccedil;&atilde;o de algoritmo (ent&atilde;o chamado &#34&semi;computabilidade efetiva&#34&semi;), com a introdu&ccedil;&atilde;o de m&aacute;quinas de Turing. No artigo ele mostrou que o &#39&semi;Entscheidungsproblem&#39&semi; n&atilde;o pode ser resolvido. Alguns meses antes Alonzo Church provou um resultado similar em &#34&semi;A Note on the Entscheidungsproblem&#34&semi;, mas ele usou as no&ccedil;&otilde;es de fun&ccedil;&otilde;es recursivas e fun&ccedil;&otilde;es lambda&shy;defin&iacute;veis para descrever formalmente a computabilidade efetiva. Fun&ccedil;&otilde;es lambda&shy;defin&iacute;veis foram introduzidas por Alonzo Church e <a href="http://en.wikipedia.org/wiki/Stephen_Kleene" id="w">Stephen Kleene</a> (Church 1932, 1936a, 1941, Kleene 1935), e fun&ccedil;&otilde;es recursivas por <a href="http://en.wikipedia.org/wiki/Kurt_G%C3%B6del" id="w">Kurt G&ouml;del</a> e <a href="http://en.wikipedia.org/wiki/Jacques_Herbrand" id="w">Jacques Herbrand</a> (G&ouml;del 1934, Herbrand 1932). Estes dois formalismos descrevem o mesmo conjunto de fun&ccedil;&otilde;es, como mostrado no caso de fun&ccedil;&otilde;es de inteiros positivos por Church e Kleene (Church 1936a, Kleene 1936). Ao ouvir a proposta de Church, Turing logo foi capaz de mostrar que suas m&aacute;quinas de Turing descrevem o mesmo conjunto de fun&ccedil;&otilde;es (Turing 1936, 263ff).</p>&#10;<a id="Sucesso_da_tese" name="Sucesso_da_tese"></a><h2> Sucesso da tese </h2>&#10;<p>Desde aquela &eacute;poca muitos outros formalismos foram propostos para descrever a computabilidade efetiva, incluindo <a href="http://en.wikipedia.org/wiki/Recursividade" id="w">fun&ccedil;&otilde;es recursivas</a>, o <a href="http://en.wikipedia.org/wiki/C%C3%A1lculo_lambda" id="w">c&aacute;lculo lambda</a>, <a href="http://en.wikipedia.org/wiki/M%C3%A1quina_de_registros" id="w">m&aacute;quinas de registros</a>, sistemas de Post, l&oacute;gica combinat&oacute;ria e algoritmos de Markov. Foi mostrado que todos esses sistemas computam essencialmente o mesmo conjunto de fun&ccedil;&otilde;es que as m&aacute;quinas de Turing&semi; sistemas como esses s&atilde;o chamados <a href="http://en.wikipedia.org/wiki/Turing_completo" id="w">Turing completos</a>. Como todas as diversas tentativas de formalizar o conceito de algoritmo levaram a resultados equivalentes, geralmente assume&shy;se que a tese de Church&shy;Turing &eacute; correta. No entanto, a tese &eacute; uma defini&ccedil;&atilde;o, e n&atilde;o um <a href="http://en.wikipedia.org/wiki/Teorema" id="w">teorema</a>, e portanto n&atilde;o pode ser provada. Ela poderia, no entanto, ser refutada se algu&eacute;m descobrisse um m&eacute;todo que fosse universalmente aceito como um algoritmo efetivo mas que n&atilde;o pudesse ser executado por uma m&aacute;quina de Turing.</p>&#10;<p>No in&iacute;cio do s&eacute;culo XX, matem&aacute;ticos freq&uuml;entemente usaram o termo informal <i>efetivamente comput&aacute;vel</i>, ent&atilde;o foi importante achar uma boa formaliza&ccedil;&atilde;o do conceito. Matem&aacute;ticos modernos usam, em seu lugar, o termo bem&shy;definido <i>Turing&shy;comput&aacute;vel</i> (ou apenas <i>comput&aacute;vel</i>). J&aacute; que a terminologia indefinida caiu em desuso, a quest&atilde;o de como defin&iacute;&shy;la &eacute; agora menos importante.</p>&#10;<p> </p>&#10;&#10;<a id="Utiliza%C3%A7%C3%A3o_informal_em_provas" name="Utiliza%C3%A7%C3%A3o_informal_em_provas"></a><h2> Utiliza&ccedil;&atilde;o informal em provas </h2>&#10;&#10;<p>Provas na teoria da computabilidade comumente usam a tese de Church&shy;Turing de um jeito informal afim de estabelecer a computabilidade de fun&ccedil;&otilde;es, evitando os detalhes (muitas vezes muito longos) que normalmente seriam mostrados em uma prova mais formal. Para estabelecer que uma fun&ccedil;&atilde;o &eacute; comput&aacute;vel usando uma m&aacute;quina de Turing, normalmente &eacute; considerado suficiente dar uma descri&ccedil;&atilde;o informal de como a fun&ccedil;&atilde;o pode ser efetivamente computada, e ent&atilde;o concluir &#34&semi;De acordo com a tese de Church&shy;Turing&#34&semi; que a fun&ccedil;&atilde;o &eacute; Turing comput&aacute;vel.&#10;Dirk van Dalen (em Gabbay 2001:284<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup>) d&aacute; o seguinte exemplo afim de ilustrar esse uso informal da tese de Church&shy;Turing:&#10;</p><dl><dd>EXEMPLO: Cada conjunto <a href="http://en.wikipedia.org/wiki/Conjuntos_recursivamente_enumer%C3%A1veis" id="w">RE</a> infinito cont&eacute;m um conjunto recursivo infinito.</dd></dl>&#10;<dl><dd><i>Prova</i>: Seja A um RE infinito. N&oacute;s listamos os elementos de A como n<sub>0</sub>, n<sub>1</sub>, n<sub>2</sub>, n<sub>3</sub>, ...</dd></dl><dl><dd>A partir dessa lista, extra&iacute;mos uma sublista crescente: fa&ccedil;a m<sub>0</sub>=n<sub>0</sub>, ap&oacute;s um n&uacute;mero finito de passos acharemos um n<sub>k</sub> tal que n<sub>k</sub> &#62&semi; m<sub>0</sub>, fa&ccedil;a m<sub>1</sub>=n<sub>k</sub>. N&oacute;s repetimos esse processo para achar m<sub>2</sub> &#62&semi; m<sub>1</sub>, etc. Isso produz uma listagem eficaz do subconjunto B={m<sub>0</sub>,m<sub>1</sub>,m<sub>2</sub>,...} de A, com a propriedade m<sub>i</sub> &#60&semi; m<sub>i+1</sub>.</dd></dl><dl><dd><i>Reivindica&ccedil;&atilde;o</i>: B &eacute; decid&iacute;vel. Para testarmos k em B precisamos testar se k=m<sub>i</sub> para algum i. J&aacute; que a sequ&ecirc;ncia de m<sub>i</sub>&#39&semi;s est&aacute; aumentando, n&oacute;s temos que produzir no m&aacute;ximo k+1 elementos da lista e comparar com k. Se nenhum &eacute; igual a k, ent&atilde;o k n&atilde;o est&aacute; em B. J&aacute; que esse teste &eacute; eficiente, B &eacute; decid&iacute;vel e, <b>de acordo com a tese de Church</b>, recursivo.</dd></dl>&#10;<p>A fim de tornar o exemplo acima completamente rigoroso, dever&iacute;amos cuidadosamente construir uma M&aacute;quina de Turing, ou fun&ccedil;&atilde;o&shy;&lambda;, ou cuidadosamente usar axiomas recursivos, ou na melhor das hip&oacute;teses habilmente usar v&aacute;rios teoremas da teoria da computabilidade. Mas j&aacute; que teoristas da computabilidade acreditam que a computabilidade de Turing corretamente captura o que se pode ser computado efetivamente, e porque um procedimento eficaz &eacute; dado em linguagem informal para decidir o conjunto B, te&oacute;ricos da computabilidade aceitam isso como prova que o conjunto &eacute; de fato recursivo.</p>&#10;<p>Como regra geral, a tese de Church&shy;Turing s&oacute; deve ser usada para simplificar provas em casos onde o escritor e o leitor sejam capazes de, facilmente (mas n&atilde;o necessariamente, rapidamente) produzir uma prova rigorosa se a mesma for pedida.</p>&#10;<a id="Varia%C3%A7%C3%B5es" name="Varia%C3%A7%C3%B5es"></a><h2> Varia&ccedil;&otilde;es </h2>&#10;&#10;<p>O Sucesso da tese de Church&shy;Turing acarretou em v&aacute;rias outras teses, baseadas na de Church&shy;Turing mas com algumas varia&ccedil;&otilde;es, a serem propostas. Por exemplo, a <b><i>Physical Church&shy;Turing thesis (PCTT)</i></b> afirma:</p>&#10;<dl><dd><dl><dd>&#34&semi;De acordo com a <b><i>PCTT</i></b>, todas as fun&ccedil;&otilde;es fisicamente comput&aacute;veis, s&atilde;o Turing&shy;comput&aacute;veis&#34&semi;</dd></dl></dd></dl>&#10;<p>A tese de Church&shy;Turing n&atilde;o menciona nada sobre a efici&ecirc;ncia com que um modelo computacional pode simular outro. Foi provado que uma M&aacute;quina de Turing multi&shy;fita s&oacute; sofre uma desacelera&ccedil;&atilde;o logar&iacute;tmica ao simular qualquer M&aacute;quina de Turing. Nenhum resultado como esse foi provado para um arbitr&aacute;rio, mas razo&aacute;vel , modelo computacional. Uma varia&ccedil;&atilde;o da tese de Church&shy;Turing que trata desse problema &eacute; a <b>Feasibility Thesis</b> ou <b>(Classical) Complexity&shy;Theoretic Church&ndash;Turing Thesis</b> (SCTT), as quais n&atilde;o s&atilde;o de Church ou Turing, mas sim foi realizado gradualmente no desenvolvimento da teoria da complexidade. Ele afirma:</p>&#10;<dl><dd><i>&#34&semi;Uma <a href="http://en.wikipedia.org/wiki/Probabilistic_Turing_machine" id="w">M&aacute;quina de Turing probabil&iacute;stica</a> pode eficientemente simular qualquer modelo computacional real&iacute;stico.&#34&semi;</i></dd></dl>&#10;<p>A palavra &#34&semi;eficientemente&#34&semi; significa problemas que s&atilde;o redut&iacute;veis em tempo polinomial. Essa tese foi originalmente chamada <i>&#34&semi;Computational Complexity&shy;Theoretic Church&shy;Turing Thesis&#34&semi;</i> de Ethan bernstein e Umesh Vazirani (1997). A <i>&#34&semi;Computational Complexity&shy;Theoretic Church&shy;Turing Thesis&#34&semi;</i> afirma que todos os modelos computacionais razo&aacute;veis pertecem a mesma classe de problemas que podem ser computados em tempo polinomial. Assumindo a conjectura de que o tempo polinomial probabil&iacute;stico (BPP) &eacute; igual ao tempo polinomial determin&iacute;stico (P), a palavra probabil&iacute;stico &eacute; opcional na <i>Computational Complexity&shy;Theoretic Church&shy;Turing Thesis</i>. Uma tese similar, chamada de <i>Tese Invariante</i>, foi introduzida por Cees F. Slot e Peter van Emde Boas. Ela afirma: <i>&#34&semi;M&aacute;quinas Razo&aacute;veis podem simular uma as outras dentro limitadas polinomialmente em sobrecarga no tempo e como fator constante de sobrecarga no espa&ccedil;o</i>. A tese originalmente foi publicada na STOC&#39&semi;84, foi a primeira tese a mostrar que a sobrecarga de tempo polinomial e sobrecarga constante no espa&ccedil;o poderiam ser realizados simultaneamente para uma simula&ccedil;&atilde;o de uma m&aacute;quina de acesso aleat&oacute;rio em uma M&aacute;quina de Turing.</p>&#10;<p>Se computadores qu&acirc;nticos pudessem ser produzidos em grande escala, os mesmos poderiam invalidar a <i>Computational Complexity&shy;Theoretic Church&shy;Turing Thesis</i>, uma vez que tamb&eacute;m &eacute; suspeitado que tempo quantum polinomial (BQP) &eacute; maior que BPP. Em outras palavras, existem algoritmos qu&acirc;nticos eficientes que realizam tarefas que n&atilde;o possuem algoritmos probabil&iacute;sticos eficientes, por exemplo, fatorar inteiros. Eles, no entanto, n&atilde;o iriam invalidar a tese de Church&shy;Turing original, j&aacute; que um computador qu&acirc;ntico pode sempre ser simulado por uma M&aacute;quina de Turing, mas eles invalidariam a <i>Classical Computational Complexity&shy;Theoretic Church&shy;Turing Thesis</i> por motivos de efici&ecirc;ncia. Consequentemente , a <i>Quantum Complexity&shy;Theoretic Church&shy;Turing Thesis</i> afirma:</p>&#10;<dl><dd><i>&#34&semi;Uma <a href="http://en.wikipedia.org/wiki/Quantum_Turing_machine" id="w">M&aacute;quina de Turing qu&acirc;ntica</a> pode eficientemente simular qualquer modelo computacional real&iacute;stico&semi;&#34&semi;</i></dd></dl>&#10;<p>Eugene Eberbach e Peter Wegner afirmam que a tese de Church&shy;Turing &eacute;, algumas vezes, interpretada de forma demasiadamente ampla, afirmando que &#34&semi;a mais ampla afirma&ccedil;&atilde;o de que algoritmos precisamente capturam o que pode ser computado &eacute; inv&aacute;lido. Eles afirmam que as formas de computa&ccedil;&atilde;o n&atilde;o englobadas na tese s&atilde;o relevantes hoje em dia, termos os quais eles chamam de computa&ccedil;&atilde;o super&shy;Turing.</p>&#10;<a id="Implica%C3%A7%C3%B5es_Filos%C3%B3ficas" name="Implica%C3%A7%C3%B5es_Filos%C3%B3ficas"></a><h2> Implica&ccedil;&otilde;es Filos&oacute;ficas </h2>&#10;&#10;<p>A tese de Church&shy;Turing tem algumas implica&ccedil;&otilde;es profundas para a filosofia da mente, no entanto muitas interpreta&ccedil;&otilde;es filos&oacute;ficas da tese envolvem erros b&aacute;sicos de interpreta&ccedil;&atilde;o da afirma&ccedil;&atilde;o da tese. Jack Copeland afirma que a quest&atilde;o da exist&ecirc;ncia de processos f&iacute;sicos e determin&iacute;sticos &eacute; uma quest&atilde;o emp&iacute;rica aberta, al&eacute;m disso, ele tamb&eacute;m afirma que a quest&atilde;o se qualquer desses processos est&atilde;o envolvidos no funcionamento do c&eacute;rebro humano tamb&eacute;m &eacute; uma quest&atilde;o emp&iacute;rica aberta. Existem tamb&eacute;m v&aacute;rias quest&otilde;es abertas sobre o relacionamento entre a tese de Church&shy;Turing e &agrave; f&iacute;sica, e a possibilidade da <a href="http://en.wikipedia.org/wiki/Hipercomputa%C3%A7%C3%A3o" id="w">Hipercomputa&ccedil;&atilde;o</a>.Quando aplicado a f&iacute;sica, a tese tem poss&iacute;veis significados:</p>&#10;&#10;<ol>&#10;<li>O universo &eacute; equivalente a uma M&aacute;quina de Turing&semi; ent&atilde;o, computar fun&ccedil;&otilde;es n&atilde;o&shy;recursivas &eacute; fisicamente imposs&iacute;vel. Isso foi chamado de a Tese Forte de Chuch&shy;Turing e &eacute; a origem da F&iacute;sica Digital.</li>&#10;<li>O universo n&atilde;o &eacute; equivalente a uma m&aacute;quina de Turing (i.e., as leis da f&iacute;sica s&atilde;o n&atilde;o Turing&shy;comput&aacute;veis), mas eventos f&iacute;sicos incomput&aacute;veis n&atilde;o s&atilde;o aproveit&aacute;veis para a constru&ccedil;&atilde;o de um hipercomputador. Por exemplo, um universo no qual a f&iacute;sica envolve n&uacute;meros reais, em oposi&ccedil;&atilde;o aos reais comput&aacute;veis, pode entrar nesta categoria.</li>&#10;<li>O universo &eacute; um hipercomputador, e &eacute; poss&iacute;vel construir dispositivos f&iacute;sicos para aproveitar essa propriedade e calcular fun&ccedil;&otilde;es n&atilde;o&shy;recursivas. Por exemplo, a quest&atilde;o de se todos os eventos da mec&acirc;nica qu&acirc;ntica s&atilde;o Turing&shy;comput&aacute;vel &eacute; uma quest&atilde;o aberta, embora se saiba que os modelos rigorosos como a M&aacute;quina de Turing Qu&acirc;ntica s&atilde;o deterministicamente equivalentes a M&aacute;quinas de Turing (elas n&atilde;o s&atilde;o necessariamente equivalentes em efici&ecirc;ncia). John Lucas e Roger Penrose sugeriram que a mente humana pode ser um resultado de uma computa&ccedil;&atilde;o n&atilde;o algor&iacute;tmica qu&acirc;ntica&shy;melhorada, apesar de n&atilde;o haver evid&ecirc;ncia cient&iacute;fica para provar essa proposi&ccedil;&atilde;o.</li></ol>&#10;<p>Existem v&aacute;rias outras possibilidades t&eacute;cnicas que ficam fora, ou entre essas tr&ecirc;s citadas acima, mas essas servem para ilustrar a amplitude do conceito.&#10;</p><a id="Fun%C3%A7%C3%B5es_N%C3%A3o&shy;Comput%C3%A1veis" name="Fun%C3%A7%C3%B5es_N%C3%A3o&shy;Comput%C3%A1veis"></a><h2> Fun&ccedil;&otilde;es N&atilde;o&shy;Comput&aacute;veis </h2>&#10;&#10;<p>Pode&shy;se definir formalmente fun&ccedil;&otilde;es que n&atilde;o s&atilde;o comput&aacute;veis. Um exemplo bem conhecido desse tipo de fun&ccedil;&atilde;o &eacute; o <a href="http://en.wikipedia.org/wiki/Algoritmo_do_castor" id="w">Algoritmo do Castor</a>. Esta fun&ccedil;&atilde;o pega uma entrada n e retorna o maior n&uacute;mero de s&iacute;mbolos que uma m&aacute;quina de turing com n estados pode mostrar antes de parar. Achar um limite superior nesta fun&ccedil;&atilde;o &eacute; equivalente a resolver o problema da parada, um problema conhecido por n&atilde;o ter solu&ccedil;&atilde;o pelas m&aacute;quinas de turing. J&aacute; que o Algoritmo do Castor n&atilde;o pode ser computada por m&aacute;quinas de turing, a tese de Church&shy;Turing afirma que esta fun&ccedil;&atilde;o n&atilde;o pode ser efetivamente computada por qualquer m&eacute;todo. Para mais informa&ccedil;&otilde;es veja o artigo sobre o castor ocupado.</p>&#10;<p>Alguns modelos computacionais permitem a computa&ccedil;&atilde;o de (Church&shy;Turing) fun&ccedil;&otilde;es n&atilde;o comput&aacute;veis. S&atilde;o conhecidos como <a href="http://en.wikipedia.org/wiki/Hipercomputa%C3%A7%C3%A3o" id="w">Hipercomputa&ccedil;&atilde;o</a>.&#10;Mark Burgin<sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup> argumenta que algoritmos <a href="http://en.wikipedia.org/wiki/Algoritmo_Super&shy;Recursivo" id="w">super&shy;recursivos</a> como m&aacute;quinas de Turing indutivas refutam a tese de Church&shy;Turing. Seu argumento est&aacute; numa defini&ccedil;&atilde;o mais ampla de algoritmo do que a usual e que fun&ccedil;&otilde;es n&atilde;o&shy;comput&aacute;veis obtidas de algumas m&aacute;quinas de turing indutivas s&atilde;o chamadas comput&aacute;veis. Essa interpreta&ccedil;&atilde;o da tese de Church&shy;Turing difere da interpreta&ccedil;&atilde;o comumente aceite em Teoria da Computa&ccedil;&atilde;o. O argumento que algoritmos super&shy;recursivos s&atilde;o de fato algoritmos no sentido da tese de Church&shy;Turing n&atilde;o teve ampla aceita&ccedil;&atilde;o entre a comunidade de investiga&ccedil;&atilde;o da computa&ccedil;&atilde;o.</p>&#10;<a id="Leitura_adicional" name="Leitura_adicional"></a><h2> Leitura adicional </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Hofstadter%2C_Douglas_R." id="w">Hofstadter, Douglas R.</a>,  <i><a href="http://en.wikipedia.org/wiki/G%C3%B6del%2C_Escher%2C_Bach:_um_entrela%C3%A7amento_de_g%C3%AAnios_brilhantes" id="w">G&ouml;del, Escher, Bach: um entrela&ccedil;amento de g&ecirc;nios brilhantes</a></i>, cap&iacute;tulo 17.</li></ul>&#10;<a id="Refer%C3%AAncias" name="Refer%C3%AAncias"></a><h2> Refer&ecirc;ncias </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Church%2C_A." id="w">Church, A.</a>, 1932, &#34&semi;A set of Postulates for the Foundation of Logic&#34&semi;, <i>Annals of Mathematics</i>, second series, 33, 346&shy;366.</li>&#10;<li>Church, A., 1936, &#34&semi;An Unsolvable Problem of Elementary Number Theory&#34&semi;, <i>American Journal of Mathematics</i>, 58, 345&shy;363.</li>&#10;<li>Church, A., 1936, &#34&semi;A Note on the Entscheidungsproblem&#34&semi;, <i>Journal of Symbolic Logic</i>, 1, 40&shy;41.</li>&#10;<li>Church, A., 1941, <i>The Calculi of Lambda&shy;Conversion</i>, Princeton: Princeton University Press.</li>&#10;<li><a href="http://en.wikipedia.org/wiki/G%C3%B6del%2C_K." id="w">G&ouml;del, K.</a>, 1934, &#34&semi;On Undecidable Propositions of Formal Mathematical Systems&#34&semi;, lecture notes taken by Kleene and Rosser at the Institute for Advanced Study, reprinted in Davis, M. (ed.) 1965, <i>The Undecidable</i>, New York: Raven.</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Herbrand%2C_J." id="w">Herbrand, J.</a>, 1932, &#34&semi;Sur la non&shy;contradiction de l&#39&semi;arithmetique&#34&semi;, <i>Journal fur die reine und angewandte Mathematik</i>, 166, 1&shy;8.</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Kleene%2C_S.C." id="w">Kleene, S.C.</a>, 1935, &#34&semi;A Theory of Positive Integers in Formal Logic&#34&semi;, <i>American Journal of Mathematics</i>, 57, 153&shy;173, 219&shy;244.</li>&#10;<li>Kleene, S.C., 1936, &#34&semi;Lambda&shy;Definability and Recursiveness&#34&semi;, <i>Duke Mathematical Journal</i> 2, 340&shy;353.</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Markov%2C_A.A." id="w">Markov, A.A.</a>, 1960, &#34&semi;The Theory of Algorithms&#34&semi;, <i>American Mathematical Society Translations</i>, series 2, 15, 1&shy;14.</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Turing%2C_A.M." id="w">Turing, A.M.</a>, 1936, &#34&semi;<a class="externallink" href="http://www.abelard.org/turpap2/tp2&shy;ie.asp" rel="nofollow" title="http://www.abelard.org/turpap2/tp2&shy;ie.asp">On Computable Numbers, with an Application to the Entscheidungsproblem</a>&#34&semi;, <i>Proceedings of the London Mathematical Society</i>, Series 2, 42 (1936&shy;37), pp.230&shy;265. </li>&#10;<li>Pour&shy;El, M.B. &#38&semi; Richards, J.I., 1989, <i>Computability in Analysis and Physics</i>, <a href="http://en.wikipedia.org/wiki/Springer_Verlag" id="w">Springer Verlag</a>.</li>&#10;<li><a href="http://en.wikipedia.org/wiki/Willem_Fouch%C3%A9" id="w">Willem Fouch&eacute;</a>, <i>Arithmetical representations of Brownian motion</i>, J. Symbolic Logic 65 (2000) 421&shy;442</li>&#10;<li>E. Bernstein, U. Vazirani, <i>Quantum complexity theory</i>, SIAM Journal on Computing 26(5) (1997) 1411&ndash;1473</li></ul>&#10;<a id="%7B%7BLinks_externos%7D%7D" name="%7B%7BLinks_externos%7D%7D"></a><h2>   </h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://plato.stanford.edu/entries/church&shy;turing/" rel="nofollow" title="http://plato.stanford.edu/entries/church&shy;turing/">Detailed info on the Church&shy;Turing Hypothesis</a> (Stanford Encyclopedia of Philosophy) &shy; em ingl&ecirc;s</li></ul>&#10;<a id="%7B%7BRefer%C3%AAncias%7D%7D" name="%7B%7BRefer%C3%AAncias%7D%7D"></a><h2>   </h2>&#10;&#10;&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Alan_Turing" id="w">Categoria:Alan Turing</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Teoria_da_computa%C3%A7%C3%A3o" id="w">Categoria:Teoria da computa&ccedil;&atilde;o</a></p>&#10;<p><a href="http://lt.wikipedia.org/wiki/Tiuringo_ma%C5%A1ina">lt:Tiuringo ma&scaron;ina</a></p></body></html>