<html><title>RC4</title><body>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:RC4.png%7Cthumb%7C300px" id="w">Esquema de um ciclo do algoritmo RC4.</a>&#10;Em <a href="http://en.wikipedia.org/wiki/Criptografia" id="w">criptografia</a>, <b>RC4</b> (ou <b>ARC4</b>) &eacute; o <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmo</a> sim&eacute;trico de <a href="http://en.wikipedia.org/wiki/Criptografia_de_fluxo" id="w">criptografia de fluxo</a> mais usado no <a href="http://en.wikipedia.org/wiki/Software" id="w">software</a> e utilizado nos <a href="http://en.wikipedia.org/wiki/Protocolo" id="w">protocolos</a> mais conhecidos, como <a href="http://en.wikipedia.org/wiki/SSL" id="w">Secure Socket Layers</a> (SSL) (para proteger o tr&aacute;fego <a href="http://en.wikipedia.org/wiki/Internet" id="w">Internet</a>) e <a href="http://en.wikipedia.org/wiki/WEP" id="w">WEP</a> (para a seguran&ccedil;a de <a href="http://en.wikipedia.org/wiki/Redes_sem_fios" id="w">redes sem fios</a>). <b>RC4</b> n&atilde;o &eacute; considerado um dos melhores sistemas criptogr&aacute;ficos pelos adeptos da criptografia, e em algumas aplica&ccedil;&otilde;es podem converter&shy;se em sistemas muito inseguros. No entanto, alguns sistemas baseados em RC4 s&atilde;o seguros o bastante num contexto pr&aacute;tico.</p>&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2> Hist&oacute;ria </h2>&#10;<p>Em <a href="http://en.wikipedia.org/wiki/1987" id="w">1987</a> <a href="http://en.wikipedia.org/wiki/Ronald_Rivest" id="w">Ronald Rivest</a> desenvolveu o <b>algoritmo RC4</b> para a empresa <a href="http://en.wikipedia.org/wiki/RSA_Data_Security%2C_Inc." id="w">RSA Data Security, Inc.</a>, l&iacute;der mundial em <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmos</a> de criptografia. Foi, durante tempos, um segredo comercial muito bem guardado, muito popular, e utilizado largamente em software, como <a href="http://en.wikipedia.org/wiki/Lotus_Notes" id="w">Lotus Notes</a>, <a href="http://en.wikipedia.org/wiki/Apple_Computer%E2%80%99s_AOCE" id="w">Apple Computer&rsquo;s AOCE</a>, <a href="http://en.wikipedia.org/wiki/Oracle_Secure_SQL" id="w">Oracle Secure SQL</a>, <a href="http://en.wikipedia.org/wiki/Internet_Explorer" id="w">Internet Explorer</a>, <a href="http://en.wikipedia.org/wiki/Netscape_Navigator" id="w">Netscape</a> e <a href="http://en.wikipedia.org/wiki/Adobe_Acrobat" id="w">Adobe Acrobat</a>.</p>&#10;<p>Sete anos depois, surge numa <a href="http://en.wikipedia.org/wiki/Mailing_list" id="w">mailing list</a> dedicada &agrave; <a href="http://en.wikipedia.org/wiki/Criptografia" id="w">criptografia</a> (<a href="http://en.wikipedia.org/wiki/Cypherpunks" id="w">Cypherpunks</a>) c&oacute;digo alegadamente equivalente ao RC4. Utilizadores com c&oacute;pias legais puderam confirmar a compatibilidade. &Eacute; de real&ccedil;ar, no entanto, que esta n&atilde;o &eacute; a implementa&ccedil;&atilde;o comercial, e, como tal, &eacute; habitualmente referida como <b>ARC4</b> (<b>Alleged RC4</b>).</p>&#10;<p>As transforma&ccedil;&otilde;es neste algoritmo s&atilde;o lineares, n&atilde;o s&atilde;o necess&aacute;rios c&aacute;lculos complexos, j&aacute; que o sistema funciona basicamente por permuta&ccedil;&otilde;es e somas de valores inteiros, o que torna este algoritmo muito simples e r&aacute;pido.</p>&#10;<p>De uma forma geral, o algoritmo consiste em utilizar um <i><a href="http://en.wikipedia.org/wiki/Vector" id="w">array</a></i> que a cada utiliza&ccedil;&atilde;o tem os seus valores permutados, e misturados com a chave, o que provoca que seja muito dependente desta. Esta chave, utilizada na inicializa&ccedil;&atilde;o do <i>array</i>, pode ter at&eacute; 256 bytes (2048 bits), embora o algoritmo seja mais eficiente quando &eacute; menor, pois a perturba&ccedil;&atilde;o aleat&oacute;ria induzida no <i>array</i> &eacute; superior.</p>&#10;<a id="Algoritmo" name="Algoritmo"></a><h2> Algoritmo </h2>&#10;<a id="KSA" name="KSA"></a><h3> KSA </h3>&#10;<p>O algoritmo <i>key&shy;scheduling</i> &eacute; usado para inicializar a permuta&ccedil;&atilde;o no array <i>S</i>. <i>K.Length</i> &eacute; definido como o n&uacute;mero de bytes na chave e pode variar entre 1 e 256, tipicamente entre 5 e 16 correspondendo ao tamanho de chave de 40&shy;128 bits.<br/>&#10;Primeiro, o array <i>S</i> &eacute; inicializado de tamanho 256.<br/>&#10;Na primeira repeti&ccedil;&atilde;o:&#10;</p>&#10;<ol>&#10;<li>O array S &eacute; preenchido com os valores de 0 &agrave; 255.</li></ol>&#10;<p>Na segunda repeti&ccedil;&atilde;o:&#10;</p>&#10;<ol>&#10;<li>&Eacute; somado o valor de <i>j</i>, o valor de <i>S</i> apontado por <i>i</i> e o valor de <i>K</i> (chave) apontado por <i>i</i> e armazenado na vari&aacute;vel <i>j</i>.</li>&#10;<li>Troca os valores entre <i>S[i]</i> e <i>S[j]</i>.</li></ol>&#10;<a id="C%23" name="C%23"></a><h4> C# </h4>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;Java&#34&semi;&#62&semi;&#10;byte[] S = new byte[256]&semi;</p>&#10;<p>for (int i = 0&semi; i &#60&semi; 256&semi; i++)&#10;{&#10;S[i] = (byte)i&semi;&#10;}</p>&#10;<p>int j = 0&semi;</p>&#10;<p>for (int i = 0&semi; i &#60&semi; 256&semi; i++)&#10;{&#10;j = (j + S[i] + K[i % K.Length]) % 256&semi;&#10;Troca(ref S[i], ref S[j])&semi;&#10;}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="PRGA" name="PRGA"></a><h3> PRGA </h3>&#10;<p>Para todas repeti&ccedil;&otilde;es necess&aacute;rias, o PRGA modifica o estado e a sa&iacute;da do byte resultante. Em cada repeti&ccedil;&atilde;o:&#10;</p>&#10;<ol>&#10;<li>O PRGA incrementa em 1 a vari&aacute;vel <i>i</i>.</li>&#10;<li>Adiciona o valor de <i>S</i> apontado por <i>i</i> com <i>j</i> e armazena o resultado em <i>j</i>.</li>&#10;<li>Troca os valores entre <i>S[i]</i> e <i>S[j]</i>.</li>&#10;<li>A sa&iacute;da &eacute; ent&atilde;o calculada fazendo&shy;se a opera&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/XOR" id="w">XOR</a> (ver em <a href="http://en.wikipedia.org/wiki/L%C3%B3gica_bin%C3%A1ria" id="w">L&oacute;gica bin&aacute;ria</a>) entre o valor de <i>S</i> apontado por <i>S[i] + S[j]</i> e a mensagem original apontado por <i>k</i>.</li></ol>&#10;<a id="C%23" name="C%23"></a><h4> C# </h4>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;Java&#34&semi;&#62&semi;&#10;int i = 0, j = 0&semi;&#10;// a mensagem original est&aacute; armazenada na vari&aacute;vel &#34&semi;input&#34&semi;.&#10;byte[] result = new byte[input.Length]&semi;</p>&#10;<p>for (int k = 0&semi; k &#60&semi; input.Length&semi; k++)&#10;{&#10;i = (i + 1) % 256&semi;&#10;j = (j + S[i]) % 256&semi;&#10;Swap(ref S[i], ref S[j])&semi;&#10;result[k] = (byte)(S[(S[i] + S[j]) % 256] ^ input[k])&semi;&#10;}&#10;return result&semi;</p>&#10;<p>//O algoritmo usado para trocar os valores das vari&aacute;veis (ver <a href="http://en.wikipedia.org/wiki/Algoritmo_Xor_Swap" id="w">Algoritmo Xor Swap</a>).</p>&#10;<p>static void Swap(ref byte val1, ref byte val2)&#10;{&#10;val1 = (byte)(val1 ^ val2)&semi; // val1 XOR val2&#10;val2 = (byte)(val1 ^ val2)&semi;&#10;val1 = (byte)(val1 ^ val2)&semi;&#10;}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="Exemplo" name="Exemplo"></a><h2> Exemplo </h2>&#10;<p>Considere a mensagem <i>input</i> = &#34&semi;Texto&#34&semi;, convertido em bytes (ver <a href="http://en.wikipedia.org/wiki/Ascii" id="w">Ascii</a>), input = { 84, 101, 120, 116, 111 }.</p>&#10;<p>Adoptemos a chave <i>K</i> = &#34&semi;chave&#34&semi;, que convertido em bytes, K = { 99, 104, 97, 118, 101 }.</p>&#10;<p>Em cada repeti&ccedil;&atilde;o:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table align="center" border="1" cellpadding="20">&#10;<tr>&#10;<td><b>k = 0</b><br/>&#10;<b>i = (i + 1) % 256&semi;</b><br/>&#10;i = 1<br/>&#10;<b>j = (j + S[i]) % 256&semi;</b><br/>&#10;j = (0 + S[1]) % 256<br/>&#10;j = 229<br/>&#10;<b>Swap(ref S[i], ref S[j])&semi;</b><br/>&#10;S[229] = 204<br/>&#10;S[1] = 229<br/>&#10;<b>result[k] = (byte)(S[(S[i] + S[j]) % 256] ^ input[k])&semi;</b><br/>&#10;result[0] = S[(229 + 204) % 256] ^ 84<br/>&#10;result[0] = S[177] ^ 84<br/>&#10;result[0] = 104 ^ 84<br/>&#10;result[0] = 60<br/></td>&#10;<td><b>k = 1</b><br/>&#10;<b>i = (i + 1) % 256&semi;</b><br/>&#10;i = 2<br/>&#10;<b>j = (j + S[i]) % 256&semi;</b><br/>&#10;j = (229 + S[2]) % 256<br/>&#10;j = 20<br/>&#10;<b>Swap(ref S[i], ref S[j])&semi;</b><br/>&#10;S[20] = 68<br/>&#10;S[2] = 47<br/>&#10;<b>result[k] = (byte)(S[(S[i] + S[j]) % 256] ^ input[k])&semi;</b><br/>&#10;result[1] = S[(47 + 68) % 256] ^ 101<br/>&#10;result[1] = S[115] ^ 101<br/>&#10;result[1] = 125 ^ 101<br/>&#10;result[1] = 24<br/></td>&#10;<td><b>k = 2</b><br/>&#10;<b>i = (i + 1) % 256&semi;</b><br/>&#10;i = 3<br/>&#10;<b>j = (j + S[i]) % 256&semi;</b><br/>&#10;j = (20 + S[3]) % 256<br/>&#10;j = 188<br/>&#10;<b>Swap(ref S[i], ref S[j])&semi;</b><br/>&#10;S[188] = 92<br/>&#10;S[3] = 168<br/>&#10;<b>result[k] = (byte)(S[(S[i] + S[j]) % 256] ^ input[k])&semi;</b><br/>&#10;result[2] = S[(168 + 92) % 256] ^ 120<br/>&#10;result[2] = S[4] ^ 120<br/>&#10;result[2] = 17 ^ 120<br/>&#10;result[2] = 105<br/></td></tr></table></div>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table align="center" border="1" cellpadding="20">&#10;<tr>&#10;<td><b>k = 3</b><br/>&#10;<b>i = (i + 1) % 256&semi;</b><br/>&#10;i = 4<br/>&#10;<b>j = (j + S[i]) % 256&semi;</b><br/>&#10;j = (188 + S[4]) % 256<br/>&#10;j = 205<br/>&#10;<b>Swap(ref S[i], ref S[j])&semi;</b><br/>&#10;S[205] = 42<br/>&#10;S[4] = 17<br/>&#10;<b>result[k] = (byte)(S[(S[i] + S[j]) % 256] ^ input[k])&semi;</b><br/>&#10;result[3] = S[(17 + 42) % 256] ^ 116<br/>&#10;result[3] = S[59] ^ 116<br/>&#10;result[3] = 160 ^ 116<br/>&#10;result[3] = 212<br/></td>&#10;<td><b>k = 4</b><br/>&#10;<b>i = (i + 1) % 256&semi;</b><br/>&#10;i = 5<br/>&#10;<b>j = (j + S[i]) % 256&semi;</b><br/>&#10;j = (205 + S[5]) % 256<br/>&#10;j = 70<br/>&#10;<b>Swap(ref S[i], ref S[j])&semi;</b><br/>&#10;S[70] = 153<br/>&#10;S[5] = 121<br/>&#10;<b>result[k] = (byte)(S[(S[i] + S[j]) % 256] ^ input[k])&semi;</b><br/>&#10;result[4] = S[(121 + 153) % 256] ^ 111<br/>&#10;result[4] = S[18] ^ 111<br/>&#10;result[4] = 85 ^ 111<br/>&#10;result[4] = 58<br/></td></tr></table></div>&#10;&#10;<p>Ou seja, o texto cifrado <i>result</i> = { 60, 24, 105, 212, 58 }. Aplicando o mesmo algoritmo em <i>result</i>, com a mesma chave consegue&shy;se recuperar a mensagem original <i>input</i>.</p>&#10;<a id="Implementa%C3%A7%C3%A3o_em_C" name="Implementa%C3%A7%C3%A3o_em_C"></a><h4> Implementa&ccedil;&atilde;o em C </h4>&#10;<p />&#10;<pre>&#10;#include &#60&semi;stdio.h&#62&semi;&#10;#include &#60&semi;stdlib.h&#62&semi;&#10;#include &#60&semi;string.h&#62&semi;&#10;&#10;//==================================================&#10;unsigned char chave[256]&semi;&#10;unsigned char entrada[256]&semi;&#10;unsigned char *resultado&semi;&#10;unsigned char s[256]&semi;&#10;unsigned int i, j, tamanho_chave, tamanho_entrada&semi;&#10;//==================================================&#10;void troca()&#10;{&#10;unsigned char aux&semi;&#10;aux=s[i]&semi;&#10;s[i]=s[j]&semi;&#10;s[j]=aux&semi;&#10;}&#10;&#10;//====================================================&#10;&#10;void ksa ()&#10;{&#10; for (i = 0&semi; i &#60&semi; 256&semi; i++)&#10;{&#10;     s[i]=i&semi;&#10;} &#10;  j=0&semi;&#10; for (i = 0&semi; i &#60&semi; 256&semi; i++)&#10;   {&#10;   j = (j + s[i] + chave[i % tamanho_chave]) % 256&semi;&#10;   troca(s, i, j)&semi;&#10;   }&#10; i=0&semi;&#10; j=0&semi;&#10;}&#10;&#10;//====================================================&#10;&#10;void prga ()&#10;{ &#10;unsigned int aux&semi;&#10;unsigned char result[tamanho_entrada&shy;1]&semi;&#10;for (aux=0&semi; aux &#60&semi; tamanho_entrada&semi; aux++)&#10;  {&#10;   i = (i + 1) % 256&semi;&#10;   j = (j + s[i]) % 256&semi;&#10;   troca(s,i,j)&semi;&#10; result[aux]=(s[(s[i] + s[j]) % 256])^entrada[aux]&semi;&#10;  }&#10;resultado=(unsigned char*)malloc((tamanho_entrada&shy;1)*(sizeof(unsigned char)))&semi;&#10;strcpy(resultado, result)&semi;&#10;}&#10;&#10;//====================================================&#10;&#10;int main ()&#10;{&#10;unsigned char confirma[256]&semi;&#10;int confirm&semi;&#10;printf (&#34&semi;Escreva a Frase a ser Criptografada:&#34&semi;)&semi;&#10;scanf (&#34&semi;%s&#34&semi;, entrada)&semi;&#10;tamanho_entrada=strlen(entrada)&semi;&#10;fflush(stdin)&semi;&#10;printf (&#34&semi;\nChave:&#34&semi;)&semi;&#10;scanf (&#34&semi;%s&#34&semi;, chave)&semi;&#10;tamanho_chave=strlen(chave)&semi;&#10;system(&#34&semi;pause&#34&semi;)&semi;&#10;ksa ()&semi;&#10;prga ()&semi;&#10;printf (&#34&semi;\nResultado Gerado: %s\n&#34&semi;, resultado)&semi;&#10;system(&#34&semi;pause&#34&semi;)&semi;&#10;fflush(stdin)&semi;&#10;printf (&#34&semi;\n\nPara Desfazer, confirme a chave: &#34&semi;)&semi;&#10;TENTA: scanf (&#34&semi;%s&#34&semi;, confirma)&semi;&#10;confirm=strcmp(confirma, chave)&semi; &#10;if (confirm==0)&#10; { &#10; printf (&#34&semi;\nDesfazendo....\n&#34&semi;)&semi;&#10; strcpy(entrada, resultado)&semi;&#10; ksa()&semi;&#10; prga ()&semi;&#10; printf (&#34&semi;\nFrase Original: %s\n&#34&semi;, resultado)&semi;&#10; fflush(stdin)&semi;&#10; system(&#34&semi;pause&#34&semi;)&semi;&#10; }&#10;else&#10;  {&#10;  fflush(stdin)&semi;&#10;  printf (&#34&semi;Chave nao confere, por favor insira a chave correta:\n&#34&semi;)&semi;&#10;  goto TENTA&semi;&#10;  }&#10;return 0&semi;&#10;}&#10;</pre>&#10;&#10;<a id="Falha_de_seguran%C3%A7a" name="Falha_de_seguran%C3%A7a"></a><h2> Falha de seguran&ccedil;a</h2>&#10;&#10;<p>Em 2013, um grupo de pesquisadores em seguran&ccedil;a em Royal Holloway, Universidade de Londres, comunicaram um ataque que pode se efetivar interceptando apenas 2<sup>24</sup> conex&otilde;es.<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup><sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup><sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup>&#10;Embora n&atilde;o seja um ataque pr&aacute;tico para boa parte dos prop&oacute;sitos, este resultado &eacute; suficiente para tornar plaus&iacute;vel que algum &oacute;rg&atilde;o criptol&oacute;gico governamental j&aacute; pode ter ataques melhores que tornem o RC4 inseguro.<sup id="_ref&shy;4" class="reference"><a href="#_note&shy;4" title="">[4]</a></sup>.&#10;Considerando que em 2013 uma grande quantidade de tr&aacute;fego <a href="http://en.wikipedia.org/wiki/TLS" id="w">TLS</a> usa RC4 para evitar ataques recentes em <a href="http://en.wikipedia.org/wiki/Blocos_cifrados" id="w">ciframento em blocos</a> pelo <a href="http://en.wikipedia.org/wiki/Modo_de_opera%C3%A7%C3%A3o_(criptografia)#Modo CBC (Cipher&shy;block chaining)" id="w">modo CBC</a>, caso estes ataques hipot&eacute;ticos existam, a combina&ccedil;&atilde;o de TLS com RC4 torna&shy;se insegura num grande n&uacute;mero de cen&aacute;rios pr&aacute;ticos.</p>&#10;<p> </p>&#10;<a id="Ver_Tamb%C3%A9m" name="Ver_Tamb%C3%A9m"></a><h2> Ver Tamb&eacute;m </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Bullrun_(Programa_de_decriptografia)" id="w">Bullrun (Programa de decriptografia)</a><sup id="_ref&shy;5" class="reference"><a href="#_note&shy;5" title="">[5]</a></sup></li></ul>&#10;<p> </p>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;<p><i>RC4</i>&#10;</p>&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li></ul>&#10;<p><i>RC4 em WEP</i>&#10;</p>&#10;<ul>&#10;<li> </li>&#10;<li> </li></ul>&#10;<p><i>Implementa&ccedil;&otilde;es</i>&#10;</p>&#10;<ul>&#10;<li> </li>&#10;<li>  &shy; Link Quebrado</li>&#10;<li> </li></ul>&#10;<p> </p>&#10;<p> &#10;<a href="http://en.wikipedia.org/wiki/Categoria:Criptografia" id="w">Categoria:Criptografia</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos_de_criptografia" id="w">Categoria:Algoritmos de criptografia</a></p></body></html>