<html><title>RSA</title><body><dl><dd><dl><dd><i>Se procura a empresa, veja <a href="http://en.wikipedia.org/wiki/RSA_Data_Security%2C_Inc." id="w">RSA Data Security, Inc.</a></i></dd></dl></dd></dl>&#10;<p><a href="http://en.wikipedia.org/wiki/File:Adi_Shamir_2009.jpg%7Cthumb%7C150px%7Cright" id="w">[[Adi Shamir]], um dos criadores do RSA</a>&#10;<b>RSA</b> &eacute; um algoritmo de <a href="http://en.wikipedia.org/wiki/Criptografia" id="w">criptografia</a> de dados, que deve o seu nome a tr&ecirc;s professores do <a href="http://en.wikipedia.org/wiki/Instituto_de_Tecnologia_de_Massachusetts" id="w">Instituto de Tecnologia de Massachusetts</a> (MIT), <a href="http://en.wikipedia.org/wiki/Ronald_Rivest" id="w">Ronald &#39&semi;&#39&semi;&#39&semi;R&#39&semi;&#39&semi;&#39&semi;ivest</a>, <a href="http://en.wikipedia.org/wiki/Adi_Shamir" id="w">Adi &#39&semi;&#39&semi;&#39&semi;S&#39&semi;&#39&semi;&#39&semi;hamir</a> e <a href="http://en.wikipedia.org/wiki/Leonard_Adleman" id="w">Leonard &#39&semi;&#39&semi;&#39&semi;A&#39&semi;&#39&semi;&#39&semi;dleman</a>, fundadores da actual empresa <a href="http://en.wikipedia.org/wiki/RSA_Data_Security%2C_Inc." id="w">RSA Data Security, Inc.</a>, que inventaram este algoritmo &mdash; at&eacute; a data (2008) a mais bem sucedida implementa&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Sistemas_de_chaves_assim%C3%A9tricas" id="w">sistemas de chaves assim&eacute;tricas</a>, e fundamenta&shy;se em <a href="http://en.wikipedia.org/wiki/Teoria_dos_n%C3%BAmeros" id="w">teorias cl&aacute;ssicas dos n&uacute;meros</a>. &Eacute; considerado dos mais seguros, j&aacute; que mandou por terra todas as tentativas de quebr&aacute;&shy;lo. Foi tamb&eacute;m o primeiro algoritmo a possibilitar criptografia e assinatura digital, e uma das grandes inova&ccedil;&otilde;es em <a href="http://en.wikipedia.org/wiki/Criptografia_de_chave_p%C3%BAblica" id="w">criptografia de chave p&uacute;blica</a>.</p>&#10;<a id="Funcionamento" name="Funcionamento"></a><h2> Funcionamento </h2>&#10;<p>O RSA envolve um par de <a href="http://en.wikipedia.org/wiki/Chave_(criptografia)" id="w">chaves</a>, uma <a href="http://en.wikipedia.org/wiki/Chave_p%C3%BAblica" id="w">chave p&uacute;blica</a> que pode ser conhecida por todos e uma <a href="http://en.wikipedia.org/wiki/Chave_privada" id="w">chave privada</a> que deve ser mantida em sigilo. Toda mensagem cifrada usando uma chave p&uacute;blica s&oacute; pode ser decifrada usando a respectiva chave privada.&#10;A criptografia RSA atua diretamente na internet, por exemplo, em mensagens de emails, em compras on&shy;line e o que voc&ecirc; imaginar&semi; tudo isso &eacute; codificado e recodificado pela criptografia RSA.</p>&#10;<a id="Gera%C3%A7%C3%A3o_das_chaves" name="Gera%C3%A7%C3%A3o_das_chaves"></a><h3> Gera&ccedil;&atilde;o das chaves </h3>&#10;<p>No RSA as chaves s&atilde;o geradas desta maneira:</p>&#10;&#10;<ol>&#10;<li>Escolha de forma aleat&oacute;ria dois <a href="http://en.wikipedia.org/wiki/N%C3%BAmero_primo" id="w">n&uacute;meros primos</a> grandes <span class="math">p \,</span> e <span class="math">q \,</span>, da ordem de <span class="math">10^{100}</span> no m&iacute;nimo.</li>&#10;<li>Compute <span class="math">n = p q \,</span></li>&#10;<li>Compute a fun&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_totiente_de_Euler" id="w">totiente</a> em <span class="math">n \,</span>: <span class="math">\phi(n) = (p&shy;1)(q&shy;1) \,</span>.</li>&#10;<li>Escolha um inteiro <span class="math">e \,</span> tal que 1 &#60&semi; <span class="math">e\,</span> &#60&semi; <span class="math">\phi(n)\,</span>, de forma que <span class="math">e\,</span> e <span class="math">\phi (n)\,</span> sejam <a href="http://en.wikipedia.org/wiki/Primos_entre_si" id="w">primos entre si</a>.</li>&#10;<li>Compute <span class="math">d \,</span> de forma que <span class="math">d e \equiv1\pmod{\phi(n)}\,</span>, ou seja, <span class="math">d \,</span> seja o inverso multiplicativo de <span class="math">e \,</span> em <span class="math">\pmod{\phi(n)}\,</span>.</li></ol>&#10;<ul>&#10;<li>No passo 1 os n&uacute;meros podem ser testados probabilisticamente para primalidade</li>&#10;<li>No passo 5 &eacute; usado o <a href="http://en.wikipedia.org/wiki/Algoritmo_de_Euclides_estendido" id="w">algoritmo de Euclides estendido</a>, e o conceito de inverso multiplicativo que vem da <a href="http://en.wikipedia.org/wiki/Aritm%C3%A9tica_modular" id="w">aritm&eacute;tica modular</a></li></ul>&#10;<p>Por final temos:</p>&#10;<p>A chave p&uacute;blica: o par de n&uacute;meros <span class="math">n \,</span> e <span class="math">e \,</span><br/>&#10;A chave privada: o par de n&uacute;meros <span class="math">n \,</span> e <span class="math">d \,</span></p>&#10;<a id="Cifragem" name="Cifragem"></a><h3> Cifragem </h3>&#10;<p>Para transformar uma mensagem <span class="math">m \,</span>, onde <span class="math">0 \,</span> <span class="math">&lt&semi; \,</span> <span class="math">m \,</span> <span class="math">&lt&semi; \,</span> <span class="math">n \,</span>, numa mensagem <span class="math">c \,</span> cifrada usando a chave p&uacute;blica do destinat&aacute;rio <span class="math">n \,</span> e <span class="math">e \,</span> basta fazer uma <a href="http://en.wikipedia.org/wiki/Potencia%C3%A7%C3%A3o" id="w">potencia&ccedil;&atilde;o</a> modular:</p>&#10;<dl><dd><span class="math"> c = m^e\mod{n}</span></dd></dl>&#10;<p>A mensagem ent&atilde;o pode ser transmitida em canal inseguro para o receptor. H&aacute; um algoritmo para realizar esta pot&ecirc;ncia rapidamente.</p>&#10;<a id="Decifragem" name="Decifragem"></a><h3> Decifragem </h3>&#10;<p>Para recuperar a mensagem <span class="math">m \,</span> da mensagem cifrada <span class="math">c \,</span> usando a respectiva chave privada do receptor <span class="math">n \,</span> e <span class="math">d \,</span>, basta fazer outra potencia&ccedil;&atilde;o modular:</p>&#10;<dl><dd><span class="math"> m = c^d\mod{n}</span></dd></dl>&#10;<a id="Implementa%C3%A7%C3%A3o" name="Implementa%C3%A7%C3%A3o"></a><h2> Implementa&ccedil;&atilde;o </h2>&#10;<p>Em tra&ccedil;os gerais, s&atilde;o gerados dois pares de n&uacute;meros &ndash; as chaves &ndash; de tal forma que uma mensagem criptografada com o primeiro par possa ser apenas decriptada com o segundo par&semi; mas, o segundo n&uacute;mero n&atilde;o pode ser derivado do primeiro. Esta propriedade assegura que o primeiro n&uacute;mero possa ser divulgado a algu&eacute;m que pretenda enviar uma mensagem criptografada ao detentor do segundo n&uacute;mero, j&aacute; que apenas essa pessoa pode decriptar a mensagem. O primeiro par &eacute; designado como chave p&uacute;blica, e o segundo como chave secreta.</p>&#10;<p>RSA baseia&shy;se no fato de que, embora seja f&aacute;cil encontrar dois <a href="http://en.wikipedia.org/wiki/N%C3%BAmeros_primos" id="w">n&uacute;meros primos</a> de grandes dimens&otilde;es (p.e. 100 d&iacute;gitos), conseguir <a href="http://en.wikipedia.org/wiki/Factoriza%C3%A7%C3%A3o" id="w">factorizar</a> o produto de tais dois n&uacute;meros &eacute; considerado <a href="http://en.wikipedia.org/wiki/Complexidade_computacional" id="w">computacionalmente complexo</a> (em outras palavras, o tempo estimado para o conseguir ronda os milhares de anos). De fato, este <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmo</a> mostra&shy;se computacionalmente inquebr&aacute;vel com n&uacute;meros de tais dimens&otilde;es, e a sua for&ccedil;a &eacute; geralmente quantificada com o n&uacute;mero de bits utilizados para descrever tais n&uacute;meros. Para um n&uacute;mero de 100 d&iacute;gitos s&atilde;o necess&aacute;rios cerca de 350 bits, e as implementa&ccedil;&otilde;es atuais superam os 512 e mesmo os 1024 bits (se divide por 8 para conseguir em bytes).</p>&#10;<p>RSA &eacute; usado comumente para transferir senhas RC4 por ser mais r&aacute;pido. A senha, geralmente, tem apenas 128 bits (16 <a href="http://en.wikipedia.org/wiki/Byte" id="w">bytes</a>) o que facilita o manuseio, j&aacute; que os processadores modernos tem tipos de 16 bytes embora restringido pelo n&uacute;mero de opera&ccedil;&otilde;es. Geralmente o servidor, como por exemplo o servidor HTTPS, gera um par de chaves, uma chave p&uacute;blica e uma chave privada, transmite a chave p&uacute;blica para o cliente, e este gera uma senha RC4 (ou de qualquer outro padr&atilde;o), criptografa com a chave p&uacute;blica do servidor e envia de volta para o servidor. Assim, tanto o receptor quanto o servidor podem usar a senha RC4 de forma segura para criptografar e decriptografar.</p>&#10;<a id="Em_Java" name="Em_Java"></a><h2>Em Java</h2>&#10;<p />&#10;&#10;<a id="Correio_An%C3%B4nimo" name="Correio_An%C3%B4nimo"></a><h2>Correio An&ocirc;nimo</h2>&#10;<p><b>Correio An&ocirc;nimo</b> &eacute; uma t&eacute;cnica utilizada para enviar mensagens anonimamente utilizando <a href="http://en.wikipedia.org/wiki/Criptografia" id="w">criptografia</a> RSA, de forma que seja necess&aacute;rio, v&aacute;rios computadores, usando aplicativos para a estragar o anonimato, para que isto seja poss&iacute;vel. Envio a requisi&ccedil;&atilde;o de chave publica, para v&aacute;rios computadores selecionados aleatoriamente. Criptografo na ordem inversa a que eu vou enviar( usando as chaves publicas que recebi ), ou seja, primeiro com a senha do ultimo que ir&aacute; receber a mensagem, e por ultimo com a senha do primeiro. Envio para o primeiro de forma que ele s&oacute; saiba o segundo destinat&aacute;rio quando descriptografar. Sendo que se todos os destinat&aacute;rios, estiverem sem criptografia, o segundo pode notificar o ultimo, estragando o sigilo. Seguindo est&aacute; sequ&ecirc;ncia, descriptografo e envio para o pr&oacute;ximo. Como ningu&eacute;m sabe a rota, s&oacute; sabem o destinat&aacute;rio atual, e como tamb&eacute;m n&atilde;o sabem o que h&aacute; no pacote, dificilmente, algu&eacute;m poder&aacute; encontrar o remetente. Trabalhar usando RSA permite, que, nem mesmo gravando todas as conex&otilde;es de um determinado computador na rede( inclusive o remetente ), seja poss&iacute;vel ler os pacotes transmitidos.</p>&#10;<a id="Assinatura_digital" name="Assinatura_digital"></a><h2> Assinatura digital </h2>&#10;<p> &#10;O algoritmo RSA &eacute; extens&iacute;vel a este contexto, pelas suas propriedades. Para implementar um sistema de assinaturas digitais com RSA, o utilizador que possua uma chave privada <i>d</i> poder&aacute; assinar uma dada mensagem (em blocos) <i>m</i> com a seguinte express&atilde;o:</p>&#10;<p><span class="math"> s = m^d \mod{n}</span></p>&#10;<p>Como se pode deduzir, &eacute; dif&iacute;cil descobrir <i>s</i> sem o conhecimento de <i>d</i>. Portanto, uma assinatura digital definida conforme esta equa&ccedil;&atilde;o &eacute; dif&iacute;cil de forjar. Mas o emissor de <i>m</i> n&atilde;o pode negar t&ecirc;&shy;la emitido, j&aacute; que mais ningu&eacute;m poderia ter criado tal assinatura. O receptor recupera a mensagem utilizando a chave p&uacute;blica <i>e</i> do emissor:</p>&#10;<p><span class="math"> s^e = (m^d)^e \mod{n} = m \mod{n}</span></p>&#10;<p>Como tal, o receptor consegue validar a assinatura do emissor calculando <i>s<sup>e</sup> mod n</i>. Podemos verificar ent&atilde;o que o algoritmo RSA satisfaz os tr&ecirc;s requisitos necess&aacute;rios de uma assinatura digital.</p>&#10;<p>&Eacute; f&aacute;cil deduzir que a assinatura varia dependentemente da mensagem em si, e que operando sobre mensagens longas o tamanho da assinatura seria proporcional. Para colmatar esta situa&ccedil;&atilde;o, faz&shy;se operar o algoritmo sobre um resumo (<i>digest</i>) da mensagem, que identifique essa mensagem como &uacute;nica &ndash; geralmente o <i>digest</i> de uma mensagem varia alterando um &uacute;nico byte &ndash;, o que mant&eacute;m, como consequ&ecirc;ncia, que uma assinatura varia de mensagem para mensagem, para um mesmo emissor. Exemplo de fun&ccedil;&atilde;o geradora do <i>digest</i> &eacute; o Secure Hash (<a href="http://en.wikipedia.org/wiki/SHA&shy;1" id="w">SHA&shy;1</a>).</p>&#10;<a id="Vulnerabilidades_do_RSA" name="Vulnerabilidades_do_RSA"></a><h2> Vulnerabilidades do RSA </h2>&#10;<p>Por ser um sistema de criptografia muito utilizado, o RSA vem tendo suas vulnerabilidades pesquisadas e analisadas praticamente desde sua publica&ccedil;&atilde;o inicial. Uma lista bem detalhada de ataques ao sistema pode ser encontrada no artigo de Dan Boneh<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup>. Segue um resumo de alguns tipos de ataque discutidos no artigo.</p>&#10;<a id="Fatorando_n%C3%BAmeros_inteiros_muito_grandes" name="Fatorando_n%C3%BAmeros_inteiros_muito_grandes"></a><h3> Fatorando n&uacute;meros inteiros muito grandes </h3>&#10;<p>Uma primeira abordagem de ataque ao RSA teria como objetivo a chave p&uacute;blica por meio da fatora&ccedil;&atilde;o do m&oacute;dulo <span class="math">n \,</span>, ou seja, dada uma fatora&ccedil;&atilde;o de <span class="math">n \,</span>, pode&shy;se chegar ao expoente de decriptografia. Este &eacute; um exemplo de ataque de for&ccedil;a bruta ao RSA.</p>&#10;<p>Apesar da melhora constante dos algoritmos de fatora&ccedil;&atilde;o de n&uacute;meros inteiros, esta ainda &eacute; uma amea&ccedil;a considerada distante da realidade, caso o sistema RSA seja corretamente implementado, devido &agrave; dificuldade para a fatora&ccedil;&atilde;o de n&uacute;meros inteiros com a tecnologia atual.</p>&#10;<p>A t&iacute;tulo de ilustra&ccedil;&atilde;o Christof Paar<sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup> apresenta a discuss&atilde;o sobre o m&oacute;dulo de 129 d&iacute;gitos publicada em um artigo da revista <i>Scientific American</i> por Martin Gardner em 1997. Fazendo uso dos m&eacute;todos de fatora&ccedil;&atilde;o dispon&iacute;veis e poder computacional da &eacute;poca foi estimado que seriam necess&aacute;rios 40 trilh&otilde;es de anos para fatorar um n&uacute;mero desta magnitude por&eacute;m a tarefa levou apenas 30 anos para ser realizada.</p>&#10;<p>A discuss&atilde;o ent&atilde;o recai em qual &eacute; o tamanho seguro para o m&oacute;dulo usado no RSA? Ainda de acordo com Christof Paar muitas aplica&ccedil;&otilde;es utilizam m&oacute;dulos de 1024 bits por&eacute;m hoje em dia acredita&shy;se que ser&aacute; poss&iacute;vel fatorar n&uacute;meros desta magnitude em 10&shy;15 anos e a ag&ecirc;ncias de intelig&ecirc;ncia podem ser capazes de faz&ecirc;&shy;lo ainda mais r&aacute;pido, j&aacute; que tipicamente empregam as maiores autoridades em criptografia do mundo. Portanto, j&aacute; &eacute; aconselhado utilizar par&acirc;metros de RSA da ordem de 2048&shy;4096 bits para uma seguran&ccedil;a mais duradoura.</p>&#10;<a id="M%C3%B3dulo_comum" name="M%C3%B3dulo_comum"></a><h3> M&oacute;dulo comum </h3>&#10;<p>Para evitar a gera&ccedil;&atilde;o de m&oacute;dulos <span class="math">n \,</span> diferentes poderia ser considerado o uso do mesmo m&oacute;dulo <span class="math">n \,</span> para todos os usu&aacute;rios emitido, por exemplo, por uma autoridade central confi&aacute;vel. Apesar de parecer eficiente em uma primeira an&aacute;lise, um usu&aacute;rio poderia usar seus pr&oacute;prios expoentes para fatorar o m&oacute;dulo <span class="math">n \,</span> de outros usu&aacute;rios. Devido a este fato, um m&oacute;dulo RSA nunca deve ser utilizado por mais de uma entidade.</p>&#10;<p>Este &eacute; considerado um ataque elementar pois ilustra o uso err&ocirc;neo do sistema RSA.</p>&#10;<a id="Pequeno_expoente_da_chave_privada" name="Pequeno_expoente_da_chave_privada"></a><h3> Pequeno expoente da chave privada </h3>&#10;<p>Para reduzir o tempo necess&aacute;rio para decriptar uma mensagem ou o tempo necess&aacute;rio para gerar uma assinatura pode&shy;se tentar usar um valor de <span class="math">d \,</span> pequeno no lugar de um <span class="math">d \,</span> aleat&oacute;rio. Usando um <span class="math">d \,</span> pequeno pode&shy;se alcan&ccedil;ar uma melhora no desempenho em torno de fatores de 10 para um m&oacute;dulo de 1024 bits por&eacute;m Michael Wiener<sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup> mostra que a escolha de um <span class="math">d \,</span> pequeno pode quebrar completamente o sistema RSA.</p>&#10;<a id="Pequeno_expoente_da_chave_p%C3%BAblica" name="Pequeno_expoente_da_chave_p%C3%BAblica"></a><h3> Pequeno expoente da chave p&uacute;blica </h3>&#10;<p>Pelos mesmos motivos do item anterior, &eacute; comum utilizar um expoente p&uacute;blico <span class="math">e \,</span> pequeno. O menor <span class="math">e \,</span> poss&iacute;vel &eacute; tr&ecirc;s por&eacute;m para o sistema ficar protegido de alguns tipos de ataque sugere&shy;se o valor <span class="math">e=2^{16}+1=65537 \,</span> e a especifica&ccedil;&atilde;o do sistema RSA menciona a gera&ccedil;&atilde;o aleat&oacute;ria de <span class="math">e \,</span> para tornar o sistema ainda mais seguro.</p>&#10;<p>Ataques desta natureza, ao contr&aacute;rio dos baseados no m&eacute;todo anterior, n&atilde;o levam a uma quebra total do sistema RSA, sendo portanto menos perigosos.</p>&#10;<p>Os ataques mais poderosos relacionados ao pequeno expoente da chave p&uacute;blica utilizam resultados baseados no <i>Teorema de Coppersmith</i><sup id="_ref&shy;4" class="reference"><a href="#_note&shy;4" title="">[4]</a></sup>.</p>&#10;<a id="Exposi%C3%A7%C3%A3o_parcial_da_chave_privada" name="Exposi%C3%A7%C3%A3o_parcial_da_chave_privada"></a><h3> Exposi&ccedil;&atilde;o parcial da chave privada </h3>&#10;<p>Imaginemos que um usu&aacute;rio teve acesso a uma fra&ccedil;&atilde;o da chave privada, de tamanho <span class="math">d \,</span> bits. Seria este usu&aacute;rio capaz de reproduzir o restante da chave <span class="math">d \,</span> a partir desta fra&ccedil;&atilde;o? Surpreendentemente a resposta &eacute; positiva caso a chave <span class="math">d \,</span> seja pequena o suficiente.</p>&#10;<p>Um artigo de 1998<sup id="_ref&shy;5" class="reference"><a href="#_note&shy;5" title="">[5]</a></sup> mostra que sendo <span class="math">e&lt&semi;\sqrt{n} \,</span> &eacute; poss&iacute;vel reconstruir toda a chave a partir de uma fra&ccedil;&atilde;o da mesma. Este resultado mostra a import&acirc;ncia de proteger a chave privada RSA de forma eficiente e completa.</p>&#10;<a id="Ataques_temporais" name="Ataques_temporais"></a><h3> Ataques temporais </h3>&#10;<p>Alguns ataques n&atilde;o s&atilde;o decorrentes de falhas ou artif&iacute;cios matem&aacute;ticos. Estes ataques s&atilde;o chamados de <i>ataques de implementa&ccedil;&atilde;o</i> e buscam vulnerabilidades na implementa&ccedil;&atilde;o computacional do sistema RSA, segue um exemplo de ataques desta natureza.</p>&#10;<p>Imaginemos que a chave privada do RSA est&aacute; resguardada pelo armazenamento em um <i>smartcard</i> devidamente protegido. Um potencial ataque n&atilde;o consegue examinar o conte&uacute;do do cart&atilde;o e portanto n&atilde;o chega a expor a chave. Por&eacute;m, um artigo de 1996<sup id="_ref&shy;6" class="reference"><a href="#_note&shy;6" title="">[6]</a></sup> mostra que por meio de uma medi&ccedil;&atilde;o precisa do tempo que o <i>smartcard</i> demora para executar uma decripta&ccedil;&atilde;o ou assinatura do RSA &eacute; poss&iacute;vel descobrir o expoente <span class="math">d \,</span> da chave privada e desta forma deixar exposto todo o sistema.</p>&#10;<p> </p>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2>Ver tamb&eacute;m</h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Assinatura_digital" id="w">Assinatura digital</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Complexidade_computacional" id="w">Complexidade computacional</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Criptografia_Qu%C3%A2ntica" id="w">Criptografia Qu&acirc;ntica</a></li></ul>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2>Liga&ccedil;&otilde;es externas</h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://www.rsasecurity.com/rsalabs/node.asp?id=2125" rel="nofollow" title="http://www.rsasecurity.com/rsalabs/node.asp?id=2125">PKCS #1: RSA Cryptography Standard</a> (<a href="http://en.wikipedia.org/wiki/RSA_Laboratories" id="w">RSA Laboratories</a> website)&#10;<ul>&#10;<li>O <a href="http://en.wikipedia.org/wiki/Standard" id="w">standard</a> <i><a href="http://en.wikipedia.org/wiki/PKCS" id="w">PKCS</a> #1</i> <i>&#34&semi;tece algumas recomenda&ccedil;&otilde;es para a implementa&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Criptografia_de_chave_p%C3%BAblica" id="w">criptografia de chave p&uacute;blica</a>, abrangendo os seguintes temas: primitivas criptogr&aacute;ficas&semi; m&eacute;todos de criptografia&semi;&#34&semi;.</i></li></ul></li>&#10;<li><a class="externallink" href="http://theory.lcs.mit.edu/~rivest/rsapaper.pdf" rel="nofollow" title="http://theory.lcs.mit.edu/~rivest/rsapaper.pdf">A Method for Obtaining Digital Signatures and Public&shy;Key Cryptosystems</a>, R. Rivest, A. Shamir, L. Adleman, Communications of the ACM, Vol. 21 (2), 1978, pages 120&mdash;126. Publicado pelo <a href="http://en.wikipedia.org/wiki/Instituto_MIT" id="w">Instituto MIT</a> como um &#34&semi;Memorando T&eacute;cnico&#34&semi; em Abril de 1977.&#10;<ul>&#10;<li>Publica&ccedil;&atilde;o inicial do esquema <i>RSA</i>.</li></ul></li>&#10;<li><a class="externallink" href="http://alexm.unetvale.com.br/blog/2009/07/criptografia&shy;rsa&shy;em&shy;simples&shy;passos/" rel="nofollow" title="http://alexm.unetvale.com.br/blog/2009/07/criptografia&shy;rsa&shy;em&shy;simples&shy;passos/">http://alexm.unetvale.com.br/blog/2009/07/criptografia&shy;rsa&shy;em&shy;simples&shy;passos/</a> RSA em scripts PHP.</li>&#10;<li><a class="externallink" href="http://www.java2s.com/Tutorial/Java/0490__Security/BasicRSAexample.htm" rel="nofollow" title="http://www.java2s.com/Tutorial/Java/0490__Security/BasicRSAexample.htm">http://www.java2s.com/Tutorial/Java/0490__Security/BasicRSAexample.htm</a> RSA em Java tutorial em ingl&ecirc;s</li></ul>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos_de_criptografia" id="w">Categoria:Algoritmos de criptografia</a></p></body></html>