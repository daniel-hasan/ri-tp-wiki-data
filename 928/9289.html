<html><title>Banco de dados relacional</title><body>&#10;<p>Um <b>banco de dados relacional</b> &eacute; um <a href="http://en.wikipedia.org/wiki/Banco_de_dados" id="w">banco de dados</a> que modela os <a href="http://en.wikipedia.org/wiki/Dados" id="w">dados</a> de uma forma que eles sejam percebidos pelo usu&aacute;rio como <a href="http://en.wikipedia.org/wiki/Tabela" id="w">tabelas</a>, ou mais formalmente <a href="http://en.wikipedia.org/wiki/Rela%C3%A7%C3%A3o_(matem%C3%A1tica)" id="w">rela&ccedil;&otilde;es</a>.</p>&#10;<p>O termo &eacute; aplicado aos pr&oacute;prios dados, quando organizados dessa forma, ou a um <b>Sistema Gerenciador de Banco de Dados Relacional (SGBDR)</b>  &ndash; do <a href="http://en.wikipedia.org/wiki/L%C3%ADngua_inglesa" id="w">ingl&ecirc;s</a> <b>Relational database management system (RDBMS)</b> &ndash; um programa de computador que implementa a abstra&ccedil;&atilde;o. </p>&#10;<a id="Hist%C3%B3rico" name="Hist%C3%B3rico"></a><h2> Hist&oacute;rico </h2>&#10;&#10;<p>Os <b>Bancos de dados relacionais</b> (BDR) surgiram em meados da <a href="http://en.wikipedia.org/wiki/D%C3%A9cada_de_1970" id="w">d&eacute;cada de 1970</a>. Por&eacute;m, apenas alguns anos mais tarde as empresas passaram a utiliz&aacute;&shy;los no lugar de arquivos simples (do ingl&ecirc;s <i>flat file</i>), <a href="http://en.wikipedia.org/wiki/Banco_de_dados_hier%C3%A1rquico" id="w">bancos de dados hier&aacute;rquicos</a> e <a href="http://en.wikipedia.org/wiki/Base_de_dados_em_rede" id="w">em rede</a>.</p>&#10;<a id="As_13_regras" name="As_13_regras"></a><h3> As 13 regras </h3>&#10;<p>Em <a href="http://en.wikipedia.org/wiki/1985" id="w">1985</a>, Edgar Frank Codd, criador do <a href="http://en.wikipedia.org/wiki/Modelo_relacional" id="w">modelo relacional</a>, publicou um artigo onde definia 13 regras para que um <a href="http://en.wikipedia.org/wiki/SGBD" id="w">Sistema Gerenciador de Banco de Dados</a> (SGBD) fosse considerado relacional:</p>&#10;&#10;<ol>&#10;<li>Regra Fundamental:&#10;<ul>&#10;<li>Um SGBD relacional deve gerir os seus dados usando apenas suas capacidades relacionais</li></ul></li>&#10;<li>Regra da informa&ccedil;&atilde;o:&#10;<ul>&#10;<li>Toda informa&ccedil;&atilde;o deve ser representada de uma &uacute;nica forma, como dados em uma tabela</li></ul></li>&#10;<li>Regra da garantia de acesso:&#10;<ul>&#10;<li>Todo o dado (valor at&oacute;mico) pode ser acedido logicamente (e unicamente) usando o nome da tabela, o valor da <a href="http://en.wikipedia.org/wiki/Chave_prim%C3%A1ria" id="w">chave prim&aacute;ria</a> da linha e o nome da coluna.</li></ul></li>&#10;<li>Tratamento sistem&aacute;tico de valores nulos:&#10;<ul>&#10;<li>Os valores nulos (diferente do zero, da string vazia, da string de caracteres em brancos e outros valores n&atilde;o nulos) existem para representar dados n&atilde;o existentes de forma sistem&aacute;tica e independente do tipo de dado.</li></ul></li>&#10;<li>Cat&aacute;logo din&acirc;mico on&shy;line baseado no modelo relacional:&#10;<ul>&#10;<li>A descri&ccedil;&atilde;o do banco de dados &eacute; representada no n&iacute;vel l&oacute;gico como dados ordin&aacute;rios (isto &eacute;, em tabelas), permitindo que usu&aacute;rios autorizados apliquem as mesmas formas de manipular dados aplicada aos dados comuns ao consult&aacute;&shy;las.</li></ul></li>&#10;<li>Regra da sub&shy;linguagem abrangente:&#10;<ul>&#10;<li>Um sistema relacional pode suportar v&aacute;rias linguagens e formas de uso, por&eacute;m deve possuir ao menos uma linguagem com sintaxe bem definida e expressa por cadeia de caracteres e com habilidade de apoiar a defini&ccedil;&atilde;o de dados, a defini&ccedil;&atilde;o de vis&otilde;es, a manipula&ccedil;&atilde;o de dados, as restri&ccedil;&otilde;es de integridade, a autoriza&ccedil;&atilde;o e a fronteira de transa&ccedil;&otilde;es.</li></ul></li>&#10;<li>Regra da atualiza&ccedil;&atilde;o de vis&otilde;es:&#10;<ul>&#10;<li>Toda vis&atilde;o que for teoricamente atualiz&aacute;vel ser&aacute; tamb&eacute;m atualiz&aacute;vel pelo sistema.</li></ul></li>&#10;<li>Inser&ccedil;&atilde;o, atualiza&ccedil;&atilde;o e elimina&ccedil;&atilde;o de alto n&iacute;vel:&#10;<ul>&#10;<li>Qualquer conjunto de dados que pode ser manipulado com um &uacute;nico comando para retornar informa&ccedil;&otilde;es, tamb&eacute;m deve ser manipulado com um &uacute;nico comando para opera&ccedil;&otilde;es de inser&ccedil;&atilde;o, atualiza&ccedil;&atilde;o e exclus&atilde;o. Simplificando, significa dizer que as opera&ccedil;&otilde;es de manipula&ccedil;&atilde;o de dados devem poder ser aplicadas a v&aacute;rias linhas de uma vez, ao inv&eacute;s de apenas uma por vez.</li></ul></li>&#10;<li>Independ&ecirc;ncia dos dados f&iacute;sicos:&#10;<ul>&#10;<li>Programas de aplica&ccedil;&atilde;o ou atividades de terminal permanecem logicamente inalteradas quaisquer que sejam as modifica&ccedil;&otilde;es na representa&ccedil;&atilde;o de armazenagem ou m&eacute;todos de acesso internos.</li></ul></li>&#10;<li>Independ&ecirc;ncia l&oacute;gica de dados&#10;<ul>&#10;<li>Programas de aplica&ccedil;&atilde;o ou atividades de terminal permanecem logicamente inalteradas quaisquer que sejam as mudan&ccedil;as de informa&ccedil;&atilde;o que permitam teoricamente a n&atilde;o altera&ccedil;&atilde;o das tabelas base.</li></ul></li>&#10;<li>Independ&ecirc;ncia de integridade:&#10;<ul>&#10;<li>As rela&ccedil;&otilde;es de integridade espec&iacute;ficas de um banco de dados relacional devem ser definidas em uma sub&shy;linguagem de dados e armazenadas no cat&aacute;logo (e n&atilde;o em programas).</li></ul></li>&#10;<li>Independ&ecirc;ncia de distribui&ccedil;&atilde;o:&#10;<ul>&#10;<li>A linguagem de manipula&ccedil;&atilde;o de dados deve possibilitar que as aplica&ccedil;&otilde;es permane&ccedil;am inalteradas estejam os dados centralizados ou distribu&iacute;dos fisicamente.</li></ul></li>&#10;<li>Regra da N&atilde;o&shy;subvers&atilde;o:&#10;<ul>&#10;<li>Se o sistema relacional possui uma linguagem de baixo n&iacute;vel (um registro por vez), n&atilde;o deve ser poss&iacute;vel subverter ou ignorar as regras de integridade e restri&ccedil;&otilde;es definidas no alto n&iacute;vel (muitos registros por vez).</li></ul></li></ol>&#10;<a id="Por_que_usar_um_Banco_de_Dados_Relacional%3F" name="Por_que_usar_um_Banco_de_Dados_Relacional%3F"></a><h2> Por que usar um Banco de Dados Relacional? </h2>&#10;&#10;<p>Os Bancos de Dados Relacionais foram desenvolvidos para prover acesso facilitado aos dados, possibilitando que os usu&aacute;rios utilizassem  uma grande variedade de abordagens no tratamento das informa&ccedil;&otilde;es. Pois, enquanto em um banco de dados hier&aacute;rquico os usu&aacute;rios precisam definir as quest&otilde;es de neg&oacute;cios de maneira espec&iacute;fica, iniciando pela raiz do mesmo, nos Bancos de Dados Relacionais os usu&aacute;rios podem fazer perguntas relacionadas aos neg&oacute;cios atrav&eacute;s de v&aacute;rios pontos.&#10;A linguagem padr&atilde;o dos Bancos de Dados Relacionais &eacute; a <a href="http://en.wikipedia.org/wiki/SQL" id="w">Structured Query Language</a>, ou simplesmente <b>SQL</b>, como &eacute; mais conhecida.</p>&#10;<a id="O_Modelo_Relacional" name="O_Modelo_Relacional"></a><h2> O Modelo Relacional </h2>&#10;&#10;<p>Um Banco de Dados Relacional segue o <a href="http://en.wikipedia.org/wiki/Modelo_Relacional" id="w">Modelo Relacional</a>.</p>&#10;<p>A arquitetura de um banco de dados relacional pode ser descrita de maneira informal ou formal. Na descri&ccedil;&atilde;o informal estamos preocupados com aspectos pr&aacute;ticos da utiliza&ccedil;&atilde;o e usamos os termos tabela, linha e coluna. Na descri&ccedil;&atilde;o formal estamos preocupados com a sem&acirc;ntica formal do modelo e usamos termos como rela&ccedil;&atilde;o (tabela), tupla(linhas) e atributo(coluna).</p>&#10;<a id="Tabelas_(ou_rela%C3%A7%C3%B5es%2C_ou_entidades)" name="Tabelas_(ou_rela%C3%A7%C3%B5es%2C_ou_entidades)"></a><h3> Tabelas (ou rela&ccedil;&otilde;es, ou entidades) </h3>&#10;<p>Todos os dados de um banco de dados relacional (BDR) s&atilde;o armazenados em tabelas. Uma tabela &eacute; uma simples estrutura de linhas e colunas. Em uma tabela, cada linha cont&eacute;m um mesmo conjunto de colunas. Em um banco de dados podem existir uma ou centenas de tabelas, sendo que o limite pode ser imposto tanto pela ferramenta de software utilizada, quanto pelos recursos de <a href="http://en.wikipedia.org/wiki/Hardware" id="w">hardware</a> dispon&iacute;veis no equipamento.</p>&#10;<p>As tabelas associam&shy;se entre si atrav&eacute;s de regras de relacionamentos, estas regras consistem em associar um ou v&aacute;rios atributos de uma tabela com um ou v&aacute;rios atributos de outra tabela.</p>&#10;&#10;<ul>&#10;<li>Exemplo: A tabela <i>funcion&aacute;rio</i> relaciona&shy;se com a tabela <i>cargo</i>. Atrav&eacute;s deste relacionamento esta &uacute;ltima tabela fornece a lista de cargos para a tabela <i>funcion&aacute;rio</i>.</li></ul>&#10;<p>Modelo te&oacute;rico usado para representar conceitualmente um BD, Idealizado por Codd (1970). Baseado numa estrutura de dados simples chamada rela&ccedil;&atilde;o. &Eacute; o modelo mais amplamente usado, principalmente em aplica&ccedil;&otilde;es convencionais de BD.</p>&#10;<a id="Registros_(ou_tuplas)" name="Registros_(ou_tuplas)"></a><h3> Registros (ou tuplas) </h3>&#10;<p>Cada linha formada por uma lista ordenada de colunas representa um <b>registro</b>, ou <b>tupla</b>. Os registros n&atilde;o precisam conter informa&ccedil;&otilde;es em todas as colunas, podendo assumir valores nulos quando assim se fizer necess&aacute;rio.</p>&#10;<p>Resumidamente, um registro &eacute; uma <a href="http://en.wikipedia.org/wiki/Inst%C3%A2ncia" id="w">inst&acirc;ncia</a> de uma tabela, ou entidade.&#10;O start da modelagem se d&aacute; a partir das ENTIDADES. Uma entidade &eacute; uma representa&ccedil;&atilde;o de um conjunto de informa&ccedil;&otilde;es sobre determinado conceito do sistema. Toda entidade possui ATRIBUTOS, que s&atilde;o as informa&ccedil;&otilde;es que referenciam a entidade.&#10;Para exemplificar no sistema de controle de Biblioteca, partimos do conceito principal que &eacute; o empr&eacute;stimo de obras por usu&aacute;rios da biblioteca. A partir deste conceito inicial, vamos ramificando e descobrindo novos conceitos. Podemos iniciar nosso racioc&iacute;nio da seguinte forma:</p>&#10;<p>&#34&semi;Uma biblioteca possui Obras liter&aacute;rias que podem ser tomadas em empr&eacute;stimos pelos usu&aacute;rios credenciados.&#34&semi;</p>&#10;<p>Podemos rapidamente enxergar um cadastro de livros, um cadastro de usu&aacute;rios e um registro de empr&eacute;stimos, certo? &Eacute; essa vis&atilde;o que temos que ter ao modelarmos um banco, isto &eacute;, devemos detectar as informa&ccedil;&otilde;es que devemos armazenar.</p>&#10;<p>Para identificar se aquele conceito pode ser uma entidade voc&ecirc; deve apenas se perguntar: &#34&semi;Eu desejo armazenar quais informa&ccedil;&otilde;es sobre este conceito ?&#34&semi; Se houver informa&ccedil;&otilde;es a serem armazenadas, voc&ecirc; tem uma ENTIDADE. Exemplificando: Eu desejo armazenar os seguintes dados do livro: T&iacute;tulo, Autor, Editora, Ano, Edi&ccedil;&atilde;o e Volume. Temos ent&atilde;o a entidade Livro.</p>&#10;&#10;<ul>&#10;<li>Exemplo: O empregado <i>Pedro</i> &eacute; uma inst&acirc;ncia (registro) da tabela <i>funcion&aacute;rio</i>, e a fun&ccedil;&atilde;o <i>Analista Comercial</i> &eacute; a inst&acirc;ncia (registro) da tabela <i>cargo</i>. Uma associa&ccedil;&atilde;o entre estas duas tabelas criaria a seguinte inst&acirc;ncia de relacionamento: <i>Pedro <b>&eacute;</b> Analista Comercial</i>, onde o verbo <b>ser</b> representa uma liga&ccedil;&atilde;o entre os registros distintos.</li></ul>&#10;<a id="Colunas_(atributos)" name="Colunas_(atributos)"></a><h3> Colunas (atributos) </h3>&#10;&#10;<p>As colunas de uma tabela s&atilde;o tamb&eacute;m chamadas de atributos. Ex.: O campo Nome, ou endere&ccedil;o de uma tabela de um BD relacional.</p>&#10;<a id="Chave" name="Chave"></a><h3> Chave </h3>&#10;<p>As tabelas relacionam&shy;se umas as outras atrav&eacute;s de <b>chaves</b>. Uma chave &eacute; um conjunto de um ou mais atributos que determinam a unicidade de cada registro.</p>&#10;<p>Por exemplo, se um banco de dados tem como chaves <i>C&oacute;digo do Produto</i> e <i>ID Sistema</i>, sempre que acontecer uma inser&ccedil;&atilde;o de dados o sistema de gerenciamento de banco de dados ir&aacute; fazer uma consulta para identificar se o registro j&aacute; n&atilde;o se encontra gravado na tabela. Neste caso, um novo registro n&atilde;o ser&aacute; criado, resultando esta opera&ccedil;&atilde;o apenas da altera&ccedil;&atilde;o do registro existente.</p>&#10;<p>A unicidade dos registros, determinada por sua chave, tamb&eacute;m &eacute; fundamental para a cria&ccedil;&atilde;o dos &iacute;ndices.</p>&#10;<p>Temos dois tipos de chaves:</p>&#10;<dl><dd><b><a href="http://en.wikipedia.org/wiki/Chave_prim%C3%A1ria" id="w">Chave prim&aacute;ria</a>:</b> (<i>PK &shy; Primary Key</i>) &eacute; a chave que identifica cada registro dando&shy;lhe unicidade. A chave prim&aacute;ria nunca se repetir&aacute;.</dd></dl>&#10;<dl><dd><b><a href="http://en.wikipedia.org/wiki/Chave_Estrangeira" id="w">Chave Estrangeira</a>:</b> (<i>FK &shy; Foreign Key</i>) &eacute; a chave formada atrav&eacute;s de um relacionamento com a chave prim&aacute;ria de outra tabela. Define um relacionamento entre as tabelas e pode ocorrer repetidas vezes. Caso a chave prim&aacute;ria seja composta na origem, a chave estrangeira tamb&eacute;m o ser&aacute;.</dd></dl>&#10;<a id="Relacionamentos" name="Relacionamentos"></a><h2> Relacionamentos </h2>&#10;<p> </p>&#10;<p>Com o advento do <a href="http://en.wikipedia.org/wiki/Modelo_de_Entidades_e_Relacionamentos" id="w">Modelo de Entidades e Relacionamentos</a> foi causada uma confus&atilde;o entre os termos <b>rela&ccedil;&atilde;o</b> e <b>relacionamento</b></p>&#10;<p>O <a href="http://en.wikipedia.org/wiki/Modelo_Relacional" id="w">Modelo Relacional</a>, quando descrito de forma matem&aacute;tica, &eacute; definido como um modelo formado por rela&ccedil;&otilde;es (no sentido matem&aacute;tico) entre os dom&iacute;nios. Cada tupla &eacute; um elemento do conjunto rela&ccedil;&atilde;o.</p>&#10;<p>Ou seja, a rela&ccedil;&atilde;o &eacute; a tabela.</p>&#10;<p>Um relacionamento do <a href="http://en.wikipedia.org/wiki/Modelo_de_Entidades_e_Relacionamentos" id="w">Modelo de Entidades e Relacionamentos</a> &eacute; uma associa&ccedil;&atilde;o entre entidades distintas. N&atilde;o h&aacute; rela&ccedil;&atilde;o direta entre o nome <i>relacionamento</i> e o nome <i>rela&ccedil;&atilde;o</i>.</p>&#10;<p>Por&eacute;m, um relacionamento, do <a href="http://en.wikipedia.org/wiki/Modelo_de_Entidades_e_Relacionamentos" id="w">Modelo de Entidades e Relacionamentos</a> &eacute; traduzido para a cria&ccedil;&atilde;o de atributos com chaves externas do <a href="http://en.wikipedia.org/wiki/Modelo_Relacional" id="w">Modelo Relacional</a>. Esta tradu&ccedil;&atilde;o &eacute; feita ligando&shy;se um campo de uma tabela X com um campo de uma tabela Y, por meio da inclus&atilde;o do campo chave da tabela Y como um campo (conhecido como chave estrangeira) da tabela X.</p>&#10;<p>Por meio das chaves estrangeiras, &eacute; poss&iacute;vel implementar restri&ccedil;&otilde;es nos SGBDR.</p>&#10;<p>Existem alguns tipos de relacionamentos poss&iacute;veis no MER:</p>&#10;&#10;<ul>&#10;<li>Um para um (<a href="http://en.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_injectiva" id="w">1 para 1</a>) &shy; indica que as tabelas t&ecirc;m rela&ccedil;&atilde;o un&iacute;voca entre si. Voc&ecirc; escolhe qual tabela vai receber a chave estrangeira&semi;</li>&#10;<li>Um para muitos (<a href="http://en.wikipedia.org/wiki/1_para_N" id="w">1 para N</a>) &shy; a chave prim&aacute;ria da tabela que tem o lado 1 est&aacute; para ir para a tabela do lado N. No lado N ela &eacute; chamada de chave estrangeira&semi;</li>&#10;<li>Muitos para muitos (<a href="http://en.wikipedia.org/wiki/N_para_N" id="w">N para N</a>) &shy; quando tabelas t&ecirc;m entre si rela&ccedil;&atilde;o n..n, &eacute; necess&aacute;rio criar uma nova tabela com as chaves prim&aacute;rias das tabelas envolvidas, ficando assim uma chave composta, ou seja, formada por diversos campos&shy;chave de outras tabelas. A rela&ccedil;&atilde;o ent&atilde;o se reduz para uma rela&ccedil;&atilde;o 1..n, sendo que o lado n ficar&aacute; com a nova tabela criada.</li></ul>&#10;<p>Os relacionamentos <i>1 para 1</i> e <i>1 para N</i> podem ser mapeados diretamente em chaves estrangeiras nas tabelas originais. J&aacute; o relacionamento <i>N para N</i>  exige o uso de uma tabela auxiliar.&#10;No relacionamento N:N n&atilde;o h&aacute; chave estrangeira.</p>&#10;<a id="Modelagem" name="Modelagem"></a><h2> Modelagem </h2>&#10;<a id="Normaliza%C3%A7%C3%A3o" name="Normaliza%C3%A7%C3%A3o"></a><h3> Normaliza&ccedil;&atilde;o </h3>&#10;<p>Os bancos de dados relacionais utilizam a <a href="http://en.wikipedia.org/wiki/Normaliza%C3%A7%C3%A3o_de_dados" id="w">normaliza&ccedil;&atilde;o de dados</a> para evitar redund&acirc;ncias e possibilitar um &#10;maior desempenho nas pesquisas.</p>&#10;<dl><dt>Normaliza&ccedil;&atilde;o</dt></dl>&#10;<p>&Eacute; o processo de organiza&ccedil;&atilde;o eficiente dos dados dentro de um banco de dados cujos objetivos principais s&atilde;o:</p>&#10;&#10;<ol>&#10;<li>Eliminar dados redundantes (por exemplo, armazenando os mesmos dados em mais de uma tabela).</li>&#10;<li>Garantir que as depend&ecirc;ncias entre os dados fa&ccedil;am sentido (armazenando apenas dados logicamente relacionados em uma tabela).</li></ol>&#10;<p>Existem cinco est&aacute;gios de normaliza&ccedil;&atilde;o, 1&ordm;, o 2&ordm;, o 3&ordm;, o 4&ordm; e o 5&ordm;. Para um banco de dados se encontrar em cada um desses est&aacute;gios ou formas (denominadas formas normais), cada uma de suas tabelas deve atender a alguns pr&eacute;&shy;requisitos. Os pr&eacute;&shy;requisitos s&atilde;o cumulativos, isto &eacute;, para alcan&ccedil;ar a 3&ordf; forma normal (3NF), um banco de dados precisa atender aos pr&eacute;&shy;requisitos das 1&ordf; e 2&ordf; formas normais, acrescidos dos requisitos exclusivos da 3NF.</p>&#10;<a id="Depend%C3%AAncia_Funcional" name="Depend%C3%AAncia_Funcional"></a><h3> Depend&ecirc;ncia Funcional </h3>&#10;<p>Um atributo B possui uma depend&ecirc;ncia funcional do atributo A se, para cada valor do atributo A, existe exatamente um &uacute;nico valor do atributo B. &#10;A depend&ecirc;ncia funcional &eacute; representada por  A &rarr; B.</p>&#10;<p>Exemplo:&#10;Observe os conjuntos:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<caption><b>Cliente</b></caption>&#10;<tr>&#10;<th>CPF </th>&#10;<th>Nome</th></tr>&#10;<tr>&#10;<td>1</td>&#10;<td>Jos&eacute;</td></tr>&#10;<tr>&#10;<td>2</td>&#10;<td>Jo&atilde;o</td></tr>&#10;<tr>&#10;<td>3</td>&#10;<td>Gabriel</td></tr>&#10;<tr>&#10;<td>4</td>&#10;<td>M. Guedes</td></tr></table></div>&#10;&#10;<p>Observe que existe uma depend&ecirc;ncia entre os valores dos conjuntos, ou seja, nome &eacute; fun&ccedil;&atilde;o do CPF, se eu estiver com numero do CPF, poderei encontrar o nome da pessoa correspondente.</p>&#10;<p>Essa depend&ecirc;ncia &eacute; expressa por:</p>&#10;<pre>      CPF &rarr; Nome&#10;</pre>&#10;<p>Leia da seguinte maneira:&#10;&shy; com um n&uacute;mero de CPF posso encontrar nome da pessoa, ou&#10;&shy; nome depende da funcionalidade do CPF.</p>&#10;<a id="Primeira_Forma_Normal_(FN1)" name="Primeira_Forma_Normal_(FN1)"></a><h3> Primeira Forma Normal (FN1) </h3>&#10;&#10;<p>Uma rela&ccedil;&atilde;o est&aacute; na primeira forma normal se os valores de seus atributos s&atilde;o at&ocirc;micos (simples, indivis&iacute;veis) e monovalorados. Em outras palavras, FN1 n&atilde;o permite &ldquo;rela&ccedil;&otilde;es dentro de rela&ccedil;&otilde;es&rdquo; ou &ldquo;rela&ccedil;&otilde;es como atributos de tuplas&rdquo;<sup id="_ref&shy;cericola_a" class="reference"><a href="#_note&shy;cericola" title="">[1]</a></sup>.</p>&#10;<p>Uma tabela est&aacute; na primeira forma normal quando seus atributos n&atilde;o cont&ecirc;m grupos de repeti&ccedil;&atilde;o.&#10;Exemplo: &#10;</p>&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<caption><b>Cliente</b></caption>&#10;<tr>&#10;<th>ClienteID </th>&#10;<th>Nome </th>&#10;<th>Telefone</th></tr>&#10;<tr>&#10;<td>123</td>&#10;<td>Rachel Ingram</td>&#10;<td>555&shy;861&shy;2025</td></tr>&#10;<tr>&#10;<td>456</td>&#10;<td>James Wright</td>&#10;<td>555&shy;403&shy;1659<br/>555&shy;776&shy;4100</td></tr>&#10;<tr>&#10;<td>789</td>&#10;<td>Maria Fernandez</td>&#10;<td>555&shy;808&shy;9633</td></tr></table></div>&#10;<p>Esta tabela logo acima n&atilde;o est&aacute; na primeira forma normal porque apresenta grupos de repeti&ccedil;&atilde;o (possibilidade de mais de um telefone por cliente).</p>&#10;<p>J&aacute; estas tabelas logo abaixo, Cliente e Telefone, est&atilde;o na primeira forma normal.</p>&#10;<p>Tabela Cliente:&#10;</p>&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<caption><b>Cliente</b></caption>&#10;<tr>&#10;<th>ClienteID </th>&#10;<th>Nome</th></tr>&#10;<tr>&#10;<td>123</td>&#10;<td>Rachel</td></tr>&#10;<tr>&#10;<td>456</td>&#10;<td>James</td></tr>&#10;<tr>&#10;<td>789</td>&#10;<td>Maria</td></tr></table></div>&#10;&#10;<p>Tabela Telefone:&#10;</p>&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<caption><b>Telefone</b></caption>&#10;<tr>&#10;<th>ClienteID </th>&#10;<th>Telefone</th></tr>&#10;<tr>&#10;<td>123</td>&#10;<td>555&shy;861&shy;2025</td></tr>&#10;<tr>&#10;<td>456</td>&#10;<td>555&shy;403&shy;1659</td></tr>&#10;<tr>&#10;<td>456</td>&#10;<td>555&shy;776&shy;4100</td></tr>&#10;<tr>&#10;<td>789</td>&#10;<td>555&shy;808&shy;9633</td></tr></table></div>&#10;&#10;<a id="Segunda_Forma_Normal_(FN2)" name="Segunda_Forma_Normal_(FN2)"></a><h3> Segunda Forma Normal (FN2) </h3>&#10;&#10;<p>Uma rela&ccedil;&atilde;o est&aacute; na FN2 quando duas condi&ccedil;&otilde;es s&atilde;o satisfeitas:</p>&#10;<p>1 &shy; A rela&ccedil;&atilde;o est&aacute; na 1FN&semi; </p>&#10;<p>2 &shy; Todo atributo da tabela seja dependente funcional da chave completa e n&atilde;o de parte da chave. Ou seja, Todos os atributos n&atilde;o&shy;chave dependem funcionalmente de toda a chave prim&aacute;ria.</p>&#10;<a id="Terceira_Forma_Normal_(FN3)" name="Terceira_Forma_Normal_(FN3)"></a><h3> Terceira Forma Normal (FN3) </h3>&#10;&#10;<p>A 3FN exige que n&atilde;o existam atributos transitivamente dependentes da chave.</p>&#10;<p>Um exemplo de uma tabela 2FN que n&atilde;o atende o crit&eacute;rio para 3FN &eacute;:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<caption><b>Vencedores de Torneios</b></caption>&#10;<tr>&#10;<th><u>Torneio</u> </th>&#10;<th><u>Ano</u> </th>&#10;<th>Vencedor</th>&#10;<th>Data de nascimento do vencedor</th></tr>&#10;<tr>&#10;<td>Indiana Invitational</td>&#10;<td>1998</td>&#10;<td>Al Fredrickson</td>&#10;<td>21 de julho de 1975</td></tr>&#10;<tr>&#10;<td>Cleveland Open</td>&#10;<td>1999</td>&#10;<td>Bob Albertson</td>&#10;<td>28 de setembro de 1968 </td></tr>&#10;<tr>&#10;<td>Des Moines Masters</td>&#10;<td>1999</td>&#10;<td>Al Fredrickson</td>&#10;<td>21 de julho de 1975</td></tr>&#10;<tr>&#10;<td>Indiana Invitational</td>&#10;<td>1999</td>&#10;<td>Chip Masterson</td>&#10;<td>14/3/1977</td></tr></table></div>&#10;&#10;<p>A chave prim&aacute;ria composta &eacute; {Torneio, Ano}.</p>&#10;<p>A tabela n&atilde;o est&aacute; na terceira forma normal porque o atributo <i>&#34&semi;data de nascimento do vencedor&#34&semi;</i> &eacute; dependente transitivamente de {Torneio, Ano} via o atributo &#34&semi;<i>Vencedor</i>&#34&semi;. O fato da <i>data de nascimento do vencedor</i> n&atilde;o ser dependente do <i>vencedor</i> torna a tabela vulner&aacute;vel a inconsist&ecirc;ncias l&oacute;gicas, j&aacute; que nada impediria de uma mesma pessoa aparecer com datas de nascimento diferentes em dois registros.</p>&#10;<p>Para atender a terceira forma normal, a mesma informa&ccedil;&atilde;o deveria ser dividida em duas tabelas:</p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<caption><b>Vencedores de Torneios</b></caption>&#10;<tr>&#10;<th><u>Torneio</u> </th>&#10;<th><u>Ano</u> </th>&#10;<th>Vencedor</th></tr>&#10;<tr>&#10;<td>Indiana Invitational</td>&#10;<td>1998</td>&#10;<td>Al Fredrickson</td></tr>&#10;<tr>&#10;<td>Cleveland Open</td>&#10;<td>1999</td>&#10;<td>Bob Albertson</td></tr>&#10;<tr>&#10;<td>Des Moines Masters</td>&#10;<td>1999</td>&#10;<td>Al Fredrickson</td></tr>&#10;<tr>&#10;<td>Indiana Invitational</td>&#10;<td>1999</td>&#10;<td>Chip Masterson</td></tr></table></div>&#10;&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<caption><b>Datas de nascimento de jogadores</b></caption>&#10;<tr>&#10;<th><u>Jogador</u> </th>&#10;<th>Data de nascimento</th></tr>&#10;<tr>&#10;<td>Chip Masterson</td>&#10;<td>14/3/1977</td></tr>&#10;<tr>&#10;<td>Al Fredrickson</td>&#10;<td>21 de julho de 1975</td></tr>&#10;<tr>&#10;<td>Bob Albertson</td>&#10;<td>28 de setembro de 1968</td></tr></table></div>&#10;&#10;<p>As duas tabelas acima est&atilde;o na terceira forma normal.</p>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Administra%C3%A7%C3%A3o_de_dados" id="w">Administra&ccedil;&atilde;o de dados</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Banco_de_dados" id="w">Banco de dados</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Data_warehouse" id="w">Data warehouse</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_Computa%C3%A7%C3%A3o" id="w">Ci&ecirc;ncia da Computa&ccedil;&atilde;o</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Arquitetura_de_dados" id="w">Arquitetura de dados</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Modelo_de_Entidades_e_Relacionamentos" id="w">Modelo de Entidades e Relacionamentos</a></li></ul>&#10;<p> </p>&#10;<p> </p>&#10;<p> &#10;<a href="http://en.wikipedia.org/wiki/Categoria:SGBDs" id="w">Categoria:SGBDs</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Modelo_relacional" id="w"> </a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Tipos_de_bancos_de_dados" id="w">Categoria:Tipos de bancos de dados</a></p></body></html>