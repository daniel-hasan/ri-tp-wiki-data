<html><title>Prolog</title><body>&#10;<p> &#10; </p>&#10;<p><b>Prolog </b> &eacute; uma <a href="http://en.wikipedia.org/wiki/Linguagens_de_programa%C3%A7%C3%A3o" id="w">linguagem de programa&ccedil;&atilde;o</a> que se enquadra no paradigma de Programa&ccedil;&atilde;o em L&oacute;gica Matem&aacute;tica. &Eacute; uma linguagem de uso geral que &eacute; especialmente associada com a <a href="http://en.wikipedia.org/wiki/Intelig%C3%AAncia_artificial" id="w">intelig&ecirc;ncia artificial</a> e <a href="http://en.wikipedia.org/wiki/Lingu%C3%ADstica_computacional" id="w">lingu&iacute;stica computacional</a>. Consiste numa linguagem puramente l&oacute;gica, que pode ser chamada de <i>Prolog puro</i>, e numa linguagem concreta, a qual acrescenta o Prolog puro com componentes <i>extra&shy;l&oacute;gicos</i>.</p>&#10;<p>O uso Prolog puro foi originalmente restrito em provas do <a href="http://en.wikipedia.org/wiki/Resolu%C3%A7%C3%A3o" id="w">teorema da resolu&ccedil;&atilde;o</a> com <a href="http://en.wikipedia.org/wiki/Cl%C3%A1usula_de_Horn" id="w">Cl&aacute;usulas de Horn</a> do formato</p>&#10;<dl><dd><tt>H :&shy; B<sub>1</sub>, &hellip;, B<sub>n</sub>.</tt>.</dd></dl>&#10;<p>A aplica&ccedil;&atilde;o do provador de teoremas trata estas cl&aacute;usulas como procedimentos</p>&#10;<dl><dd>para mostrar/resolver <tt>H</tt>, mostrar/resolver <tt>B<sub>1</sub></tt> and &hellip; and <tt>B<sub>n</sub></tt>.</dd></dl>&#10;<p>O Prolog puro foi ent&atilde;o estendido para incluir a <a href="http://en.wikipedia.org/wiki/Nega%C3%A7%C3%A3o_por_falha" id="w">nega&ccedil;&atilde;o por falha</a>, na qual condi&ccedil;&otilde;es negativas da forma not(B<sub>i</sub>) s&atilde;o mostradas por tentativa e falha para resolver as condi&ccedil;&otilde;es positivas correspondentes B<sub>i</sub>).</p>&#10;<p>O nome <i>Prolog</i> para a linguagem concreta foi escolhido por <a href="http://en.wikipedia.org/wiki/Philippe_Roussel" id="w">Philippe Roussel</a> como uma abrevia&ccedil;&atilde;o de &ldquo;<b>PRO</b>grammation en <b>LOG</b>ique&rdquo;. Foi criada em meados de 1972 por <a href="http://en.wikipedia.org/wiki/Alain_Colmerauer" id="w">Alain Colmerauer</a> e <a href="http://en.wikipedia.org/wiki/Philippe_Roussel" id="w">Philippe Roussel</a>, baseados no conceito de <a href="http://en.wikipedia.org/wiki/Robert_Kowalski" id="w">Robert Kowalski</a> da interpreta&ccedil;&atilde;o procedimental das cl&aacute;usulas de Horn. A motiva&ccedil;&atilde;o para isso veio em parte da vontade de reconciliar o uso da l&oacute;gica como uma linguagem declarativa de representa&ccedil;&atilde;o do conhecimento com a representa&ccedil;&atilde;o procedimental do conhecimento, que era popular na Am&eacute;rica do Norte no final da d&eacute;cada de 1960 para in&iacute;cio de 1970.</p>&#10;<p>Muito do desenvolvimento moderno do Prolog veio dos projetos de <a href="http://en.wikipedia.org/wiki/Computa%C3%A7%C3%A3o_da_quinta_gera%C3%A7%C3%A3o" id="w">computadores da quinta gera&ccedil;&atilde;o</a> (FGCS), que desenvolveu uma variante do Prolog chamada <i>Kernel Language</i> para seu primeiro <a href="http://en.wikipedia.org/wiki/Sistema_operacional" id="w">sistema operacional</a>.</p>&#10;<p>Apesar do longo tempo de desenvolvimento, Prolog ainda n&atilde;o &eacute; uma linguagem port&aacute;vel, j&aacute; que cada implementa&ccedil;&atilde;o usa rotinas completamente diferentes e incompat&iacute;veis entre si. Por exemplo, um programa trivial que faz um loop de ler uma linha da console e escreve a mesma linha, terminando quando for entrada uma linha vazia, &eacute; imposs&iacute;vel de ser escrito de forma que qualquer interpretador consiga rodar.</p>&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2> Hist&oacute;ria </h2>&#10;&#10;<p>A linguagem de programa&ccedil;&atilde;o Prolog nasceu de um projeto que n&atilde;o tinha por foco a implementa&ccedil;&atilde;o de uma linguagem de programa&ccedil;&atilde;o, mas o processamento de linguagens naturais. Na Universidade de Marselha, Alain Colmerauer e Robert Pasero trabalhavam na parte de linguagem natural e Jean Trudel e Philippe Roussel trabalhavam na parte de dedu&ccedil;&atilde;o do projeto.  Interessado pelo m&eacute;todo de resolu&ccedil;&atilde;o SL, Trudel persuadiu um dos seus inventores, Robert Kowalski, que se uniu ao projeto. O projeto resultou em uma vers&atilde;o preliminar da linguagem Prolog em fins de 1971 sendo que a vers&atilde;o definitiva apareceu em fins de 1972<sup id="_ref&shy;hoplii_a" class="reference"><a href="#_note&shy;hoplii" title="">[1]</a></sup>.</p>&#10;<a id="Caracter%C3%ADsticas" name="Caracter%C3%ADsticas"></a><h2> Caracter&iacute;sticas </h2>&#10;&#10;<p>O Prolog &eacute; uma linguagem declarativa, significando que em vez de o programa estipular a maneira de chegar &agrave; solu&ccedil;&atilde;o, passo a passo, (como nas linguagens procedimentais ou imperativas), limita&shy;se a fornecer uma descri&ccedil;&atilde;o do problema que se pretende computar. Usa uma cole&ccedil;&atilde;o  <a href="http://en.wikipedia.org/wiki/Banco_de_dados" id="w">base de dados</a> de <i>fatos</i> e de rela&ccedil;&otilde;es l&oacute;gicas (<i>regras</i>) que exprimem o dom&iacute;nio relacional do problema a resolver. </p>&#10;<p>Um  programa pode rodar num modo interativo, a partir de consultas (queries) formuladas pelo usu&aacute;rio, usando a base de dados (os &#39&semi;fatos&#39&semi;) e as regras relacionais (essencialmente implica&ccedil;&otilde;es l&oacute;gicas: se.. ent&atilde;o), e o mecanismo de unifica&ccedil;&atilde;o para produzir (por uma cadeia de dedu&ccedil;&otilde;es l&oacute;gicas) a solu&ccedil;&atilde;o.</p>&#10;<p>O Prolog &eacute; baseado num subconjunto do <a href="http://en.wikipedia.org/wiki/L%C3%B3gica_de_primeira_ordem" id="w">c&aacute;lculo de predicados de primeira ordem</a>, o que &eacute; definido por <a href="http://en.wikipedia.org/wiki/Cl%C3%A1usula_de_Horn" id="w">cl&aacute;usulas de Horn</a>. A execu&ccedil;&atilde;o de um programa em Prolog &eacute; efetivamente a prova de um teorema por <a href="http://en.wikipedia.org/wiki/Princ%C3%ADpio_da_resolu%C3%A7%C3%A3o" id="w">resolu&ccedil;&atilde;o de primeira ordem</a>. Alguns conceitos fundamentais s&atilde;o <a href="http://en.wikipedia.org/wiki/Unifica%C3%A7%C3%A3o" id="w">unifica&ccedil;&atilde;o</a>, <a href="http://en.wikipedia.org/wiki/Recurs%C3%A3o" id="w">recurs&atilde;o</a>, e <a href="http://en.wikipedia.org/wiki/Backtracking" id="w">backtracking</a>.</p>&#10;<a id="Tipos_de_dados" name="Tipos_de_dados"></a><h2> Tipos de dados </h2>&#10;<p>Prolog n&atilde;o emprega <a href="http://en.wikipedia.org/wiki/Tipos_de_dados" id="w">tipos de dados</a> do mesmo modo que as linguagens de programa&ccedil;&atilde;o mais comuns normalmente fazem. Todos os dados s&atilde;o tratados como sendo de um &uacute;nico tipo, <b>Termo</b>, cuja natureza depende da forma como esse termo foi declarado. Ou seja, os elementos l&eacute;xicos utilizados na sua declara&ccedil;&atilde;o determinam se esse termo ser&aacute; um n&uacute;mero, um texto, uma vari&aacute;vel, uma estrutura complexa e assim por diante.</p>&#10;<a id="Escopo_dos_identificadores" name="Escopo_dos_identificadores"></a><h3>Escopo dos identificadores</h3>&#10;<p>Com exce&ccedil;&atilde;o de &aacute;tomos num&eacute;ricos, fun&ccedil;&otilde;es ou predicados constru&iacute;dos, os nomes em Prolog para constantes, vari&aacute;veis, fun&ccedil;&otilde;es e predicados, n&atilde;o t&ecirc;m nenhum significado intr&iacute;nseco e podem ser escolhidos livremente pelo programador. Em geral, duas nota&ccedil;&otilde;es distintas denotar&atilde;o ou ser&atilde;o objetos distintos. Como em qualquer linguagem de programa&ccedil;&atilde;o, a cada nome deve ser dado um escopo.</p>&#10;<p>Em Prolog, as regras de escopo s&atilde;o:&#10;</p>&#10;<ul>&#10;<li>O escopo de uma vari&aacute;vel &eacute; a asser&ccedil;&atilde;o (fato, regra, ou consulta) na qual aparece.</li>&#10;<li>O escopo de qualquer outro nome (constante, nome de fun&ccedil;&atilde;o, ou nome de predicado) &eacute; todo o programa.</li></ul>&#10;<p>Isto significa que um nome de vari&aacute;vel pode ser utilizado e reutilizado a vontade no programa para denotar vari&aacute;veis diferentes, enquanto qualquer outra nota&ccedil;&atilde;o representa, ou &eacute;, o mesmo objeto para o programa todo.</p>&#10;<a id="%C3%81tomos" name="%C3%81tomos"></a><h3> &Aacute;tomos </h3>&#10;<p>As constantes de texto s&atilde;o introduzidas por meio de &aacute;tomos. Um &aacute;tomo &eacute; uma sequ&ecirc;ncia constitu&iacute;da de letras, n&uacute;meros e <a href="http://en.wikipedia.org/wiki/Underscore" id="w">underscore</a>, mas iniciando com uma letra min&uacute;scula. Se um &aacute;tomo n&atilde;o alfanum&eacute;rico &eacute; necess&aacute;rio, pode&shy;se usar qualquer sequ&ecirc;ncia entre aspas simples (ex: &#39&semi;um &aacute;tomo contendo espa&ccedil;os&#39&semi;).</p>&#10;<p>Um &aacute;tomo pode ser definido das seguintes maneiras:</p>&#10;<p>come&ccedil;ando com letra min&uacute;scula:&#10;pedro         henrique_iv</p>&#10;<p>como uma sequ&ecirc;ncia de caracteres entre aspas simples:&#10;&#39&semi;quem &eacute; voc&ecirc;?&#39&semi;        &#39&semi;eu n&atilde;o sei&#39&semi;.</p>&#10;<a id="N%C3%BAmeros" name="N%C3%BAmeros"></a><h3> N&uacute;meros </h3>&#10;<p>Um n&uacute;mero &eacute; uma sequ&ecirc;ncia de d&iacute;gitos, permitindo tamb&eacute;m os sinais de <b>.</b> (para n&uacute;meros reais), <b>&shy;</b> (n&uacute;mero negativo) e <b>e</b> (<a href="http://en.wikipedia.org/wiki/Nota%C3%A7%C3%A3o_cient%C3%ADfica" id="w">nota&ccedil;&atilde;o cient&iacute;fica</a>). Algumas implementa&ccedil;&otilde;es do Prolog n&atilde;o fazem distin&ccedil;&atilde;o entre inteiros e n&uacute;meros reais.</p>&#10;<p>exemplos:&#10;321        3.21</p>&#10;<a id="Vari%C3%A1veis" name="Vari%C3%A1veis"></a><h3> Vari&aacute;veis </h3>&#10;<p>Vari&aacute;veis s&atilde;o declaradas da mesma forma que &aacute;tomos, por&eacute;m iniciando com uma letra mai&uacute;scula ou underscore. No ambiente Prolog uma vari&aacute;vel n&atilde;o &eacute; um <a href="http://en.wikipedia.org/wiki/Container_(programa%C3%A7%C3%A3o)" id="w">cont&ecirc;iner</a> cujo valor pode ser atribu&iacute;do (como ocorre nas <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_imperativa" id="w">linguagens imperativas</a>). Seu comportamento &eacute; mais pr&oacute;ximo de um padr&atilde;o, que &eacute; incrementalmente especificado pela <a href="http://en.wikipedia.org/wiki/Unifica%C3%A7%C3%A3o" id="w">unifica&ccedil;&atilde;o</a>. Em outras palavras, uma vari&aacute;vel Prolog &eacute; como uma inc&oacute;gnita, cujo valor &eacute; desconhecido a princ&iacute;pio mas, ap&oacute;s descoberto, n&atilde;o sofre mais mudan&ccedil;as.</p>&#10;<p>Um tipo especial de vari&aacute;vel, a <i>vari&aacute;vel an&ocirc;nima</i> (explicada mais adiante), &eacute; uma express&atilde;o que significa &#39&semi;qualquer vari&aacute;vel&#39&semi;, e &eacute; escrita como um &uacute;nico subtra&ccedil;o (_).</p>&#10;<p>exemplos:&#10;X         Nome          Rei_da_Espanha</p>&#10;<a id="Termos_compostos" name="Termos_compostos"></a><h3> Termos compostos </h3>&#10;<p>Termos compostos s&atilde;o a &uacute;nica forma de se expressar estruturas de dados complexas em Prolog. Um termo composto consiste de uma cabe&ccedil;a, tamb&eacute;m chamada funtor (que &eacute; obrigatoriamente um &aacute;tomo) e par&acirc;metros (de quaisquer tipos) listados entre par&ecirc;nteses e separados por v&iacute;rgulas.</p>&#10;<p>O n&uacute;mero de par&acirc;metros, chamado <a href="http://en.wikipedia.org/wiki/Aridade" id="w">aridade</a> do termo, &eacute; significativo. Um termo &eacute; identificado por sua cabe&ccedil;a e aridade, normalmente escrita como funtor/aridade. &Aacute;tomos e n&uacute;meros tamb&eacute;m podem ser identificados dessa forma, como um termo de aridade zero (ex: um_atomo/0).</p>&#10;<a id="Listas" name="Listas"></a><h3> Listas </h3>&#10;<p>Uma lista n&atilde;o &eacute; um tipo de dados &agrave; parte, mas sim definida por uma constru&ccedil;&atilde;o recursiva (usando o termo &#39&semi;.&#39&semi;/2):</p>&#10;&#10;<ol>&#10;<li>o &aacute;tomo [] &eacute; uma lista vazia&semi;</li>&#10;<li>se <i>T</i> &eacute; uma lista e <i>H</i> &eacute; um elemento, ent&atilde;o o termo &#39&semi;.&#39&semi;(<i>H</i>, <i>T</i>) &eacute; uma lista.</li></ol>&#10;<p>O primeiro elemento, chamado cabe&ccedil;a, &eacute; <i>H</i>, que &eacute; seguida pelo conte&uacute;do do restante da lista, <i>T</i>, tamb&eacute;m chamado de cauda.&#10;A lista [1, 2, 3] seria representada internamente como &#39&semi;.&#39&semi;(1, &#39&semi;.&#39&semi;(2, &#39&semi;.&#39&semi;(3, []))).&#10;Um atalho sint&aacute;tico &eacute; [<i>H</i> | <i>T</i>], que &eacute; mais usado para construir regras.&#10;Uma lista pode ser processada como um todo processando o primeiro elemento, e em seguida o restante da lista, de forma <a href="http://en.wikipedia.org/wiki/Recursividade" id="w">recursiva</a>.</p>&#10;<p>Para conveni&ecirc;ncia do programador, as listas podem ser constru&iacute;das e destru&iacute;das de v&aacute;rias formas.</p>&#10;&#10;<ul>&#10;<li>Enumerando os elementos: [abc, 1, f(X), <i>Y</i>, g(<i>A</i>,rst)]</li>&#10;<li>Precedendo&shy;a com um elemento: [abc | <i>L1</i>]</li>&#10;<li>Precedendo&shy;a com m&uacute;ltiplos elementos: [abc, 1, f(X) | <i>L2</i>]</li>&#10;<li>Expandindo o termo: &#39&semi;.&#39&semi;(abc, &#39&semi;.&#39&semi;(1, &#39&semi;.&#39&semi;(f(X), &#39&semi;.&#39&semi;(<i>Y</i>, &#39&semi;.&#39&semi;(g(<i>A</i>,rst), [])))))</li>&#10;<li>O predicado <b>append</b></li></ul>&#10;<a id="Strings" name="Strings"></a><h3> Strings </h3>&#10;<p>Strings s&atilde;o normalmente escritas como uma sequ&ecirc;ncia de caracteres entre aspas. &Eacute; comum serem representadas internamente como listas de c&oacute;digos de caracteres, em geral utilizando a codifica&ccedil;&atilde;o local ou <a href="http://en.wikipedia.org/wiki/Unicode" id="w">Unicode</a>, se o sistema d&aacute; suporte a Unicode. O ISO Prolog tamb&eacute;m permite que strings sejam representadas por uma lista de &aacute;tomos com um &uacute;nico caractere.</p>&#10;<a id="Fatos" name="Fatos"></a><h2> Fatos </h2>&#10;<p>Programar em Prolog &eacute; bem diferente de programar em uma linguagem procedimental. Em Prolog se fornece fatos e regras para uma base de dados&semi; ent&atilde;o se executam consultas ou (<i>queries</i>) a essa base de dados. A unidade b&aacute;sica do Prolog &eacute; o predicado, que &eacute; postulado verdadeiro. Um predicado consiste de uma cabe&ccedil;a e um n&uacute;mero de argumentos. Por exemplo:</p>&#10;<p />&#10;&#10;<p>Isso informa &agrave; base de dados o fato que &#39&semi;tom&#39&semi; &eacute; um &#39&semi;gato&#39&semi;. Formalmente, &#39&semi;gato&#39&semi; &eacute; a cabe&ccedil;a e &#39&semi;tom&#39&semi; &eacute; o &uacute;nico argumento do predicado. Alguns exemplos de consultas que podem ser feitas ao interpretador Prolog baseado nesse fato:</p>&#10;<p><i>tom &eacute; um gato?</i></p>&#10;<p />&#10;&#10;<p><i>que coisas (conhecidas) s&atilde;o gatos?</i></p>&#10;<p />&#10;&#10;<p>Predicados s&atilde;o normalmente definidos para expressar algum fato sobre o mundo que o programa deve conhecer. Na maioria dos casos, o uso de predicados requer uma certa conven&ccedil;&atilde;o. Por exemplo, qual das duas vers&otilde;es abaixo significaria que Jos&eacute; &eacute; o pai de Ana?</p>&#10;<p />&#10;&#10;<p>Em ambos os casos &#39&semi;pai&#39&semi; &eacute; a cabe&ccedil;a e &#39&semi;ana&#39&semi; e &#39&semi;jose&#39&semi; s&atilde;o argumentos. Entretanto, no primeiro caso Ana vem primeiro na lista de argumentos, e no segundo, quem vem primeiro &eacute; Jos&eacute; (a ordem nos argumentos &eacute; importante). O primeiro caso &eacute; um exemplo de defini&ccedil;&atilde;o na ordem <b>Verbo Sujeito Objeto</b>, e o segundo, na ordem <b>Verbo Objeto Sujeito</b>. Como Prolog n&atilde;o entende portugu&ecirc;s, ambas as vers&otilde;es est&atilde;o corretas de acordo com seu escopo&semi; no entanto &eacute; uma boa pr&aacute;tica de programa&ccedil;&atilde;o escolher uma &uacute;nica conven&ccedil;&atilde;o para ser usada no mesmo programa, para evitar escrever algo como</p>&#10;<p />&#10;&#10;<p>Alguns predicados s&atilde;o pre&shy;definidos na pr&oacute;pria linguagem, permitindo que os programas Prolog desempenhem atividades rotineiras (como entrada/sa&iacute;da, uso de gr&aacute;ficos e outros tipos de comunica&ccedil;&atilde;o com o sistema operacional). Por exemplo, o predicado <tt>write</tt> pode ser usado para sa&iacute;da na tela. Ent&atilde;o,</p>&#10;<p />&#10;&#10;<p>vai exibir a palavra &#39&semi;Ol&aacute;&#39&semi; na tela.</p>&#10;<a id="Regras" name="Regras"></a><h2> Regras </h2>&#10;<p>O segundo tipo de predicado no Prolog &eacute; a regra, tamb&eacute;m chamada de &#34&semi;cl&aacute;usula&#34&semi;. Um exemplo de uma regra &eacute;:</p>&#10;<p />&#10;&#10;<p>O &#34&semi;:&shy;&#34&semi; significa &#34&semi;se&#34&semi;&semi; essa regra significa que luz(acesa) &eacute; verdadeiro se interruptor(ligado) &eacute; verdadeiro. Regras podem tamb&eacute;m fazer uso de vari&aacute;veis, como por exemplo,</p>&#10;<p />&#10;&#10;<p>(X &eacute; av&ocirc; de Z se X &eacute; pai de Y e Y &eacute; pai de Z)</p>&#10;<p>Isso significa &#34&semi;se algu&eacute;m &eacute; pai de outra pessoa, que por sua vez &eacute; pai de uma terceira, ent&atilde;o ele &eacute; av&ocirc;&#34&semi;. O antecedente e o consequente est&atilde;o na ordem inversa do que &eacute; normalmente encontrado na nota&ccedil;&atilde;o da l&oacute;gica: o consequente &eacute; escrito primeiro e &eacute; chamado a <b>cabe&ccedil;a</b> da regra, o antecedente &eacute; chamado <b>corpo</b>. A conjun&ccedil;&atilde;o (e) &eacute; escrita como &#34&semi;,&#34&semi;, enquanto a disjun&ccedil;&atilde;o (ou) &eacute; escrita como &#34&semi;&semi;&#34&semi;. Tamb&eacute;m &eacute; poss&iacute;vel colocar m&uacute;ltiplos predicados em um mesmo corpo, unindo seus antecedentes por disjun&ccedil;&atilde;o, como por exemplo:</p>&#10;<p />&#10;&#10;<p>que &eacute; equivalente &agrave;s tr&ecirc;s regras separadas:</p>&#10;<p />&#10;&#10;<p>No entanto n&atilde;o s&atilde;o permitidas regras como:</p>&#10;<p />&#10;&#10;<p>Ou seja, &#34&semi;se c ent&atilde;o a ou b&#34&semi;. Isso &eacute; devido &agrave; restri&ccedil;&atilde;o &agrave;s <a href="http://en.wikipedia.org/wiki/Cl%C3%A1usula_de_Horn" id="w">cl&aacute;usulas de Horn</a>.</p>&#10;<p>Uma maneira de simular tal regra, usando o operador de nega&ccedil;&atilde;o, &eacute;:</p>&#10;<p />&#10;&#10;<a id="Regras_Recursivas" name="Regras_Recursivas"></a><h3>Regras Recursivas</h3>&#10;&#10;<p>Regras <a href="http://en.wikipedia.org/wiki/Recursividade" id="w">recursivas</a> devem ser permitidas a fim de tornar a linguagem &uacute;til para muitas aplica&ccedil;&otilde;es. Um predicado definido por uma regra recursiva deve necessariamente ter, no m&iacute;nimo uma defini&ccedil;&atilde;o n&atilde;o recursiva. Se isto n&atilde;o acontecer, a defini&ccedil;&atilde;o &eacute; logicamente mal&shy;formada e o programa ficaria em <a href="http://en.wikipedia.org/wiki/La%C3%A7o_infinito" id="w">la&ccedil;o infinito</a>.&#10;Um exemplo de regra recursiva seria a defini&ccedil;&atilde;o de uma base de dados sobre rela&ccedil;&otilde;es familiares que responda quest&otilde;es sobre ancestralidade. Isto pode ser definido da seguinte forma:</p>&#10;<p />&#10;&#10;<p>Al&eacute;m disso, &eacute; necess&aacute;rio tomar cuidado com a ordem na qual <a href="http://en.wikipedia.org/wiki/Unifica%C3%A7%C3%A3o" id="w">unifica&ccedil;&otilde;es</a>(ver <a href="http://en.wikipedia.org/wiki/Unifica%C3%A7%C3%A3o" id="w">Unifica&ccedil;&atilde;o</a> em Prolog) s&atilde;o procurados para objetivos. Se invertermos a ordem nas regras recursivas do predicado ancestral, isto &eacute;</p>&#10;<p />&#10;&#10;<p>a consulta resultar&aacute; uma recurs&atilde;o infinita.  </p>&#10;<a id="Recurs%C3%A3o_em_cauda" name="Recurs%C3%A3o_em_cauda"></a><h4> Recurs&atilde;o em cauda </h4>&#10;&#10;<p>Uma fun&ccedil;&atilde;o <span class="math">f</span> pode ser definida por recurs&atilde;o em cauda da seguinte maneira:</p>&#10;<pre>f(x): se c(x) ent&atilde;o g(x) sen&atilde;o f(h(x))&#10;</pre>&#10;<p>onde:&#10;&shy; <span class="math">c(x)</span> &eacute; algum tipo de condi&ccedil;&atilde;o sobre o valor de <span class="math">x</span>&semi;&#10;&shy; <span class="math">g(x),h(x)</span> s&atilde;o fun&ccedil;&otilde;es definidas com um argumento n&atilde;o definido na fun&ccedil;&atilde;o <span class="math">f</span>.</p>&#10;<p>A mesma senten&ccedil;a pode ser escrita em Prolog desta forma:</p>&#10;<p />&#10;&#10;<p>Recurs&atilde;o em cauda &eacute; importante e prefer&iacute;vel sobre recurs&atilde;o n&atilde;o cauda pois pode ser implementada como uma itera&ccedil;&atilde;o que &eacute; computada usando uma pilha est&aacute;tica.</p>&#10;<a id="Recurs%C3%A3o_n%C3%A3o_em_cauda" name="Recurs%C3%A3o_n%C3%A3o_em_cauda"></a><h4> Recurs&atilde;o n&atilde;o em cauda </h4>&#10;&#10;<p>Recurs&atilde;o n&atilde;o em cauda pode ser definida pela senten&ccedil;a</p>&#10;<pre>f(x): se c(x) ent&atilde;o g(x) sen&atilde;o k(x, f(h(x)))&#10;</pre>&#10;<p>Isto significa que o valor da chamada de recurs&atilde;o &eacute; modificado ap&oacute;s sua computa&ccedil;&atilde;o. Em Prolog, esta fun&ccedil;&atilde;o pode ser implementada assim:</p>&#10;<p />&#10;&#10;<p>Recurs&atilde;o em n&atilde;o cauda usa um espa&ccedil;o linear na pilha, consequentemente evitado caso n&atilde;o seja necess&aacute;rio. Em alguns casos &eacute; poss&iacute;vel otimizar a implementa&ccedil;&atilde;o.&#10;Considere o esquema:</p>&#10;<pre>f(n): se n = 0 ent&atilde;o a sen&atilde;o k(n, f(n &shy; 1))&#10;</pre>&#10;<p>Isto pode ser escrito em Prolog usando recurs&atilde;o n&atilde;o em cauda:</p>&#10;<p />&#10;&#10;<p>Este c&oacute;digo requer espa&ccedil;o linear na pilha para guardar resultados tempor&aacute;rios de chamadas recursivas. Usando um acumulador, o c&oacute;digo abaixo pode ser escrito usando recurs&atilde;o em cauda:</p>&#10;<p />&#10;&#10;&#10;<a id="Avalia%C3%A7%C3%A3o" name="Avalia%C3%A7%C3%A3o"></a><h2> Avalia&ccedil;&atilde;o </h2>&#10;<p>Quando o interpretador recebe uma consulta, ele tenta encontrar predicados que se encaixam na consulta, sejam eles fatos diretos ou regras que possuem o termo consultado como conclus&atilde;o. Por exemplo:</p>&#10;<p />que em L&oacute;gica de Primeira ordem &eacute;: <span class="math">\forall</span>X<span class="math">\forall</span>Y<span class="math">\forall</span>Z((filho(X,Z)^filho(Y,Z))<span class="math">\rightarrow</span>irmaos(X,Y))&#10;<p />&#10;<p>De acordo com essa base, a seguinte consulta &eacute; avaliada como verdadeira:</p>&#10;<p />&#10;&#10;<p>O interpretador chega a esse resultado utilizando a regra <i>irmaos(X,Y)</i>, <a href="http://en.wikipedia.org/wiki/Unifica%C3%A7%C3%A3o" id="w">unificando</a> <i>ana</i> com <i>X</i> e <i>erica</i> com <i>Y</i>. Isso significa que a consulta pode ser expandida para <i>filho(ana,Z)</i>, <i>filho(erica,Z)</i>. A <a href="http://en.wikipedia.org/wiki/Princ%C3%ADpio_da_resolu%C3%A7%C3%A3o" id="w">resolu&ccedil;&atilde;o</a> dessa conjun&ccedil;&atilde;o &eacute; feita procurando&shy;se todos os pais poss&iacute;veis para <i>ana</i>. Entretanto, <i>filho(ana,marcia)</i> n&atilde;o leva a uma solu&ccedil;&atilde;o vi&aacute;vel, porque se <i>Z</i> for substitu&iacute;do por <i>marcia</i>, <i>filho(erica,marcia)</i> deveria ser verdadeiro, e nenhum fato que afirma (ou alguma regra que pode satisfazer) isso est&aacute; presente. Ent&atilde;o, em vez disso <i>Z</i> &eacute; sustitu&iacute;do por <i>tomas</i>, descobrindo&shy;se que <i>erica</i> e <i>ana</i> s&atilde;o irm&atilde;os de qualquer forma. O c&oacute;digo&#10;</p>&#10;<p>pode parecer suspeito. Afinal, n&atilde;o s&oacute; pais tem filhos. No entanto esse c&oacute;digo significa, na verdade, que todo pai tem filhos (da mesma forma que a regra seguinte significa que toda m&atilde;e tem filhos). Para descobrir se algu&eacute;m &eacute; pai, pode&shy;se usar o c&oacute;digo</p>&#10;<p />&#10;<p>ou&#10;</p>&#10;<p>que simplesmente n&atilde;o se importa com quem &eacute; o filho (o underscore &eacute; uma vari&aacute;vel an&ocirc;nima).</p>&#10;<a id="Nega%C3%A7%C3%A3o" name="Nega%C3%A7%C3%A3o"></a><h3> Nega&ccedil;&atilde;o </h3>&#10;<p>Tipicamente, uma consulta &eacute; avaliada como falsa no caso de n&atilde;o estar presente nenhuma regra positiva ou fato que d&ecirc; suporte ao termo proposto. Isso &eacute; chamado <a href="http://en.wikipedia.org/wiki/Hip%C3%B3tese_do_mundo_fechado" id="w">hip&oacute;tese do mundo fechado</a>&semi; assume&shy;se que tudo o que &eacute; importante saber est&aacute; na base de dados, de modo que n&atilde;o existe um mundo exterior que pode possuir evid&ecirc;ncias desconhecidas. Em outras palavras, se um fato n&atilde;o &eacute; conhecido ser verdadeiro (ou falso), assume&shy;se que ele &eacute; falso.</p>&#10;<p>Uma regra como</p>&#10;<p />&#10;&#10;<p>pode ser avaliada somente pela busca exaustiva de todas as coisas que s&atilde;o ilegais e comparando elas com X, e se nenhum fato ilegal for descoberto ser o mesmo que X, X &eacute; legal. Isso &eacute; chamado <a href="http://en.wikipedia.org/wiki/Nega%C3%A7%C3%A3o_por_falha" id="w">nega&ccedil;&atilde;o por falha</a>. O operador prefixo \+/1 (muitos dialetos do Prolog possuem pr&eacute;&shy;definido o comando <i>not/1</i>) usado acima implementa a nega&ccedil;&atilde;o por falha em compiladores ISO Prolog.</p>&#10;<a id="Operadores_de_Controle" name="Operadores_de_Controle"></a><h2>Operadores de Controle</h2>&#10;&#10;<a id="Backtracking" name="Backtracking"></a><h3> Backtracking </h3>&#10;&#10;<p>Backtracking &eacute; um procedimento dentro da <a href="http://en.wikipedia.org/wiki/Linguagem" id="w">linguagem</a> Prolog. Uma busca inicial &#10;em um programa nesta linguagem segue o padr&atilde;o <a href="http://en.wikipedia.org/wiki/Busca_em_profundidade" id="w">Busca em profundidade</a> (<i>depth&shy;first search</i>), ou seja, a <a href="http://en.wikipedia.org/wiki/&Aacute;rvore" id="w">&aacute;rvore</a> &eacute; percorrida sistematicamente de cima para baixo e da esquerda para direita. Quando essa pesquisa falha, ou &eacute; encontrado um <a href="http://en.wikipedia.org/wiki/N%C3%B3_terminal_da_%C3%A1rvore" id="w">n&oacute; terminal da &aacute;rvore</a>, entra em funcionamento o mecanismo de backtracking. Esse procedimento faz com que o sistema retorne pelo mesmo caminho percorrido com a finalidade de encontrar solu&ccedil;&otilde;es alternativas.</p>&#10;<p>Exemplo:</p>&#10;<p>Considerando uma base de dados fam&iacute;lia, fazemos a seguinte consulta:</p>&#10;<p />&#10;&#10;<p>O compilador tenta satisfazer o primeiro objetivo. Quando conseguir, tenta satisfazer o segundo. Caso n&atilde;o consiga, ele retorna ao ponto onde encontrou a solu&ccedil;&atilde;o para o primeiro objetivo (<i>backtracking</i>).</p>&#10;<a id="Comando_''Cut''" name="Comando_''Cut''"></a><h3> Comando &#39&semi;&#39&semi;Cut&#39&semi;&#39&semi; </h3>&#10; &#10;<p>O comando <i>cut</i> permite indicar ao Prolog quais sub&shy;objetivos j&aacute; satisfeitos n&atilde;o necessitam ser reconsiderados ao se realizar um <a href="http://en.wikipedia.org/wiki/Backtracking" id="w">backtracking</a>. Isto &eacute;, ele aborta o processo de <a href="http://en.wikipedia.org/wiki/Backtracking" id="w">backtracking</a>.&#10;O uso do comando cut &eacute; importante porque permite que o programa rode mais r&aacute;pido, sem perder tempo com sub&shy;objetivos que n&atilde;o contribuem para determinar a resposta do objetivo principal. Al&eacute;m disso, o programa ocupar&aacute; menos mem&oacute;ria, pois n&atilde;o ser&aacute; necess&aacute;rio armazenar todos os sub&shy;objetivos considerados (pontos do backtracking). Em alguns casos, o cut evita que o programa entre em <a href="http://en.wikipedia.org/wiki/La%C3%A7o_infinito" id="w">la&ccedil;o infinito</a>.</p>&#10;<p />&#10;&#10;<p>Exemplo (o c&oacute;digo abaixo faz a consulta ao banco e para na primeira ocorr&ecirc;ncia de filho do sexo masculino):</p>&#10;<p />&#10;&#10;<p>Algumas das principais aplica&ccedil;&otilde;es do cut s&atilde;o as seguintes:&#10;  &bull; Unifica&ccedil;&atilde;o de padr&otilde;es, de forma que quando um padr&atilde;o &eacute; encontrado os outros padr&otilde;es poss&iacute;&shy;veis s&atilde;o descartados&#10;  &bull; Na implementa&ccedil;&atilde;o da nega&ccedil;&atilde;o como regra de falha&#10;  &bull; Para eliminar da &aacute;rvore de pesquisa solu&ccedil;&otilde;es alternativas quando uma s&oacute; &eacute; suficiente&#10;  &bull; Para encerrar a pesquisa quando a continua&ccedil;&atilde;o iria conduzir a uma pesquisa infinita, etc.</p>&#10;<p>Sintaticamente o uso do cut em uma cl&aacute;usula tem a apar&ecirc;ncia de um objetivo sem nenhum argumento,&#10;representado por um ponto de exclama&ccedil;&atilde;o &#34&semi;!&#34&semi;.</p>&#10;<a id="Comando_''Fail''" name="Comando_''Fail''"></a><h3> Comando &#39&semi;&#39&semi;Fail&#39&semi;&#39&semi; </h3>&#10;&#10;<p>Inversamente ao comando <i>cut</i>, o predicado pr&eacute;&shy;definido <i>fail</i> sempre falha. O operador de corte pode ser combinado com o predicado <i>fail</i> para produzir uma falha for&ccedil;ada. &#10;Uma conjun&ccedil;&atilde;o de objetivos da forma</p>&#10;<p />&#10;&#10;<p>&eacute; usada para informar ao PROLOG: <i>se a execu&ccedil;&atilde;o chegou at&eacute; esse ponto, ent&atilde;o pode abandonar a tentativa de satisfazer a regra</i>. A conjun&ccedil;&atilde;o falha devido ao <i>fail</i>, e o objetivo&shy;pai falha devido ao corte.</p>&#10;<p>Exemplo (Ana gosta de mam&iacute;feros exceto de gatos):</p>&#10;<p />&#10;&#10;<a id="Execu%C3%A7%C3%A3o" name="Execu%C3%A7%C3%A3o"></a><h2> Execu&ccedil;&atilde;o </h2>&#10;<p>Prolog &eacute; uma linguagem de <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_l%C3%B3gica" id="w">programa&ccedil;&atilde;o l&oacute;gica</a>, portanto em teoria o programador n&atilde;o deveria ter de se preocupar com o modo como ela executa. Entretanto, &agrave;s vezes &eacute; prudente levar em conta como o <a href="http://en.wikipedia.org/wiki/Princ%C3%ADpio_da_resolu%C3%A7%C3%A3o" id="w">algoritmo de infer&ecirc;ncia</a> funciona, para evitar que o programa Prolog execute por um tempo denecessariamente longo (ou mesmo infinito).</p>&#10;<p>Por exemplo, pode&shy;se escrever um c&oacute;digo para contar o n&uacute;mero de elementos em uma lista.</p>&#10;<p />&#10;&#10;<p>Isso simplesmente diz:&#10;Se a lista est&aacute; vazia, o n&uacute;mero de elementos &eacute; zero.&#10;Se a lista n&atilde;o &eacute; vazia, ent&atilde;o X &eacute; um a mais que Y, que por sua vez &eacute; o n&uacute;mero de elementos no restante da lista, exclu&iacute;do&shy;se seu primeiro elemento.</p>&#10;<p>Nesse caso, existe uma distin&ccedil;&atilde;o clara entre os casos no antecedente das regras. Mas no caso a seguir, onde se decide por continuar ou n&atilde;o jogando em um cassino:</p>&#10;<p />&#10;&#10;<p>Se voc&ecirc; tem dinheiro, voc&ecirc; continua jogando. Se voc&ecirc; perdeu todo o dinheiro, voc&ecirc; precisa pegar emprestado, ou ent&atilde;o n&atilde;o &eacute; poss&iacute;vel jogar mais.&#10;temdinheiro(X) pode ser uma fun&ccedil;&atilde;o muito custosa &shy; por exemplo, ela pode acessar sua conta de banco na internet para verificar seu saldo, o que leva tempo. Entretanto, o mesmo pode&shy;se dizer de temcredito(X).</p>&#10;<p>Em teoria, as implementa&ccedil;&otilde;es Prolog poderiam avaliar essas regras fora de ordem, de modo que elas poderiam ser escritas como:</p>&#10;<p />&#10;&#10;<p>Isso est&aacute; correto, porque as duas op&ccedil;&otilde;es se excluem mutuamente. Entretanto, verificar se voc&ecirc; precisa de um empr&eacute;stimo n&atilde;o &eacute; necess&aacute;rio se voc&ecirc; j&aacute; sabe que tem dinheiro. Ent&atilde;o, na pr&aacute;tica, implementa&ccedil;&otilde;es Prolog v&atilde;o verificar a primeira regra primeiro (de fato, a maioria delas vai sempre tentar as regras na ordem em que est&atilde;o presentes na base). Pode&shy;se usar o operador de corte para informar ao interpretador para n&atilde;o testar a segunda op&ccedil;&atilde;o se a primeira &eacute; suficiente.&#10;Por exemplo:</p>&#10;<p />&#10;&#10;<p>Isso &eacute; chamado um <i>operador de corte</i> <i>verde</i>. O ! simplesmente informa ao interpretador para parar de buscar por alternativas. Mas deve&shy;se notar que se voc&ecirc; precisa de um empr&eacute;stimo ser&aacute; necess&aacute;rio verificar a segunda regra, e isso ser&aacute; feito. Verificando o temdinheiro na segunda regra &eacute; desnecess&aacute;rio, j&aacute; que &eacute; conhecido o fato de que voc&ecirc; n&atilde;o tem, ou a segunda regra n&atilde;o seria sequer avaliada. Ent&atilde;o pode&shy;se modificar o c&oacute;digo para</p>&#10;<p />&#10;&#10;<p>Isso &eacute; chamado um <i>operador de corte</i> <i>vermelho</i>, porque &eacute; arriscado fazer isso. O programa agora depende da coloca&ccedil;&atilde;o correta do operador de corte e da ordem das regras para determinar seu significado l&oacute;gico. Acidentes de recorta&shy;e&shy;cola por exemplo s&atilde;o comuns e dif&iacute;ceis de detectar. Se as regras forem misturadas, voc&ecirc; pode terminar estourando seu cart&atilde;o de cr&eacute;dito antes de gastar seu dinheiro.</p>&#10;<a id="DCGs_e_parsing" name="DCGs_e_parsing"></a><h2> DCGs e parsing </h2>&#10;<p> </p>&#10;<p>Existe uma nota&ccedil;&atilde;o especial chamada <a href="http://en.wikipedia.org/wiki/Gram%C3%A1tica_de_cl%C3%A1usulas_definidas" id="w">gram&aacute;tica de cl&aacute;usulas definidas</a> (<i>definite clause grammar</i> &shy; DCGs). Uma regra definida via &shy;&shy;&#62&semi;/2 em vez de :&shy;/2 &eacute; expandida pelo pr&eacute;&shy;processador (expand_term/2, uma facilidade an&aacute;loga &agrave;s macros em outras linguagens) de acordo com algumas regras de reescrita, resultando em cl&aacute;usulas Prolog ordin&aacute;rias. DCGs s&atilde;o usadas para escrever <a href="http://en.wikipedia.org/wiki/Parser" id="w">parsers</a> e geradores de listas, e tamb&eacute;m prov&eacute;m uma interface conveniente para opera&ccedil;&otilde;es sobre diferen&ccedil;as de listas.</p>&#10;<a id="Exemplos_de_c%C3%B3digo" name="Exemplos_de_c%C3%B3digo"></a><h2> Exemplos de c&oacute;digo </h2>&#10;&#10;<p>Seguem alguns exemplos de programas escritos em ISO&shy;Prolog.</p>&#10;<a id="Quicksort" name="Quicksort"></a><h3> Quicksort </h3>&#10;<p />&#10;&#10;<a id="Torres_de_Hanoi" name="Torres_de_Hanoi"></a><h4> Torres de Hanoi </h4>&#10;&#10;<p />&#10;&#10;<a id="Mergesort" name="Mergesort"></a><h3> Mergesort </h3>&#10;&#10;<p />&#10;&#10;<a id="Implementa%C3%A7%C3%B5es" name="Implementa%C3%A7%C3%B5es"></a><h3> Implementa&ccedil;&otilde;es </h3>&#10;&#10;<ul>&#10;<li>LPA Prolog (<a class="externallink" href="http://www.lpa.co.uk/" rel="nofollow" title="http://www.lpa.co.uk/">http://www.lpa.co.uk/</a>)</li>&#10;<li>Open Prolog (<a class="externallink" href="http://www.cs.tcd.ie/open&shy;prolog/" rel="nofollow" title="http://www.cs.tcd.ie/open&shy;prolog/">http://www.cs.tcd.ie/open&shy;prolog/</a>)</li>&#10;<li>Ciao Prolog (<a class="externallink" href="http://www.clip.dia.fi.upm.es/Software/Ciao" rel="nofollow" title="http://www.clip.dia.fi.upm.es/Software/Ciao">http://www.clip.dia.fi.upm.es/Software/Ciao</a>)</li>&#10;<li>GNU Prolog (<a class="externallink" href="http://www.gprolog.org" rel="nofollow" title="http://www.gprolog.org">http://www.gprolog.org</a>)</li>&#10;<li>YAP Prolog (<a class="externallink" href="http://www.ncc.up.pt/~vsc/Yap" rel="nofollow" title="http://www.ncc.up.pt/~vsc/Yap">http://www.ncc.up.pt/~vsc/Yap</a>)</li>&#10;<li>SWI Prolog (<a class="externallink" href="http://www.swi&shy;prolog.org" rel="nofollow" title="http://www.swi&shy;prolog.org">http://www.swi&shy;prolog.org</a>)</li>&#10;<li>Strawberry Prolog (<a class="externallink" href="http://www.dobrev.com/" rel="nofollow" title="http://www.dobrev.com/">http://www.dobrev.com/</a>)</li>&#10;<li>SICStus Prolog (<a class="externallink" href="http://www.sics.se/sicstus/" rel="nofollow" title="http://www.sics.se/sicstus/">http://www.sics.se/sicstus/</a>)</li>&#10;<li>Amzi! Prolog (<a class="externallink" href="http://www.amzi.com/" rel="nofollow" title="http://www.amzi.com/">http://www.amzi.com/</a>)</li>&#10;<li>B&shy;Prolog (<a class="externallink" href="http://www.probp.com/" rel="nofollow" title="http://www.probp.com/">http://www.probp.com/</a>)</li>&#10;<li>tuProlog (<a class="externallink" href="http://tuprolog.sourceforge.net/" rel="nofollow" title="http://tuprolog.sourceforge.net/">http://tuprolog.sourceforge.net/</a>) &shy; C&oacute;digo Aberto integr&aacute;vel ao Java</li>&#10;<li>XSB (<a class="externallink" href="http://xsb.sourceforge.net/" rel="nofollow" title="http://xsb.sourceforge.net/">http://xsb.sourceforge.net/</a>)</li>&#10;<li>Trinc Prolog (<a class="externallink" href="http://www.trinc&shy;prolog.com" rel="nofollow" title="http://www.trinc&shy;prolog.com">http://www.trinc&shy;prolog.com</a>)</li>&#10;<li>hProlog ( <a class="externallink" href="http://www.cs.kuleuven.ac.be/~bmd/hProlog/" rel="nofollow" title="http://www.cs.kuleuven.ac.be/~bmd/hProlog/">http://www.cs.kuleuven.ac.be/~bmd/hProlog/</a> )</li>&#10;<li>ilProlog ( <a class="externallink" href="http://www.pharmadm.com/dmax.asp" rel="nofollow" title="http://www.pharmadm.com/dmax.asp">http://www.pharmadm.com/dmax.asp</a> )</li>&#10;<li>CxProlog ( <a class="externallink" href="http://ctp.di.fct.unl.pt/~amd/cxprolog/" rel="nofollow" title="http://ctp.di.fct.unl.pt/~amd/cxprolog/">http://ctp.di.fct.unl.pt/~amd/cxprolog/</a> )</li>&#10;<li>NanoProlog ( <a class="externallink" href="http://ctp.di.fct.unl.pt/~amd/cxprolog/" rel="nofollow" title="http://ctp.di.fct.unl.pt/~amd/cxprolog/">http://ctp.di.fct.unl.pt/~amd/cxprolog/</a> )</li>&#10;<li>Visual Prolog ( <a class="externallink" href="http://visual&shy;prolog.com/" rel="nofollow" title="http://visual&shy;prolog.com/">http://visual&shy;prolog.com/</a> )</li>&#10;<li>Jekejeke Prolog ( <a class="externallink" href="http://www.jekejeke.ch/" rel="nofollow" title="http://www.jekejeke.ch/">http://www.jekejeke.ch/</a> )</li></ul>&#10;<a id="Extens%C3%B5es" name="Extens%C3%B5es"></a><h2> Extens&otilde;es </h2>&#10;&#10;<ul>&#10;<li>Visual Prolog (<a class="externallink" href="http://www.visual&shy;prolog.com/" rel="nofollow" title="http://www.visual&shy;prolog.com/">http://www.visual&shy;prolog.com/</a>), tamb&eacute;m conhecido como PDC Prolog e Turbo Prolog.  Visual Prolog &eacute; um dialeto de Prolog fortemente tipado que &eacute; consideravelmente diferente do Prolog padr&atilde;o.  Foi desenvolvido e divulgado como Turbo Prolog enquanto sob controle da Borland, mas hoje &eacute; desenvolvido pela empresa Danish PDC (Prolog Development Center) que foi quem o criou.</li></ul>&#10;<a id="Refer%C3%AAncias" name="Refer%C3%AAncias"></a><h2> Refer&ecirc;ncias </h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://www.csse.monash.edu.au/~lloyd/tildeLogic/Prolog.toy/Examples/" rel="nofollow" title="http://www.csse.monash.edu.au/~lloyd/tildeLogic/Prolog.toy/Examples/">Runnable examples</a></li>&#10;<li><a class="externallink" href="http://ktiml.mff.cuni.cz/~bartak/prolog/testing.html" rel="nofollow" title="http://ktiml.mff.cuni.cz/~bartak/prolog/testing.html">A Prolog interpreter in a Java applet</a></li>&#10;<li><a class="externallink" href="http://pauillac.inria.fr/~deransar/prolog/docs.html" rel="nofollow" title="http://pauillac.inria.fr/~deransar/prolog/docs.html">Prolog: The ISO standard</a></li>&#10;<li><a class="externallink" href="http://www.visual&shy;prolog.com/vip6/tutorial/" rel="nofollow" title="http://www.visual&shy;prolog.com/vip6/tutorial/">Fundamental Prolog Tutorial</a></li>&#10;<li><a class="externallink" href="http://cs.wwc.edu/~cs_dept/KU/PR/Prolog.html" rel="nofollow" title="http://cs.wwc.edu/~cs_dept/KU/PR/Prolog.html">Prolog Tutorial</a></li>&#10;<li><a class="externallink" href="http://www.visual&shy;prolog.com/vip6/tutorial/" rel="nofollow" title="http://www.visual&shy;prolog.com/vip6/tutorial/">Visual Prolog Tutorial</a></li>&#10;<li><a class="externallink" href="http://www.visual&shy;prolog.com/vip6/community/examples.htm" rel="nofollow" title="http://www.visual&shy;prolog.com/vip6/community/examples.htm">Visual Prolog Examples</a></li>&#10;<li><a class="externallink" href="http://www.pdc.dk" rel="nofollow" title="http://www.pdc.dk">Prolog Development Center</a></li>&#10;<li><a class="externallink" href="http://www.lim.univ&shy;mrs.fr/~colmer/ArchivesPublications/HistoireProlog/19november92.pdf" rel="nofollow" title="http://www.lim.univ&shy;mrs.fr/~colmer/ArchivesPublications/HistoireProlog/19november92.pdf">Alain Colmerauer&#39&semi;s and Philippe Roussel&#39&semi;s account of the birth of Prolog</a></li>&#10;<li>BEBREGAL, Benjam&iacute;n Callejas&semi; ACIOLY, Benedito Melo. L&oacute;gica para Ci&ecirc;ncia da Computa&ccedil;&atilde;o, vers&atilde;o preliminar 2006.</li>&#10;<li> </li></ul>&#10;<p> </p>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;<p> </p>&#10;<p> &#10; </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_declarativas" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o declarativas</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:L%C3%B3gica" id="w">Categoria:L&oacute;gica</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Intelig%C3%AAncia_artificial" id="w">Categoria:Intelig&ecirc;ncia artificial</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_l%C3%B3gicas" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o l&oacute;gicas</a></p>&#10;<p> &#10; </p></body></html>