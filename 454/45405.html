<html><title>Chamada de procedimento remoto</title><body>&#10;<p> &#10;<b>Chamada remota de procedimento</b> (<b>RPC</b>, acr&ocirc;nimo de <i>Remote Procedure Call</i>) &eacute; uma tecnologia de <a href="http://en.wikipedia.org/wiki/Comunica%C3%A7%C3%A3o_entre_processos" id="w">comunica&ccedil;&atilde;o entre processos</a> que permite a um <a href="http://en.wikipedia.org/wiki/Programa_de_computador" id="w">programa de computador</a> chamar um <a href="http://en.wikipedia.org/wiki/Subrotina" id="w">procedimento</a> em outro <a href="http://en.wikipedia.org/wiki/Espa%C3%A7o_de_endere%C3%A7amento" id="w">espa&ccedil;o de endere&ccedil;amento</a> (geralmente em outro computador, conectado por uma <a href="http://en.wikipedia.org/wiki/Rede_de_computadores" id="w">rede</a>). O programador n&atilde;o se preocupa com detalhes de implementa&ccedil;&atilde;o dessa intera&ccedil;&atilde;o remota: do ponto de vista do c&oacute;digo, a chamada se assemelha a chamadas de procedimentos locais.</p>&#10;<p>RPC &eacute; uma tecnologia popular para a implementa&ccedil;&atilde;o do modelo <a href="http://en.wikipedia.org/wiki/Cliente&shy;servidor" id="w">cliente&shy;servidor</a> de <a href="http://en.wikipedia.org/wiki/Computa%C3%A7%C3%A3o_distribu%C3%ADda" id="w">computa&ccedil;&atilde;o distribu&iacute;da</a>. Uma chamada de procedimento remoto &eacute; iniciada pelo cliente enviando uma mensagem para um servidor remoto para executar um procedimento espec&iacute;fico. Uma resposta &eacute; retornada ao cliente. Uma diferen&ccedil;a importante entre chamadas de procedimento remotas e chamadas de procedimento locais &eacute; que, no primeiro caso, a chamada pode falhar por problemas da rede. Nesse caso, n&atilde;o h&aacute; nem mesmo garantia de que o procedimento foi invocado.</p>&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2>Hist&oacute;ria</h2>&#10;<p>A id&eacute;ia de RPC data de <a href="http://en.wikipedia.org/wiki/1976" id="w">1976</a>, quando foi descrito no RFC 707. Um dos primeiros usos comerciais da tecnologia foi feita pela <a href="http://en.wikipedia.org/wiki/Xerox" id="w">Xerox</a> no &#34&semi;Courier&#34&semi;, de <a href="http://en.wikipedia.org/wiki/1981" id="w">1981</a>. A primeira implementa&ccedil;&atilde;o popular para <a href="http://en.wikipedia.org/wiki/Unix" id="w">Unix</a> foi o Sun RPC (atualmente chamado <a href="http://en.wikipedia.org/wiki/ONC_RPC" id="w">ONC RPC</a>), usado como base do <a href="http://en.wikipedia.org/wiki/Network_File_System" id="w">Network File System</a> e que ainda &eacute; usada em diversas plataformas.</p>&#10;<p>Outra implementa&ccedil;&atilde;o pioneira em Unix foi o Network Computing System (NCS) da <a href="http://en.wikipedia.org/wiki/Apollo_Computer" id="w">Apollo Computer</a>, que posteriormente foi usada como funda&ccedil;&atilde;o do <a href="http://en.wikipedia.org/wiki/DCE/RPC" id="w">DCE/RPC</a> no <a href="http://en.wikipedia.org/wiki/Distributed_Computing_Environment" id="w">Distributed Computing Environment</a> (DCE). Uma d&eacute;cada depois a <a href="http://en.wikipedia.org/wiki/Microsoft" id="w">Microsoft</a> adotou o DCE/RPC como base para a sua pr&oacute;pria implementa&ccedil;&atilde;o de RPC, <a href="http://en.wikipedia.org/wiki/MSRPC" id="w">MSRPC</a>, a <a href="http://en.wikipedia.org/wiki/Distributed_Component_Object_Model" id="w">DCOM</a> foi implementada com base nesse sistema. Ainda no mesmo per&iacute;odo da d&eacute;cada de 1990, o <a href="http://en.wikipedia.org/wiki/ILU" id="w">ILU</a> da <a href="http://en.wikipedia.org/wiki/Xerox_PARC" id="w">Xerox PARC</a> e o <a href="http://en.wikipedia.org/wiki/CORBA" id="w">CORBA</a> ofereciam outro paradigma de RPC baseado em objetos distribu&iacute;dos, com mecanismos de heran&ccedil;a.</p>&#10;<p>De forma an&aacute;loga, atualmente utiliza&shy;se <a href="http://en.wikipedia.org/wiki/XML" id="w">XML</a> como <a href="http://en.wikipedia.org/wiki/Linguagem_de_descri%C3%A7%C3%A3o_de_interface" id="w">linguagem de descri&ccedil;&atilde;o de interface</a> e <a href="http://en.wikipedia.org/wiki/HTTP" id="w">HTTP</a> como <a href="http://en.wikipedia.org/wiki/Protocolo_de_rede" id="w">protocolo de rede</a> para formar <a href="http://en.wikipedia.org/wiki/Servi%C3%A7o_web" id="w">servi&ccedil;os web</a>, cujas implementa&ccedil;&otilde;es incluem <a href="http://en.wikipedia.org/wiki/SOAP" id="w">SOAP</a> e <a href="http://en.wikipedia.org/wiki/XML&shy;RPC" id="w">XML&shy;RPC</a>.</p>&#10;<a id="O_Modelo" name="O_Modelo"></a><h2>O Modelo</h2>&#10;<pre>O modelo de Chamada Remota de Procedimento &eacute; similar ao modelo de chamadas locais de procedimentos, no qual a rotina que invoca o procedimento coloca os argumentos em uma &aacute;rea de <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_(computador)" id="w">mem&oacute;ria</a> bem conhecida e transfere o controle para o procedimento em execu&ccedil;&atilde;o, que l&ecirc; os argumentos e os processa. Em algum momento, a rotina retoma o controle, extraindo o resultado da execu&ccedil;&atilde;o de uma &aacute;rea bem conhecida da mem&oacute;ria. Ap&oacute;s isso, a rotina prossegue com a execu&ccedil;&atilde;o normal.&#10;</pre>&#10;<p><div style="wigth:400px"><a class="internal" href="http://en.wikipedia.org/wiki/Image:400px&shy;ChamadaRemotaDeProcedimentoPassos.png" title="Sequ&ecirc;ncia de passos de uma chamada remota de procedimento."><img src="http://en.wikipedia.org/wiki/400px&shy;ChamadaRemotaDeProcedimentoPassos.png" alt="Sequ&ecirc;ncia de passos de uma chamada remota de procedimento." title="Sequ&ecirc;ncia de passos de uma chamada remota de procedimento." class="location&shy;none type&shy;thumb" width="400px" />&#10;</a>&#10;<div class="thumbcaption">Sequ&ecirc;ncia de passos de uma chamada remota de procedimento.</div></div>&#10;</p>&#10;<p>No modelo RPC, o processo de invoca&ccedil;&atilde;o ocorre de maneira similar. Uma <a href="http://en.wikipedia.org/wiki/Thread_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">Thread</a> &eacute; respons&aacute;vel pelo controle de dois <a href="http://en.wikipedia.org/wiki/Processo_(inform%C3%A1tica)" id="w">processos</a>: invocador e servidor. O processo invocador primeiro manda uma mensagem para o processo servidor e aguarda (bloqueia) uma mensagem de resposta. A mensagem de invoca&ccedil;&atilde;o cont&eacute;m os par&acirc;metros do procedimento e a mensagem de resposta cont&eacute;m o resultado da execu&ccedil;&atilde;o do procedimento. Uma vez que a mensagem de resposta &eacute; recebida, os resultados da execu&ccedil;&atilde;o do procedimento s&atilde;o coletados e a execu&ccedil;&atilde;o do invocador prossegue.</p>&#10;<p>Do lado do servidor, um processo permanece em espera at&eacute; a chegada de uma mensagem de invoca&ccedil;&atilde;o. Quando uma mensagem de invoca&ccedil;&atilde;o &eacute; recebida, o servidor extrai os par&acirc;metros, processa&shy;os e produz os resultados, que s&atilde;o enviados na mensagem de resposta. O servidor, ent&atilde;o, volta a esperar por uma nova mensagem de invoca&ccedil;&atilde;o.</p>&#10;<p>Nesse modelo, apenas um dos dois processos permanece ativo, em um dado instante de tempo. No entanto, esse modelo serve apenas de ilustra&ccedil;&atilde;o. O <a href="http://en.wikipedia.org/wiki/Protocolo_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">protocolo</a> <a href="http://en.wikipedia.org/wiki/ONC_RPC" id="w">ONC RPC</a> n&atilde;o faz restri&ccedil;&otilde;es &agrave; implementa&ccedil;&otilde;es que permitam <a href="http://en.wikipedia.org/wiki/Concorr%C3%AAncia_(inform%C3%A1tica)" id="w">concorr&ecirc;ncia</a> entre esses processos. Por exemplo, uma implementa&ccedil;&atilde;o poderia optar por chamadas ass&iacute;ncronas, que permitiriam ao cliente continuar com o trabalho &uacute;til, enquanto estivesse aguardando a mensagem de resposta.</p>&#10;<p>Uma chamada remota de procedimento difere das chamadas locais em alguns pontos:</p>&#10;&#10;<ol>&#10;<li><b>Tratamento de erros</b>: falhas do servidor ou da rede devem ser tratadas.</li>&#10;<li><b>Vari&aacute;veis globais e efeitos colaterais</b>: Uma vez que o servidor n&atilde;o possui acesso ao espa&ccedil;o de endere&ccedil;os do cliente, argumentos protegidos n&atilde;o podem ser passados como vari&aacute;veis globais ou retornados.</li>&#10;<li><b>Desempenho</b>: chamadas remotas geralmente operam a velocidades inferiores em uma ou mais ordens de grandeza em rela&ccedil;&atilde;o &agrave;s chamadas locais.</li>&#10;<li><b>Autentica&ccedil;&atilde;o</b>: uma vez que chamadas remotas de procedimento podem ser transportadas em redes sem seguran&ccedil;a, autentica&ccedil;&atilde;o pode ser necess&aacute;rio.</li></ol>&#10;<p>Dessa forma, mesmo havendo diversas ferramentas que geram automaticamente o cliente e o servidor, os protocolos precisam ser desenvolvidos cuidadosamente.</p>&#10;<a id="Sem%C3%A2ntica_de_Transporte" name="Sem%C3%A2ntica_de_Transporte"></a><h2> Sem&acirc;ntica de Transporte </h2>&#10;<p>O protocolo RPC pode ser implementado sobre diferentes tipos de <a href="http://en.wikipedia.org/wiki/Protocolo_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">protocolos</a> de transporte, uma vez que &eacute; indiferente a maneira de como uma mensagem &eacute; transmitida entre os processos. &Eacute; importante salientar que o protocolo RPC n&atilde;o implementa nenhuma forma de confiabilidade e que a <a href="http://en.wikipedia.org/wiki/Software_aplicativo" id="w">aplica&ccedil;&atilde;o</a> precisa tomar cuidados quanto ao tipo de protocolo sobre o qual RPC opera. Caso se trate de um protocolo confi&aacute;vel, como <a href="http://en.wikipedia.org/wiki/TCP" id="w">TCP</a>, as preocupa&ccedil;&otilde;es com <a href="http://en.wikipedia.org/wiki/Confiabilidade" id="w">confiabilidade</a> j&aacute; s&atilde;o resolvidas. Por outro lado, caso a <a href="http://en.wikipedia.org/wiki/Camada_de_transporte" id="w">camada de transporte</a> seja n&atilde;o&shy;confi&aacute;vel, como <a href="http://en.wikipedia.org/wiki/Protocolo_UDP" id="w">UDP</a>, mecanismos de <i>timeout</i>, retransmiss&atilde;o e detec&ccedil;&atilde;o de duplicatas devem ser implementados, uma vez que esses servi&ccedil;os n&atilde;o s&atilde;o providos por RPC.</p>&#10;<p>Devido &agrave; independ&ecirc;ncia da camada de transporte, o protocolo RPC n&atilde;o modifica a sem&acirc;ntica das chamadas remotas, nem seus requisitos de execu&ccedil;&atilde;o. A sem&acirc;ntica pode ser inferida a partir da camada de transporte em uso. Por exemplo, considere o caso em que RPC opera sobre uma camada de transporte n&atilde;o&shy;confi&aacute;vel, como UDP. Se uma aplica&ccedil;&atilde;o retransmite mensagens de invoca&ccedil;&atilde;o RPC, ap&oacute;s <i>timeouts</i>, e n&atilde;o recebe respostas, n&atilde;o pode inferir o n&uacute;mero de vezes em que o procedimento foi executado. Se uma mensagem &eacute; recebida, ela pode inferir que o procedimento foi executado, pelo menos, uma vez. O servidor pode efetuar o controle do n&uacute;mero de execu&ccedil;&otilde;es, simplesmente gravando o n&uacute;mero do &uacute;ltimo procedimento executado com &ecirc;xito, evitando assim reexecu&ccedil;&otilde;es de uma mesma chamada.</p>&#10;<p>Por outro lado, quando RPC opera sobre uma camada de transporte confi&aacute;vel, como TCP, a aplica&ccedil;&atilde;o pode inferir, a partir de uma mensagem de resposta, que o procedimento foi executado exatamente uma vez. No entanto, se nenhuma mensagem de reposta &eacute; recebida, a aplica&ccedil;&atilde;o n&atilde;o pode assumir que o procedimento n&atilde;o foi executado. Perceba que, mesmo usando um protocolo orientado a conex&otilde;es, aplica&ccedil;&otilde;es ainda requerem timeouts para identificar falhas do servidor.</p>&#10;<p>H&aacute;, ainda, muitas outras possibilidades de transporte al&eacute;m de datagramas e protocolos orientados a conex&atilde;o. Por exemplo, protocolos de consulta&shy;resposta como <a href="http://en.wikipedia.org/wiki/VMTP" id="w">VMTP</a> pode ser usado por TCP.</p>&#10;<a id="Implementando_RPC" name="Implementando_RPC"></a><h2> Implementando RPC </h2>&#10;<p>Para permitir que os servidores sejam acessados por diferentes clientes, diversos sistemas padronizados de RPC foram criados. A maioria deles usa uma <a href="http://en.wikipedia.org/wiki/Linguagem_de_descri%C3%A7%C3%A3o_de_interface" id="w">linguagem de descri&ccedil;&atilde;o de interface</a> (IDL) para que diferentes plataformas possam chamar procedimentos. Fazendo uso de uma ferramenta como o <a href="http://en.wikipedia.org/wiki/RPCGEN" id="w">RPCGEN</a>, pode&shy;se gerar interfaces entre cliente e servidor a partir de um arquivo IDL, os chamados <i>stubs</i>. Como os <i>stubs</i> s&atilde;o embarcados nas aplica&ccedil;&otilde;es cliente e servidor, a RPC n&atilde;o &eacute; uma camada de <a href="http://en.wikipedia.org/wiki/Middleware" id="w">middleware</a>.<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup></p>&#10;<p>Na codifica&ccedil;&atilde;o, o procedimento remoto do cliente chama o <i>stub</i> cliente como qualquer outro procedimento local, e a implementa&ccedil;&atilde;o interna do <i>stub</i> cliente &eacute; respons&aacute;vel por iniciar o processo de transmiss&atilde;o para <i>stub</i> servidor, empacotando a chamada numa mensagem. Ao chegar, o <i>stub</i> servidor desempacota a mensagem e invoca localmente o procedimento, aguardando o retorno. Quando a chamada local retorna, o <i>stub</i> servidor &eacute; respons&aacute;vel por iniciar o processo de transmiss&atilde;o para o <i>stub</i> cliente, empacotando a resposta numa mensagem. Chegando, a resposta &eacute; desempacotada pelo <i>stub</i> cliente, sendo retornada localmente para o procedimento que realizou a chamada remota.</p>&#10;<p>Ao invocar o procedimento remoto, deve&shy;se atentar que cliente e servidor podem ser plataformas diferentes, que representam dados de forma diferente. Nesse caso &eacute; preciso um protocolo comum de representa&ccedil;&atilde;o dos dados, como o <a href="http://en.wikipedia.org/wiki/External_Data_Representation" id="w">XDR</a>, ou a garantia de que ambas as partes saibam converter os dados para tipos de dado suportados. Por ser uma chamada remota, noutro espa&ccedil;o de endere&ccedil;amento, deve&shy;se atentar tamb&eacute;m o desafio de passar um <a href="http://en.wikipedia.org/wiki/Ponteiro_(programa%C3%A7%C3%A3o)" id="w">ponteiro</a>. Nesse caso, a implementa&ccedil;&atilde;o interna do RPC deve passar o conte&uacute;do do ponteiro por c&oacute;pia e restaurar a &aacute;rea de mem&oacute;ria no retorno do procedimento.</p>&#10;<a id="Limita%C3%A7%C3%B5es" name="Limita%C3%A7%C3%B5es"></a><h2>Limita&ccedil;&otilde;es</h2>&#10;<p>Diferentes implementa&ccedil;&otilde;es de chamada de procedimento remoto costumam ser incompat&iacute;veis entre si, ainda que existam exce&ccedil;&otilde;es. Por isso, o uso de uma determinada implementa&ccedil;&atilde;o, provavelmente, resultar&aacute; na depend&ecirc;ncia com o fornecedor da implementa&ccedil;&atilde;o. Essa incompatibilidade entre implementa&ccedil;&otilde;es se mostra tamb&eacute;m na disponibilidade de funcionalidades, no suporte a diferentes protocolos de rede e diferentes <a href="http://en.wikipedia.org/wiki/Sistema_de_arquivo" id="w">sistemas de arquivo</a>.</p>&#10;<p>A maioria das implementa&ccedil;&otilde;es n&atilde;o suporta <a href="http://en.wikipedia.org/wiki/P2P" id="w">P2P</a> e ou intera&ccedil;&atilde;o ass&iacute;ncrona entre cliente e servidor (por defini&ccedil;&atilde;o, a chamada remota corresponde a uma chamada local do ponto de vista da aplica&ccedil;&atilde;o, bloqueante da mesma forma). A comunica&ccedil;&atilde;o s&iacute;ncrona implica na disponibilidade constante tanto do cliente quanto do servidor.</p>&#10;<a id="Implementa%C3%A7%C3%B5es" name="Implementa%C3%A7%C3%B5es"></a><h2>Implementa&ccedil;&otilde;es</h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/CORBA" id="w">CORBA</a> &mdash; padr&atilde;o RPC <a href="http://en.wikipedia.org/wiki/Multiplataforma" id="w">independente de plataforma</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Sun_RPC" id="w">Sun RPC</a> &mdash; RPC para as plataformas <a href="http://en.wikipedia.org/wiki/Unix" id="w">Unix</a> e <a href="http://en.wikipedia.org/wiki/Linux" id="w">Linux</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/DCOM" id="w">DCOM</a> &mdash; RPC para <a href="http://en.wikipedia.org/wiki/Windows" id="w">Windows</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/RMI" id="w">RMI</a> &mdash; RPC para <a href="http://en.wikipedia.org/wiki/Plataforma_Java" id="w">Java</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/SOAP" id="w">SOAP</a> &mdash; padr&atilde;o RPC para <i><a href="http://en.wikipedia.org/wiki/Web_service" id="w">web service</a></i></li>&#10;<li><a class="externallink" href="https://www.jmasters.info:8443/jres/" rel="nofollow" title="https://www.jmasters.info:8443/jres/">JRES &shy; Java Remote Execution Service</a> &eacute; um protocolo RPC que usa um mecanismo de codifica&ccedil;&atilde;o estilo SSL para codificar suas chamadas e HTTP puro como mecanismo de transporte.</li></ul>&#10;<p> </p>&#10;<a id="Refer%C3%AAncias" name="Refer%C3%AAncias"></a><h2>Refer&ecirc;ncias</h2>&#10;&#10;<ul>&#10;<li>RFC 1057 &shy; ONC RPC vers&atilde;o 1</li>&#10;<li>RFC 1831 &shy; ONC RPC vers&atilde;o 2</li>&#10;<li><a class="externallink" href="http://www.cs.cf.ac.uk/Dave/C/node33.html|Remote" rel="nofollow" title="http://www.cs.cf.ac.uk/Dave/C/node33.html|Remote">Procedure Calls Tutorial (em ingl&ecirc;s)</a></li>&#10;<li> </li></ul>&#10;<a id="%7B%7BVer_tamb%C3%A9m%7D%7D" name="%7B%7BVer_tamb%C3%A9m%7D%7D"></a><h2> </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/XML&shy;RPC" id="w">XML&shy;RPC</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Middleware" id="w">Middleware</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Computa%C3%A7%C3%A3o_distribu%C3%ADda" id="w">Computa&ccedil;&atilde;o distribu&iacute;da</a></li></ul>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Chamada_de_procedimento_remoto" id="w"> </a></p></body></html>