<html><title>Merge sort</title><body>&#10;<p> </p>&#10;<p>O <b><i>merge sort</i></b>, ou <a href="http://en.wikipedia.org/wiki/Ordena%C3%A7%C3%A3o_(computa%C3%A7%C3%A3o)" id="w">ordena&ccedil;&atilde;o</a> por mistura, &eacute; um exemplo de <a href="http://en.wikipedia.org/wiki/Algoritmo_de_ordena%C3%A7%C3%A3o" id="w">algoritmo de ordena&ccedil;&atilde;o</a> do tipo <a href="http://en.wikipedia.org/wiki/Divis%C3%A3o_e_Conquista" id="w">dividir&shy;para&shy;conquistar</a>.</p>&#10;<p>Sua ideia b&aacute;sica consiste em Dividir(o problema em v&aacute;rios sub&shy;problemas e resolver esses sub&shy;problemas atrav&eacute;s da recursividade) e Conquistar(ap&oacute;s todos os sub&shy;problemas terem sido resolvidos ocorre a conquista que &eacute; a uni&atilde;o das resolu&ccedil;&otilde;es dos sub&shy;problemas).Como o algoritmo do Merge Sort usa a recursividade em alguns problemas esta t&eacute;cnica n&atilde;o &eacute; muito eficiente devido ao alto consumo de mem&oacute;ria e tempo de execu&ccedil;&atilde;o. </p>&#10;<p>Os tr&ecirc;s passos &uacute;teis dos algoritmos dividir&shy;para&shy;conquistar, ou <i>divide and conquer</i>, que se aplicam ao <i>merge sort</i> s&atilde;o:&#10;</p>&#10;<ol>&#10;<li>Dividir: Dividir os dados em subsequ&ecirc;ncias pequenas&semi;</li>&#10;<li>Conquistar: Classificar as duas metades recursivamente aplicando o <i>merge sort</i>&semi;</li>&#10;<li>Combinar: Juntar as duas metades em um &uacute;nico conjunto j&aacute; classificado.</li></ol>&#10;<a id="Caracter%C3%ADsticas" name="Caracter%C3%ADsticas"></a><h2> Caracter&iacute;sticas </h2>&#10;&#10;&#10;<ul>&#10;<li>Complexidade de tempo: &Theta;(n log<sub>2</sub> n)</li>&#10;<li>Complexidade de espa&ccedil;o: &Theta;(n)</li></ul>&#10;<a id="Observa%C3%A7%C3%B5es" name="Observa%C3%A7%C3%B5es"></a><h3> Observa&ccedil;&otilde;es </h3>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Merge&shy;sort&shy;example&shy;300px.gif%7Cthumb" id="w">Exemplo de execu&ccedil;&atilde;o do merge sort.</a></p>&#10;&#10;<ul>&#10;<li>&Eacute; poss&iacute;vel implementar o <i>merge sort</i> utilizando somente um vetor auxiliar ao longo de toda a execu&ccedil;&atilde;o, tornando assim a complexidade de espa&ccedil;o adicional igual a &Theta;(n log n).</li>&#10;<li>&Eacute; poss&iacute;vel tamb&eacute;m implementar o algoritmo com espa&ccedil;o adicional &Theta;(1)</li>&#10;<li>Algoritmo Criado por <a href="http://en.wikipedia.org/wiki/Von_Neumann" id="w">Von Neumann</a> em <a href="http://en.wikipedia.org/wiki/1945" id="w">1945</a>.</li></ul>&#10;<a id="Desvantagens" name="Desvantagens"></a><h3> Desvantagens </h3>&#10;&#10;<ul>&#10;<li>Utiliza fun&ccedil;&otilde;es recursivas</li>&#10;<li>Gasto extra de mem&oacute;ria, o algor&iacute;timo cria uma c&oacute;pia do vetor para cada n&iacute;vel da chamada recursiva, totalizando um uso adicional de mem&oacute;ria igual &aacute; (n log n)</li></ul>&#10;<a id="Implementa%C3%A7%C3%B5es" name="Implementa%C3%A7%C3%B5es"></a><h2> Implementa&ccedil;&otilde;es </h2>&#10;&#10;&#10;<a id="C%C3%B3digo_em_C" name="C%C3%B3digo_em_C"></a><h3>C&oacute;digo em C</h3>&#10;&#10;<p />&#10;&#10;<a id="C%C3%B3digo_em_C%2B%2B" name="C%C3%B3digo_em_C%2B%2B"></a><h3>C&oacute;digo em C++</h3>&#10;<p />&#10;&#10;<a id="%5B%5BActionScript_3%5D%5D" name="%5B%5BActionScript_3%5D%5D"></a><h3> [[ActionScript 3]] </h3>&#10;<p />&#10;&#10;<a id="%5B%5BHaskell%5D%5D" name="%5B%5BHaskell%5D%5D"></a><h3>[[Haskell]]</h3>&#10;<p />&#10;<pre>&#10;&#10;sort :: Ord a =&#62&semi; [a] &shy;&#62&semi; [a]&#10;&#10;sort []         =  []&#10;sort [x]        =  [x]&#10;sort xs         =  merge (sort ys) (sort zs)&#10;  where &#10;      (ys,zs) =  splitAt (length xs `div` 2) xs&#10;       merge [] y=y&#10;       merge x []=x&#10;       merge (x:xs) (y:ys)&#10;         | x &#60&semi;= y = x:merge xs (y:ys)&#10;         | otherwise = y:merge (x:xs) ys&#10;</pre>&#10;&#10;<a id="%5B%5BPython%5D%5D" name="%5B%5BPython%5D%5D"></a><h3>[[Python]]</h3>&#10;<p />&#10;&#10;<a id="%5B%5BRuby_(linguagem_de_programa%C3%A7%C3%A3o)%7CRuby%5D%5D" name="%5B%5BRuby_(linguagem_de_programa%C3%A7%C3%A3o)%7CRuby%5D%5D"></a><h3>[[Ruby (linguagem de programa&ccedil;&atilde;o)|Ruby]]</h3>&#10;&#10;<p />&#10;&#10;<a id="%5B%5BR_(linguagem_de_programa%C3%A7%C3%A3o)%7CR%5D%5D" name="%5B%5BR_(linguagem_de_programa%C3%A7%C3%A3o)%7CR%5D%5D"></a><h3>[[R (linguagem de programa&ccedil;&atilde;o)|R]]</h3>&#10;&#10;<p />&#10;<pre>&#10;mergesort=function(x){ # Fun&ccedil;&atilde;o que ir&aacute; quebrar a entrada ao meio cada vez que for acionada&#10;&#9;semisort=function(y,z){ #Fun&ccedil;&atilde;o que vai juntando ordenadamente as partes da entrada&#10;&#9;&#9;resultado=NULL&#10;&#9;&#9;while(length(y)&#62&semi;0 & length(z)&#62&semi;0){ # Enquanto tiver elemento nas duas partes que estou trabalhando&#10;&#9;&#9;&#9;if(y[1]&#60&semi;=z[1]){&#10;&#9;&#9;&#9;&#9;resultado=c(resultado,y[1])&#10;&#9;&#9;&#9;&#9;y=y[&shy;1] # Tira o primeiro elemento do vetor, j&aacute; que ele j&aacute; foi adicionado ao resultado&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;else{&#10;&#9;&#9;&#9;&#9;resultado=c(resultado,z[1])&#10;&#9;&#9;&#9;&#9;z=z[&shy;1] &#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;if(length(y)&#62&semi;0){ # A partir do momento que acaba os elementos em uma das metades, me resta &#34&semi;copiar&#34&semi; o que sobrou  da outra metade&#10;&#9;&#9;&#9;resultado=c(resultado,y)&#10;&#9;&#9;}&#10;&#9;&#9;if(length(z)&#62&semi;0){&#10;&#9;&#9;&#9;resultado=c(resultado,z)&#10;&#9;&#9;}&#10;&#9;&#9;return(resultado) # Retorna o resultado ordenado&#10;&#9;}&#10;&#9;tamanho=length(x) # Se a entrada tiver mais de um elemento, o algoritmo ir&aacute; &#34&semi;quebrar&#34&semi; a entrada ao &#34&semi;meio&#34&semi; para ordenar individualmente cada entrada e depois juntar as metades j&aacute; ordenadas&#10;&#9;if(tamanho&#62&semi;1){&#10;&#9;&#9;meio= tamanho/2&#10;&#9;&#9;esq=x[1:floor(meio)]&#10;&#9;&#9;dit=x[floor(meio+1):tamanho]&#10;&#9;&#9;esq=mergesort(esq) &#10;&#9;&#9;dit=mergesort(dit)&#10;&#9;&#9;if(esq[length(esq)]&#60&semi;=dit[1]){&#10;&#9;&#9;&#9;return(c(esq,dit))&#10;&#9;&#9;}&#10;&#9;&#9;else{&#10;&#9;&#9;&#9;semisort(esq,dit)&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;else{ # Se a entrada for um unico elemento, a ordena&ccedil;&atilde;o dela &eacute; trivial&#10;&#9;&#9;return(x)&#10;&#9;}&#10;}&#10;&#10;</pre>&#10;&#10;<a id="%5B%5BMiranda%5D%5D" name="%5B%5BMiranda%5D%5D"></a><h3>[[Miranda]]</h3>&#10;<p />&#10;<pre>&#10;sort []    = []&#10;sort [x]   = [x]&#10;sort array = merge (sort left) (sort right)&#10;             where&#10;               left  = [array!y | y &#60&semi;&shy; [0..mid]]&#10;               right = [array!y | y &#60&semi;&shy; [(mid+1)..max]]&#10;               max   = #array &shy; 1&#10;               mid   = max div 2&#10;</pre>&#10;&#10;<a id="%5B%5BMatlab%5D%5D" name="%5B%5BMatlab%5D%5D"></a><h3> [[Matlab]] </h3>&#10;<p />&#10;<pre>&#10;%exemplo de chamada&#10;inteiro_maximo = 10000&semi;&#10;tamanho_vetor=10000&semi;&#10;vetor_original=randi(inteiro_maximo,1,tamanho_vetor)&semi;&#10;a=mergesort(vetor_original)&semi;&#10;&#10;function ms=mergesort(vetor)&#10;    if length(vetor)&#62&semi;1&#10;      meio=int64(length(vetor)/2)&semi;&#10;      vetor=[mergesort(vetor(:,1:meio)) vetor(:,meio+1:end)]&semi;&#10;      vetor=[vetor(:,1:meio) mergesort(vetor(:,meio+1:end))]&semi;&#10;      vetor=mescla(vetor(:,1:meio),vetor(:,meio+1:end))&semi;&#10;    end&#10;    ms=vetor&semi;&#10;end&#10;&#10;function mc=mescla(vetor1,vetor2)&#10;i=1&semi;&#10;j=1&semi;&#10;vetor_final=[vetor1 vetor2]&semi;&#10;for k=1:(length(vetor1)+length(vetor2))&#10;    if vetor1(:,i)&#60&semi;vetor2(:,j)&#10;        vetor_final(:,k)=vetor1(i)&semi;&#10;        i=i+1&semi;&#10;        if i&#62&semi;length(vetor1)&#10;            while j&#60&semi;=length(vetor2)&#10;                k=k+1&semi;&#10;                vetor_final(:,k)=vetor2(j)&semi;&#10;                j=j+1&semi;&#10;            end&#10;            break&#10;        end&#10;    else&#10;        vetor_final(:,k)=vetor2(j)&semi;&#10;        j=j+1&semi;&#10;        if j&#62&semi;length(vetor2)&#10;            while i&#60&semi;=length(vetor1)&#10;                k=k+1&semi;&#10;                vetor_final(:,k)=vetor1(i)&semi;&#10;                i=i+1&semi;&#10;            end&#10;            break&#10;        end&#10;    end&#10;end&#10;mc=vetor_final&semi;&#10;end&#10;&#10;</pre>&#10;<a id="%5B%5BProlog%5D%5D" name="%5B%5BProlog%5D%5D"></a><h3> [[Prolog]] </h3>&#10;<p />&#10;<pre>&#10;&#10;split([], K, [], []).&#10;split(XS, K, [], XS)&#9;&#9;:&shy;&#10;&#9;K &#60&semi; 1.&#10;split([X|XS], K, [X|YS], ZS)&#9;:&shy;&#10;&#9;K &#62&semi;= 1,&#10;&#9;P is K &shy;1,&#10;&#9;split(XS, P, YS, ZS).&#10;&#10;merge1([], [], []).&#10;merge1(XS, [], XS).&#10;merge1([], YS, YS).&#10;merge1([X|XS], [Y|YS], [X|ZS])&#9;:&shy;&#10;&#9;X =&#60&semi; Y,&#10;&#9;merge1(XS, [Y|YS], ZS).&#10;merge1([X|XS], [Y|YS], [Y|ZS])&#9;:&shy;&#10;&#9;Y &#60&semi; X,&#10;&#9;merge1([X|XS], YS, ZS).&#10;&#10;mergesort([], []).&#10;mergesort([X], [X]).&#10;mergesort([X, Y], [X, Y])&#9;:&shy;&#10;&#9;X =&#60&semi; Y, !.&#10;mergesort([X, Y], [Y, X])&#9;:&shy;&#10;&#9;X &#62&semi; Y, !.&#10;mergesort(XS, ZS)&#9;&#9;:&shy;&#10;&#9;length(XS, L),&#10;&#9;L &#62&semi; 0,&#10;&#9;K is L / 2,&#10;&#9;split(XS, K, XS1, XS2),&#10;&#9;mergesort(XS1, YS1),&#10;&#9;mergesort(XS2, YS2),&#10;&#9;merge1(YS1, YS2, ZS), !.&#10;&#10;</pre>&#10;&#10;<a id="%7B%7BVer_tamb%C3%A9m%7D%7D" name="%7B%7BVer_tamb%C3%A9m%7D%7D"></a><h2>   </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Ordena%C3%A7%C3%A3o_de_vector" id="w">Ordena&ccedil;&atilde;o de vector</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Quick_sort" id="w">Quick sort</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Bubble_sort" id="w">Bubble sort</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Selection_sort" id="w">Selection sort</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Pesquisa_bin%C3%A1ria" id="w">Pesquisa bin&aacute;ria</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Sort&shy;merge_utility" id="w">sort&shy;merge utility</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Heapsort" id="w">Heapsort</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Shell_sort" id="w">Shell sort</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Radix_sort" id="w">Radix sort</a></li></ul>&#10;<a id="%7B%7BLiga%C3%A7%C3%B5es_externas%7D%7D" name="%7B%7BLiga%C3%A7%C3%B5es_externas%7D%7D"></a><h2> </h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://c2.com/cgi/wiki?MergeSort" rel="nofollow" title="http://c2.com/cgi/wiki?MergeSort">http://c2.com/cgi/wiki?MergeSort</a></li>&#10;<li><a class="externallink" href="http://www.codecodex.com/wiki/Merge_sort" rel="nofollow" title="http://www.codecodex.com/wiki/Merge_sort">Merge sort em 13 linguagens</a></li></ul>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos_de_ordena%C3%A7%C3%A3o" id="w">Categoria:Algoritmos de ordena&ccedil;&atilde;o</a></p>&#10;<p><a href="http://no.wikipedia.org/wiki/Sorteringsalgoritme">no:Sorteringsalgoritme</a></p></body></html>