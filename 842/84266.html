<html><title>Pesquisa bin&aacute;ria</title><body>&#10;<p> &#10;A <b>pesquisa</b> ou <b>busca bin&aacute;ria</b> (em <a href="http://en.wikipedia.org/wiki/L%C3%ADngua_inglesa" id="w">ingl&ecirc;s</a> <i>binary search algorithm</i> ou  <i>binary chop</i>) &eacute; um <a href="http://en.wikipedia.org/wiki/Algoritmo_de_busca" id="w">algoritmo de busca</a> em <a href="http://en.wikipedia.org/wiki/Vetor" id="w">vetores</a> que segue o paradigma de <a href="http://en.wikipedia.org/wiki/Divis%C3%A3o_e_conquista" id="w">divis&atilde;o e conquista</a>. Ela parte do pressuposto de que o vetor est&aacute; ordenado e realiza sucessivas divis&otilde;es do espa&ccedil;o de busca comparando o elemento buscado (chave) com o elemento no meio do vetor. Se o elemento do meio do vetor for a chave, a busca termina com sucesso. Caso contr&aacute;rio, se o elemento do meio vier antes do elemento buscado, ent&atilde;o a busca continua na metade posterior do vetor. E finalmente, se o elemento do meio vier depois da chave, a busca continua na metade anterior do vetor.</p>&#10;<a id="An%C3%A1lise_de_Complexidade" name="An%C3%A1lise_de_Complexidade"></a><h2>An&aacute;lise de Complexidade</h2>&#10;&#10;<p>A <a href="http://en.wikipedia.org/wiki/Complexidade" id="w">complexidade</a> desse <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmo</a> &eacute; da ordem de &Theta;(log<sub>2</sub> n), em que <i>n</i> &eacute; o tamanho do vetor de busca. Apresenta&shy;se mais eficiente que a <a href="http://en.wikipedia.org/wiki/Busca_linear" id="w">Busca linear</a> cuja ordem &eacute; O(n).</p>&#10;<a id="Pseudo&shy;C%C3%B3digo" name="Pseudo&shy;C%C3%B3digo"></a><h2>Pseudo&shy;C&oacute;digo</h2>&#10;&#10;<p>Um <a href="http://en.wikipedia.org/wiki/Pseudo&shy;c%C3%B3digo" id="w">pseudo&shy;c&oacute;digo</a> <a href="http://en.wikipedia.org/wiki/Algoritmo_recursivo" id="w">recursivo</a> para esse algoritmo, dados <code>V</code> o vetor com elementos compar&aacute;veis, <code>n</code> seu tamanho e <code>e</code> o elemento que se deseja encontrar:</p>&#10;<pre>BUSCA&shy;BIN&Aacute;RIA (V[], in&iacute;cio, fim, e)&#10;    i recebe o &iacute;ndice do meio entre in&iacute;cio e fim&#10;    se (v[i] = e) entao&#10;        devolva o &iacute;ndice i   # elemento e encontrado&#10;    fimse&#10;    se (inicio = fim) entao&#10;        n&atilde;o encontrou o elemento procurado &#10;    sen&atilde;o &#10;       se (V[i] vem antes de e) ent&atilde;o&#10;          fa&ccedil;a a BUSCA&shy;BIN&Aacute;RIA(V, i+1, fim, e)&#10;       sen&atilde;o&#10;          fa&ccedil;a a BUSCA&shy;BIN&Aacute;RIA(V, inicio, i&shy;1, e)&#10;       fimse&#10;    fimse&#10;&#10;</pre><a id="Implementa%C3%A7%C3%B5es" name="Implementa%C3%A7%C3%B5es"></a><h2>Implementa&ccedil;&otilde;es</h2>&#10;<a id="C%C3%B3digo_em_Ruby" name="C%C3%B3digo_em_Ruby"></a><h3>C&oacute;digo em Ruby</h3>&#10;<p />&#10;&#10;<a id="C%C3%B3digo_em_C" name="C%C3%B3digo_em_C"></a><h3>C&oacute;digo em C</h3>&#10;<p />&#10;<p>Obs: A linguagem <a href="http://en.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">C</a> fornece a fun&ccedil;&atilde;o <code><a href="http://en.wikipedia.org/wiki/Bsearch" id="w">bsearch</a></code><sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup> na sua <a href="http://en.wikipedia.org/wiki/Stdlib.h" id="w">biblioteca padr&atilde;o</a>.</p>&#10;<a id="%5B%5BJava%5D%5D" name="%5B%5BJava%5D%5D"></a><h3> [[Java]] </h3>&#10;<p /><pre class="code">&#10;<b><font color="#7F0055">public</font></b> <b><font color="#7F0055">static</font></b> <b><font color="#7F0055">int</font></b> buscaBinaria( <b><font color="#7F0055">int</font></b>[] tabela, <b><font color="#7F0055">int</font></b> valor ) {&#10;&#10;    <b><font color="#7F0055">boolean</font></b> achou = <b><font color="#7F0055">false</font></b>&semi;&#10;    <b><font color="#7F0055">int</font></b> alto = tabela.length &shy; 1&semi;&#10;    <b><font color="#7F0055">int</font></b> baixo = 0&semi;&#10;    <b><font color="#7F0055">int</font></b> meio = alto / 2&semi;&#10;&#10;    <b><font color="#7F0055">while</font></b> (!achou &#38&semi;&#38&semi; alto &#62&semi;= baixo) {&#10;        <b><font color="#7F0055">if</font></b> (valor == tabela[meio]) {&#10;            achou = <b><font color="#7F0055">true</font></b>&semi;&#10;        } <b><font color="#7F0055">else</font></b> <b><font color="#7F0055">if</font></b> (valor &#60&semi; tabela[meio]) {&#10;            alto = meio &shy;1&semi;&#10;        } <b><font color="#7F0055">else</font></b> {&#10;            baixo = meio + 1&semi;&#10;        }&#10;        meio = (alto + baixo) / 2&semi;&#10;    }&#10;    <b><font color="#7F0055">return</font></b> ( (achou) ? meio : &shy;1)&semi;&#10;}&#10;</pre>&#10;&#10;<a id="C%C3%B3digo_em_python" name="C%C3%B3digo_em_python"></a><h3>C&oacute;digo em python</h3>&#10;&#10;<p />&#10;&#10;<a id="C%C3%B3digo_em_C%23" name="C%C3%B3digo_em_C%23"></a><h3>C&oacute;digo em C#</h3>&#10;<p /><pre class="code">&#10;<b><font color="#7F0055">static</font></b> int pesquisaBinaria(int[] vetor, int chave)&#10;    {&#10;    <font color="#3F7F5F">//Ordena o vetor.&#10;</font>    Array.Sort(vetor)&semi;&#10;&#10;    int meio&semi;&#10;    int Min = 0&semi;&#10;    int Max = vetor.Length &shy; 1&semi;&#10;&#10;    <b><font color="#7F0055">do</font></b>&#10;        {&#10;        meio = (int)(Min + Max) / 2&semi;&#10;        <b><font color="#7F0055">if</font></b> (vetor[meio] == chave)&#10;            {&#10;            <font color="#3F7F5F">//Retorna a posi&ccedil;&atilde;o do n&uacute;mero na seq&uuml;encia.&#10;</font>            <b><font color="#7F0055">return</font></b> meio&semi;&#10;            }&#10;        <b><font color="#7F0055">else</font></b> <b><font color="#7F0055">if</font></b> (chave &#62&semi; vetor[meio])&#10;            Min = meio + 1&semi;&#10;        <b><font color="#7F0055">else</font></b>&#10;            Max = meio &shy; 1&semi;&#10;        }&#10;    <b><font color="#7F0055">while</font></b> (Min &#60&semi;= Max)&semi;&#10;&#10;    <font color="#3F7F5F">//Caso o retorno for &shy;1, ent&atilde;o o n&uacute;mero n&atilde;o existe na seq&uuml;encia.&#10;</font>    <b><font color="#7F0055">return</font></b> &shy;1&semi;&#10;    }&#10;&#10;</pre>&#10;&#10;<a id="C%C3%B3digo_em_Pascal" name="C%C3%B3digo_em_Pascal"></a><h3>C&oacute;digo em Pascal</h3>&#10;<p />&#10;&#10;<a id="C%C3%B3digo_Recursivo_em_Pascal" name="C%C3%B3digo_Recursivo_em_Pascal"></a><h3>C&oacute;digo Recursivo em Pascal</h3>&#10;<p />&#10;&#10;<a id="C%C3%B3digo_em_Lua" name="C%C3%B3digo_em_Lua"></a><h3>C&oacute;digo em Lua</h3>&#10;<p />&#10;&#10;<a id="C%C3%B3digo_em_Scheme" name="C%C3%B3digo_em_Scheme"></a><h3>C&oacute;digo em Scheme</h3>&#10;<p />&#10;&#10;<a id="C%C3%B3digo_em_PHP" name="C%C3%B3digo_em_PHP"></a><h3>C&oacute;digo em PHP</h3>&#10;<p /><pre class="code">&#10;<b><font color="#7F0055">function</font></b> buscaBinaria($valorPesquisa, <b><font color="#7F0055">array</font></b> $vetor) {&#10;&#10;&#9;$n_elementos = count($vetor)&semi;&#10;&#9;$inicio = 0&semi; $fim = $n_elementos &shy;1&semi; $meio = (int) (($fim &shy; $inicio) / 2) + $inicio&semi;&#10;&#10;&#9;<b><font color="#7F0055">while</font></b> ($inicio &#60&semi;= $fim) {&#10;&#9;&#9;<b><font color="#7F0055">if</font></b> ($vetor[$meio] &#60&semi; $valorPesquisa) {&#10;&#9;&#9;&#9;$inicio = $meio + 1&semi;&#10;&#9;&#9;} <b><font color="#7F0055">elseif</font></b> ($vetor[$meio] &#62&semi; $valorPesquisa) {&#10;&#9;&#9;&#9;$fim = $meio &shy; 1&semi;&#10;&#9;&#9;} <b><font color="#7F0055">else</font></b> {&#10;&#9;&#9;&#9;<b><font color="#7F0055">return</font></b> $meio&semi;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;$meio = (int) (($fim &shy; $inicio) / 2) + $inicio&semi;&#10;&#9;&#10;&#9;}&#10;&#10;&#9;<b><font color="#7F0055">return</font></b> &shy;1&semi;&#10;}&#10;&#10;$a = <b><font color="#7F0055">array</font></b>(1, 2, 3, 4, 5, 6)&semi;&#10;&#10;<b><font color="#7F0055">print</font></b> <font color="#2A00FF">&#34&semi;call buscaBinaria(4, [1, 2, 3, 4, 5, 6])&semi; return: &#34&semi;</font>&semi; var_dump(buscaBinaria(4, $a))&semi;&#10;<b><font color="#7F0055">print</font></b> <font color="#2A00FF">&#34&semi;call buscaBinaria(6, [1, 2, 3, 4, 5, 6])&semi; return: &#34&semi;</font>&semi; var_dump(buscaBinaria(6, $a))&semi;&#10;<b><font color="#7F0055">print</font></b> <font color="#2A00FF">&#34&semi;call buscaBinaria(1, [1, 2, 3, 4, 5, 6])&semi; return: &#34&semi;</font>&semi; var_dump(buscaBinaria(1, $a))&semi;&#10;<b><font color="#7F0055">print</font></b> <font color="#2A00FF">&#34&semi;call buscaBinaria(8, [1, 2, 3, 4, 5, 6])&semi; return: &#34&semi;</font>&semi; var_dump(buscaBinaria(8, $a))&semi;&#10;</pre>&#10;&#10;<a id="C%C3%B3digo_em_VB.Net" name="C%C3%B3digo_em_VB.Net"></a><h3>C&oacute;digo em VB.Net</h3>&#10;<p />&#10;&#10;<p> </p>&#10;<a id="%7B%7BLiga%C3%A7%C3%B5es_externas%7D%7D" name="%7B%7BLiga%C3%A7%C3%B5es_externas%7D%7D"></a><h2> </h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://www.go.senac.br/faculdade" rel="nofollow" title="http://www.go.senac.br/faculdade">Tecnologia da Informa&ccedil;&atilde;o &shy; Goi&acirc;nia &shy; GO</a> </li>&#10;<li><a class="externallink" href="http://www.ime.usp.br/~pf/algoritmos/aulas/bubi2.html" rel="nofollow" title="http://www.ime.usp.br/~pf/algoritmos/aulas/bubi2.html">Projeto de Algoritmos &shy; Paulo Feofiloff &shy;IME&shy;USP</a> </li>&#10;<li><a class="externallink" href="http://www.nist.gov/dads/HTML/binarySearch.html" rel="nofollow" title="http://www.nist.gov/dads/HTML/binarySearch.html">NIST Dicion&aacute;rio de Algoritmos e Estrutura de Dados :binary search</a></li>&#10;<li>Tim Bray. <a class="externallink" href="http://www.tbray.org/ongoing/When/200x/2003/03/22/Binary" rel="nofollow" title="http://www.tbray.org/ongoing/When/200x/2003/03/22/Binary">&#39&semi;&#39&semi;On the Goodness of Binary Search&#39&semi;&#39&semi;</a>. Pequeno ensaio das vantagens da busca bin&aacute;ria e exemplo de c&oacute;digo em Java.</li>&#10;<li><a class="externallink" href="http://www.datastructures.info/what&shy;is&shy;a&shy;binary&shy;seach&shy;algorithm&shy;and&shy;how&shy;does&shy;it&shy;work/" rel="nofollow" title="http://www.datastructures.info/what&shy;is&shy;a&shy;binary&shy;seach&shy;algorithm&shy;and&shy;how&shy;does&shy;it&shy;work/">Explana&ccedil;&atilde;o e c&oacute;digo da busca bin&aacute;ria em C++</a></li>&#10;<li><a class="externallink" href="http://googleresearch.blogspot.com/2006/06/extra&shy;extra&shy;read&shy;all&shy;about&shy;it&shy;nearly.html" rel="nofollow" title="http://googleresearch.blogspot.com/2006/06/extra&shy;extra&shy;read&shy;all&shy;about&shy;it&shy;nearly.html">&#39&semi;&#39&semi;Google Research: Nearly All Binary Searches and Mergesorts are Broken&#39&semi;&#39&semi;</a></li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos_de_busca" id="w">Categoria:Algoritmos de busca</a></p></body></html>