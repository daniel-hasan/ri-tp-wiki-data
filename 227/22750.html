<html><title>Coletor de lixo (inform&aacute;tica)</title><body>&#10;<p><b>Coletor de lixo</b> ( , ou o acr&ocirc;nimo GC) &eacute; um processo usado para a automa&ccedil;&atilde;o do <a href="http://en.wikipedia.org/wiki/Gerenciamento_de_mem%C3%B3ria" id="w">gerenciamento de mem&oacute;ria</a>. Com ele &eacute; poss&iacute;vel recuperar uma &aacute;rea de mem&oacute;ria inutilizada por um <a href="http://en.wikipedia.org/wiki/Programa_de_computador" id="w">programa</a>, o que pode evitar problemas de <a href="http://en.wikipedia.org/wiki/Vazamento_de_mem%C3%B3ria" id="w">vazamento de mem&oacute;ria</a>, resultando no esgotamento da mem&oacute;ria livre para aloca&ccedil;&atilde;o.</p>&#10;<p>Esse sistema contrasta com o gerenciamento manual de mem&oacute;ria, em que o programador deve especificar explicitamente quando e quais objetos devem ser desalocados e retornados ao sistema. Entretanto, muitos sistemas usam uma combina&ccedil;&atilde;o das duas abordagens.</p>&#10;<p>Foi inventado por <a href="http://en.wikipedia.org/wiki/John_McCarthy" id="w">John McCarthy</a> por volta de <a href="http://en.wikipedia.org/wiki/1959" id="w">1959</a> para resolver problemas de gerenciamento manual de mem&oacute;ria em <a href="http://en.wikipedia.org/wiki/Lisp_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Lisp</a>.<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup></p>&#10;<a id="Descri%C3%A7%C3%A3o" name="Descri%C3%A7%C3%A3o"></a><h2> Descri&ccedil;&atilde;o </h2>&#10;<p>Os princ&iacute;pios b&aacute;sicos do coletor de lixo s&atilde;o encontrar objetos de um programa que n&atilde;o ser&atilde;o mais acessados no futuro, e desalocar os recursos utilizados por tais objetos. Tornando a desaloca&ccedil;&atilde;o manual de mem&oacute;ria desnecess&aacute;ria, e geralmente proibindo tal pr&aacute;tica, o coletor de lixo livra o programador de se preocupar com a libera&ccedil;&atilde;o de recursos j&aacute; n&atilde;o utilizados, o que pode consumir uma parte significativa do desenvolvimento do software. Tamb&eacute;m evita que o programador introduza erros no programa devido a m&aacute; utiliza&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Ponteiro_(programa%C3%A7%C3%A3o)" id="w">ponteiros</a>.</p>&#10;<a id="Vantagens" name="Vantagens"></a><h3> Vantagens </h3>&#10;<p>O coletor de lixo livra o programador de lidar manualmente com o gerenciamento de mem&oacute;ria. Como resultado, certas categorias e <a href="http://en.wikipedia.org/wiki/Defeito_de_software" id="w">defeitos de software</a> s&atilde;o eliminadas ou reduzidas. Um dos problemas se refere ao <a href="http://en.wikipedia.org/wiki/Apontador_pendente" id="w">apontador pendente</a>, que ocorre quando um peda&ccedil;o de mem&oacute;ria &eacute; desalocado enquanto ainda h&aacute; ponteiros apontando para o objeto, e um desses ponteiros &eacute; usado. Outro problema &eacute; liberar uma regi&atilde;o de mem&oacute;ria mais de uma vez. Tamb&eacute;m h&aacute; certos tipos de <a href="http://en.wikipedia.org/wiki/Vazamento_de_mem%C3%B3ria" id="w">vazamento de mem&oacute;ria</a>, em que o programa deixa de desalocar mem&oacute;ria j&aacute; n&atilde;o usada de forma a chegar num ponto de esgotamento de mem&oacute;ria.</p>&#10;<p>H&aacute; uma distin&ccedil;&atilde;o entre vazamentos f&iacute;sicos e l&oacute;gicos de mem&oacute;ria. No vazamento f&iacute;sico, o &uacute;ltimo ponteiro para uma regi&atilde;o de mem&oacute;ria alocada &eacute; removido, mas a mem&oacute;ria n&atilde;o &eacute; desalocada. No vazamento l&oacute;gico, uma regi&atilde;o de mem&oacute;ria ainda &eacute; referenciada por um ponteiro, mas nunca ser&aacute; usada.<sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup> Coletores de lixo n&atilde;o conseguem reduzir o risco de vazamentos l&oacute;gicos, somente f&iacute;sicos.</p>&#10;<p>Em linguagens que provem aloca&ccedil;&atilde;o din&acirc;mica, o coletor de lixo &eacute; essencial para a <a href="http://en.wikipedia.org/wiki/Seguran%C3%A7a_de_mem%C3%B3ria" id="w">seguran&ccedil;a de mem&oacute;ria</a> e est&aacute; geralmente associado &agrave; propriedade de <a href="http://en.wikipedia.org/wiki/Seguran%C3%A7a_de_tipo" id="w">seguran&ccedil;a de tipo</a>.</p>&#10;<p>Em linguagens <a href="http://en.wikipedia.org/wiki/Orientadas_a_objetos" id="w">orientadas a objetos</a> onde o tempo de carga do objeto &eacute; muito alta o coletor pode conter um algoritmo para cache de objetos de forma a devolver objetos que costumam ser utilizados com frequ&ecirc;ncia sem precisar recri&aacute;&shy;los.</p>&#10;<a id="Desvantagens" name="Desvantagens"></a><h3> Desvantagens </h3>&#10;<p>Coletores de lixo tamb&eacute;m possuem suas desvantagens. Eles s&atilde;o processos que consomem recursos computacionais para decidir quais partes da mem&oacute;ria podem ser liberadas, enquanto no gerenciamento manual esse consumo &eacute; m&iacute;nimo. Outro ponto negativo &eacute; que o momento em que o objeto &eacute; realmente desalocado n&atilde;o &eacute; determin&iacute;stico, o que pode acarretar na varia&ccedil;&atilde;o do tempo de execu&ccedil;&atilde;o de algoritmo em partes aleat&oacute;rias, o que impens&aacute;vel em sistemas como em <a href="http://en.wikipedia.org/wiki/Tempo_real" id="w">tempo real</a>, <a href="http://en.wikipedia.org/wiki/Driver_de_dispositivo" id="w">drivers de dispositivo</a> e processamento de transa&ccedil;&otilde;es. Tamb&eacute;m, o uso de <a href="http://en.wikipedia.org/wiki/Recursividade_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">recursividade</a> atrasa  a desaloca&ccedil;&atilde;o autom&aacute;tica da mem&oacute;ria da pilha de execu&ccedil;&atilde;o at&eacute; que a &uacute;ltima chamada seja completada, aumentando os requisitos de mem&oacute;ria do algoritmo. Por fim, a detec&ccedil;&atilde;o sem&acirc;ntica de objetos a serem desalocados &eacute; um problema indecid&iacute;vel para qualquer processo autom&aacute;tico, devido ao <a href="http://en.wikipedia.org/wiki/Problema_da_parada" id="w">problema da parada</a>.</p>&#10;<a id="Uso_pr%C3%A1tico" name="Uso_pr%C3%A1tico"></a><h2> Uso pr&aacute;tico </h2>&#10;<p>Diversas <a href="http://en.wikipedia.org/wiki/Linguagem_de_computador" id="w">linguagens de computador</a> exigem o coletor de lixo, seja como parte da especifica&ccedil;&atilde;o da linguagem (como em <a href="http://en.wikipedia.org/wiki/Java_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Java</a> e <a href="http://en.wikipedia.org/wiki/C_Sharp" id="w">C#</a>) ou na implementa&ccedil;&atilde;o (como em linguagens formais tais quais <a href="http://en.wikipedia.org/wiki/C%C3%A1lculo_lambda" id="w">c&aacute;lculo lambda</a>). Outras linguagens foram desenvolvidas para suportar somente o gerenciamento manual de mem&oacute;ria, mas possuem implementa&ccedil;&otilde;es de coletor de lixo dispon&iacute;veis, como <a href="http://en.wikipedia.org/wiki/C%2B%2B" id="w">C++</a>.</p>&#10;<p>Para algumas linguagens, h&aacute; suporte para o gerenciamento manual ou autom&aacute;tico de mem&oacute;ria ao utilizar diferentes <a href="http://en.wikipedia.org/wiki/Mem%C3%B3ria_heap" id="w">mem&oacute;rias &#39&semi;&#39&semi;heap&#39&semi;&#39&semi;</a> para os objetos manuais ou autom&aacute;tcos, como em <a href="http://en.wikipedia.org/wiki/Ada_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Ada</a>. J&aacute; <a href="http://en.wikipedia.org/wiki/D_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">D</a> permite o coletor de lixo mas tamb&eacute;m a desaloca&ccedil;&atilde;o manual e desabilitar completamente o coletor.</p>&#10;<p> </p>&#10;<a id="Refer%C3%AAncias" name="Refer%C3%AAncias"></a><h2> Refer&ecirc;ncias </h2>&#10;&#10;<ul>&#10;<li> </li>&#10;<li> </li></ul>&#10;<a id="%7B%7BVer_tamb%C3%A9m%7D%7D" name="%7B%7BVer_tamb%C3%A9m%7D%7D"></a><h2>   </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Gerenciamento_de_mem%C3%B3ria" id="w">Gerenciamento de mem&oacute;ria</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Vazamento_de_mem%C3%B3ria" id="w">Vazamento de mem&oacute;ria</a></li></ul>&#10;<p> </p>&#10;<p> &#10;<a href="http://en.wikipedia.org/wiki/Categoria:Gerenciamento_de_mem%C3%B3ria" id="w">Categoria:Gerenciamento de mem&oacute;ria</a></p></body></html>