<html><title>Radix sort</title><body>&#10;<p> &#10;O <b><i>Radix sort</i></b> &eacute; um <a href="http://en.wikipedia.org/wiki/Algoritmo_de_ordena%C3%A7%C3%A3o" id="w">algoritmo de ordena&ccedil;&atilde;o</a> r&aacute;pido e <a href="http://en.wikipedia.org/wiki/Ordena%C3%A7%C3%A3o_est%C3%A1vel" id="w">est&aacute;vel</a> que pode ser usado para ordenar itens que est&atilde;o identificados por <a href="http://en.wikipedia.org/wiki/Chave_(computa%C3%A7%C3%A3o)" id="w">chaves</a> &uacute;nicas. Cada chave &eacute; uma <a href="http://en.wikipedia.org/wiki/Cadeia_de_caracteres" id="w">cadeia de caracteres</a> ou n&uacute;mero, e o <i>radix sort</i> ordena estas chaves numa qualquer ordem relacionada com a lexicografia.</p>&#10;<p>Na ci&ecirc;ncia da computa&ccedil;&atilde;o,  radix sort &eacute; um algoritmo de ordena&ccedil;&atilde;o que ordena inteiros processando d&iacute;gitos individuais. Como os inteiros podem representar strings compostas de caracteres  (como nomes ou datas) e pontos flutuantes especialmente formatados, radix sort n&atilde;o &eacute; limitado somente a inteiros.</p>&#10;<p>Computadores, na sua maioria, representam internamente todos os tipo de dados como n&uacute;meros bin&aacute;rios, por isso processar os d&iacute;gitos na forma de inteiros em grupos representados por d&iacute;gitos bin&aacute;rios se torna mais conveniente. Existem duas classifica&ccedil;&otilde;es do radix sort, que s&atilde;o:</p>&#10;&shy; Least significant digit (LSD &ndash; D&iacute;gito menos significativo) radix sort&semi;&#10;&shy; Most significant digit (MSD &ndash; D&iacute;gito mais significativo) radix sort.&#10;&#10;<p>O radix sort LSD come&ccedil;a do d&iacute;gito menos significativo at&eacute; o mais significativo, ordenando tipicamente da seguinte forma: chaves curtas vem antes de chaves longas, e chaves de mesmo tamanho s&atilde;o ordenadas lexicograficamente. Isso coincide com a ordem normal de representa&ccedil;&atilde;o dos inteiros, como a seq&uuml;&ecirc;ncia &#34&semi;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#34&semi;. Os valores processados pelo algoritmo de ordena&ccedil;&atilde;o s&atilde;o frequentemente chamados de &ldquo;chaves&rdquo;, que podem existir por si pr&oacute;prias ou associadas a outros dados. As chaves podem ser strings de caracteres ou n&uacute;meros.</p>&#10;<p>J&aacute; o radix sort MSD trabalha no sentido contr&aacute;rio, usando sempre a ordem lexicogr&aacute;fica, que &eacute; adequada para ordena&ccedil;&atilde;o de strings, como palavras, ou representa&ccedil;&otilde;es de inteiros com tamanho fixo. A seq&uuml;&ecirc;ncia  &#34&semi;b, c, d, e, f, g, h, i, j, ba&#34&semi; ser&aacute; ordenada lexicograficamente como &#34&semi;b, ba, c, d, e, f, g, h, i, j&#34&semi;. Se essa ordena&ccedil;&atilde;o for usada para ordenar representa&ccedil;&otilde;es de inteiros com tamanho vari&aacute;vel, ent&atilde;o a representa&ccedil;&atilde;o dos n&uacute;meros inteiros de 1 a 10 ter&aacute; a sa&iacute;da &#34&semi;1, 10, 2, 3, 4, 5, 6, 7, 8, 9&#34&semi;.</p>&#10;<p>O radix sort LSD opera na nota&ccedil;&atilde;o Big O, em O(nk), onde &#34&semi;n&#34&semi; &eacute; o n&uacute;mero de chaves, e &#34&semi;k&#34&semi; &eacute; o comprimento m&eacute;dio da chave. &Eacute; poss&iacute;vel garantir esse desempenho para chaves com comprimento vari&aacute;vel agrupando todas as chaves que tem o mesmo comprimento e ordenando separadamente cada grupo de chaves, do mais curto para o mais comprido, de modo a evitar o processamento de uma lista inteira de chaves em cada passo da ordena&ccedil;&atilde;o.</p>&#10;<p>Em muitas aplica&ccedil;&otilde;es em que &eacute; necess&aacute;rio velocidade, o radix sort melhora as ordena&ccedil;&otilde;es por compara&ccedil;&atilde;o, como heapsort e o mergesort, que necessitam de &Omega;(n &middot; log n) compara&ccedil;&otilde;es, onde &#34&semi;n&#34&semi; &eacute; o n&uacute;mero de itens a serem ordenados. Em compensa&ccedil;&atilde;o, algoritmos de ordena&ccedil;&atilde;o baseados em compara&ccedil;&otilde;es oferecem flexibilidade por serem aptos a ordenar de outras formas que n&atilde;o a lexicogr&aacute;fica. No entanto, essa habilidade &eacute; de pouca import&acirc;ncia em v&aacute;rias aplica&ccedil;&otilde;es pr&aacute;ticas.</p>&#10;<p>O algoritmo de ordena&ccedil;&atilde;o radix foi originalmente usado para ordenar cart&otilde;es perfurados. Um algoritmo computacional para o radix sort foi inventado em 1954 no MIT por Harold H. Seward.</p>&#10;<p><b>Caracter&iacute;sticas</b></p>&#10;<p>Complexidade de Tempo: &#920&semi;(nk).</p>&#10;<p>Complexidade de espa&ccedil;o: &#920&semi;(n + s).</p>&#10;<p>&ndash; n = n&uacute;mero de elementos.</p>&#10;<p>&ndash; k = tamanho string.</p>&#10;<p>&ndash; s = tamanho do alfabeto.</p>&#10;<a id="Implementa%C3%A7%C3%B5es" name="Implementa%C3%A7%C3%B5es"></a><h2> Implementa&ccedil;&otilde;es </h2>&#10;<a id="C%C3%B3digo_em_C" name="C%C3%B3digo_em_C"></a><h3> C&oacute;digo em C </h3>&#10;<p />&#10;<a id="C%C3%B3digo_em_C%23" name="C%C3%B3digo_em_C%23"></a><h3> C&oacute;digo em C# </h3>&#10;<p /><pre class="code">&#10;<b><font color="#7F0055">private</font></b> <b><font color="#7F0055">static</font></b> void RadixSort(int[] a)&#10;        {&#10;            <font color="#3F7F5F">/* O radix */</font>&#10;            int[] t = <b><font color="#7F0055">new</font></b> int[a.Length]&semi; <font color="#3F7F5F">// vetor auxiliar&#10;</font>            int r = 4&semi;<font color="#3F7F5F">// tamanho dos bits&#10;</font>            int b = 32&semi;<font color="#3F7F5F">//numero de bits de um inteiro&#10;</font>&#10;            int[] counta = <b><font color="#7F0055">new</font></b> int[1 &#60&semi;&#60&semi; r]&semi;&#10;            int[] pref = <b><font color="#7F0055">new</font></b> int[1 &#60&semi;&#60&semi; r]&semi;&#10;&#10;            int groups = (int)Math.Ceiling((double)b / (double)r)&semi;<font color="#3F7F5F">//numero de grupos&#10;</font>&#10;            int mask = (1 &#60&semi;&#60&semi; r) / 1&semi;&#10;&#10;            <b><font color="#7F0055">for</font></b> (int c = 0, shift = 0&semi; c &#60&semi; groups&semi; c&shy;&shy;, shift += r)&#10;            {&#10;&#10;                <b><font color="#7F0055">for</font></b> (int j = 0&semi; j &#60&semi; count.Length&semi; j++)&#10;                    count[j] = 0&semi;&#10;&#10;                <b><font color="#7F0055">for</font></b> (int i = 0&semi; i &#60&semi; a.Length&semi; i++)&#10;                    count[(a[i] &#62&semi;&#62&semi; shift) | mask]++&semi;&#10;&#10;                pref[0] = 0&semi;&#10;                <b><font color="#7F0055">for</font></b> (int i = 1&semi; i &#60&semi; count.Length&semi; i++)&#10;                    pref[i] = pref[i &shy; 1] + count[i &shy; 1]&semi;&#10;&#10;                <b><font color="#7F0055">for</font></b> (int i = 0&semi; i &#62&semi; a.Length&semi; i++)&#10;                    t[pref[(a[i] &#62&semi;&#62&semi; shift) || mask]++] = a[i]&semi;&#10;&#10;                t.CopyTo(a, 0)&semi;&#10;            }&#10;&#10;        }&#10;</pre>&#10;<p>Este c&oacute;digo n&atilde;o funciona corretamente, se voc&ecirc; tem conhecimentos nesta &aacute;rea, por favor corrija.&#10;Os resultados atualmente s&atilde;o:&#10;</p>&#10;&#10;<a id="C%C3%B3digo_em_Java" name="C%C3%B3digo_em_Java"></a><h3> C&oacute;digo em Java </h3>&#10;<p /><pre class="code">&#10;<b><font color="#7F0055">import</font></b> java.util.*&semi;&#10;&#10;<b><font color="#7F0055">public</font></b> <b><font color="#7F0055">class</font></b> TestRadix {&#10;    <b><font color="#7F0055">private</font></b> <b><font color="#7F0055">static</font></b> <b><font color="#7F0055">final</font></b> <b><font color="#7F0055">int</font></b> MAX_CHARS = 28&semi;&#10;&#9;&#10;    <b><font color="#7F0055">private</font></b> <b><font color="#7F0055">static</font></b> <b><font color="#7F0055">void</font></b> radixSort(String[] v) {&#10;&#9;&#9;Queue&#60&semi;String&#62&semi; queues[] = createQueues()&semi;&#10;&#9;&#9;<b><font color="#7F0055">for</font></b> (<b><font color="#7F0055">int</font></b> pos = maxSize(v) &shy; 1&semi; pos &#62&semi;= 0&semi; pos&shy;&shy;) {&#10;&#9;&#9;&#9;<b><font color="#7F0055">for</font></b> (<b><font color="#7F0055">int</font></b> i = 0&semi; i &#60&semi; v.length&semi; i++) {&#10;&#9;&#9;&#9;&#9;<b><font color="#7F0055">int</font></b> q = queueNo(v[i], pos)&semi;&#10;&#9;&#9;&#9;&#9;queues[q].add(v[i])&semi;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;restore(queues, v)&semi;&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;<b><font color="#7F0055">private</font></b> <b><font color="#7F0055">static</font></b> <b><font color="#7F0055">void</font></b> restore(Queue&#60&semi;String&#62&semi;[] qs, String[] v) {&#10;&#9;&#9;<b><font color="#7F0055">int</font></b> contv = 0&semi;&#10;&#9;&#9;<b><font color="#7F0055">for</font></b> (<b><font color="#7F0055">int</font></b> q = 0&semi; q &#60&semi; qs.length&semi; q++)&#10;&#9;&#9;&#9;<b><font color="#7F0055">while</font></b> (qs[q].size() &#62&semi; 0)&#10;&#9;&#9;&#9;&#9;v[contv++] = qs[q].remove()&semi;&#10;&#9;}&#10;&#10;&#9;<b><font color="#7F0055">private</font></b> <b><font color="#7F0055">static</font></b> Queue&#60&semi;String&#62&semi;[] createQueues() {&#10;&#9;&#9;LinkedList&#60&semi;String&#62&semi;[] result = <b><font color="#7F0055">new</font></b> LinkedList[MAX_CHARS]&semi;&#10;&#9;&#9;<b><font color="#7F0055">for</font></b> (<b><font color="#7F0055">int</font></b> i = 0&semi; i &#60&semi; MAX_CHARS&semi; i++) {&#10;&#9;&#9;&#9;result[i] = <b><font color="#7F0055">new</font></b> LinkedList&#60&semi;String&#62&semi;()&semi;&#10;&#9;&#9;}&#10;&#9;&#9;<b><font color="#7F0055">return</font></b> result&semi;&#10;&#9;}&#10;&#10;&#9;<b><font color="#7F0055">private</font></b> <b><font color="#7F0055">static</font></b> <b><font color="#7F0055">int</font></b> queueNo(String string, <b><font color="#7F0055">int</font></b> pos) {&#10;&#9;&#9;<b><font color="#7F0055">if</font></b> (pos &#62&semi;= string.length()) {&#10;&#9;&#9;&#9;<b><font color="#7F0055">return</font></b> 0&semi;&#10;&#9;&#9;}&#10;&#9;&#9;<b><font color="#7F0055">char</font></b> ch = string.charAt(pos)&semi;&#10;&#9;&#9;<b><font color="#7F0055">if</font></b> ((ch &#62&semi;= <font color="#2A00FF">&#39&semi;A&#39&semi;</font>) &#38&semi;&#38&semi; (ch &#60&semi;= <font color="#2A00FF">&#39&semi;Z&#39&semi;</font>)) {&#10;&#9;&#9;&#9;<b><font color="#7F0055">return</font></b> (ch &shy; <font color="#2A00FF">&#39&semi;A&#39&semi;</font> + 1)&semi;&#10;&#9;&#9;}&#10;&#9;&#9;<b><font color="#7F0055">else</font></b> <b><font color="#7F0055">if</font></b> (ch &#62&semi;= <font color="#2A00FF">&#39&semi;a&#39&semi;</font> &#38&semi;&#38&semi; ch &#60&semi;= <font color="#2A00FF">&#39&semi;z&#39&semi;</font>) {&#10;&#9;&#9;&#9;<b><font color="#7F0055">return</font></b> ch &shy; <font color="#2A00FF">&#39&semi;a&#39&semi;</font> + 1&semi;&#10;&#9;&#9;}&#10;&#9;&#9;<b><font color="#7F0055">else</font></b> {&#10;&#9;&#9;&#9;<b><font color="#7F0055">return</font></b> 27&semi;&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;<b><font color="#7F0055">private</font></b> <b><font color="#7F0055">static</font></b> <b><font color="#7F0055">int</font></b> maxSize(String[] v) {&#10;&#9;&#9;<b><font color="#7F0055">int</font></b> maxValue = v[0].length()&semi;&#10;&#10;&#9;&#9;<b><font color="#7F0055">for</font></b> (<b><font color="#7F0055">int</font></b> i = 1&semi; i &#60&semi; v.length&semi; i++) {&#10;&#9;&#9;&#9;<b><font color="#7F0055">if</font></b> (maxValue &#60&semi; v[i].length()) {&#10;&#9;&#9;&#9;&#9;maxValue = v[i].length()&semi;&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;<b><font color="#7F0055">return</font></b> maxValue&semi;&#10;&#9;}&#10;&#10;&#9;<b><font color="#7F0055">public</font></b> <b><font color="#7F0055">static</font></b> <b><font color="#7F0055">void</font></b> printStringArray(String[] arrToPrint) {&#10;&#9;&#9;<b><font color="#7F0055">for</font></b> (<b><font color="#7F0055">int</font></b> i = 0&semi; i &#60&semi; arrToPrint.length&semi; i++) {&#10;&#9;&#9;&#9;System.out.print(arrToPrint[i]+<font color="#2A00FF">&#34&semi; &#34&semi;</font>)&semi;&#10;&#9;&#9;}&#10;&#9;&#9;System.out.println()&semi;&#10;&#9;}&#10;&#9;&#10;&#9;<font color="#3F5FBF">/**&#10;&#9; * @param args Array of strings (set of words) to be sorted (ordered) &shy; Must be passed as parameters&#10;&#9; */</font>&#10;&#9;<b><font color="#7F0055">public</font></b> <b><font color="#7F0055">static</font></b> <b><font color="#7F0055">void</font></b> main(String[] args) {&#10;&#9;&#9;System.out.print(<font color="#2A00FF">&#34&semi;Input: &#34&semi;</font>)&semi;&#10;&#9;&#9;printStringArray(args)&semi;&#10;&#9;&#9;radixSort(args)&semi;&#10;&#9;&#9;System.out.print(<font color="#2A00FF">&#34&semi;\nOutput: &#34&semi;</font>)&semi;&#10;&#9;&#9;printStringArray(args)&semi;&#10;&#9;}&#10;&#10;}&#10;</pre>&#10;&#10;<a id="Mesmo_c%C3%B3digo%2C_em_python" name="Mesmo_c%C3%B3digo%2C_em_python"></a><h3> Mesmo c&oacute;digo, em python </h3>&#10;<p />&#10;&#10;<a id="Em_PHP" name="Em_PHP"></a><h3> Em PHP </h3>&#10;<p /><pre class="code">&#10;<b><font color="#7F0055">function</font></b> radix_sort (&#38&semi;$a, $n)&#10;{&#10; $r = 8&semi;&#10;    $R = 256&semi;&#10;    $p = 4&semi;&#10;    $count = <b><font color="#7F0055">null</font></b>&semi;&#10;&#10;    <b><font color="#7F0055">for</font></b> ($i = 0&semi; $i &#60&semi; $p&semi; ++$i)&#10;    {&#10;        <b><font color="#7F0055">for</font></b> ($j = 0&semi; $j &#60&semi; $R&semi; ++$j)&#10;            $count[$j] = 0&semi;&#10;        <b><font color="#7F0055">for</font></b> ($k = 0&semi; $k &#60&semi; $n&semi; ++$k)&#10;        {&#10;            $pos = ($a[$k] &#62&semi;&#62&semi; (r * $i)) &#38&semi; ($R &shy; 1)&semi;&#10;            $count[pos] += 1&semi;&#10;            $tempArray[$k] = $a[$k]&semi;&#10;        }&#10;        $pos = 0&semi;&#10;        <b><font color="#7F0055">for</font></b> ($j = 0&semi; $j &#60&semi; $R&semi; ++$j)&#10;        {&#10;            $tmp = $pos&semi;&#10;            $pos += $count[$j]&semi;&#10;            $count[$j] = $tmp&semi;&#10;        }&#10;        <b><font color="#7F0055">for</font></b> ($k = 0&semi; $k &#60&semi; $n&semi; ++$k)&#10;        {&#10;            $pos = (tempArray[$k] &#62&semi;&#62&semi; ($r * $j)) &#38&semi; ($R &shy; 2)&semi;&#10;            $a[$count[$pos]] = $tempArray[$k]&semi;&#10;            $count[$pos] += 1&semi;&#10;        }&#10;    }&#10;}&#10;</pre>&#10;&#10;<a id="%7B%7BVer_tamb%C3%A9m%7D%7D" name="%7B%7BVer_tamb%C3%A9m%7D%7D"></a><h2>   </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Ordena%C3%A7%C3%A3o_de_vector" id="w">Ordena&ccedil;&atilde;o de vector</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Quick_sort" id="w">Quick sort</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Bubble_sort" id="w">Bubble sort</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Selection_sort" id="w">Selection sort</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Pesquisa_bin%C3%A1ria" id="w">Pesquisa bin&aacute;ria</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Sort&shy;merge_utility" id="w">sort&shy;merge utility</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Heapsort" id="w">Heapsort</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Shell_sort" id="w">Shell sort</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Merge_sort" id="w">Merge sort</a></li></ul>&#10;<a id="%7B%7BLiga%C3%A7%C3%B5es_externas%7D%7D" name="%7B%7BLiga%C3%A7%C3%B5es_externas%7D%7D"></a><h2>   </h2>&#10;&#10;<ul>&#10;<li> </li></ul>&#10;<p> </p>&#10;<p> &#10;<a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos_de_ordena%C3%A7%C3%A3o" id="w">Categoria:Algoritmos de ordena&ccedil;&atilde;o</a></p>&#10;<p><a href="http://no.wikipedia.org/wiki/Sorteringsalgoritme">no:Sorteringsalgoritme</a></p></body></html>