<html><title>C Sharp</title><body>&#10;<p><i>Nota: O t&iacute;tulo correto deste artigo &eacute; <b>C#</b>. A substitui&ccedil;&atilde;o ou omiss&atilde;o do sinal <b><a href="http://en.wikipedia.org/wiki/Cerquilha" id="w">#</a></b> se deve por <a href="http://en.wikipedia.org/wiki/Wikip%C3%A9dia:Conven%C3%A7%C3%A3o_de_nomenclatura/Limita%C3%A7%C3%B5es_t%C3%A9cnicas#Caracteres exclu&iacute;dos" id="w">restri&ccedil;&otilde;es t&eacute;cnicas</a>.</i><br/>&#10; &#10; &#10;<b>C&#9839;</b>, tamb&eacute;m escrito como <b>C#</b> ou <b>C Sharp</b> (em <a href="http://en.wikipedia.org/wiki/L%C3%ADngua_portuguesa" id="w">portugu&ecirc;s</a> l&ecirc;&shy;se &#34&semi;c&ecirc; charp&#34&semi;), &eacute; uma <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagem de programa&ccedil;&atilde;o</a> <a href="http://en.wikipedia.org/wiki/Orienta%C3%A7%C3%A3o_a_objetos" id="w">orientada a objetos</a>, fortemente tipada, desenvolvida pela <a href="http://en.wikipedia.org/wiki/Microsoft" id="w">Microsoft</a> como parte da <a href="http://en.wikipedia.org/wiki/Microsoft_.NET" id="w">plataforma .NET</a>. A sua sintaxe orientada a objetos foi baseada no <a href="http://en.wikipedia.org/wiki/C%2B%2B" id="w">C++</a> mas inclui muitas influ&ecirc;ncias de outras linguagens de programa&ccedil;&atilde;o, como <a href="http://en.wikipedia.org/wiki/Object_Pascal" id="w">Object Pascal</a> e <a href="http://en.wikipedia.org/wiki/Java_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Java</a>.</p>&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2> Hist&oacute;ria </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Anders_Hejlsberg_at_PDC2008.jpg%7Cminiaturadaimagem" id="w">Anders Hejlsberg &shy; criador do C#.</a>&#10;A linguagem C# faz parte do conjunto de ferramentas oferecidas na plataforma .NET e surge como uma linguagem simples, robusta, orientada a objetos, fortemente tipada e altamente escal&aacute;vel a fim de permitir que uma mesma aplica&ccedil;&atilde;o possa ser executada em diversos dispositivos de <i>hardware</i>, independentemente destes serem PCs, <i>handhelds</i> ou qualquer outro dispositivo m&oacute;vel.</p>&#10;<p>O avan&ccedil;o das ferramentas de programa&ccedil;&atilde;o e dos dispositivos eletr&ocirc;nicos inteligentes, criou problemas e novas exig&ecirc;ncias. As novas vers&otilde;es de componentes compartilhados eram incompat&iacute;veis com o <i>software</i> antigo. Os desenvolvedores reconheceram a necessidade de <i>software</i> que fosse acess&iacute;vel para qualquer um e dispon&iacute;vel por meio de praticamente qualquer tipo de dispositivo. Para tratar dessas necessidades, a <i>Microsoft</i> anunciou sua iniciativa .NET e a linguagem de programa&ccedil;&atilde;o C#.<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup>  </p>&#10;<p>Durante o desenvolvimento da plataforma .NET, as <a href="http://en.wikipedia.org/wiki/Biblioteca_(computa%C3%A7%C3%A3o)" id="w">bibliotecas</a> foram escritas originalmente numa linguagem chamada <i>Simple Managed C</i> (SMC), que tinha um compilador pr&oacute;prio. Mas, em Janeiro de 1999, uma equipe de desenvolvimento foi formada por <a href="http://en.wikipedia.org/wiki/Anders_Hejlsberg" id="w">Anders Hejlsberg</a>, que fora escolhido pela <i>Microsoft</i> para desenvolver a linguagem. D&aacute;&shy;se inicio &agrave; cria&ccedil;&atilde;o da linguagem chamada <i>Cool</i>. Um pouco mais tarde, em 2000, o projeto .NET era apresentado ao p&uacute;blico na <i>Professional Developers Conference</i> (PDC), e a linguagem Cool fora renomeada e apresentada como C#.</p>&#10;<p>A cria&ccedil;&atilde;o da linguagem, embora tenha sido feita por v&aacute;rios programadores, &eacute; atribu&iacute;da principalmente a Anders, hoje um <i>Distinguished Engineer</i> na <a href="http://en.wikipedia.org/wiki/Microsoft" id="w">Microsoft</a>. Ele fora o arquiteto de alguns compiladores da <a href="http://en.wikipedia.org/wiki/Borland" id="w">Borland</a>, e entre suas cria&ccedil;&otilde;es mais conhecidas est&atilde;o o <a href="http://en.wikipedia.org/wiki/Turbo_Pascal" id="w">Turbo Pascal</a> e o <a href="http://en.wikipedia.org/wiki/Embarcadero_Delphi" id="w">Delphi</a>.</p>&#10;<p>A <a href="http://en.wikipedia.org/wiki/Microsoft" id="w">Microsoft</a> submeteu o C# &agrave; <a href="http://en.wikipedia.org/wiki/ECMA" id="w">ECMA</a> para uma <a href="http://en.wikipedia.org/wiki/Padr%C3%A3o" id="w">padroniza&ccedil;&atilde;o</a> formal. Em Dezembro de <a href="http://en.wikipedia.org/wiki/2001" id="w">2001</a> a associa&ccedil;&atilde;o liberou a especifica&ccedil;&atilde;o ECMA&shy;334 <i>Especifica&ccedil;&atilde;o da Linguagem C#</i>. Em <a href="http://en.wikipedia.org/wiki/2003" id="w">2003</a> tornou&shy;se um padr&atilde;o <a href="http://en.wikipedia.org/wiki/ISO" id="w">ISO</a> (ISO/IEC 23270). H&aacute; algumas implementa&ccedil;&otilde;es em desenvolvimento, destacando&shy;se a <a href="http://en.wikipedia.org/wiki/Mono_(projeto)" id="w">Mono</a>, implementa&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/Open_source" id="w">open source</a> da <a href="http://en.wikipedia.org/wiki/Novell_(empresa)" id="w">Novell</a>, o <a href="http://en.wikipedia.org/wiki/DotGNU" id="w">dotGNU</a> e o <a href="http://en.wikipedia.org/wiki/Portable.NET" id="w">Portable.NET</a>, implementa&ccedil;&otilde;es da <a href="http://en.wikipedia.org/wiki/Free_Software_Foundation" id="w">Free Software Foundation</a>, e o <a href="http://en.wikipedia.org/wiki/BDS" id="w">BDS</a> 2008, implementa&ccedil;&atilde;o da <a href="http://en.wikipedia.org/wiki/CodeGear" id="w">CodeGear</a>.</p>&#10;<a id="Etimologia" name="Etimologia"></a><h2> Etimologia </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Music_C_sharp.svg%7Cthumb%7C80px" id="w">A nota [[d&oacute;]] sustenido em [[clave de sol]].</a>&#10;Pensava&shy;se que o nome C# viria duma sobreposi&ccedil;&atilde;o de quatro s&iacute;mbolos <i><a href="http://en.wikipedia.org/wiki/+" id="w">+</a></i>, dando a impress&atilde;o de <i>++++</i>, uma alus&atilde;o &agrave; continua&ccedil;&atilde;o do <a href="http://en.wikipedia.org/wiki/C%2B%2B" id="w">C++</a>. Entretanto, o <i>#</i> de C# se refere ao sinal musical <a href="http://en.wikipedia.org/wiki/Sustenido" id="w">sustenido</a> (&#9839;), pronunciado <i>sharp</i> em ingl&ecirc;s, que aumenta em meio tom uma <a href="http://en.wikipedia.org/wiki/Nota_musical" id="w">nota musical</a>.<sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup></p>&#10;<p>Por&eacute;m, devido a limita&ccedil;&otilde;es t&eacute;cnicas (fontes padr&otilde;es, <a href="http://en.wikipedia.org/wiki/Navegador" id="w">navegadores</a>, etc) e o fato do s&iacute;mbolo do sustenido (&#9839;) n&atilde;o estar presente nos teclados, o cerquilha (#) foi escolhido para ser usado no nome escrito.<sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup> Essa conven&ccedil;&atilde;o &eacute; refletida no <i>ECMA&shy;334 C# Language Specification</i>, a especifica&ccedil;&atilde;o t&eacute;cnica da linguagem.<sup id="_ref&shy;4" class="reference"><a href="#_note&shy;4" title="">[4]</a></sup> Entretanto, em determinados lugares, como em propagandas e capas de livros, &eacute; usado o s&iacute;mbolo sustenido.<sup id="_ref&shy;5" class="reference"><a href="#_note&shy;5" title="">[5]</a></sup></p>&#10;<a id="Caracter%C3%ADsticas" name="Caracter%C3%ADsticas"></a><h2> Caracter&iacute;sticas </h2>&#10;<p>O C# &eacute; uma linguagem de programa&ccedil;&atilde;o visual dirigida por eventos e totalmente orientada a objetos. Permite um novo grau de interc&acirc;mbio entre linguagens (componentes de software de diferentes linguagens podem interagir). Os desenvolvedores podem empacotar at&eacute; software antigo, para trabalhar com novos programas C#. Al&eacute;m disso, os aplicativos C# podem interagir pela Internet usando padr&otilde;es do setor, como <i>SOAP</i> (protocolo de acesso a objetos simples) e <i>XML</i> (linguagem de marca&ccedil;&atilde;o extens&iacute;vel). </p>&#10;<p>O C# tem ra&iacute;zes em C, C++ e Java, adaptando os melhores recursos de cada linguagem e acrescentando novas capacidades pr&oacute;prias. Ele fornece os recursos que s&atilde;o mais importantes para os programadores, como programa&ccedil;&atilde;o orientada a objetos,<i>strings</i>, elementos gr&aacute;ficos, componentes de interface com o usu&aacute;rio gr&aacute;fica (GUI), tratamento de exce&ccedil;&otilde;es, m&uacute;ltiplas linhas de execu&ccedil;&atilde;o, multim&iacute;dia (&aacute;udio, imagens, anima&ccedil;&atilde;o e v&iacute;deo), processamento de arquivos, estruturas de dados pr&eacute;&shy;empacotadas, processamento de banco de dados, redes cliente/servidor com base na Internet e na <i>World Wide Web</i> e computa&ccedil;&atilde;o distribu&iacute;da.</p>&#10;<a id="Principais_caracter%C3%ADsticas_do_C%23" name="Principais_caracter%C3%ADsticas_do_C%23"></a><h3> Principais caracter&iacute;sticas do C# </h3>&#10;<p>Dentre as caracter&iacute;sticas essenciais do C# podemos citar:</p>&#10;&#10;<ul>&#10;<li>Simplicidade: os projetistas de C# costumam dizer que essa linguagem &eacute; t&atilde;o poderosa quanto o C++ e t&atilde;o simples quanto o <i>Visual Basic</i>&semi;</li>&#10;<li>Completamente orientada a objetos:  em C#, qualquer vari&aacute;vel tem de fazer parte de uma classe&semi;</li>&#10;<li>Fortemente tipada: isso ajudar&aacute; a evitar erros por manipula&ccedil;&atilde;o impr&oacute;pria de tipos e atribui&ccedil;&otilde;es incorretas&semi;</li>&#10;<li>Gera c&oacute;digo gerenciado: assim como o ambiente .NET &eacute; gerenciado, assim tamb&eacute;m &eacute; o C#&semi;</li>&#10;<li>Tudo &eacute; um objeto: <i>System.Object</i> &eacute; a classe base de todo o sistema de tipos de C#&semi;</li>&#10;<li>Controle de vers&otilde;es: cada <i>assembly</i> gerado, seja como <i>EXE</i> ou <i>DLL</i>, tem informa&ccedil;&atilde;o sobre a vers&atilde;o do c&oacute;digo, permitindo a coexist&ecirc;ncia de dois assemblies hom&ocirc;nimos, mas de vers&otilde;es diferentes no mesmo ambiente&semi;</li>&#10;<li>Suporte a c&oacute;digo legado: o C# pode interagir com c&oacute;digo legado de objetos COM e DLLs escritas em uma linguagem n&atilde;o&shy;gerenciada&semi;</li>&#10;<li>Flexibilidade: se o desenvolvedor precisar usar ponteiros, o C# permite, mas ao custo de desenvolver c&oacute;digo n&atilde;o&shy;gerenciado, chamado &ldquo;<i>unsafe</i>&rdquo;&semi;</li>&#10;<li>Linguagem gerenciada: os programas desenvolvidos em C# executam num ambiente gerenciado, o que significa que todo o gerenciamento de mem&oacute;ria &eacute; feito pelo <i>runtime</i> via o <i>GC (Garbage Collector</i>).<sup id="_ref&shy;6" class="reference"><a href="#_note&shy;6" title="">[6]</a></sup></li></ul>&#10;<a id="Tipos_de_dados" name="Tipos_de_dados"></a><h2> Tipos de dados </h2>&#10;<p>Os tipos de dados em C# s&atilde;o tipos de valor ou tipos de refer&ecirc;ncia. Uma vari&aacute;vel de tipo de valor cont&eacute;m dados desse tipo. Uma vari&aacute;vel de tipo de refer&ecirc;ncia cont&eacute;m o endere&ccedil;o da localiza&ccedil;&atilde;o na mem&oacute;ria em que os dados est&atilde;o armazenados. Os tipos de valor normalmente representam dados simples, como valores <i>int</i> ou <i>bool</i>. Os tipos de refer&ecirc;ncia, por outro lado, se referem a objetos, os quais podem conter muitos dados individuais.&#10;Os tipos de valor internos s&atilde;o os tipos integrais, os tipos de ponto flutuante e os tipos decimal e <i>bool</i>.  Os tipos de refer&ecirc;ncia internos s&atilde;o <i>string</i> e <i>object</i>. Os programadores tamb&eacute;m podem criar tipos de valor e tipos de refer&ecirc;ncia. Os tipos de refer&ecirc;ncia que os programadores podem criar s&atilde;o classes, interfaces e delegados. &#10;Existem dois tipos de convers&otilde;es no C#: impl&iacute;cita e expl&iacute;cita.&#10;Segundo seu escopo e disponibilidade, as vari&aacute;veis podem ser  do tipo <i>Static</i> (o valor fica dispon&iacute;vel para todos os objetos da classe em que a vari&aacute;vel foi declarada), <i>Instance</i> (criada na mem&oacute;ria cada vez que instanciamos um novo objeto) e <i>Array</i> (grupo de elementos do mesmo tipo de dado).</p>&#10;<a id="Classes" name="Classes"></a><h2> Classes </h2>&#10;<p>Em C#, a unidade de programa&ccedil;&atilde;o &eacute; a classe. Os objetos s&atilde;o eventualmente instanciados (criados) dessas classes, e as fun&ccedil;&otilde;es s&atilde;o encapsuladas dentro dos &ldquo;limites&rdquo; das classes como m&eacute;todos.&#10;Defini&ccedil;&otilde;es de classe C# n&atilde;o necessitam de arquivos de cabe&ccedil;alho ou arquivos separados (<i>IDL, Interface Definition Language</i>).&#10;Tamb&eacute;m permite interfaces, um meio de fazer um contrato com uma classe para processos que a interface determina. No C#, uma classe pode herdar de apenas um objeto pai (<i>parent</i>), mas uma classe pode implementar m&uacute;ltiplas interfaces. &#10;C# proporciona tamb&eacute;m um suporte a <i>structs</i> (estruturas). C# proporciona suporte total de <i>delegates</i> (delegados): para invoca&ccedil;&atilde;o de m&eacute;todos indiretamente. <i>Delegates</i> s&atilde;o refer&ecirc;ncia de tipos seguros que encapsulam m&eacute;todos com assinaturas e tipos de retorno espec&iacute;ficos.<sup id="_ref&shy;7" class="reference"><a href="#_note&shy;7" title="">[7]</a></sup></p>&#10;<a id="Classe_''Console''" name="Classe_''Console''"></a><h4> Classe &#39&semi;&#39&semi;Console&#39&semi;&#39&semi; </h4>&#10;<p>A classe <i>Console</i>, do <i>namespace System</i>, fornece suporte b&aacute;sico para leitura e escrita de caracteres. Os principais m&eacute;todos usados para essas funcionalidades s&atilde;o:&#10;</p>&#10;<ul>&#10;<li><i><code>Write</code></i>: escreve uma informa&ccedil;&atilde;o espec&iacute;fica em tela.</li>&#10;<li><i><code>WriteLine</code></i>: escreve uma informa&ccedil;&atilde;o espec&iacute;fica em tela e pula uma linha em seguida.</li>&#10;<li><i><code>ReadLine</code></i>: captura uma linha de texto digitada pelo usu&aacute;rio e retorna seu valor na forma de <i>string</i>.</li>&#10;<li><i><code>ReadKey</code></i>: captura um &uacute;nico caracter digitado pelo usu&aacute;rio. O retorno desse m&eacute;todo &eacute; um objeto da classe <i>ConsoleKeyInfo</i>, que cont&eacute;m informa&ccedil;&otilde;es sobre a tecla digitada pelo usu&aacute;rio.</li>&#10;<li><i><code>Clear</code></i>: esse m&eacute;todo limpa toda a tela do console. &Uacute;til para programas que exigem formata&ccedil;&atilde;o dos resultados.</li></ul>&#10;<a id="Classe_''Convert''" name="Classe_''Convert''"></a><h4> Classe &#39&semi;&#39&semi;Convert&#39&semi;&#39&semi; </h4>&#10;<p>Ao utilizar o m&eacute;todo <i>ReadLine</i> da classe Console, obtemos informa&ccedil;&atilde;o do usu&aacute;rio no formato <i>string</i>. Muita vezes precisamos converter o texto lido para outro tipo. Neste caso, podemos usar a Classe <i>Convert</i>, que fornece diversos m&eacute;todos para convers&atilde;o entre os tipos b&aacute;sicos de dados. Exemplo:   &#10;&#60&semi;syntaxhighlight lang=&#34&semi;CSharp&#34&semi;&#62&semi;&#10;int num&semi;&#10;string texto = &rdquo;2&rdquo;&semi;&#10;num = Convert.ToInt32 (texto)&semi;&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="Propriedades" name="Propriedades"></a><h2> Propriedades </h2>&#10;<p>Uma propriedade &eacute; o atributo de uma classe (o tamanho de uma <i>string</i>, por exemplo). Propriedades n&atilde;o denotam localiza&ccedil;&otilde;es de armazenamento mas cont&eacute;m declara&ccedil;&otilde;es execut&aacute;veis que s&atilde;o usadas para ler ou escrever o valor da propriedade. As propriedades podem ser dos tipos:&#10;</p>&#10;<ul>&#10;<li><i>static</i>: usamos o modificador static. N&atilde;o podemos nos referir a uma propriedade <i>static</i> usando <i>this</i>. Usamos apenas seu nome.</li>&#10;<li><i>instance</i>: &eacute; a propriedade padr&atilde;o. </li></ul>&#10;<p>Os acessores das propriedades s&atilde;o declara&ccedil;&otilde;es execut&aacute;veis que l&ecirc;em ou escrevem o valor de uma propriedade. S&atilde;o eles o <i>get</i> (&eacute; um m&eacute;todo sem nenhum par&acirc;metro que retorna o valor da propriedade) e <i>set</i> (m&eacute;todo que atribui o valor em uma propriedade).</p>&#10;<a id="M%C3%A9todos" name="M%C3%A9todos"></a><h2> M&eacute;todos </h2>&#10;<p>M&eacute;todo &eacute; um membro de uma classe que permite implementar uma a&ccedil;&atilde;o. Consiste de um cabe&ccedil;alho (cont&eacute;m um atributo, um modificador, um tipo de retorno, um nome do membro e uma lista formal de par&acirc;metros) e um corpo (bloco de declara&ccedil;&otilde;es).&#10;O C# inclui 8 modificadores: <sup id="_ref&shy;8" class="reference"><a href="#_note&shy;8" title="">[8]</a></sup></p>&#10;&#10;<div style="page&shy;break&shy;inside:&#9;avoid&semi;">&#10;<table class="wikitable">&#10;<tr>&#10;<td><i><code>new</code></i> </td>&#10;<td>O modificador new em um m&eacute;todo indica que o m&eacute;todo <br/> derivado &eacute; planejado para esconder o m&eacute;todo base</td></tr>&#10;<tr>&#10;<td><i><code>public</code></i> </td>&#10;<td>&Eacute; usado para garantir que um m&eacute;todo &eacute; acessado por todas<br/> as classes sem qualquer restri&ccedil;&atilde;o</td></tr>&#10;<tr>&#10;<td><i><code>static</code></i> </td>&#10;<td>O modificador static indica que o m&eacute;todo pertence somente<br/> ao tipo static e n&atilde;o pode referir&shy;se a m&eacute;todos non&shy;static ou vari&aacute;veis em uma classe</td></tr>&#10;<tr>&#10;<td><i><code>virtual</code></i> </td>&#10;<td>&Eacute; usado quando a implementa&ccedil;&atilde;o de um m&eacute;todo pode ser mudada por classes derivadas</td></tr>&#10;<tr>&#10;<td><i><code>sealed</code></i> </td>&#10;<td>Em um m&eacute;todo, previne uma classe derivada sobrescrever um m&eacute;todo</td></tr>&#10;<tr>&#10;<td><i><code>override</code></i> </td>&#10;<td>&Eacute; usado para modificar um m&eacute;todo de uma classe base na classe derivada</td></tr>&#10;<tr>&#10;<td><i><code>abstract</code></i> </td>&#10;<td>Em um m&eacute;todo, indica que o m&eacute;todo n&atilde;o cont&eacute;m implementa&ccedil;&atilde;o</td></tr>&#10;<tr>&#10;<td><i><code>extern</code></i></td>&#10;<td>Indica que o m&eacute;todo &eacute; implementado externamente</td></tr></table></div>&#10;&#10;<p>Os m&eacute;todos da classe Math permitem que o programador efetue certos c&aacute;lculos matem&aacute;ticos comuns. Os m&eacute;todos s&atilde;o chamados escrevendo&shy;se o nome do m&eacute;todo, seguido de um par&ecirc;ntese de abertura, do argumento (ou uma lista de argumentos separados por v&iacute;rgulas) do m&eacute;todo e um par&ecirc;ntese de fechamento. Exemplo: para calcular e imprimir a raiz quadrada de 900.0 podemos escrever:&#10;&#60&semi;syntaxhighlight lang=&#34&semi;CSharp&#34&semi;&#62&semi;&#10;Console.WriteLine ( Math.Sqrt ( 900.0 ) ) &semi;&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<p>O C# permite que v&aacute;rios m&eacute;todos de mesmo nome sejam definidos na mesma classe, desde que esses m&eacute;todos tenham diferentes conjuntos de par&acirc;metros (n&uacute;mero, tipos ou ordem dos par&acirc;metros). Isso &eacute; chamado sobrecarga de m&eacute;todos. Quando um m&eacute;todo sobrecarregado &eacute; chamado, o compilador C# seleciona o m&eacute;todo correto examinando o n&uacute;mero, os tipos e a ordem dos argumentos da chamada.</p>&#10;<a id="''Delegates''" name="''Delegates''"></a><h2> &#39&semi;&#39&semi;Delegates&#39&semi;&#39&semi; </h2>&#10;<p>&Eacute; um elemento que permite que voc&ecirc; fa&ccedil;a refer&ecirc;ncia a um m&eacute;todo. &Eacute; semelhante a um ponteiro de fun&ccedil;&atilde;o, mas sua diferen&ccedil;a se baseia em ser totalmente orientado a objetos encapsulando a inst&acirc;ncia de m&eacute;todo ou objeto.<sup id="_ref&shy;9" class="reference"><a href="#_note&shy;9" title="">[9]</a></sup></p>&#10;<p>O objeto de delega&ccedil;&atilde;o pode ser passado para o c&oacute;digo que pode chamar o m&eacute;todo referenciado sem ter que saber em tempo de compila&ccedil;&atilde;o qual m&eacute;todo ser&aacute; chamado. Usando <i>delegates</i> voc&ecirc; tem a flexibilidade para implementar qualquer funcionalidade em tempo de execu&ccedil;&atilde;o. A &uacute;nica restri&ccedil;&atilde;o &eacute; que o m&eacute;todo seja compat&iacute;vel com o tipo de declara&ccedil;&atilde;o do <i>delegate</i>, usando assim perfeitamente invoca&ccedil;&atilde;o an&ocirc;nima.&#10;<i>Delegates</i> possuem a seguintes propriedades: &#10;</p>&#10;<ul>&#10;<li>S&atilde;o como Ponteiros em C++, mas s&atilde;o do tipo seguro&semi;</li>&#10;<li>Permitem m&eacute;todos para serem passados por par&acirc;metros&semi; </li>&#10;<li>Podem ser usados para definir m&eacute;todos callback.<sup id="_ref&shy;10" class="reference"><a href="#_note&shy;10" title="">[10]</a></sup></li></ul>&#10;<p>Exemplo:&#10;&#60&semi;syntaxhighlight lang=&#34&semi;CSharp&#34&semi;&#62&semi;&#10;// Declare delegate &shy;&shy; defines required signature:&#10;delegate double MathAction (double num)&semi;&#10;class DelegateTest&#10;{&#10;// Regular method that matches signature:&#10;static double Double(double input)&#10;{&#10;return input * 2&semi;&#10;}&#10;static void Main()&#10;{&#10;// Instantiate delegate with named method:&#10;MathAction ma = Double&semi;&#10;// Invoke delegate ma:&#10;double multByTwo = ma(4.5)&semi;&#10;Console.WriteLine(&#34&semi;multByTwo: {0}&#34&semi;, multByTwo)&semi;&#10;// Instantiate delegate with anonymous method:&#10;MathAction ma2 = delegate(double input)&#10;{&#10;return input * input&semi;&#10;    }&semi;&#10;double square = ma2(5)&semi;&#10;Console.WriteLine(&#34&semi;square: {0}&#34&semi;, square)&semi;&#10;// Instantiate delegate with lambda expression&#10;MathAction ma3 = s =&#62&semi; s * s * s&semi;&#10;double cube = ma3(4.375)&semi;&#10;Console.WriteLine(&#34&semi;cube: {0}&#34&semi;, cube)&semi;&#10;}&#10;// Output:&#10;// multByTwo: 9&#10;// square: 25&#10;// cube: 83.740234375&#10;}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="Passagem_de_par%C3%A2metros" name="Passagem_de_par%C3%A2metros"></a><h2> Passagem de par&acirc;metros </h2>&#10;<p>Os tipos de par&acirc;metros s&atilde;o quatro:&#10;</p>&#10;<ul>&#10;<li>valor: corresponde a uma vari&aacute;vel local que recebe seu valor inicial do argumento fornecido quando um m&eacute;todo &eacute; chamado. Isto acontece porque um par&acirc;metro de valor declarado em um m&eacute;todo refere&shy;se &agrave; localiza&ccedil;&atilde;o da mem&oacute;ria diferente daquela do argumento chamado em um m&eacute;todo. </li>&#10;<li>refer&ecirc;ncia: um par&acirc;metro declarado com o modificador ref &eacute; chamado de par&acirc;metro de refer&ecirc;ncia. Diferente do par&acirc;metro de valor, o par&acirc;metro de refer&ecirc;ncia n&atilde;o cria uma nova localiza&ccedil;&atilde;o na mem&oacute;ria.  Refere&shy;se &agrave; mesma localiza&ccedil;&atilde;o de mem&oacute;ria do argumento chamado em um m&eacute;todo.</li>&#10;<li>sa&iacute;da: um par&acirc;metro declarado com o modificador out &eacute; um par&acirc;metro de sa&iacute;da. Par&acirc;metros de sa&iacute;da s&atilde;o usados em m&eacute;todos que retornam v&aacute;rios valores. Refere&shy;se &agrave; mesma localiza&ccedil;&atilde;o de mem&oacute;ria do argumento chamado em um m&eacute;todo. &Eacute; necess&aacute;rio atribuir um par&acirc;metro de sa&iacute;da antes do m&eacute;todo retornar um valor.</li>&#10;<li>params: um par&acirc;metro params pode ser um <i>array</i> de &uacute;nica dimens&atilde;o ou um <i>array</i> de v&aacute;rias dimens&otilde;es.</li></ul>&#10;<a id="''Namespace''" name="''Namespace''"></a><h2> &#39&semi;&#39&semi;Namespace&#39&semi;&#39&semi; </h2>&#10;<p>A palavra&shy;chave de <i>namespace</i> &eacute; usada para declarar um escopo que cont&eacute;m um conjunto de objetos relacionados. Voc&ecirc; pode usar um namespace para organizar elementos de c&oacute;digo e para criar globalmente tipos exclusivos.<sup id="_ref&shy;11" class="reference"><a href="#_note&shy;11" title="">[11]</a></sup>&#10;<sup id="_ref&shy;12" class="reference"><a href="#_note&shy;12" title="">[12]</a></sup>&#10;<sup id="_ref&shy;13" class="reference"><a href="#_note&shy;13" title="">[13]</a></sup>&#10;<sup id="_ref&shy;14" class="reference"><a href="#_note&shy;14" title="">[14]</a></sup>&#10;<sup id="_ref&shy;15" class="reference"><a href="#_note&shy;15" title="">[15]</a></sup></p>&#10;<p><i>Namespaces</i> possuem as principais propriedades:&#10;</p>&#10;<ul>&#10;<li>Usados para organizar c&oacute;digos de grandes projetos&semi;</li>&#10;<li>A diretiva <i>using</i> evita a necessidade de especificar o nome para cada classe&semi;</li>&#10;<li>H&aacute; sempre um <i>namespace</i> global que faz refer&ecirc;ncia ao <i>namespace System</i> do <i>.Netframework</i>.</li></ul>&#10;<a id="''Enum''" name="''Enum''"></a><h2> &#39&semi;&#39&semi;Enum&#39&semi;&#39&semi; </h2>&#10;<p><i>Enum</i> em C# &eacute; usado para declarar uma enumera&ccedil;&atilde;o, um tipo distinto que consiste em um conjunto de constantes nomeados lista de enumerador.</p>&#10;<p>Usados geralmente dentro de namespace para ser vis&iacute;vel para acesso das classes e usados dentro de classes e <i>structs</i>, sendo considerados constantes num&eacute;ricas.</p>&#10;<p>Por caracter&iacute;stica come&ccedil;a com 0 mas pode ser inicializado com outro valor.</p>&#10;<p>N&atilde;o devem conter espa&ccedil;o em branco em seu nome. E principalmente: se for atribu&iacute;do a uma vari&aacute;vel, deve ser feita uma convers&atilde;o expl&iacute;cita do tipo <i>enum</i> para o tipo da vari&aacute;vel tratada.&#10;Exemplo:&#10;&#60&semi;syntaxhighlight lang=&#34&semi;CSharp&#34&semi;&#62&semi;&#10;public class EnumTest2&#10;{&#10;enum Range : long { Max = 2147483648L, Min = 255L }&semi;&#10;static void Main()&#10;{&#10;long x = (long)Range.Max&semi;&#10;long y = (long)Range.Min&semi;&#10;Console.WriteLine(&#34&semi;Max = {0}&#34&semi;, x)&semi;&#10;Console.WriteLine(&#34&semi;Min = {0}&#34&semi;, y)&semi;&#10;}&#10;}&#10;/* Sa&iacute;da:&#10;Max = 2147483648&#10;Min = 255&#10;</p>&#10;<ul>&#10;<li>/</li></ul>&#10;<p>&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="Interface" name="Interface"></a><h2> Interface </h2>&#10;<p>Interfaces pertencem aos tipos de refer&ecirc;ncia, em que definem contratos que s&atilde;o implementados por uma classe ou estrutura (que a utiliza para simular heran&ccedil;a j&aacute; que n&atilde;o oferece suporte para herdar outra estrutura). Uma classe pode implementar m&uacute;ltiplas interfaces.<sup id="_ref&shy;16" class="reference"><a href="#_note&shy;16" title="">[16]</a></sup>&#10;<sup id="_ref&shy;17" class="reference"><a href="#_note&shy;17" title="">[17]</a></sup></p>&#10;<p>Uma Interface pode conter m&eacute;todos, propriedades, eventos e indexadores, mas n&atilde;o pode implementar seus m&eacute;todos.</p>&#10;<p>Principais Propriedades:</p>&#10;&#10;<ul>&#10;<li>Uma interface &eacute; como uma classe base abstrata. Qualquer classe ou estrutura que implementa a interface deve implementar todos os seus membros&semi;</li>&#10;<li>Uma interface n&atilde;o pode ser instanciada diretamente. Seus membros s&atilde;o implementados por qualquer classe ou estrutura que implementa a interface&semi;</li>&#10;<li>Interfaces podem conter eventos, indexadores, m&eacute;todos, propriedades&semi;</li>&#10;<li>As interfaces n&atilde;o cont&ecirc;m qualquer implementa&ccedil;&atilde;o dos m&eacute;todos&semi;</li>&#10;<li>Uma classe ou estrutura pode implementar interfaces m&uacute;ltiplas. Uma classe pode herdar uma classe base e tamb&eacute;m implementar uma ou mais interfaces.</li></ul>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;CSharp&#34&semi;&#62&semi;&#10;interface ISampleInterface&#10;{&#10;void SampleMethod()&semi;&#10;}&#10;class ImplementationClass : ISampleInterface&#10;{&#10;// implementa&ccedil;&atilde;o expl&iacute;cita do membro da interface:&#10;void ISampleInterface.SampleMethod()&#10;{&#10;// Implementa&ccedil;&atilde;o do M&eacute;todo.&#10;}&#10;static void Main()&#10;{&#10;// Inst&acirc;ncia da interface.&#10;ISampleInterface obj = new ImplementationClass()&semi;&#10;// Chamada do membro.&#10;obj.SampleMethod()&semi;&#10;}&#10;}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="''Iterador''" name="''Iterador''"></a><h2> &#39&semi;&#39&semi;Iterador&#39&semi;&#39&semi; </h2>&#10;<p><i>Iteradores</i> s&atilde;o utilizados para percorrer uma cole&ccedil;&atilde;o de dados como uma lista.</p>&#10;<p>O m&eacute;todo <i>iterator</i> &eacute; um <i>get</i> personalizado para cole&ccedil;&otilde;es, em C# usa&shy;se a declara&ccedil;&atilde;o de produzir retorno de um elemento de cada vez, como o operador <i>yield return</i> recordando o local atual do c&oacute;digo e retornando a executar no mesmo local para a pr&oacute;xima itera&ccedil;&atilde;o.</p>&#10;<p>Por meio do <i>foreach</i> um iterator pode retornar mais de um valor at&eacute; o fim do bloco ou quando o comando <i>yield break</i> for encontrado.&#10;Seus tipos de retorno mais usados s&atilde;o: <i>IEnumerable</i>, <i>IEnumerable&#60&semi;T&#62&semi;</i>, <i>IEnumerator ou IEnumerator&#60&semi;T&#62&semi;</i>.</p>&#10;<p>Exemplo:&#10;&#60&semi;syntaxhighlight lang=&#34&semi;CSharp&#34&semi;&#62&semi;&#10;static void Main()&#10;{&#10;foreach (int number inSomeNumbers())&#10;{&#10;Console.Write(number.ToString() + &#34&semi; &#34&semi;)&semi;&#10;}&#10;// Sa&iacute;da: 3 5 8&#10;Console.ReadKey()&semi;&#10;}&#10;public static System.Collections.IEnumerableSomeNumbers()&#10;{&#10;yieldreturn 3&semi;&#10;yieldreturn 5&semi;&#10;yieldreturn 8&semi;&#10;}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="Recursos_Visual_Studio" name="Recursos_Visual_Studio"></a><h2> Recursos Visual Studio </h2>&#10;<p>Sendo a principal IDE de desenvolvimento C# junto ao <i>.NetFramework</i> para compila&ccedil;&atilde;o dos projetos, a IDE foi evoluindo junto &agrave; linguagem, dando suporte para desenvolvimento de outras linguagens como VB, C++, ASP.NET, e arquivos de sistemas DLLs.</p>&#10;<p>C# 1.2 trouxe junto com a atualiza&ccedil;&atilde;o do .NetFramework 1.1 a possibilidade de desenvolvimento mobile por meio de recursos ASP.NET, o que foi a primeira grande mudan&ccedil;a da linguagem.</p>&#10;<a id="Principais_comandos" name="Principais_comandos"></a><h2> Principais comandos </h2>&#10;&#10;<ul>&#10;<li><i><code>if</code></i> : executa um bloco de c&oacute;digo com base no valor de uma express&atilde;o booleana&semi;</li>&#10;<li><i><code>goto</code></i> : transfere o controle para uma estrutura de comandos que &eacute; identificada por um r&oacute;tulo&semi;</li>&#10;<li><i><code>while</code></i> : executa condicionalmente o c&oacute;digo dentro do bloco <i>while</i> zero ou mais vezes&semi; </li>&#10;<li><i><code>do...while</code></i> : executa condicionalmente o c&oacute;digo dentro do <i>do</i> uma ou mais vezes&semi;</li>&#10;<li><i><code>for</code></i> : seu uso &eacute; recomendado quando sabemos a quantidade de repeti&ccedil;&otilde;es que devemos mostrar no console&semi;</li>&#10;<li><i><code>foreach</code></i> : percorre cada um dos elementos de um <i>array</i>&semi;</li>&#10;<li><i><code>switch</code></i> : executa o bloco de c&oacute;digo que &eacute; associado com o valor da express&atilde;o de controle.</li></ul>&#10;<a id="Cole%C3%A7%C3%B5es" name="Cole%C3%A7%C3%B5es"></a><h2> Cole&ccedil;&otilde;es </h2>&#10;<p>Cole&ccedil;&otilde;es s&atilde;o grupos de objetos de tipos semelhantes.  O gerenciamento da quantidade de objetos que as comp&otilde;em &eacute; feito internamente nas cole&ccedil;&otilde;es&semi; por sua vez, quando usamos um <i>array</i> o seu tamanho precisa ser gerenciado pelo programador.&#10;No <i>namespace collections</i>, encontramos uma s&eacute;rie de cole&ccedil;&otilde;es predefinidas a partir das quais podemos criar nossas pr&oacute;prias cole&ccedil;&otilde;es. Al&eacute;m disso, neste namespace podemos encontrar a implementa&ccedil;&atilde;o de estruturas de dados como pilhas, listas, listas ordenadas, filas, e todas s&atilde;o implementadas usando cole&ccedil;&otilde;es. Algumas classes membros do namespace <i>System.Collections</i>:&#10;</p>&#10;<ul>&#10;<li><i><code>ArrayList</code></i>: usa um <i>array</i> cujo tamanho &eacute; incrementado dinamicamente conforme necess&aacute;rio&semi;</li>&#10;<li><i><code>CollectionBase</code></i>: usada como classe para implementar cole&ccedil;&otilde;es fortemente tipadas&semi;</li>&#10;<li><i><code>Queue</code></i>: cole&ccedil;&atilde;o de objetos que implementa uma fila do tipo &ldquo;primeiro a entrar, primeiro a sair&rdquo;&semi;</li>&#10;<li><i><code>SortedList</code></i>: cole&ccedil;&atilde;o que implementa uma lista ordenada&semi;</li>&#10;<li><i><code>Stack</code></i>: cole&ccedil;&atilde;o de objetos que implementa uma pilha (&uacute;ltimo a entrar, primeiro a sair).</li></ul>&#10;<a id="''Exceptions''_%E2%80%93_Exce%C3%A7%C3%B5es" name="''Exceptions''_%E2%80%93_Exce%C3%A7%C3%B5es"></a><h2> &#39&semi;&#39&semi;Exceptions&#39&semi;&#39&semi; &ndash; Exce&ccedil;&otilde;es </h2>&#10;<p>Exce&ccedil;&otilde;es em C# fornecem uma maneira estruturada, uniforme e segura de manipula&ccedil;&atilde;o, tanto em n&iacute;vel de sistema e erros condicionais de aplica&ccedil;&atilde;o. <i>Exceptions</i> em C# s&atilde;o similares a Exce&ccedil;&otilde;es em C++, mas com algumas importantes diferen&ccedil;as:&#10;</p>&#10;<ul>&#10;<li>Em C#, todas as <i>exceptions</i> representam um inst&acirc;ncia de classe derivada de <i>System.Exception</i>. Em C++, qualquer valor de qualquer tipo pode ser usado para representar uma exce&ccedil;&atilde;o.</li>&#10;<li>Em C# o Bloco <i>finally</i> pode ser escrito ao final do c&oacute;digo para executar em ambas as situa&ccedil;&otilde;es de exce&ccedil;&atilde;o ou execu&ccedil;&atilde;o normal. Em C++ &eacute; dif&iacute;cil escrever sem duplicar c&oacute;digos.</li></ul>&#10;<p>Exce&ccedil;&otilde;es possuem as principais propriedades:&#10;</p>&#10;<ul>&#10;<li>Um Bloco <i>try</i> em torno de uma instru&ccedil;&atilde;o pode lan&ccedil;ar exce&ccedil;&otilde;es&semi;</li>&#10;<li>Ap&oacute;s a execu&ccedil;&atilde;o do bloco <i>try</i>, o fluxo de controle vai para o primeiro manipulador de exce&ccedil;&atilde;o associado que est&aacute; presente em qualquer lugar na pilha de chamadas. O <i>catch</i> &eacute; usado para definir o manipulador de exce&ccedil;&atilde;o&semi;</li>&#10;<li>Se nenhum manipulador de exce&ccedil;&atilde;o para uma determinada exce&ccedil;&atilde;o estiver presente, o programa apresenta erro.</li></ul>&#10;<p>Exce&ccedil;&otilde;es podem ser explicitamente geradas por um programa usando a palavra&shy;chave <i>throw</i>.</p>&#10;<p>Exemplo:&#10;&#60&semi;syntaxhighlight lang=&#34&semi;CSharp&#34&semi;&#62&semi;&#10;static void TestCatch2()&#10;{&#10;System.IO.StreamWritersw = null&semi;&#10;try&#10;{&#10;sw = newSystem.IO.StreamWriter(@&#34&semi;C:\test\test.txt&#34&semi;)&semi;&#10;sw.WriteLine(&#34&semi;Hello&#34&semi;)&semi;&#10;}&#10;catch (System.IO.FileNotFoundException ex)&#10;{&#10;// Put the more specific exception first.&#10;System.Console.WriteLine(ex.ToString())&semi; &#10;}&#10;catch (System.IO.IOException ex)&#10;{&#10;// Put the less specific exception last.&#10;System.Console.WriteLine(ex.ToString())&semi; &#10;}&#10;finally&#10;{&#10;sw.Close()&semi;&#10;}&#10;System.Console.WriteLine(&#34&semi;Done&#34&semi;)&semi;&#10;}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="Escrevendo_um_programa" name="Escrevendo_um_programa"></a><h2> Escrevendo um programa </h2>&#10;<p>Um programa em C# cont&eacute;m 4 elementos principais:&#10;</p>&#10;<ul>&#10;<li>uma declara&ccedil;&atilde;o de namespace: cont&eacute;m as bibliotecas de classe que voc&ecirc; pode usar em um programa. A diretiva <i>using System</i> especifica que o programa pode utilizar a biblioteca no namespace <i>System</i>.</li>&#10;<li>uma classe: cont&eacute;m as declara&ccedil;&otilde;es de dados e m&eacute;todos para uma aplica&ccedil;&atilde;o&semi;</li>&#10;<li>um m&eacute;todo <i>Main</i>: semelhante ao C++, todos os programas C# come&ccedil;am executando o m&eacute;todo <i>Main</i> &semi;</li>&#10;<li>e uma declara&ccedil;&atilde;o do programa.</li></ul>&#10;<a id="Compilando_o_c%C3%B3digo" name="Compilando_o_c%C3%B3digo"></a><h2> Compilando o c&oacute;digo </h2>&#10;<p>As aplica&ccedil;&otilde;es desenvolvidas em C# s&atilde;o baseadas em arquivos (com extens&atilde;o .cs) contendo o c&oacute;digo&shy;fonte dos programas. &#10;Quando voc&ecirc; compila seu c&oacute;digo, cria um <i>assembly</i>. Um <i>assembly</i> &eacute; uma cole&ccedil;&atilde;o de arquivos que aparecem ao programador como uma &uacute;nica DLL, biblioteca de <i>link</i> din&acirc;mico (<i>Dynamic Link Library</i>), ou execut&aacute;vel (EXE). Em .NET, um <i>assembly</i> &eacute; a unidade b&aacute;sica de reutiliza&ccedil;&atilde;o, versionamento, seguran&ccedil;a e implanta&ccedil;&atilde;o. O CLR proporciona um n&uacute;mero de classes para manipula&ccedil;&atilde;o de <i>assemblies</i>.</p>&#10;<a id="Heran%C3%A7a" name="Heran%C3%A7a"></a><h2> Heran&ccedil;a </h2>&#10;<p>Um dos principais recursos da programa&ccedil;&atilde;o orientada a objetos &eacute; a heran&ccedil;a. Heran&ccedil;a &eacute; uma forma de reutiliza&ccedil;&atilde;o de software em que as classes s&atilde;o criadas pela absor&ccedil;&atilde;o dos dados e comportamentos de uma classe j&aacute; existente e aprimorando&shy;as com novos recursos.&#10;Ao criar uma classe, em vez de escrever vari&aacute;veis de inst&acirc;ncia e m&eacute;todos complementares novos, o programador pode indicar que a nova classe deve herdar as vari&aacute;veis de classe, propriedades e m&eacute;todos de outra classe. Uma classe derivada &eacute; mais espec&iacute;fica do que sua classe base e representa um grupo mais especializado de objetos. Normalmente, a classe derivada cont&eacute;m os comportamentos de sua classe base e comportamentos adicionais.&#10;No caso de heran&ccedil;a simples, uma classe &eacute; derivada de uma &uacute;nica classe base.  Ao contr&aacute;rio do C++, o C# n&atilde;o suporta heran&ccedil;a m&uacute;ltipla (que ocorre quando uma classe &eacute; derivada de mais de uma classe base direta).</p>&#10;<a id="Coleta_de_lixo" name="Coleta_de_lixo"></a><h2> Coleta de lixo </h2>&#10;<p>O operador <i>new</i> aloca mem&oacute;ria para o objeto e, ent&atilde;o, chama o construtor desse objeto.&#10;Ao contr&aacute;rio do C e do C++, em que os programadores devem gerenciar a mem&oacute;ria de maneira expl&iacute;cita, o C# realiza o gerenciamento de mem&oacute;ria internamente. A plataforma .NET realiza a coleta de lixo da mem&oacute;ria para retornar a mem&oacute;ria do sistema que n&atilde;o &eacute; mais necess&aacute;ria. Quando o coletor de lixo executa, ele localiza os objetos para os quais o aplicativo n&atilde;o tem refer&ecirc;ncias. Tais objetos podem ser coletados nesse momento ou durante uma execu&ccedil;&atilde;o subseq&uuml;ente do coletor de lixo.&#10;A aloca&ccedil;&atilde;o e libera&ccedil;&atilde;o de recursos, como conex&otilde;es de rede, conex&otilde;es de banco de dados e arquivos, devem ser manipuladas explicitamente pelo programador. Uma t&eacute;cnica empregada em conjunto com o coletor de lixo &eacute; definir um destrutor.</p>&#10;<a id="Exemplos_de_c%C3%B3digo" name="Exemplos_de_c%C3%B3digo"></a><h2> Exemplos de c&oacute;digo </h2>&#10;<p> &#10; </p>&#10;<p>Segue, abaixo, o programa teste Ol&aacute; Mundo, que exibe a frase &#34&semi;Ol&aacute;, Mundo!&#34&semi;:</p>&#10;<p>&#60&semi;syntaxhighlight lang=&#34&semi;CSharp&#34&semi;&#62&semi;&#10;using System&semi;</p>&#10;<p>namespace Teste&#10;{&#10;   class OlaMundo&#10;   {&#10;       static void Main()&#10;       {&#10;           Console.WriteLine(&#34&semi;Ol&aacute;, Mundo!&#34&semi;)&semi;&#10;       }&#10;   }&#10;}&#10;&#60&semi;/syntaxhighlight&#62&semi;</p>&#10;<a id="Bibliotecas" name="Bibliotecas"></a><h2> Bibliotecas </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Banshee_AlbumPic.png%7Cthumb%7C300px%7CCaptura_de_tela_do_%5B%5BBanshee_(media_player)" id="w">Banshee]], um &#39&semi;&#39&semi;media player&#39&semi;&#39&semi; desenvolvido em C#</a>&#10;Ao contr&aacute;rio das outras <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagens de programa&ccedil;&atilde;o</a>, nenhuma implementa&ccedil;&atilde;o de C# actualmente inclui qualquer conjunto de bibliotecas de classes ou fun&ccedil;&otilde;es. Mesmo assim, esta linguagem est&aacute; muito vinculada &agrave; plataforma .NET, da qual obt&eacute;m as suas classes ou fun&ccedil;&otilde;es de execu&ccedil;&atilde;o. O c&oacute;digo &eacute; organizado num conjunto de <a href="http://en.wikipedia.org/wiki/Espa%C3%A7o_de_nomes" id="w">espa&ccedil;os de nomes</a> que agrupam as classes com fun&ccedil;&otilde;es semelhantes. Por exemplo, <code>System.Windows.Forms</code> cont&eacute;m o sistema <a href="http://en.wikipedia.org/wiki/Windows_Forms" id="w">Windows Forms</a>&semi; <code>System.Console</code> &eacute; usado para <a href="http://en.wikipedia.org/wiki/Entrada/sa%C3%ADda" id="w">entrada/sa&iacute;da</a> de dados.</p>&#10;<p>Um n&iacute;vel de organiza&ccedil;&atilde;o superior &eacute; fornecido pelo conceito de <a href="http://en.wikipedia.org/wiki/Montador" id="w">montador</a>, que pode ser um simples arquivo ou m&uacute;ltiplos arquivos ligados juntos que podem conter muitos espa&ccedil;os de nomes ou objetos. Programas que precisam de classes para realizar uma fun&ccedil;&atilde;o em particular podem se referenciar aos montadores como <code>System.Drawing.dll</code> e <code>System.Windows.Forms.dll</code> assim como a biblioteca <code>core</code> (conhecida como <code>mscorlib.dll</code> na implementa&ccedil;&atilde;o da <a href="http://en.wikipedia.org/wiki/Microsoft" id="w">Microsoft</a>).</p>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Anexo:Lista_de_exemplos_de_c%C3%B3digo_C%E2%99%AF" id="w">Anexo:Lista de exemplos de c&oacute;digo C&#9839;</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/ASP.NET" id="w">ASP.NET</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Common_Language_Runtime" id="w">Common Language Runtime</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Microsoft_.NET" id="w">Microsoft .NET</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Microsoft_XNA" id="w">Microsoft XNA</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Mono_(projeto)" id="w">Mono (projeto)</a></li></ul>&#10;<p> </p>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Ferramentas_de_desenvolvimento_Microsoft" id="w">Categoria:Ferramentas de desenvolvimento Microsoft</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:C_Sharp" id="w"> </a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_.NET" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o .NET</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_orientadas_a_objetos" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o orientadas a objetos</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_baseadas_em_classes" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o baseadas em classes</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Normas_ISO" id="w">Categoria:Normas ISO</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Normas_IEC" id="w">Categoria:Normas IEC</a></p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o_criadas_em_2001" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o criadas em 2001</a></p></body></html>