<html><title>Problema do caixeiro&shy;viajante</title><body>&#10;<p> &#10; &#10; </p>&#10;<p>O <b>Problema do Caixeiro Viajante</b>  (<b><i>PCV</i></b>) &eacute; um problema que tenta determinar a menor rota para percorrer uma s&eacute;rie de cidades (visitando cada uma pelo menos uma vez), retornando &agrave; cidade de origem. Ele &eacute; um problema de <a href="http://en.wikipedia.org/wiki/Otimiza%C3%A7%C3%A3o_combinat%C3%B3ria" id="w">otimiza&ccedil;&atilde;o</a> <a href="http://en.wikipedia.org/wiki/NP&shy;dif%C3%ADcil" id="w">NP&shy;dif&iacute;cil</a> inspirado na necessidade dos vendedores em realizar entregas em diversos locais (as cidades) percorrendo o menor caminho poss&iacute;vel, reduzindo o tempo necess&aacute;rio para a viagem e os poss&iacute;veis custos com transporte e combust&iacute;vel.</p>&#10;<a id="Fatos_hist%C3%B3ricos" name="Fatos_hist%C3%B3ricos"></a><h2> Fatos hist&oacute;ricos </h2>&#10;<p>A origem do nome &laquo;<i>travelling salesman problem</i>&raquo; &eacute; desconhecida. N&atilde;o parece existir qualquer documento que prove o(a) autor(a) do nome do problema. Merril Flood, da <a href="http://en.wikipedia.org/wiki/Universidade_de_Princeton" id="w">Universidade de Princeton</a>, um dos investigadores mais proeminentes nas primeiras aplica&ccedil;&otilde;es do problema proferiu, no entanto, o seguinte coment&aacute;rio: &laquo;I don&acute;t know who coined the peppier name &#34&semi;Traveling Salesman Problem&#34&semi; for <i>Whitney&#39&semi;s</i> problem, [...]&raquo; <a href="http://en.wikipedia.org/wiki/#refcApplegate2006" id="w">(Applegate et al., cop. 2006, p. 2)</a>.</p>&#10;<p>Nos anos de 1800, problemas relacionados com o PCV come&ccedil;aram a ser desenvolvidos por dois matem&aacute;ticos: o escoc&ecirc;s <a href="http://en.wikipedia.org/wiki/William_Rowan_Hamilton" id="w">William Rowan Hamilton</a> e o brit&acirc;nico Thomas Penyngton Kerkman. A forma geral do PCV parece ter sido, pela primeira vez, estudada por matem&aacute;ticos nos anos de 1930 em <a href="http://en.wikipedia.org/wiki/Universidade_Harvard" id="w">Harvard</a> e <a href="http://en.wikipedia.org/wiki/Universidade_de_Viena" id="w">Viena</a>. O problema foi posteriormente estudado por Hassler Whitney e Merril Flood em Princeton. Exceptuando pequenas varia&ccedil;&otilde;es ortogr&aacute;ficas, como <i>traveling</i> vs <i>travelling</i> ou <i>salesman</i> vs <i>salesman&#39&semi;s</i>, o nome do problema ficou globalmente conhecido por volta do ano 1950 <a href="http://en.wikipedia.org/wiki/#refcApplegate2006" id="w">(Applegate et al., cop. 2006, p.2)</a>.</p>&#10;<a id="Defini%C3%A7%C3%A3o_e_formula%C3%A7%C3%A3o_do_problema" name="Defini%C3%A7%C3%A3o_e_formula%C3%A7%C3%A3o_do_problema"></a><h2> Defini&ccedil;&atilde;o e formula&ccedil;&atilde;o do problema </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:Example_The_travelling_salesman_problem_(TSP).gif%7Cthumb%7Cright%7C400px" id="w">Figura 1. Problema do caixeiro&shy;viajante.</a></p>&#10;<p>O problema do caixeiro&shy;viajante (representado na Figura 1) consiste na procura de um circuito que possua a menor dist&acirc;ncia, come&ccedil;ando numa cidade qualquer, entre v&aacute;rias, visitando cada cidade precisamente uma vez e regressando &agrave; cidade inicial <span id="refbNilsson1982"><a href="http://en.wikipedia.org/wiki/#refNilsson1982" id="w">(Nilsson, 1982)</a></span>.</p>&#10;<dl><dt>Formula&ccedil;&atilde;o combinat&oacute;ria</dt></dl>&#10;<p>Dado um conjunto <big><span class="math">C=\{ c_1\&semi;, ...,\&semi;c_n \}</span></big> de <i>n</i> cidades <i>c<sub>i</sub></i> e uma matriz de dist&acirc;ncias <big><span class="math">\left ( \rho_{ij} \right )</span></big>, onde <big><span class="math">\rho_{ij}=\rho( c_i,\&semi;c_j )</span></big> <big><big><span class="math">(</span></big></big> <span class="math">i,\&semi;j</span> <big><span class="math">\in</span></big> <big><span class="math">\{ 1,\&semi;...,\&semi;n \}</span></big>,  <i><big><big><span class="math">\rho_{ij}</span></big></big></i> <i><big><big><span class="math">=\rho_{ji}</span></big></big></i>, <i><big><big><span class="math">\rho_{ii}</span></big></big></i><big><big><span class="math">=0 )</span></big></big>, a tarefa passa por encontrar a <a href="http://en.wikipedia.org/wiki/Permuta%C3%A7%C3%A3o" id="w">permuta&ccedil;&atilde;o</a> <span class="math"> \pi \in S_n = \{ s : \{ 1, ..., n \} \rightarrow \{ 1, ..., n \} \}</span> que fa&ccedil;a com que a fun&ccedil;&atilde;o objectivo (dist&acirc;ncia do circuito) <span class="math">f : S_n \rightarrow \mathbb{R}</span>, onde</p>&#10;<pre>         <span class="math">f ( \pi ) = \sum_{i=1}^{n&shy;1} \rho\pi( i ), \pi( i+1 ) + \rho\pi( n ), \pi( 1 )</span>,&#10;</pre>&#10;<p>atinja o seu <a href="http://en.wikipedia.org/wiki/M%C3%ADnimo" id="w">m&iacute;nimo</a>.</p>&#10;<p>O tamanho do espa&ccedil;o de procura aumenta exponencialmente dependendo de <i>n</i>, o n&uacute;mero de cidades, uma vez que existem</p>&#10;<pre>         <span class="math">( n&shy;1 )!/2 \approx {1 \over 2}\sqrt{2\pi( n&shy;1 )}\left ( \frac{n&shy;1}{e} \right )^{n&shy;1}</span>&#10;</pre>&#10;<p>circuitos poss&iacute;veis (a posi&ccedil;&atilde;o inicial &eacute; arbitr&aacute;ria, e a ordem do circuito pode ser invertida).</p>&#10;<p>Embora tenham sido desenvolvidos bons <a href="http://en.wikipedia.org/wiki/Algoritmos" id="w">algoritmos</a> de aproxima&ccedil;&atilde;o para o PCV, o problema continua a oferecer uma grande atrac&ccedil;&atilde;o para a aplica&ccedil;&atilde;o de novos algoritmos, tais como os evolucion&aacute;rios. Isto deve&shy;se, essencialmente, &agrave;s seguintes raz&otilde;es:</p>&#10;&#10;<ul>&#10;<li>A problem&aacute;tica do PCV pode ser entendida facilmente, uma vez que se aproxima dos problemas populares do mundo real&semi;</li>&#10;<li>O PCV demonstra o caso mais simples dos problemas de requisi&ccedil;&atilde;o que s&atilde;o de enorme relev&acirc;ncia para a programa&ccedil;&atilde;o de processos industriais&semi;</li>&#10;<li>Existem v&aacute;rios conjuntos de dados sobre o PCV &laquo;standard&raquo; que est&atilde;o dispon&iacute;veis em literatura, de tal forma que os resultados s&atilde;o compar&aacute;veis mesmo que o &oacute;ptimo global n&atilde;o seja ainda definitivamente conhecido&semi;</li>&#10;<li>Relativamente &agrave; complexidade computacional, o PCV, como um problema NP&shy;completo, &eacute; conhecido por representar uma larga classe de problemas para os quais n&atilde;o existem algoritmos polinomiais em <a href="http://en.wikipedia.org/wiki/S%C3%A9ries_temporais" id="w">s&eacute;ries temporais</a> determin&iacute;sticos.</li></ul>&#10;<dl><dt>Representa&ccedil;&atilde;o continua do PCV</dt></dl>&#10;<p>A topologia de um PCV pode ser visualizada segundo uma representa&ccedil;&atilde;o cont&iacute;nua do problema:</p>&#10;<pre>         <span class="math"> \vec x \in [u, v]^n &semi; u, v \in \mathbb{R} </span>&#10;</pre>&#10;<p>Partindo de   <span class="math">\ \vec x\ = (x_{1}, ..., x_{n}) \in [u, v]^n\ </span> , uma permuta&ccedil;&atilde;o   <big><span class="math"> \pi </span></big>   pode ser obtida atrav&eacute;s de uma ordena&ccedil;&atilde;o das componentes do <a href="http://en.wikipedia.org/wiki/Vetor_(espacial)" id="w">vector</a>, que originam um novo vector <span class="math">\vec x^\prime\ = (x_{\pi(1)}, ..., x_{\pi(n)})</span>   de tal forma que   <big><span class="math">\ x_{\pi(1)}\&semi;&lt&semi;\&semi;x_{\pi(2)}\&semi;&lt&semi;\&semi;x_{\pi(n)}\ </span></big>.    A nova ordem   <big><span class="math">\  \pi(1),\&semi;\pi(2),\&semi;\pi(n)\ </span></big> &eacute; interpretada como o circuito resultante da permuta&ccedil;&atilde;o <span id="refbB&auml;ck1996"><a href="http://en.wikipedia.org/wiki/#refB&amp&semi;auml&semi;ck1996" id="w">(B&#228&semi;ck, 1996)</a></span>.</p>&#10;<dl><dt>Formula&ccedil;&atilde;o gr&aacute;fica</dt></dl>&#10;<p>No dom&iacute;nio da <a href="http://en.wikipedia.org/wiki/Teoria_dos_grafos" id="w">teoria dos grafos</a>, cada cidade &eacute; identificada com um n&oacute; (ou v&eacute;rtice) e as rotas que ligam cada par de n&oacute;s s&atilde;o identicadas como arcos (ou arestas). A cada uma destas linhas estar&atilde;o associadas as dist&acirc;ncias (ou custos) correspondentes. Desde que seja poss&iacute;vel ir directamente de uma cidade para qualquer outra, o gr&aacute;fico diz&shy;se completo. Uma viagem que passe por todas as cidades corresponde a um <a href="http://en.wikipedia.org/wiki/Caminho_hamiltoniano" id="w">ciclo Hamiltoniano</a>, representado por um conjunto espec&iacute;fico de linhas. A dist&acirc;ncia do ciclo &eacute; o somat&oacute;rio das dist&acirc;ncias das linhas presentes no mesmo.</p>&#10;<p>Formalmente, o problema pode ser representado por um <a href="http://en.wikipedia.org/wiki/Grafo" id="w">grafo</a> G(V, E), com <span class="math">|V| \ge 3</span> e custos <big><big><span class="math">c_{ij}</span></big></big>,  <i><span class="math"> \left ( i,\&semi;j \right )</span></i> <span class="math">\in E</span>, referentes a cada uma das arestas. O objectivo, no caso de um grafo completo com <i>n</i> v&eacute;rtices (cidades) &eacute; encontrar o melhor circuito entre os <big><span class="math"> [(n&shy;1)!/2]</span></big> poss&iacute;veis.</p>&#10;<p>Dependendo da import&acirc;ncia que poder&aacute; ter o sentido das setas(arestas), entre n&oacute;s(cidades), o PCV pode&shy;se distinguir em sim&eacute;trico ou assim&eacute;trico <span id="refbGuedes2005"><a href="http://en.wikipedia.org/wiki/#refGuedes2005" id="w">(Guedes, 2005)</a></span>.</p>&#10;<dl><dt>PCV assim&eacute;trico</dt></dl>&#10;<p>Dependendo da import&acirc;ncia que a dire&ccedil;&atilde;o das arestas que atravessam o grafo possam ter, distingue&shy;se o PCV assim&eacute;trico do sim&eacute;trico. Para formular o PCV assim&eacute;trico em <i>m</i> cidades, introduzem&shy;se vari&aacute;veis zero ou um:</p>&#10;<pre>         <span class="math">x_{ij} = \begin{cases} 1,  & \mbox{se }i \rightarrow j\mbox{ existe} \\ 0, & \mbox{se }i \rightarrow j\mbox{ n&atilde;o existe} \end{cases}</span>&#10;</pre>&#10;<p>Assim, e dado o facto de que a cada n&oacute; do grafo apenas pode corresponder e sair uma seta (Figura 2), um obt&eacute;m uma atribui&ccedil;&atilde;o cl&aacute;ssica do problema. Estas restri&ccedil;&otilde;es, contudo n&atilde;o s&atilde;o suficientes, uma vez que esta formula&ccedil;&atilde;o permite a ocorr&ecirc;ncia de subcircuitos, ou seja, mesmo respeitando as condi&ccedil;&otilde;es impostas, considera&shy;se a forma&ccedil;&atilde;o de aglomerados de cidades sem liga&ccedil;&atilde;o. Por esta raz&atilde;o, a formula&ccedil;&atilde;o do problema tem que possuir condi&ccedil;&otilde;es necess&aacute;rias para remo&ccedil;&atilde;o de subcircuitos. Assim, o problema &eacute; reformulado da seguinte forma:</p>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:TSP_degree_constraints.png%7Cthumb%7Cright%7C300px" id="w">Figura 2. Entrada e sa&iacute;da de uma seta por cada n&oacute;.</a></p>&#10;<pre>         <center><span class="math">min \sum_{j=1}^{m} \sum_{i=1}^{m} c_{ij} x_{ij}</span></center>&#10;&#10;         <center><span class="math">tal que\sum_{j=1}^{m} x_{ij}=1 \qquad \qquad para\ i = 1, ..., m</span></center>&#10;&#10;         <center><span class="math">\sum_{i=1}^{m} x_{ij}=1 \qquad \qquad para\ j = 1, ..., m</span></center>&#10;&#10;         <center><span class="math">\sum_{i \in K} \sum_{j \in K} x_{ij} \le |K| &shy; 1 \qquad \qquad para\ todo\ i, j</span></center>&#10;&#10;         <center><span class="math"> x_{ij} = 0\ ou\ 1 \qquad \qquad para\ todo\ i,j</span></center>&#10;</pre>&#10;<p>Onde:</p>&#10;&#10;<ul>&#10;<li><i>K</i> &eacute; um subconjunto n&atilde;o vazio apropriado das cidades <i>1, ..., m</i>&semi;</li>&#10;<li>O custo <big><span class="math">c_{ij}</span></big> pode ser diferente do custo <big><span class="math">c_{ji}</span></big>&semi;</li>&#10;<li>Existem <i>m(m&shy;1)</i> zero&shy;um vari&aacute;veis.</li></ul>&#10;<dl><dt>PCV sim&eacute;trico</dt></dl>&#10;<p>Para formular o PCV sim&eacute;trico, um demonstra que a direc&ccedil;&atilde;o atravessada &eacute; imaterial, de modo que <big><span class="math">c_{ij}</span></big> = <big><span class="math">c_{ji}</span></big>. Uma vez que a direc&ccedil;&atilde;o n&atilde;o tem interesse, um pode considerar o gr&aacute;fo onde existe apenas um arco, sem direc&ccedil;&atilde;o, entre todos os pares de n&oacute;s. Assim, <span class="math">x_{j}\ \varepsilon\ {0,1}</span> &eacute; a vari&aacute;vel de decis&atilde;o onde <i>j</i> percorre todos os arcos <i>E</i> do grafo, sem direc&ccedil;&atilde;o, e <big><span class="math">c_{j}</span></big> &eacute; o custo de percorrer cada tro&ccedil;o. Para encontrar um circuito neste gr&aacute;fo, um, deve seleccionar um subconjunto de arcos, tal que todos os n&oacute;s estejam contidos exactamente em dois dos arcos seleccionados. Assim, o problema pode ser formulado como um problema 2&shy;<i>matching</i> no gr&aacute;fo <span class="math">G^V</span> com <i>m(m&shy;1)/2</i> zero&shy;um vari&aacute;veis, isto &eacute;, metade do n&uacute;mero da formula&ccedil;&atilde;o anterior. Tal como no caso assim&eacute;trico, os subcircuitos devem ser eliminados atrav&eacute;s de restri&ccedil;&otilde;es de elimina&ccedil;&atilde;o de subcircuitos. O problema pode ent&atilde;o ser formulado como:</p>&#10;<pre>         <center><span class="math"> min 1/2 \sum_{j=1}^{m} \sum_{k \in J(j)} c_{k}\ x_{k}</span></center>&#10;&#10;         <center><span class="math"> s.t. \sum_{k \in J(j)} x_{k}=2 \qquad \qquad para\ todo\ j=1, ..., m</span></center>&#10;&#10;         <center><span class="math"> \sum_{j \in E(K)} x_{j} \le |K| &shy; 1 \qquad \qquad para\ todo\ K \subset {1, ..., m}</span></center>&#10;&#10;         <center><span class="math"> x_{j} = 0\ ou\ 1 \qquad \qquad para\ todo\ j \varepsilon E</span></center>&#10;</pre>&#10;<p>onde <i>J(j)</i> &eacute; o conjunto de todos os arcos, n&atilde;o direccionados, ligados ao n&oacute; <i>j</i> e <i>E(K)</i> &eacute; o subconjunto de todos os arcos, n&atilde;o direccionados, que ligam as cidades em qualquer subconjunto <i>K</i> n&atilde;o vazio apropriado de todas as cidades.</p>&#10;<p>&Eacute; evidente que o problema sim&eacute;trico &eacute; um caso especial do assim&eacute;trico, mas experi&ecirc;ncias pr&aacute;ticas demonstram que os algoritmos para o problema assim&eacute;trico, regra geral, desenvolvem mal no sim&eacute;trico. Assim, este tipo de problemas requerem formula&ccedil;&otilde;es especiais e tratamentos de solu&ccedil;&otilde;es <span id="refbHoffman2000"><a href="http://en.wikipedia.org/wiki/#refHoffman2000" id="w">(Hoffman, 2000)</a></span>.</p>&#10;<a id="Tipologia_de_m%C3%A9todos_para_a_resolu%C3%A7%C3%A3o_do_PCV" name="Tipologia_de_m%C3%A9todos_para_a_resolu%C3%A7%C3%A3o_do_PCV"></a><h2> Tipologia de m&eacute;todos para a resolu&ccedil;&atilde;o do PCV </h2>&#10;<p>A solu&ccedil;&atilde;o do PCV pode ser determinada por diferentes m&eacute;todos. Estes, podem ser agrupados em m&eacute;todos exactos e heur&iacute;sticos. Os primeiros t&ecirc;m por base procedimentos  </p>&#10;<p>Os m&eacute;todos heur&iacute;sticos s&atilde;o procedimentos bastante particulares, o que os torna inflex&iacute;veis para a determina&ccedil;&atilde;o de boas solu&ccedil;&otilde;es para um outro problema ligeiramente diferente.</p>&#10;<p>As heur&iacute;sticas podem ser agrupadas em m&eacute;todos de constru&ccedil;&atilde;o de circuitos e m&eacute;todos de melhorias de circuitos.</p>&#10;<dl><dt>M&eacute;todos de constru&ccedil;&atilde;o de circuitos</dt></dl>&#10;<p>Nestes m&eacute;todos, o circuito &eacute; constru&iacute;do sequencialmente, isto &eacute;, os n&oacute;s v&atilde;o sendo inseridos faseadamente, mediante certas condi&ccedil;&otilde;es, sem que exista qualquer modifica&ccedil;&atilde;o posterior &agrave; inser&ccedil;&atilde;o definida pelo processamento do algoritmo.</p>&#10;<p>A constru&ccedil;&atilde;o do circuito pode ser elaborada atrav&eacute;s dos seguintes m&eacute;todos:</p>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Algoritmo_do_vizinho_mais_pr%C3%B3ximo" id="w">Vizinho mais pr&oacute;ximo</a>, que &eacute; caracterizado pela escolha da cidade mais pr&oacute;xima, sempre que o caixeiro se desloque, at&eacute; que todas as cidades sejam visitadas&semi;</li>&#10;<li>De inser&ccedil;&atilde;o, que se descreve pela inclus&atilde;o de cidades, uma a uma, atendendo a um determinado crit&eacute;rio de proximidade, por exemplo, a cidade mais distante, partindo de um circuito inicial com duas cidades. Aquando da inser&ccedil;&atilde;o, a escolha deve ser analisada entre cada par de cidades do circuito parcial, at&eacute; que todas estejam inseridas&semi;</li>&#10;<li>Da <a href="http://en.wikipedia.org/wiki/&Aacute;rvore_de_extens%C3%A3o_m%C3%ADnima" id="w">cobertura m&iacute;nima</a>, onde &eacute; elaborada um &aacute;rvore que contenha todas as cidades, com a finalidade de se encontrar uma &aacute;rvore de cobertura com a menor soma de dist&acirc;ncias poss&iacute;vel&semi;</li>&#10;<li>Das economias, ou <a href="http://en.wikipedia.org/wiki/Heur%C3%ADstica_de_Clarke_e_Wright" id="w">heur&iacute;stica de Clarke e Wright</a>, que consiste no agrupamento sequencial de cidades, com base numa ordem decrescente de economias decorrentes da sua inclus&atilde;o, isto &eacute;, considerando o impacto, da jun&ccedil;&atilde;o do n&oacute; no circuito, nas economias agregadas da dist&acirc;ncia entre n&oacute;s e da dist&acirc;ncia de cada um dos n&oacute;s ao n&oacute; inicial <a href="http://en.wikipedia.org/wiki/#refcCunha2002" id="w">(Cunha, 2002)</a> e <span id="refbGoodrich1899"><a href="http://en.wikipedia.org/wiki/#refGoodrich1899" id="w">(Goodrich, 1899)</a></span>.</li></ul>&#10;<dl><dt>M&eacute;todos de melhoria de circuitos</dt></dl>&#10;<p>Estes m&eacute;todos procuram melhorar o circuito obtido atrav&eacute;s de algum outro m&eacute;todo. Para tal, o m&eacute;todo mais utilizado, elaborado por Lin e Kernighan em 1973, denomina&shy;se por <i>k&shy;opt</i>. Nesta proposta, <i>k</i> arcos s&atilde;o substitu&iacute;dos, no circuito, por outros <i>k</i> arcos com o objectivo de diminuir a dist&acirc;ncia total percorrida.&#10;Quanto maior for o valor de <i>k</i>, melhor &eacute; a precis&atilde;o do m&eacute;todo, mas maior &eacute; o esfor&ccedil;o computacional.</p>&#10;<p>Com a varia&ccedil;&atilde;o do valor <i>k</i>, no m&eacute;todo de melhoria <i>k&shy;opt</i>, a heur&iacute;stica de Lin e Kernighan aumentaria a sua efici&ecirc;ncia quando comparada com o mesmo m&eacute;todo utilizando um valor de <i>k</i> fixo. Desta forma, o m&eacute;todo n&atilde;o fica mais simples, contudo passa a ser poss&iacute;vel a aplica&ccedil;&atilde;o do m&eacute;todo a problemas mais abrangentes com resultados favor&aacute;veis.</p>&#10;<p>Para al&eacute;m deste m&eacute;todo, existem outros m&eacute;todos de melhorias baseados em <a href="http://en.wikipedia.org/wiki/Metaheur%C3%ADstica" id="w">metaheur&iacute;sticas</a> do tipo <i><a href="http://en.wikipedia.org/wiki/Simulated_annealing" id="w">simulated annealing</a></i> e <a href="http://en.wikipedia.org/wiki/Pesquisa_tabu" id="w">busca tabu</a>. Estes, para al&eacute;m de se basearem no desenvolvimento <i>k&shy;opt</i>, procuram uma solu&ccedil;&atilde;o que n&atilde;o a dada pelos m&eacute;todos anteriores. No <i>simulated annealing</i> &eacute; utilizado um controlo de possibilidades de solu&ccedil;&atilde;o melhores partindo de piores, no in&iacute;cio. Na busca tabu os movimentos considerados tabu, isto &eacute;, que n&atilde;o se podem efectuar, mesmo que melhorem a solu&ccedil;&atilde;o s&atilde;o temporariamente interditos com o objectivo de se alcan&ccedil;ar solu&ccedil;&otilde;es piores no in&iacute;cio que no final poder&atilde;o ser consideradas melhores (Laporte, 2002) e (Heslgaun, 2000), citados por <a href="http://en.wikipedia.org/wiki/#refcCunha2002" id="w">(Cunha, 2002)</a>.</p>&#10;<a id="Exemplos" name="Exemplos"></a><h2> Exemplos </h2>&#10;<a id="WRNN_e_WTA" name="WRNN_e_WTA"></a><h3> WRNN e WTA </h3>&#10;<p>A <a href="http://en.wikipedia.org/wiki/Rede_neural" id="w">rede neural</a> peri&oacute;dica de Wang, do ingl&ecirc;s <i>Wang Recurrent Neural Network</i> (WRNN), com o princ&iacute;pio <i>Winner Takes All</i> (WTA), pode ser aplicada para a resolu&ccedil;&atilde;o do PCV. Al&eacute;m disso, a utiliza&ccedil;&atilde;o do princ&iacute;pio WTA nas solu&ccedil;&otilde;es encontradas pelo WRNN faz com que as mesmas formem circuitos exequ&iacute;veis. Como tal, este &eacute; um m&eacute;todo de constru&ccedil;&atilde;o (WRNN) e de melhoria (WTA) de circuitos.</p>&#10;<p>O n&uacute;mero m&eacute;dio de itera&ccedil;&otilde;es necess&aacute;rias para a resolu&ccedil;&atilde;o do PCV  utilizando o WRNN &eacute; de 4463, com o WRNN + WTA &eacute; de 41, isto em problemas que variam entre 3 x 3 e 20 x 20.</p>&#10;<p>A WRNN &eacute; caracterizada por uma equa&ccedil;&atilde;o diferencial, que engloba uma fun&ccedil;&atilde;o do tipo <a href="http://en.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_sigm%C3%B3ide" id="w">sigm&oacute;ide</a>. Os v&aacute;rios par&acirc;metros inclu&iacute;dos nas equa&ccedil;&otilde;es afectam a converg&ecirc;ncia da rede, pois trata&shy;se de factores penalizantes pelas viola&ccedil;&otilde;es &agrave;s restri&ccedil;&otilde;es do problema, de controlo para a minimiza&ccedil;&atilde;o da fun&ccedil;&atilde;o objectivo, entre outros. Esta formula&ccedil;&atilde;o possui ainda um termo que avalia as viola&ccedil;&otilde;es &agrave;s restri&ccedil;&otilde;es do problema dando a indica&ccedil;&atilde;o do cumprimento das mesmas, ap&oacute;s um certo n&uacute;mero de itera&ccedil;&otilde;es. Depois de encontrados tais par&acirc;metros, aplica&shy;se o princ&iacute;pio WTA que pode ser dado atrav&eacute;s do seguinte algoritmo:</p>&#10;<p>1) Determinar o n&uacute;mero m&aacute;ximo de circuitos r<sub>max</sub> e encontrar uma solu&ccedil;&atilde;o  para o problema utilizando a t&eacute;cnica WRNN. Se o termo que avalia as restri&ccedil;&otilde;es for satisfeito, segue&shy;se para o passo 2, caso contr&aacute;rio encontra&shy;se outra solu&ccedil;&atilde;o x.</p>&#10;<p>2) Dada uma matriz de decis&atilde;o, considera&shy;se uma matriz <span class="math"> \overline{x}</span>, onde <span class="math"> \overline{x}</span> = x = <span class="math">x</span>&semi;</p>&#10;<p>3) Escolhe&shy;se uma linha <i>k</i> na matriz de decis&atilde;o <span class="math"> \overline{x}</span>. Faz&shy;se <i>p</i> = <i>k</i>, <span class="math">x^\prime (m) = k</span>:</p>&#10;<p>4) Encontra&shy;se o maior elemento da linha <i>k</i>, <span class="math"> \overline{x}_{kl}</span>. O valor deste elemento &eacute; dado por metade do somat&oacute;rio de todos os elementos da linha <i>k</i>:</p>&#10;<pre>         <span class="math"> \overline{x}_{kl} = \frac{1}{2} \left (\sum_{i=1}^{n} x_{il} + \sum_{j=1}^{n} x_{kj}  \right )</span>&#10;</pre>&#10;<p>Os outros elementos da linha <i>k</i> e da coluna <i>l</i> passam a ser nulos. Para que n&atilde;o exista a forma&ccedil;&atilde;o de sub circuitos os elmentos da coluna <i>k</i> t&ecirc;m, tamb&eacute;m, que ser nulos. Depois destas condi&ccedil;&otilde;es, faz&shy;se  <span class="math">x^\prime (m + 1) = l</span> e avan&ccedil;a&shy;se para o passo 5.</p>&#10;<p>5) Se <i>m</i> &#60&semi; <i>n</i>, ent&atilde;o faz&shy;se <i>m = m + 1</i> e retorna&shy;se ao passo 4. Caso contr&aacute;rio, aplica&shy;se a seguinte express&atilde;o:</p>&#10;<pre>         <span class="math"> \overline{x}_{kp} = \frac{1}{2} \left (\sum_{i=1}^{n} x_{ip} + \sum_{j=1}^{n} x_{kj} \right )</span>&#10;</pre>&#10;<p>A equa&ccedil;&atilde;o <span class="math">x^\prime (n + 1) = p</span>  determina o custo do circuito, <i>z</i>.</p>&#10;<p>6) Se <i>z</i> &#60&semi;<i>z<sub>min</sub></i>, faz&shy;se z<sub>min</sub> = z e x = <span class="math"> \overline{x}</span>. De seguida verifica&shy;se se <i>r</i> &#60&semi;<i>r<sub>max</sub></i> pela equa&ccedil;&atilde;o <i>r</i> = <i>r + 1</i>. Se tal acontecer, inicia&shy;se o procedimento do WRNN no passo 2, caso contr&aacute;rio finaliza&shy;se o algoritmo.</p>&#10;<p>Este procedimento pode ser aplicado tanto ao PCV sim&eacute;trico como ao assim&eacute;trico <span id="refbSiqueira2006"><a href="http://en.wikipedia.org/wiki/#refSiqueira2006" id="w">(Siqueira, 2006)</a></span>.</p>&#10;<a id="%5B%5BAlgoritmos_gen%C3%A9ticos%5D%5D" name="%5B%5BAlgoritmos_gen%C3%A9ticos%5D%5D"></a><h3> [[Algoritmos gen&eacute;ticos]] </h3>&#10;<p>Os algoritmos gen&eacute;ticos (AGs) s&atilde;o um dos v&aacute;rios m&eacute;todos que se utilizam para a resolu&ccedil;&atilde;o de problemas complexos. Este m&eacute;todo tem por base um processo iterativo sobre uma determinada popula&ccedil;&atilde;o fixa, denominados por indiv&iacute;duos, que representam as v&aacute;rias solu&ccedil;&otilde;es do problema. Esta t&eacute;cnica adv&eacute;m do processo de evolu&ccedil;&atilde;o dos seres vivos demonstrada por Darwin.</p>&#10;<p>Da mesma forma que os sistemas biol&oacute;gicos, ao longo da sua evolu&ccedil;&atilde;o, tiveram que se &laquo;moldar&raquo; &agrave;s altera&ccedil;&otilde;es ambientais para a sua sobreviv&ecirc;ncia, os AGs acumulam a informa&ccedil;&atilde;o sobre o ambiente com o intuito de se adptarem ao novo meio. Tal informa&ccedil;&atilde;o funciona como um sistema de triagem para a obten&ccedil;&atilde;o de novas solu&ccedil;&otilde;es exequ&iacute;veis.</p>&#10;<p>O m&eacute;todo dos algoritmos gen&eacute;ticos &eacute; muito utilizado devido &agrave; simplicidade de opera&ccedil;&atilde;o, efic&aacute;cia pela determina&ccedil;&atilde;o de um m&aacute;ximo global e aplicabilidade em problemas onde se desconhece o modelo matem&aacute;tico ou onde o mesmo se torna impreciso em <a href="http://en.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_linear" id="w">fun&ccedil;&otilde;es lineares</a> e n&atilde;o&shy;lineares <span id="refbCosta2003"><a href="http://en.wikipedia.org/wiki/#refCosta2003" id="w">(Costa, 2003)</a></span>.</p>&#10;<a id="M%C3%A9todo_de_aplica%C3%A7%C3%A3o" name="M%C3%A9todo_de_aplica%C3%A7%C3%A3o"></a><h4> M&eacute;todo de aplica&ccedil;&atilde;o </h4>&#10;<p>A forma&ccedil;&atilde;o de um algoritmo gen&eacute;tico convencional desenvolve&shy;se atrav&eacute;s dos seguintes passos:</p>&#10;&#10;<ol>&#10;<li>Representa&ccedil;&atilde;o de uma solu&ccedil;&atilde;o (Loco) na estrutura do <a href="http://en.wikipedia.org/wiki/Cromossoma" id="w">cromossoma</a>&semi;</li>&#10;<li>Constru&ccedil;&atilde;o de uma popula&ccedil;&atilde;o (indiv&iacute;duos) inicial de cromossomas&semi;</li>&#10;<li>Mecanismo para avalia&ccedil;&atilde;o dos cromossomas mediante as suas caracter&iacute;sticas&semi;</li>&#10;<li>Mecanismo para reprodu&ccedil;&atilde;o de cromossomas, designado por operador gen&eacute;tico&semi;</li>&#10;<li>Defini&ccedil;&atilde;o dos par&acirc;metros de um AG.</li></ol>&#10;<p>Para o desenvolvimento do primeiro passo, deve&shy;se ter em considera&ccedil;&atilde;o que a representa&ccedil;&atilde;o tradicional de um algoritmo gen&eacute;tico &eacute; feita por <a href="http://en.wikipedia.org/wiki/Sistema_bin%C3%A1rio_(matem%C3%A1tica)" id="w">bin&aacute;rios</a> (zero&shy;um). Esta representa&ccedil;&atilde;o, embora eficiente, torna&shy;se cada vez mais limitada &agrave; medida que o n&uacute;mero de restri&ccedil;&otilde;es do problema cresce. Desta forma, convencionou&shy;se a utiliza&ccedil;&atilde;o de um vector, formado por n&uacute;meros inteiros, para a representa&ccedil;&atilde;o de um cromossoma.</p>&#10;<p>Qualquer que seja a representa&ccedil;&atilde;o escolhida, a mesma deve verificar uma associa&ccedil;&atilde;o correcta com as solu&ccedil;&otilde;es do problema em estudo. Isto &eacute;, para cada solu&ccedil;&atilde;o deve existir um cromossoma associado, atribu&iacute;do pelo AG, e vice&shy;versa.</p>&#10;<p>Para o PCV a representa&ccedil;&atilde;o que mais se adequa &eacute; a dos n&uacute;meros inteiros. Tal facto, deve&shy;se &agrave; possibilidade de obten&ccedil;&atilde;o de solu&ccedil;&otilde;es, por sequ&ecirc;ncia de tr&ecirc;s bits, al&eacute;m do n&uacute;mero de cidades do problema.</p>&#10;<p>Para a constru&ccedil;&atilde;o de uma popula&ccedil;&atilde;o inicial de cromossomas (passo 2), o AG demonstra uma capacidade bastante alta. Pegando num exemplo de um PCV com <i>n</i> cidades, a tarefa de se obter <i>k</i> solu&ccedil;&otilde;es exequ&iacute;veis numa estrutura de <i>k</i> cromossomas, mediante a utiliza&ccedil;&atilde;o da representa&ccedil;&atilde;o por n&uacute;meros inteiros, tem o mesmo significado que a obten&ccedil;&atilde;o de <i>k</i> vectores com <i>n</i> n&uacute;meros inteiros, de <i>1</i> a <i>n</i> e diferentes entre eles. Caso a obten&ccedil;&atilde;o da popula&ccedil;&atilde;o inicial de cromossomas seja dif&iacute;cil, isto &eacute;, caso o problema tenha v&aacute;rios par&acirc;metros e restri&ccedil;&otilde;es, torna&shy;se mais f&aacute;cil e r&aacute;pido a utiliza&ccedil;&atilde;o de heur&iacute;sticas simples.</p>&#10;<p>A avalia&ccedil;&atilde;o dos cromossomas num AG, faz&shy;se considerando a capacidade de sobreviv&ecirc;ncia dos cromossomas. Num PCV, esta capacidade de sobreviv&ecirc;ncia &eacute; relativa ao valor da fun&ccedil;&atilde;o objectivo, que por sua vez, &eacute; avaliada pelo cromossoma associado. Para um PCV com <i>n</i> igual a 5 cidades, por exemplo, a capacidade do cromossoma &eacute; avaliada consoante o custo <i>D</i>, referente &agrave; soma das dist&acirc;ncias <i>(<span class="math">d_{ij}</span>)</i>:</p>&#10;<pre>         <big><span class="math">D = d_{12} + d_{23} + d_{34} + d_{45} + d_{51}</span></big>&#10;</pre>&#10;<p>Assim, quanto menor o <i>D</i>, maior &eacute; o n&iacute;vel de aptid&atilde;o do cromossoma.</p>&#10;<p>O operador gen&eacute;tico &eacute; o n&uacute;cleo de um AG e o seu objectivo passa pela produ&ccedil;&atilde;o de novos cromossomas, com propriedades superiores relativamente aos que lhes deram origem.</p>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:Computational.science.Genetic.algorithm.Crossover.One.Point.svg%7Cthumb%7Cright%7C250px" id="w">Figura 3. Exemplo de &#39&semi;&#39&semi;crossover&#39&semi;&#39&semi; de um ponto, ou seja, um &#39&semi;&#39&semi;crossover&#39&semi;&#39&semi; com apenas uma quebra no cromossoma.</a></p>&#10;<p>Nos AG convencionais, os operadores gen&eacute;ticos mais utilizados s&atilde;o a <a href="http://en.wikipedia.org/wiki/Muta%C3%A7%C3%A3o" id="w">muta&ccedil;&atilde;o</a> e o  </p>&#10;<p>Estes dois tipos de operadores, embora simples, t&ecirc;m a particularidade de n&atilde;o conseguirem dar uma resposta adequada quando confrontados com problemas de elevada complexidade.</p>&#10;<p>Os par&acirc;metros de um algoritmo gen&eacute;tico que se devem ter em considera&ccedil;&atilde;o, aquando da sua implementa&ccedil;&atilde;o, diferem entre autores. De uma maneira geral, os par&acirc;metros s&atilde;o os seguintes:</p>&#10;&#10;<ul>&#10;<li>Tamanho da popula&ccedil;&atilde;o&semi;</li>&#10;<li>Selec&ccedil;&atilde;o dos cromossomas reprodutores&semi;</li>&#10;<li>Crit&eacute;rio de sobreviv&ecirc;ncia dos cromossomas&semi;</li>&#10;<li>Crit&eacute;rio de finaliza&ccedil;&atilde;o de um AG.</li></ul>&#10;<p>Sendo o PCV um problema de optimiza&ccedil;&atilde;o muito complexo, o AG convencional &eacute; um m&eacute;todo relativamente ineficaz quando comparado com outras heur&iacute;sticas desenvolvidas. Desta forma, o AG sofreu v&aacute;rios desenvolvimentos com o intuito de dar resposta &agrave;s condi&ccedil;&otilde;es propostas pelos problemas. A este conjunto de algoritmos gen&eacute;ticos d&aacute;&shy;se o nome de algoritmos gen&eacute;ticos n&atilde;o convencionais <span id="refbOchi1998"><a href="http://en.wikipedia.org/wiki/#refOchi1998" id="w">(Ochi, 1998)</a></span>.</p>&#10;<a id="%5B%5BOtimiza%C3%A7%C3%A3o_da_col%C3%B4nia_de_formigas%7CAlgoritmo_ACO%5D%5D" name="%5B%5BOtimiza%C3%A7%C3%A3o_da_col%C3%B4nia_de_formigas%7CAlgoritmo_ACO%5D%5D"></a><h3> [[Otimiza&ccedil;&atilde;o da col&ocirc;nia de formigas|Algoritmo ACO]] </h3>&#10;<p>O PCV tem um papel importante na <a href="http://en.wikipedia.org/wiki/Otimiza%C3%A7%C3%A3o_da_col%C3%B4nia_de_formigas" id="w">optimiza&ccedil;&atilde;o das col&oacute;nias de formigas</a>,  </p>&#10;<p>O PCV foi escolhido por muitas raz&otilde;es:</p>&#10;&#10;<ul>&#10;<li>&Eacute; um problema para o qual os algoritmos ACO s&atilde;o facilmente aplicados&semi;</li>&#10;<li>&Eacute; um problema de optimiza&ccedil;&atilde;o NP&shy;dif&iacute;cil&semi;</li>&#10;<li>Serve de teste para a aplica&ccedil;&atilde;o de novos algoritmos, e um bom desempenho no PCV &eacute; muitas vezes tido em considera&ccedil;&atilde;o como prova da sua utilidade&semi;</li>&#10;<li>&Eacute; um problema facilmente percept&iacute;vel, o que faz com que a linha de desenvolvimento de um algoritmo n&atilde;o se difunda em demasiados aspectos t&eacute;cnicos.</li></ul>&#10;<p>Nos algoritmos ACO, as formigas s&atilde;o simples agentes que, no caso do PCV, constroem circuitos atrav&eacute;s do movimento entre cidades no grafo do problema. A solu&ccedil;&atilde;o construida pelas formigas &eacute; elaborada por trilhos de <a href="http://en.wikipedia.org/wiki/Ferom%C3%B4nio" id="w">feromonas</a> (artificiais) e pela disponibilidade de informa&ccedil;&atilde;o heur&iacute;stica, &agrave; priori. Quando o algoritmo ACO &eacute; aplicado, &eacute; associada uma for&ccedil;a da feromona , onde <big><span class="math">\tau_{ij}(t)</span></big> &eacute; uma informa&ccedil;&atilde;o num&eacute;rica que &eacute; modificada durante o algoritmo, e <i>t</i> &eacute; o contador das itera&ccedil;&otilde;es.</p>&#10;<p>Para o PCV sim&eacute;trico, o algoritmo ACO caracteriza&shy;se por <big><span class="math">\tau_{ij}(t) = \tau_{ji}(t)</span></big>. No assim&eacute;trico a igualdade pode ser desfeita por  <span class="math">\ne</span> <span class="math">\tau_{ji}(t)</span>.</p>&#10;<p>Inicialmente, cada uma das <i>m</i> formigas &eacute; colocada numa cidade, de forma aleat&oacute;ria, aplicando&shy;se depois, de modo iterativo, uma regra de transi&ccedil;&atilde;o de estado para cada uma das cidades.</p>&#10;<p>Uma formiga constroi um circuito da seguinte forma. Na cidade <i>i</i> a formiga escolhe uma cidade <i>j</i> que ainda n&atilde;o tenha visitado. Esta escolha &eacute; feita probabilisticamente segundo a for&ccedil;a da feromona <span class="math">\tau_{ij}(t)</span> no arco entre as cidades <i>i</i> e <i>j</i>, e a informa&ccedil;&atilde;o heur&iacute;stica dispon&iacute;vel localmente, que &eacute; fun&ccedil;&atilde;o do comprimento do arco. As formigas, de um modo probabil&iacute;stico, preferem as cidades que estejam mais pr&oacute;ximas e ligadas por arcos com grande for&ccedil;a de feromona. Para construir um solu&ccedil;&atilde;o exequ&iacute;vel, cada formiga possui uma forma de mem&oacute;ria limitada, chamada <i>tabu list</i> onde &eacute; guardada o corrente circuito parcial. A mem&oacute;ria &eacute; utilizada para determinar, a cada passo da constru&ccedil;&atilde;o, o conjunto de cidades que t&ecirc;m ainda que ser visitadas e para garantir que &eacute; elaborada uma solu&ccedil;&atilde;o exequ&iacute;vel. Adicionalmente, permite &agrave; formiga refazer o seu circuito, assim que esteja completo.</p>&#10;<p>Depois de todas as formigas terem constru&iacute;do um circuito, as feromonas s&atilde;o actualizadas. Isto &eacute; tipicamente elaborado atrav&eacute;s da descida da for&ccedil;a dos trilhos das feromonas, atrav&eacute;s de um factor constante, e depois &eacute; dada liberdade para que as formigas depositem as suas feromonas nos arcos que visitaram. A actualiza&ccedil;&atilde;o dos trilhos &eacute; feita de tal forma que os arcos mais curtos, ou visitados por muitas formigas, recebem quantidades maiores de feromonas e por isso s&atilde;o escolhidas com uma maior probabilidade nas itera&ccedil;&otilde;es posteriores (Figura 4). Neste sentido, a quantidade de feromonas <big><span class="math">\tau_{ij}(t)</span></big> representa o desejo instru&iacute;do de escolher a pr&oacute;xima cidade <i>j</i> quando a formiga estiver na cidade <i>i</i>.</p>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:Aco_TSP.svg%7Cthumb%7Ccenter%7C450px" id="w">Figura 4. Efeito do algoritmo ACO para a constitui&ccedil;&atilde;o do circuito preferencial.</a></p>&#10;<p>Os algoritmos ACO que melhor desempenho t&ecirc;m no PCV, melhoram os circuitos constru&iacute;dos pelas formigas atrav&eacute;s da aplica&ccedil;&atilde;o de algoritmos de procura local. Estes algoritmos s&atilde;o na verdade algoritmos h&iacute;bridos que combinam a constru&ccedil;&atilde;o da solu&ccedil;&atilde;o de modo probabil&iacute;stico com algoritmos de procura local.</p>&#10;<p>No aspecto geral, todos os algoritmos ACO para o PCV seguem o esquema de um algoritmo espec&iacute;fico. Depois de iniciados o rasto de feromonas e alguns par&acirc;metros, o circuito principal &eacute; repetido at&eacute; que a condi&ccedil;&atilde;o seja conhecida e rescindida. No circuito principal, primeiro as formigas constroem circuitos exequ&iacute;veis, depois os circuitos produzidos s&atilde;o melhorados pela aplica&ccedil;&atilde;o de uma procura local, e finalmente, os rastos de feromonas s&atilde;o actualizados. De facto, a maior parte dos algoritmos ACO que melhor se desenvolvem nos problemas NP&shy;dif&iacute;cil seguem este esquema algor&iacute;tmico.</p>&#10;<p>Por fim &eacute; de salientar que as metaheur&iacute;sticas ACO s&atilde;o mais generalizados que o esquema algor&iacute;tmico dado anteriormente <span id="refbSt&uuml;tzle1999"><a href="http://en.wikipedia.org/wiki/#refSt&uuml;tzle1999" id="w">(St&uuml;tzle, 1999)</a></span>.</p>&#10;<a id="%7B%7B%C3%82ncora%7D%7D_Algoritmo_por_programa%C3%A7%C3%A3o_din%C3%A2mica" name="%7B%7B%C3%82ncora%7D%7D_Algoritmo_por_programa%C3%A7%C3%A3o_din%C3%A2mica"></a><h3>  Algoritmo por programa&ccedil;&atilde;o din&acirc;mica </h3>&#10;&#10;<p>Se pensarmos em um abordagem de for&ccedil;a bruta, temos que avaliar todas as poss&iacute;veis jornadas e retornar a melhor encontrada. Essa abordagem utiliza tempo O(n!).</p>&#10;<p>Em programa&ccedil;&atilde;o din&acirc;mica temos uma solu&ccedil;&atilde;o muito mais r&aacute;pida, embora n&atilde;o polinomial.</p>&#10;<p>A programa&ccedil;&atilde;o din&acirc;mica reduz o n&uacute;mero de poss&iacute;veis combina&ccedil;&otilde;es eliminando as que n&atilde;o poder&atilde;o fazer parte de uma solu&ccedil;&atilde;o &oacute;tima do problema, dando assim origem a algoritmos mais eficientes.</p>&#10;<p>A ideia b&aacute;sica &eacute; construir por etapas uma resposta &oacute;tima combinando respostas j&aacute; obtidas para partes menores. Assim, &eacute; poss&iacute;vel escolher subproblemas de modo que a informa&ccedil;&atilde;o vital seja recordada e levada a diante.</p>&#10;<p>Precisamos saber todas as cidades visitadas, para que n&atilde;o repitamos nenhuma delas. Veja um subproblema apropriado:</p>&#10;<p>Para um subconjunto de cidades <span class="math">S \subseteq {1,2,...,n}</span> que inclui <span class="math">1</span> e <span class="math">j \in S</span>, seja <span class="math">C(S,j)</span> o comprimento do caminho m&iacute;nimo visitando cada n&oacute; em <span class="math">S</span> exatamente uma vez, come&ccedil;ando em <span class="math">1</span> e terminando em <span class="math">j</span>.</p>&#10;<p>Vamos expressar <span class="math">C(S,j)</span> em termos de subproblemas menores. Precisamos come&ccedil;ar em <span class="math">1</span> e terminar em <span class="math">j</span>&semi; qual devemos escolher como a pen&uacute;ltima cidade? Ela tem de ser algum <span class="math">i</span> <span class="math">\in S</span>, tal que o comprimento total seja a dist&acirc;ncia de <span class="math">1</span> at&eacute; <span class="math">i</span>, ou seja <span class="math">C(S &shy; \{j\}, i)</span>, mais o comprimento da aresta final, <span class="math">d_{ij}</span>. Temos de selecionar o melhor tal que:</p>&#10;<p><span class="math">C(S,j) = \min_{i \in S, i \neq j} C(S &shy; \{j\}, i) + dij</span></p>&#10;<p>Pseudoc&oacute;digo:</p> &#10;<pre><b>Os problemas s&atilde;o ordenados por |S|:</b>&#10; &#10;   <b>C({1},1) = 0</b>:&#10;   <b>Para s = 2 at&eacute; n</b>:&#10;           <b>Para todos os subconjuntos S <span class="math">\subseteq</span> {1,2,...,n} de tamanho s e contendo 1:</b>&#10;               <b>C(S,1) = <span class="math">\infty</span></b>:&#10;               <b>Para todo j <span class="math">\in</span> S, i <span class="math">\neq</span> j:</b>&#10;                      <b>C(S,j) = min{C(S &shy; {j},i) + d<span class="math">_{ij}</span>: i <span class="math">\in</span> S, i <span class="math">\neq</span> j}</b></pre>&#10;<pre>   <b>Retornar min<span class="math">_{j}</span> C({1,...,n},j) + d<span class="math">_{ij}</span></b>&#10;&#10;</pre><a id="Refer%C3%AAncias_gerais" name="Refer%C3%AAncias_gerais"></a><h2> Refer&ecirc;ncias gerais </h2>&#10;&#10;<ul>&#10;<li>&#10;<div id="refcApplegate2006">APPLEGATE, David L. [et al.] &ndash; <i>The travelling salesman problem: a computational Study</i>. Princeton: Princeton University Press, 2006. <a class="external text" href="http://www.amazon.com/exec/obidos/ASIN/9780691129938" rel="nofollow" title="http://www.amazon.com/exec/obidos/ASIN/9780691129938">ISBN 978&shy;0&shy;691&shy;12993&shy;8</a></div></li>&#10;<li>&#10;<div id="refB&auml;ck1996"><a href="http://en.wikipedia.org/wiki/#refbB&auml;ck1996" id="w">B&auml;CK</a>, Thomas &ndash; <i>Evolutionary algorithms in theory and practice</i>. New York: Oxford University Press, 1996. <a class="external text" href="http://www.amazon.com/exec/obidos/ASIN/9780195099713" rel="nofollow" title="http://www.amazon.com/exec/obidos/ASIN/9780195099713">ISBN 978&shy;0&shy;195&shy;09971&shy;3</a></div></li>&#10;<li>&#10;<div id="refConway2003"><a href="http://en.wikipedia.org/wiki/#refbConway2003" id="w">CONWAY</a>, Richard Walter&semi; MAXWELL, William L.&semi; MILLER, Louis W. &ndash; <i>Theory of scheduling</i>. Reading, [Mass]: Edi&ccedil;&atilde;o de Courier Dover Publications, 2003. <a class="external text" href="http://www.amazon.com/exec/obidos/ASIN/9780486428178" rel="nofollow" title="http://www.amazon.com/exec/obidos/ASIN/9780486428178">ISBN 978&shy;0&shy;486&shy;42817&shy;8</a></div></li>&#10;<li>&#10;<div id="refCosta2003"><a href="http://en.wikipedia.org/wiki/#refbCosta2003" id="w">COSTA</a>, Fredson Vieira&semi; VIDAL, F&aacute;bio Silveira&semi; ANDR&Eacute;, Claudomiro Moura Gomes &ndash; <i>SLAG &ndash; Resolvendo o problema do caixeiro viajante utilizando algoritmos gen&eacute;ticos</i> [Em Linha]. Tocantins [Brasil]: Sistemas e Computa&ccedil;&atilde;o &shy; P&oacute;s&shy;Gradua&ccedil;&atilde;o, 2003. [Consult. 15 Abr. 2009]. Dispon&iacute;vel em WWW: &#60&semi;URL:<a class="externallink" href="http://www.de9.ime.eb.br/~fsvidal/trabpub/slag.pdf" rel="nofollow" title="http://www.de9.ime.eb.br/~fsvidal/trabpub/slag.pdf">http://www.de9.ime.eb.br/~fsvidal/trabpub/slag.pdf</a>&#62&semi;</div></li>&#10;<li>&#10;<div id="refcCunha2002">CUNHA, Claudio Barbieri da&semi; BONASSER, Ulisses de Oliveira&semi; ABRAH&Atilde;O, Fernando Teixeira Mendes &ndash; <i>Experimentos computacionais com heur&iacute;sticas de melhorias para o problema do caixeiro viajante</i> [Em Linha]. S&atilde;o Paulo: ANPET, 2002. [Consult. 13 Abr. 2009]. Dispon&iacute;vel em WWW: &#60&semi;URL:<a class="externallink" href="http://www.ptr.poli.usp.br/ptr/docentes/cbcunha/files/2&shy;opt_TSP_Anpet_2002_CBC.pdf" rel="nofollow" title="http://www.ptr.poli.usp.br/ptr/docentes/cbcunha/files/2&shy;opt_TSP_Anpet_2002_CBC.pdf">http://www.ptr.poli.usp.br/ptr/docentes/cbcunha/files/2&shy;opt_TSP_Anpet_2002_CBC.pdf</a>&#62&semi;</div></li>&#10;<li>&#10;<div id="refGuedes2005"><a href="http://en.wikipedia.org/wiki/#refbGuedes2005" id="w">GUEDES</a>, Allison da Costa Neves&semi; LEITE, J&eacute;ssica Neiva de Figueiredo&semi; ALOISE, D&aacute;rio Jos&eacute; &ndash; <i>Um algoritmo gen&eacute;tico com infec&ccedil;&atilde;o viral para o problema do caixeiro viajante</i> [Em Linha]. Natal [Brasil]: Revista On Line de Inicia&ccedil;&atilde;o Cient&iacute;fica, 2005. [Consult. 15 Abr. 2009]. Dispon&iacute;vel em WWW: &#60&semi;URL:<a class="externallink" href="http://www.propesq.ufrn.br/publica/artigos&shy;1edicao/et/MSIC&shy;ET&shy;011.pdf" rel="nofollow" title="http://www.propesq.ufrn.br/publica/artigos&shy;1edicao/et/MSIC&shy;ET&shy;011.pdf">http://www.propesq.ufrn.br/publica/artigos&shy;1edicao/et/MSIC&shy;ET&shy;011.pdf</a>&#62&semi;</div></li>&#10;<li>&#10;<div id="refGoodrich1899"><a href="http://en.wikipedia.org/wiki/#refbGoodrich1899" id="w">GOODRICH</a>, Michael T.&semi; TAMASSIA, Roberto &ndash; <i>Estruturas de Dados E Algoritmos Em Java </i>. 4&ordf; ed.. S&atilde;o Paulo: Edi&ccedil;&atilde;o de Bookman, 1899. <a class="external text" href="http://www.amazon.com/exec/obidos/ASIN/9780471738848" rel="nofollow" title="http://www.amazon.com/exec/obidos/ASIN/9780471738848">ISBN 978&shy;0&shy;471&shy;73884&shy;8</a></div></li>&#10;<li>&#10;<div id="refHoffman2000"><a href="http://en.wikipedia.org/wiki/#refbHoffman2000" id="w">HOFFMAN</a>, Karla&semi; PADBERG, Manfred &ndash; <i>Traveling salesman problem</i> [Em Linha]. Fairfax [Virg&iacute;nia]: Department of Electrical and Computer Engineering &shy; George Mason University, 2000. [Consult. 13 Abr. 2009]. Dispon&iacute;vel em WWW: &#60&semi;URL: <a class="externallink" href="http://iris.gmu.edu/~khoffman/papers/trav_salesman.html" rel="nofollow" title="http://iris.gmu.edu/~khoffman/papers/trav_salesman.html">http://iris.gmu.edu/~khoffman/papers/trav_salesman.html</a>&#62&semi;</div></li>&#10;<li>&#10;<div id="refNilsson1982"><a href="http://en.wikipedia.org/wiki/#refbNilsson1982" id="w">NILSSON</a>, Nils J. &ndash; <i>Principals of artificial intelligence</i>. New York: edi&ccedil;&atilde;o de Birkhauser, 1982. <a class="external text" href="http://www.amazon.com/exec/obidos/ASIN/9783540113409" rel="nofollow" title="http://www.amazon.com/exec/obidos/ASIN/9783540113409">ISBN 978&shy;3&shy;540&shy;11340&shy;9</a></div></li>&#10;<li>&#10;<div id="refOchi1998"><a href="http://en.wikipedia.org/wiki/#refbOchi1998" id="w">OCHI</a>, Luiz Satoru &ndash; <i>Algoritmos gen&eacute;ticos: origem e evolu&ccedil;&atilde;o</i> [Em Linha]. S&atilde;o Paulo: Sociedade Brasileira de Matem&aacute;tica Aplicada e Computacional, 1998. [Consult. 18 Abr. 2009]. Dispon&iacute;vel em WWW: &#60&semi;URL:<a class="externallink" href="http://www.sbmac.org.br/bol/bol&shy;2/artigos/satoru/satoru.html#caixeiro" rel="nofollow" title="http://www.sbmac.org.br/bol/bol&shy;2/artigos/satoru/satoru.html#caixeiro">http://www.sbmac.org.br/bol/bol&shy;2/artigos/satoru/satoru.html#caixeiro</a>&#62&semi;</div></li>&#10;<li>&#10;<div id="refSiqueira2006"><a href="http://en.wikipedia.org/wiki/#refbSiqueira2006" id="w">SIQUEIRA</a>, Paulo Henrique&semi; STEINER, Maria Teresinha Arns&semi; SCHEER, S&eacute;rgio &ndash; <i>A new approach to solve the traveling salesman problem</i> [Em Linha]. Amsterdam: ScienceDirect &shy; Neurocomputing: A new approach to solve the traveling salesman problem, 2006. [Consult. 15 Abr. 2009]. Dispon&iacute;vel em WWW: &#60&semi;URL:<a class="externallink" href="http://www.sciencedirect.com/science?_ob=ArticleURL&#38&semi;_udi=B6V10&shy;4M7CMDB&shy;1&#38&semi;_user=2975255&#38&semi;_rdoc=1&#38&semi;_fmt=&#38&semi;_orig=search&#38&semi;_sort=d&#38&semi;view=c&#38&semi;_acct=C000057395&#38&semi;_version=1&#38&semi;_urlVersion=0&#38&semi;_userid=2975255&#38&semi;md5=c0e8406e94b63d03d280bac5311d805e" rel="nofollow" title="http://www.sciencedirect.com/science?_ob=ArticleURL&#38&semi;_udi=B6V10&shy;4M7CMDB&shy;1&#38&semi;_user=2975255&#38&semi;_rdoc=1&#38&semi;_fmt=&#38&semi;_orig=search&#38&semi;_sort=d&#38&semi;view=c&#38&semi;_acct=C000057395&#38&semi;_version=1&#38&semi;_urlVersion=0&#38&semi;_userid=2975255&#38&semi;md5=c0e8406e94b63d03d280bac5311d805e">http://www.sciencedirect.com/science?_ob=ArticleURL&#38&semi;_udi=B6V10&shy;4M7CMDB&shy;1&#38&semi;_user=2975255&#38&semi;_rdoc=1&#38&semi;_fmt=&#38&semi;_orig=search&#38&semi;_sort=d&#38&semi;view=c&#38&semi;_acct=C000057395&#38&semi;_version=1&#38&semi;_urlVersion=0&#38&semi;_userid=2975255&#38&semi;md5=c0e8406e94b63d03d280bac5311d805e</a>&#62&semi;</div></li>&#10;<li>&#10;<div id="refSt&uuml;tzle1999"><a href="http://en.wikipedia.org/wiki/#refbSt&uuml;tzle1999" id="w">ST&#220&semi;TZLE</a>, Thomas&semi; DORIGO, Marco &ndash; <i>ACO Algorithms for the traveling salesman problem</i> [Em Linha]. New York: Swarm Intelligence Resources, 1999. [Consult. 17 Abr. 2009]. Dispon&iacute;vel em WWW: &#60&semi;URL:<a class="externallink" href="http://staff.washington.edu/paymana/swarm/stutzle99&shy;eaecs.pdf" rel="nofollow" title="http://staff.washington.edu/paymana/swarm/stutzle99&shy;eaecs.pdf">http://staff.washington.edu/paymana/swarm/stutzle99&shy;eaecs.pdf</a>&#62&semi;</div></li></ul>&#10;<a id="Bibliografia" name="Bibliografia"></a><h2> Bibliografia </h2>&#10;&#10;<ul>&#10;<li>CERVIERI, Alexandre&semi; PY, M&oacute;nica &ndash; <i>Algoritmo para a resolu&ccedil;&atilde;o do problema do caixeiro viajante</i> [Em Linha]. Porto Alegre: Instituto de Inform&aacute;tica &shy; UFRGS, 2000. [Consult. 15 Abr. 2009]. Dispon&iacute;vel em WWW: &#60&semi;URL:<a class="externallink" href="http://www.inf.ufrgs.br/procpar/disc/cmp134/trabs/T2/001/mpisalesman/mpisalesman.pdf" rel="nofollow" title="http://www.inf.ufrgs.br/procpar/disc/cmp134/trabs/T2/001/mpisalesman/mpisalesman.pdf">http://www.inf.ufrgs.br/procpar/disc/cmp134/trabs/T2/001/mpisalesman/mpisalesman.pdf</a>&#62&semi;</li>&#10;<li>REEVES, Colin R., ed. &ndash; <i>Modern heuristic techniques for combinatorial problems</i>. Ed. Colin R. Reeves. London: McGraw&shy;Hill Book, 2000. XIII, 320 p..( Advanced Topic in Computer Science). <a class="external text" href="http://www.amazon.com/exec/obidos/ASIN/9780077092399" rel="nofollow" title="http://www.amazon.com/exec/obidos/ASIN/9780077092399">ISBN 978&shy;0&shy;077&shy;09239&shy;9</a></li>&#10;<li>LAWLER, Eug&egrave;ne L.&semi; RINNOOY&shy;KAN, A. H. G.&semi; LENSTRA, Jan Karel&semi; SHMOYS, David B. &ndash; <i>The Traveling salesman problem: a guided tour of combinatorial optimization</i>. [S.l.]: Edi&ccedil;&atilde;o de Wiley, 1985. <a class="external text" href="http://www.amazon.com/exec/obidos/ASIN/9780471904137" rel="nofollow" title="http://www.amazon.com/exec/obidos/ASIN/9780471904137">ISBN 978&shy;0&shy;471&shy;90413&shy;7</a></li></ul>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Algoritmo_simplex" id="w">Algoritmo simplex</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Problema_de_roteamento_de_ve%C3%ADculos" id="w">Problema de roteamento de ve&iacute;culos</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Problema_da_mochila" id="w">Problema da mochila</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Problema_do_caminho_m%C3%ADnimo" id="w">Problema do caminho m&iacute;nimo</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Caminho_hamiltoniano" id="w">Caminho hamiltoniano</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Sete_pontes_de_K%C3%B6nigsberg" id="w">Sete pontes de K&ouml;nigsberg</a></li></ul>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li></ul>&#10;<p> &#10;<a href="http://en.wikipedia.org/wiki/Categoria:Log%C3%ADstica" id="w">Categoria:Log&iacute;stica</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos_de_grafos" id="w">Categoria:Algoritmos de grafos</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Problemas_matem%C3%A1ticos" id="w">Categoria:Problemas matem&aacute;ticos</a></p>&#10;<p> </p></body></html>