<html><title>Torre de Han&oacute;i</title><body>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Tower_of_Hanoi.jpeg%7C300px%7Cthumb" id="w">Um Modelo das Torres de Hanoi</a>&#10;<b>Torre de Han&oacute;i</b> &eacute; um &#34&semi;<a href="http://en.wikipedia.org/wiki/Quebra&shy;cabe%C3%A7a" id="w">quebra&shy;cabe&ccedil;a</a>&#34&semi; que consiste em uma base contendo tr&ecirc;s pinos, em um dos quais s&atilde;o dispostos alguns <a href="http://en.wikipedia.org/wiki/C%C3%ADrculo" id="w">discos</a> uns sobre os outros, em ordem crescente de di&acirc;metro, de cima para baixo.  O problema consiste em passar todos os discos de um pino para outro qualquer, usando um dos pinos como auxiliar, de maneira que um disco maior nunca fique em cima de outro menor em nenhuma situa&ccedil;&atilde;o.  O n&uacute;mero de discos pode variar sendo que o mais simples cont&eacute;m apenas tr&ecirc;s.</p>&#10;<p>A Torre de Han&oacute;i tem sido tradicionalmente considerada como um procedimento para avalia&ccedil;&atilde;o da capacidade de mem&oacute;ria de trabalho, e principalmente de planejamento e solu&ccedil;&atilde;o de problemas.</p>&#10;<a id="Origens" name="Origens"></a><h2> Origens </h2>&#10;&#10;<p>O quebra&shy;cabe&ccedil;a foi divulgado pela primeira vez no Ocidente pelo matem&aacute;tico franc&ecirc;s <a href="http://en.wikipedia.org/wiki/Edouard_Lucas" id="w">&Eacute;douard Lucas</a>. Ele teve inspira&ccedil;&atilde;o de uma lenda para construir o jogo das Torres de Han&oacute;i em 1883<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup>. J&aacute; seu nome foi inspirado na torre s&iacute;mbolo da cidade de <a href="http://en.wikipedia.org/wiki/Han%C3%B3i" id="w">Han&oacute;i</a>, no <a href="http://en.wikipedia.org/wiki/Vietn%C3%A3" id="w">Vietn&atilde;</a><sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup>.</p>&#10;<p>Existem v&aacute;rias lendas a respeito da origem do jogo, a mais conhecida diz respeito a um templo <a href="http://en.wikipedia.org/wiki/Hindu" id="w">Hindu</a>, situado no centro do universo. Diz&shy;se que <a href="http://en.wikipedia.org/wiki/Brahma" id="w">Brahma</a> supostamente havia criado uma torre com 64 discos de ouro e mais duas estacas equilibradas sobre uma plataforma. Brahma ordenara&shy;lhes que movessem todos os discos de uma estaca para outra segundo as suas instru&ccedil;&otilde;es. As regras eram simples: apenas um disco poderia ser movido por vez e nunca um disco maior deveria ficar por cima de um disco menor. Segundo a lenda, quando todos os discos fossem transferidos de uma estaca para a outra, o templo desmoronar&shy;se&shy;ia e o mundo desapareceria.  N&atilde;o &eacute; claro se Lucas inventou essa lenda ou foi inspirado por ele.</p>&#10;<p>Existem muitas varia&ccedil;&otilde;es sobre esta lenda. Por exemplo, em algumas narrativas, o templo &eacute; um mosteiro e os sacerdotes s&atilde;o monges. O templo ou mosteiro pode estar em diferentes partes do mundo &shy; incluindo Han&oacute;i, Vietn&atilde;, e pode ser associado a qualquer religi&atilde;o. Em algumas vers&otilde;es, s&atilde;o introduzidos outros elementos, tais como o facto de a torre foi criado no in&iacute;cio do mundo, ou que os padres ou monges podem fazer apenas uma mudan&ccedil;a por dia.</p>&#10;<a id="Solu%C3%A7%C3%B5es" name="Solu%C3%A7%C3%B5es"></a><h2> Solu&ccedil;&otilde;es </h2>&#10;&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Tower_of_Hanoi_4.gif%7Cright%7Cframed" id="w">Solu&ccedil;&atilde;o do problema com uma torre de quatro discos.</a></p>&#10;<p>&Eacute; interessante observar que o n&uacute;mero m&iacute;nimo de &#34&semi;movimentos&#34&semi; para conseguir transferir todos os discos da primeira estaca &agrave; terceira &eacute; 2<sup>n</sup>&shy;1, sendo n o n&uacute;mero de discos. Logo:</p>&#10;<p>Para solucionar um Han&oacute;i de 4 discos, s&atilde;o necess&aacute;rios 15 movimentos</p>&#10;<p>Para solucionar um Han&oacute;i de 7 discos, s&atilde;o necess&aacute;rios 127 movimentos</p>&#10;<p>Para solucionar um Han&oacute;i de 15 discos, s&atilde;o necess&aacute;rios 32.767 movimentos</p>&#10;<p>Para solucionar um Han&oacute;i de 64 discos, como diz a lenda, s&atilde;o necess&aacute;rios 18.446.744.073.709.551.615  movimentos.</p>&#10;<p>Para mover o primeiro disco da torre original, 1 movimento &eacute; gasto. Para mover o segundo da torre original, sendo que o primeiro j&aacute; foi movido e ser&aacute; constru&iacute;da uma torre com os 2 menores discos, s&atilde;o gastos 2 movimentos. Para deslocar o terceiro disco formando nova torre com os tr&ecirc;s menores discos, tendo a torre com os dois menores j&aacute; formada, s&atilde;o gastos 7 movimentos.</p>&#10;<p>Assim se sucede com os pr&oacute;ximos discos at&eacute; que o en&eacute;simo disco (o &uacute;ltimo) seja deslocado compondo uma torre com os outros discos tendo uma torre com o pen&uacute;ltimo disco e os demais juntos j&aacute; formada. A sucess&atilde;o formada pela soma dos movimentos &eacute; uma sucess&atilde;o <span class="math">(1,2,4,8...2^n)</span></p>&#10;<p>A f&oacute;rmula <span class="math">2^n&shy;1</span> &eacute; provinda da soma de uma progress&atilde;o geom&eacute;trica.</p>&#10;<p>Sabe&shy;se que em uma progress&atilde;o geom&eacute;trica a soma de seus termos equivale a <span class="math">[a*(q^n&shy;1)]/q&shy;1</span>, onde &#34&semi;a&#34&semi; &eacute; o primeiro termo e &#34&semi;q&#34&semi; &eacute; a raz&atilde;o.</p>&#10;<p>J&aacute; que a raz&atilde;o &eacute; 2 e o primeiro termo &eacute; 1 temos que <span class="math">[a*(q^n&shy;1)]/q&shy;1 = [1*(2^n&shy;1)]/2&shy;1 = 2^n&shy;1</span></p>&#10;<p>Uma solu&ccedil;&atilde;o <b>iterativa</b> em <b>Java</b> para as Torres de Hanoi. A letra <b>A</b> representa o primeiro pino mais &agrave; esquerda, a letra <b>C</b> o pino central e a letra <b>B</b> representa o &uacute;ltimo pino para o qual todos os Disco devem estar no final do algoritmo.&#10;</p><a id="%5B%5BJava_(linguagem_de_programa%C3%A7%C3%A3o)%7CJAVA%5D%5D" name="%5B%5BJava_(linguagem_de_programa%C3%A7%C3%A3o)%7CJAVA%5D%5D"></a><h3> [[Java (linguagem de programa&ccedil;&atilde;o)|JAVA]] </h3>&#10;<p /><pre class="code">&#10;<b><font color="#7F0055">import</font></b> java.util.ArrayList&semi;  &#10;<b><font color="#7F0055">import</font></b> java.util.Collections&semi;  &#10;<b><font color="#7F0055">import</font></b> java.util.InputMismatchException&semi;  &#10;<b><font color="#7F0055">import</font></b> java.util.List&semi;  &#10;<b><font color="#7F0055">import</font></b> java.util.Scanner&semi;  &#10;   &#10;<b><font color="#7F0055">class</font></b> Disco <b><font color="#7F0055">implements</font></b> Comparable&#60&semi;Disco&#62&semi;{  &#10;      Integer index&semi;  &#10;      String movimento&semi;  &#10;      Disco(<b><font color="#7F0055">int</font></b> index,String movimento){  &#10;         <b><font color="#7F0055">this</font></b>.index=index&semi;  &#10;         <b><font color="#7F0055">this</font></b>.movimento=movimento&semi;  &#10;      }  &#10;    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">int</font></b> compareTo(Disco o) {  &#10;        <b><font color="#7F0055">return</font></b> index.compareTo(o.index)&semi;  &#10;    }&#10;}  &#10;<b><font color="#7F0055">public</font></b> <b><font color="#7F0055">class</font></b> HanoiIterativo {     &#10;    <b><font color="#7F0055">private</font></b> <b><font color="#7F0055">int</font></b> qtDiscos&semi;    &#10;    <b><font color="#7F0055">private</font></b> String sequenciaImpares[] =   {<font color="#2A00FF">&#34&semi;A&shy;&shy;&#62&semi;C&#34&semi;</font>, <font color="#2A00FF">&#34&semi;C&shy;&shy;&#62&semi;B&#34&semi;</font>, <font color="#2A00FF">&#34&semi;B&shy;&shy;&#62&semi;A&#34&semi;</font>}&semi;<font color="#3F7F5F">//para impares   &#10;</font>    <b><font color="#7F0055">private</font></b> String sequenciaPares  [] =   {<font color="#2A00FF">&#34&semi;A&shy;&shy;&#62&semi;B&#34&semi;</font>, <font color="#2A00FF">&#34&semi;B&shy;&shy;&#62&semi;C&#34&semi;</font>, <font color="#2A00FF">&#34&semi;C&shy;&shy;&#62&semi;A&#34&semi;</font>}&semi;<font color="#3F7F5F">//para pares    &#10;</font>    <b><font color="#7F0055">private</font></b> List&#60&semi;Disco&#62&semi; arrayDiscos = <b><font color="#7F0055">new</font></b> ArrayList&#60&semi;Disco&#62&semi;()&semi;  &#10;    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> lerDados() {    &#10;        System.out.println(<font color="#2A00FF">&#34&semi;Digite a quantidade de  discos&#34&semi;</font>)&semi;    &#10;        Scanner rc = <b><font color="#7F0055">new</font></b> Scanner(System.in)&semi;    &#10;        <b><font color="#7F0055">try</font></b>{    &#10;         qtDiscos = rc.nextInt()&semi;    &#10;        }<b><font color="#7F0055">catch</font></b>(InputMismatchException e){    &#10;            System.out.println(<font color="#2A00FF">&#34&semi;Amig&atilde;o! &Eacute; f&aacute;cil! Digite o n&uacute;mero de discos por favor!&#34&semi;</font>)&semi;    &#10;            lerDados()&semi;    &#10;        }     &#10;    }    &#10;    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">void</font></b> hanoi() {         &#10;            <b><font color="#7F0055">int</font></b> maxP=(<b><font color="#7F0055">int</font></b>) Math.pow(2, qtDiscos)&semi;  &#10;            <b><font color="#7F0055">int</font></b> y  = 1&semi;  &#10;            <b><font color="#7F0055">int</font></b> pos =1&semi;  &#10;            <b><font color="#7F0055">while</font></b>(y &#60&semi;= qtDiscos ){     &#10;                 <b><font color="#7F0055">int</font></b> ctPulos = (<b><font color="#7F0055">int</font></b>) Math.pow(2, y)&semi;  &#10;                 pos*=2&semi;  &#10;                 <b><font color="#7F0055">if</font></b>(y==1){  &#10;                     pos=1&semi;  &#10;                 }  &#10;                 <b><font color="#7F0055">if</font></b>(qtDiscos%2==0){  &#10;                  populaArrayPares(pos,ctPulos,maxP,y)&semi;  &#10;                 }<b><font color="#7F0055">else</font></b>{  &#10;                  populaArrayImpares(pos,ctPulos,maxP,y)&semi;  &#10;                 }  &#10;                 y++&semi;  &#10;           }  &#10;    }  &#10;    <b><font color="#7F0055">private</font></b> <b><font color="#7F0055">void</font></b> populaArrayPares(<b><font color="#7F0055">int</font></b> pos,<b><font color="#7F0055">int</font></b> intervalos, <b><font color="#7F0055">int</font></b> maxP,<b><font color="#7F0055">int</font></b> y){  &#10;           <b><font color="#7F0055">int</font></b> index = 0&semi;  &#10;           <b><font color="#7F0055">if</font></b>(y%2==0){  &#10;               <b><font color="#7F0055">for</font></b> (<b><font color="#7F0055">int</font></b> i = pos&semi; i &#60&semi;= maxP&semi; i+=intervalos) {  &#10;                   Disco d = <b><font color="#7F0055">new</font></b> Disco(i, sequenciaPares[index])&semi;  &#10;                   arrayDiscos.add(d)&semi;  &#10;                   index++&semi;  &#10;                   <b><font color="#7F0055">if</font></b>(index&#62&semi;2){  &#10;                      index=0&semi;   &#10;                   }  &#10;               }  &#10;           }<b><font color="#7F0055">else</font></b>{  &#10;               <b><font color="#7F0055">for</font></b> (<b><font color="#7F0055">int</font></b> i = pos&semi; i &#60&semi; maxP&semi; i+=intervalos) {  &#10;                   Disco d = <b><font color="#7F0055">new</font></b> Disco(i, sequenciaImpares[index])&semi;  &#10;                   arrayDiscos.add(d)&semi;  &#10;                   index++&semi;  &#10;                   <b><font color="#7F0055">if</font></b>(index&#62&semi;2){  &#10;                      index=0&semi;   &#10;                   }  &#10;               }  &#10;           }          &#10;        }  &#10;    <b><font color="#7F0055">private</font></b> <b><font color="#7F0055">void</font></b> populaArrayImpares(<b><font color="#7F0055">int</font></b> pos,<b><font color="#7F0055">int</font></b> intervalos, <b><font color="#7F0055">int</font></b> maxP,<b><font color="#7F0055">int</font></b> y){  &#10;       <b><font color="#7F0055">int</font></b> index = 0&semi;  &#10;       <b><font color="#7F0055">if</font></b>(y%2==0){  &#10;           <b><font color="#7F0055">for</font></b> (<b><font color="#7F0055">int</font></b> i = pos&semi; i &#60&semi; maxP&semi; i+=intervalos) {  &#10;               Disco d = <b><font color="#7F0055">new</font></b> Disco(i, sequenciaImpares[index])&semi;  &#10;                   arrayDiscos.add(d)&semi;  &#10;                   index++&semi;  &#10;                   <b><font color="#7F0055">if</font></b>(index&#62&semi;2){  &#10;                      index=0&semi;   &#10;                   }  &#10;               }                 &#10;       }<b><font color="#7F0055">else</font></b>{  &#10;          <b><font color="#7F0055">for</font></b> (<b><font color="#7F0055">int</font></b> i = pos&semi; i &#60&semi;= maxP&semi; i+=intervalos) {  &#10;               Disco d = <b><font color="#7F0055">new</font></b> Disco(i, sequenciaPares[index])&semi;  &#10;               arrayDiscos.add(d)&semi;  &#10;           index++&semi;  &#10;           <b><font color="#7F0055">if</font></b>(index&#62&semi;2){  &#10;              index=0&semi;   &#10;           }  &#10;           }  &#10;       }          &#10;        }    &#10;    <b><font color="#7F0055">public</font></b> <b><font color="#7F0055">static</font></b> <b><font color="#7F0055">void</font></b> main(String[] args) {    &#10;        HanoiIterativo h = <b><font color="#7F0055">new</font></b> HanoiIterativo()&semi;    &#10;        h.lerDados()&semi;    &#10;        h.hanoi()&semi;    &#10;        Collections.sort(h.arrayDiscos)&semi;  &#10;        <b><font color="#7F0055">for</font></b> (Disco d : h.arrayDiscos) {  &#10;             System.out.println(<font color="#2A00FF">&#34&semi;execute: &#34&semi;</font>+d.index+<font color="#2A00FF">&#34&semi;  &#34&semi;</font>+d.movimento)&semi;  &#10;        }      &#10;    }    &#10;}  &#10;</pre>&#10;<a id="%5B%5BC_(linguagem_de_programa%C3%A7%C3%A3o)%7CC%5D%5D" name="%5B%5BC_(linguagem_de_programa%C3%A7%C3%A3o)%7CC%5D%5D"></a><h3> [[C (linguagem de programa&ccedil;&atilde;o)|C]] </h3>&#10;<a id="Implementa%C3%A7%C3%A3o_do_Algor%C3%ADtimo_Iterativo" name="Implementa%C3%A7%C3%A3o_do_Algor%C3%ADtimo_Iterativo"></a><h4> Implementa&ccedil;&atilde;o do Algor&iacute;timo Iterativo </h4>&#10;<p />&#10;&#10;<a id="Implementa%C3%A7%C3%A3o_do_Algor%C3%ADtimo_Recursivo" name="Implementa%C3%A7%C3%A3o_do_Algor%C3%ADtimo_Recursivo"></a><h4> Implementa&ccedil;&atilde;o do Algor&iacute;timo Recursivo </h4>&#10;<p />&#10;&#10;<a id="Aplica%C3%A7%C3%A3o" name="Aplica%C3%A7%C3%A3o"></a><h2> Aplica&ccedil;&atilde;o </h2>&#10;&#10;<p>A Torre de Han&oacute;i pode ser trabalhada em n&iacute;veis de desenvolvimento com crian&ccedil;as. Na pr&eacute;&shy;escola, com regras simples de separa&ccedil;&atilde;o de cores e tamanhos, a torre de Han&oacute;i ajuda em quest&otilde;es de coordena&ccedil;&atilde;o motora, identifica&ccedil;&atilde;o de formas, ordem crescente e decrescente, entre outras formas de aprendizado.</p>&#10;<p>De uma maneira mais ampla, o jogo pode ser usado para o estabelecimento de estrat&eacute;gias de transfer&ecirc;ncia das pe&ccedil;as, como a contagem dos movimentos e racioc&iacute;nio.</p>&#10;<p>Iniciando com um n&uacute;mero menor de pe&ccedil;as, ou seja, resolvendo problemas mais simples, teremos oportunidade de experimentar uma das mais importantes formas de racioc&iacute;nio matem&aacute;tico.</p>&#10;<p>O jogo trabalha o desenvolvimento da l&oacute;gica e do racioc&iacute;nio matem&aacute;tico.&Eacute; usado para desenvolver as crian&ccedil;as.</p>&#10;<a id="Conclus%C3%A3o" name="Conclus%C3%A3o"></a><h2> Conclus&atilde;o </h2>&#10;&#10;<p>A Torre de Han&oacute;i consiste em passar todos os discos de uma extremidade a outra sem que um disco maior fique em cima de um menor.</p>&#10;<p>As suas aplica&ccedil;&otilde;es s&atilde;o basicamente usadas em escolas para que os professores possam melhorar e desenvolver o cognitivo das crian&ccedil;as, al&eacute;m do trabalho em grupo. Sendo este aplicado em pequenos grupos ou individualmente.</p>&#10;<p>A Torre de Han&oacute;i possui v&aacute;rias formas de resolu&ccedil;&atilde;o. Uma delas &eacute; a resolu&ccedil;&atilde;o recursiva a qual podemos dizer que &eacute; a mais limitada quanto ao tempo de realiza&ccedil;&atilde;o, j&aacute; que sua execu&ccedil;&atilde;o depender&aacute; de alguns fatores para tornar&shy;se mais eficaz.</p>&#10;<p>A resolu&ccedil;&atilde;o Iterativa utiliza alguns ciclos (estruturas) de repeti&ccedil;&atilde;o (for, whiles) que podem ser chamados de la&ccedil;os, existe ainda a possibilidade de algumas estruturas adicionais (mais complexas) as quais tornam o algoritmo mais r&aacute;pido.</p>&#10;<p>&Eacute; fato que todo algoritmo recursivo possui um algoritmo interativo equivalente&semi; Dependendo apenas da sua complexidade de constru&ccedil;&atilde;o.</p>&#10;<p> </p>&#10;<a id="%7B%7BLiga%C3%A7%C3%B5es_externas%7D%7D" name="%7B%7BLiga%C3%A7%C3%B5es_externas%7D%7D"></a><h2>   </h2>&#10;&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://tecnicasparainformatica.blogspot.com.br/2012/07/algoritimo&shy;torre&shy;de&shy;hanoi&shy;implementado.html" rel="nofollow" title="http://tecnicasparainformatica.blogspot.com.br/2012/07/algoritimo&shy;torre&shy;de&shy;hanoi&shy;implementado.html">Veja torre de Hanoi implementada em java.</a></li>&#10;<li><a class="externallink" href="http://tecnicasparainformatica.blogspot.com.br/2012/07/algoritimo&shy;torre&shy;de&shy;hanoi&shy;implementado_22.html" rel="nofollow" title="http://tecnicasparainformatica.blogspot.com.br/2012/07/algoritimo&shy;torre&shy;de&shy;hanoi&shy;implementado_22.html">Veja torre de Han&oacute;i implementada em C# ou C sharp.</a></li>&#10;<li><a class="externallink" href="http://www6.ufrgs.br/psicoeduc/piaget/a&shy;torre&shy;de&shy;hanoi" rel="nofollow" title="http://www6.ufrgs.br/psicoeduc/piaget/a&shy;torre&shy;de&shy;hanoi">Vers&atilde;o eletr&ocirc;nica do jogo A Torre de Hanoi</a></li>&#10;<li><a class="externallink" href="http://osicode.zxq.net/Main.html?op=jogos" rel="nofollow" title="http://osicode.zxq.net/Main.html?op=jogos">torres de han&oacute;i com licen&ccedil;a GPL, com capacidade de auto&shy;resolucao, em C++, usando wxWidgets como gui</a></li></ul>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Quebra&shy;cabe%C3%A7as" id="w">Categoria:Quebra&shy;cabe&ccedil;as</a></p>&#10;<p> </p>&#10;<p> </p></body></html>