<html><title>Algoritmo de Ford&shy;Fulkerson</title><body>&#10;<p>O <b>algoritmo de Ford&shy;Fulkerson</b> (assim designado em honra de <a href="http://en.wikipedia.org/wiki/Lester_Randolph_Ford%2C_Jr" id="w">Lester Randolph Ford, Jr</a> e <a href="http://en.wikipedia.org/wiki/Delbert_Ray_Fulkerson" id="w">Delbert Ray Fulkerson</a>) &eacute; um <a href="http://en.wikipedia.org/wiki/Algoritmo" id="w">algoritmo</a> utilizado para resolver problemas de fluxo em rede (<i>network flow</i>). O algoritmo &eacute; empregado quando se deseja encontrar um fluxo de valor m&aacute;ximo que fa&ccedil;a o melhor uso poss&iacute;vel das capacidades dispon&iacute;veis na rede em quest&atilde;o.</p>&#10;<p>A hist&oacute;ria do algoritmo est&aacute; relacionada &agrave; an&aacute;lise da <a href="http://en.wikipedia.org/wiki/Ferrovia" id="w">rede ferrovi&aacute;ria</a> da <a href="http://en.wikipedia.org/wiki/Uni%C3%A3o_Sovi%C3%A9tica" id="w">Uni&atilde;o Sovi&eacute;tica</a>, tanto por russos quanto por americanos, nas d&eacute;cadas de 1930, 1940 e 1950.<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup></p>&#10;<p>O problema resolvido pelo algoritmo &eacute; o de encontrar um fluxo m&aacute;ximo em uma rede. Uma rede pode ser uma <a href="http://en.wikipedia.org/wiki/Transmiss%C3%A3o_de_energia_el%C3%A9trica" id="w"> rede el&eacute;trica</a>, um sistema de <a href="http://en.wikipedia.org/wiki/Engenharia_hidr%C3%A1ulica" id="w"> transporte de fluidos</a> ou a distribui&ccedil;&atilde;o de produtos ao longo de uma rede de transportes, como uma malha ferrovi&aacute;ria ou <a href="http://en.wikipedia.org/wiki/Rodovia" id="w"> rodovi&aacute;ria</a>.<sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup> Por exemplo, deseja&shy;se transportar o m&aacute;ximo de min&eacute;rio de ferro atrav&eacute;s de uma rede ferrovi&aacute;ria, limitadas pela capacidade de cada via. O tratamento aqui dado ao algoritmo sup&otilde;e a exist&ecirc;ncia de um &uacute;nico &ldquo;ponto de entrada&rdquo; (uma <i>fonte</i>) e de um &uacute;nico &ldquo;ponto de sa&iacute;da&rdquo; (um <i>terminal</i>).</p>&#10;<p>Para valores de fluxo irracionais, o algoritmo poder&aacute; ficar em um loop infinito e nunca retornar o fluxo m&aacute;ximo desejado. O <a href="http://en.wikipedia.org/wiki/Algoritmo_de_Edmonds&shy;Karp" id="w">algoritmo de Edmonds&shy;Karp</a> &eacute; uma varia&ccedil;&atilde;o do algoritmo de Ford&shy;Fulkerson, mas com um final garantido e com um tempo de execu&ccedil;&atilde;o independente do valor do fluxo m&aacute;ximo.</p> &#10;<p>== Defini&ccedil;&otilde;es<sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup> == </p>&#10;<p>Uma <i>rede de fluxo</i> &eacute; um <a href="http://en.wikipedia.org/wiki/Grafo" id="w">grafo</a> direcionado <span class="math">G=(N, A)</span>, sendo <span class="math">N</span> o conjunto de n&oacute;s e <span class="math">A</span> o conjunto de arestas, dotado das seguintes propriedades:&#10;</p><dl><dd>&#10;<ul>&#10;<li>Para cada aresta <span class="math">a \in A</span> h&aacute; um n&uacute;mero n&atilde;o negativo <span class="math">c_{a}</span>, que indica a capacidade da mesma (ou seja, a quantidade m&aacute;xima de fluxo que cada uma &eacute; capaz de carregar).</li></ul></dd></dl><dl><dd>&#10;<ul>&#10;<li>Existe um &uacute;nico n&oacute; que ser&aacute; identificado como <i>fonte</i> (<i>sink</i>), a ser denotado por <span class="math">s</span>&semi;</li></ul></dd></dl><dl><dd>&#10;<ul>&#10;<li>Existe um &uacute;nico n&oacute; que ser&aacute; identificado como <i>terminal</i> (ou <i>sumidouro</i>) <span class="math">t</span>, tal que <span class="math">t \in N</span>&semi;</li></ul></dd></dl><dl><dd>&#10;<ul>&#10;<li>N&atilde;o h&aacute; nenhuma aresta direcionada para a fonte <span class="math">s</span>, apenas arestas que saem dela e s&atilde;o direcionadas para outros n&oacute;s.</li></ul></dd></dl><dl><dd>&#10;<ul>&#10;<li>N&atilde;o h&aacute; nenhuma aresta que saia do terminal <span class="math">t</span>, apenas arestas direcionadas a ele.</li></ul></dd></dl>&#10;<p>Um <i>fluxo</i> &eacute; uma fun&ccedil;&atilde;o <span class="math">f: A \rightarrow \mathbb{R_{+}}\,</span>  que respeite as seguintes propriedades:&#10;</p><dl><dd>&#10;<ul>&#10;<li>Restri&ccedil;&otilde;es de capacidade (<i>capacity conditions</i>): Para cada <span class="math">a \in A</span>, temos que <span class="math">0 \leq f(a) \leq c_{a}</span>.</li></ul></dd></dl><dl><dd>&#10;<ul>&#10;<li>Restri&ccedil;&otilde;es de conserva&ccedil;&atilde;o (<i>conservation conditions</i>): Para cada n&oacute; <span class="math">n \in N</span> diferente de <span class="math">s</span> e <span class="math">t</span>, temos que o fluxo total que entra em determinado n&oacute; &eacute; igual ao fluxo total que sai de tal n&oacute;.</li></ul></dd></dl>&#10;<p>Para evitar comportamentos patol&oacute;gicos, em geral se sup&otilde;e que os valores das capacidades s&atilde;o inteiros (o que acarreta, neste algoritmo, em valores de fluxos inteiros).</p>&#10;<p>Definindo o valor de um fluxo como <span class="math">v(f) = \sum_{a \in out(s)} f(a)</span> (sendo <span class="math">out(s)</span> o conjunto de arestas que sai de <span class="math">s</span>), o problema a ser resolvido &eacute;, dada uma rede de fluxo <span class="math">G</span>, achar um fluxo <span class="math">f</span>  tal que <span class="math">v(f)</span> seja o m&aacute;ximo poss&iacute;vel.</p>&#10; &#10;  &#10;<a id="O_Algoritmo" name="O_Algoritmo"></a><h2>O Algoritmo</h2>&#10; &#10;<p><a href="http://en.wikipedia.org/wiki/File:Fluxo_max_ford_fulkerson.gif%7Cthumb" id="w">Anima&ccedil;&atilde;o representando o Algoritmo de Ford&shy;Fulkerson para problemas de maximiza&ccedil;&atilde;o de fluxo em rede. &Agrave; esquerda o grafo original e &agrave; direita seu grafo residual. A cor azul representa o caminho simples s&shy;t escolhido&semi;a cor vermelha representa o novo fluxo no grafo original&semi;a linha pontilhada representa as novas arestas do grafo residual.</a></p>&#10;<p>Come&ccedil;amos supondo que o fluxo inicial em todas as arestas &eacute; nulo. Desta forma, iremos aumentar gradativamente este valor acrescentando fluxo na fonte atrav&eacute;s de algumas regras b&aacute;sicas.</p> &#10;<p>A ideia principal do algoritmo gira em torno de duas opera&ccedil;&otilde;es: quando uma aresta possui menos fluxo do que permite a sua capacidade (o que inclui possuir fluxo nulo), temos a op&ccedil;&atilde;o de &ldquo;empurrar&rdquo; fluxo na sua dire&ccedil;&atilde;o (&ldquo;empurrar fluxo &agrave; frente&rdquo;)&semi; do mesmo modo, quando uma aresta possui uma quantidade positiva de fluxo, seja ela menor ou igual &agrave; sua capacidade, temos a op&ccedil;&atilde;o de fazer com que esse fluxo retroceda, &ldquo;empurrando&shy;o para tr&aacute;s&rdquo;, ou seja, na dire&ccedil;&atilde;o contr&aacute;ria.</p> &#10;<p>Para concretizar tais opera&ccedil;&otilde;es, definimos primeiramente um grafo auxiliar que vamos chamar de <b>grafo residual (<span class="math">G_{R}</span>) </b>, que &eacute; constru&iacute;do da seguinte forma:</p> &#10;&#10;<ul>&#10;<li>O conjunto de n&oacute;s de <span class="math">G_{R}</span> &eacute; o mesmo de <span class="math">G</span>&semi;</li>&#10;<li>Ao percorrer as arestas em <span class="math">G</span>, vamos criando as arestas de <span class="math">G_{R}</span> do seguinte modo:&#10;<ul>&#10;<li>Para cada aresta <span class="math">a=(n_{i},n_{j})</span> de <span class="math">G</span> &shy; sai do n&oacute; <span class="math">n_{i}</span> e entra no n&oacute; <span class="math">n_{j})</span> &shy; que possui fluxo <span class="math">f(a)&lt&semi;c_{a}</span>, adicionamos uma aresta <span class="math">a_{R}=(n_{i},n_{j})</span> com capacidade <span class="math">c_a{_{R}}= c_{a} &shy; f(a)</span> e <span class="math">f(a_{R})= 0</span>. Deste modo, estamos definindo a possibilidade de &ldquo;empurrar para frente&rdquo; a quantidade de fluxo que a aresta <span class="math">a</span> conseguiria carregar a mais.</li>&#10;<li>Para cada aresta <span class="math">a=(n_{i},n_{j})</span> de <span class="math">G</span> tal que <span class="math">f(a)&gt&semi; 0</span>, ou seja, cada aresta que j&aacute; esteja carregando alguma quantidade positiva de fluxo, existe a possibilidade de empurrar este fluxo para tr&aacute;s, se assim desejarmos. Desta forma, adicionamos uma aresta <span class="math">a'_{R}=(n_{i},n_{j})</span> em <span class="math">G_{R}</span> com dire&ccedil;&atilde;o inversa a <span class="math">a</span> e capacidade <span class="math">c_{a'_{R}}=f(a)</span> Assim como no passo anterior, o fluxo de <span class="math">a'_{R}</span> no grafo residual &eacute; nulo.</li></ul></li></ul>&#10;&#10;<p>Observa&ccedil;&atilde;o: Cada aresta do grafo original <span class="math">G</span> pode dar origem a no m&aacute;ximo duas arestas correspondentes a ela no grafo residual, j&aacute; que se <span class="math">a</span> possuir um fluxo positivo que seja menor que sua capacidade, uma aresta de mesma dire&ccedil;&atilde;o ser&aacute; criada para representar o fluxo a mais que ainda pode ser carregado, e uma aresta de dire&ccedil;&atilde;o oposta ser&aacute; inserida para representar o fluxo existente que pode retroceder caso seja necess&aacute;rio para a otimiza&ccedil;&atilde;o do problema. Resumindo, <span class="math">G_{R}</span> pode possuir at&eacute; duas vezes o n&uacute;mero de arestas de <span class="math">G</span>.&#10;<br/></p>&#10;&#10;<p>Assim, para definir como ser&aacute; feito o aumento gradual de fluxo que entrar&aacute; na rede (ou seja, em <span class="math">G</span>), at&eacute; que o m&aacute;ximo seja atingido, o restante do algoritmo baseia&shy;se principalmente no grafo residual, alterando sua configura&ccedil;&atilde;o a cada aumento realizado.Os passos seguintes realizados pelo algoritmo, ap&oacute;s a cria&ccedil;&atilde;o do grafo residual, est&atilde;o descritos a seguir:</p>&#10;<dl><dd>&#10;<ul>&#10;<li>Seja um caminho simples s&shy;t de <span class="math">G_{R}</span> aquele que vai da fonte <span class="math">s</span> at&eacute; o terminal <span class="math">t</span> passando por cada aresta uma &uacute;nica vez. O primeiro passo do algoritmo &eacute; encontrar um caminho simples s&shy;t qualquer que exista no grafo residual. Esse caminho &eacute; chamado de <b>caminho de aumento</b>&semi;</li></ul></dd></dl><dl><dd>&#10;<ul>&#10;<li>Escolhido o caminho de aumento, o segundo passo &eacute; procurar a aresta pertencente a ele que possui o menor valor <span class="math">c_{a_{R}}</span> (capacidade). Vamos chamar tal valor de <span class="math">b</span>&semi;</li></ul></dd></dl><dl><dd>&#10;<ul>&#10;<li>Analisamos cada aresta <span class="math">a_{R}=(n_{i},n_{j})</span> do caminho escolhido. Se <span class="math">a_{R}</span> possui dire&ccedil;&atilde;o s&shy;t (i.e., a mesma dire&ccedil;&atilde;o que possui no gr&aacute;fo original, levando o fluxo de <span class="math">s</span> para <span class="math">t</span>), ent&atilde;o procuramos a aresta correspondente <span class="math">a=(n_{i},n_{j})</span> em <span class="math">G</span> e aumentamos seu fluxo <span class="math">f(a)</span> em <span class="math">b</span> unidades: <span class="math">f(a)_{depois}= f(a)_{antes} +  b</span>.</li></ul></dd></dl><dl><dd><dl><dd>Em contrapartida, se <span class="math">a_{R}=(n_{i},n_{j})</span> possuir dire&ccedil;&atilde;o inversa (apontando de <span class="math">t</span> para <span class="math">s</span>), ent&atilde;o modificamos a sua correspondente em G diminuindo seu fluxo em <span class="math">b</span> unidades: <span class="math">f(a)_{depois}= f(a)_{antes} &shy;  b</span> &semi;</dd></dl></dd></dl><dl><dd>&#10;<ul>&#10;<li>Reconfiguramos <span class="math">G_{R}</span> para os novos valores das arestas de <span class="math">G</span> e repetimos os passos anteriores at&eacute; que nao haja mais nenhum caminho de aumento no grafo residual para ser analisado. Quando isso acontecer, o fluxo <span class="math">f</span> presente em <span class="math">G</span> ser&aacute; o fluxo m&aacute;ximo.</li></ul></dd></dl>&#10;&#10;&#10;<a id="Pseudoc%C3%B3digo" name="Pseudoc%C3%B3digo"></a><h2>Pseudoc&oacute;digo</h2>&#10;&#10;&#10;<pre>fun&ccedil;&atilde;o <b>Atualiza&shy;Grafo&shy;Residual</b>(G, f)&#10;    Para cada aresta <i>a</i>(u,v) em G, , com u,v&#8712&semi;N&#10;           Se f(<i>a</i>) &#60&semi; c<sub>a</sub> ent&atilde;o&#10;               insira <i>a<sub>R</sub></i>(u,v) com c<sub>a<sub>R</sub></sub>=(c<sub>a</sub> &shy; f(<i>a</i>))&#10;           Se f(<i>a</i>) &#62&semi; 0 ent&atilde;o&#10;               insira <i>a<sub>R</sub></i>(v,u) com c<sub>a<sub>R</sub></sub>=f(<i>a</i>)&#10;     Retorna(G<sub>R</sub>)&#10;&#10;fun&ccedil;&atilde;o <b>Ford&shy;Fulkerson</b>(G, s, t)&#10;   Inicia f(<i>a</i>)=0 para cada aresta <i>a</i> de G&#10;   Defina G<sub>R</sub> = Atualiza&shy;Grafo&shy;Residual(G, f)&#10;   Enquanto existir caminho de aumento de <i>s</i> para <i>t</i> em G<sub>R</sub>&#10;        Seja P um caminho de aumento s&shy;t em G<sub>R</sub>&#10;        Defina c<sub>P</sub> = min{c<sub>a</sub> : <i>a</i>&#8712&semi;P}&#10;        Para cada aresta <i>a</i> em P&#10;            Se <i>a</i> tem dire&ccedil;&atilde;o s&shy;t ent&atilde;o&#10;                 fa&ccedil;a [f(<i>a</i>) &#8594&semi; f(<i>a</i>) + c<sub>P</sub>] em G&#10;           Caso contr&aacute;rio&#10;                fa&ccedil;a [f(<i>a</i>) &#8594&semi; f(<i>a</i>) &shy; c<sub>P</sub>] em G&#10;        G<sub>R</sub> = Atualiza&shy;Grafo&shy;Residual(G, f)&#10;  Retorna (f)&#10;&#10;&#10;</pre><a id="Complexidade" name="Complexidade"></a><h2> Complexidade </h2>&#10;&#10;<p>Para valores inteiros de <span class="math">c_a</span>, a complexidade do algoritmo &eacute; <span class="math"> O(mf) </span>, em que <span class="math">m</span> representa o n&uacute;mero de arestas presentes no grafo <span class="math">G</span> e <span class="math">f</span> o fluxo m&aacute;ximo encontrado. Utilizando uma <a href="http://en.wikipedia.org/wiki/Busca_em_largura" id="w">busca em largura</a> (<i>breadth&shy;first search</i>) ou uma <a href="http://en.wikipedia.org/wiki/Busca_em_profundidade" id="w">busca em profundidade</a>  (<i>depth&shy;first search</i>), &eacute; poss&iacute;vel encontrar um caminho simples <span class="math">s</span>&shy;<span class="math">t</span> no grafo residual em <span class="math"> O(m+n) </span>, tal que <span class="math">n</span> &eacute; o n&uacute;mero total de n&oacute;s do grafo. Supondo que todos os n&oacute;s possuem pelo menos uma aresta incidente, podemos afirmar que <span class="math">m &gt&semi; n/2</span> e, portanto, simplificamos a express&atilde;o anterior para <span class="math"> O(m) </span>. Cada caminho simples encontrado resulta em um novo fluxo a ser acrescentado no grafo original. Como os incrementos de fluxo obtidos em cada itera&ccedil;&atilde;o ser&atilde;o sempre maiores ou iguais a 1, por as capacidades serem inteiras, podemos concluir que o algoritmo ir&aacute; rodar em no m&aacute;ximo <span class="math">O(mf)</span> para atingir o fluxo m&aacute;ximo desejado.</p>&#10;&#10;&#10; &#10;<a id="Refer%C3%AAncias" name="Refer%C3%AAncias"></a><h2> Refer&ecirc;ncias </h2>&#10;<p> </p>&#10;&#10;<ul>&#10;<li> </li></ul>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos_de_grafos" id="w">Categoria:Algoritmos de grafos</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos_de_otimiza%C3%A7%C3%A3o" id="w">Categoria:Algoritmos de otimiza&ccedil;&atilde;o</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Pesquisa_operacional" id="w">Categoria:Pesquisa operacional</a></p></body></html>