<html><title>Icon (linguagem de programa&ccedil;&atilde;o)</title><body>&#10;<p> &#10; &#10;<b>Icon</b> &eacute; uma <a href="http://en.wikipedia.org/wiki/Linguagem_interpretada" id="w">linguagem de programa&ccedil;&atilde;o interpretada</a> de <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o_de_alto_n%C3%ADvel" id="w">alto n&iacute;vel</a>, derivada do <a href="http://en.wikipedia.org/wiki/ALGOL" id="w">ALGOL</a>. Tamb&eacute;m herdou propriedades do <a href="http://en.wikipedia.org/wiki/SNOBOL_4" id="w">SNOBOL 4</a> (processamento de cadeias de caracteres). Por ser derivada do ALGOL, faz parte de uma classe de linguagens de <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_estruturada" id="w">programa&ccedil;&atilde;o estruturadas</a>, tendo assim, uma sintaxe similar a de <a href="http://en.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">C</a> e <a href="http://en.wikipedia.org/wiki/Pascal_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Pascal</a>. A partir de Icon, descende a linguagem de programa&ccedil;&atilde;o <a href="http://en.wikipedia.org/wiki/Unicon" id="w">Unicon</a>, que adiciona <a href="http://en.wikipedia.org/wiki/Orienta%C3%A7%C3%A3o_a_objetos" id="w">orienta&ccedil;&atilde;o a objetos</a>. Icon foi implementado em C&semi; em sua p&aacute;gina oficial, est&atilde;o dispon&iacute;veis, al&eacute;m do <a href="http://en.wikipedia.org/wiki/C%C3%B3digo_fonte" id="w">c&oacute;digo fonte</a> e bin&aacute;rios, alguns livros, dentre os quais um descreve o processo da implementa&ccedil;&atilde;o de Icon. </p>&#10;<a id="Sintaxe_b%C3%A1sica" name="Sintaxe_b%C3%A1sica"></a><h2> Sintaxe b&aacute;sica </h2>&#10;<p>De muitas maneiras, Icon partilha caracter&iacute;sticas de uma <a href="http://en.wikipedia.org/wiki/Linguagem_de_script" id="w">linguagem de script</a>: as vari&aacute;veis n&atilde;o precisam ser declaradas, os tipos s&atilde;o definidos de forma autom&aacute;tica, e os n&uacute;meros podem ser convertidos para strings e de volta automaticamente. Outra caracter&iacute;stica comum a muitas linguagens de script, mas n&atilde;o a todas, &eacute; a falta de um caracter de fim de linha. Em Icon as linhas que n&atilde;o terminam com <a href="http://en.wikipedia.org/wiki/Ponto&shy;e&shy;v%C3%ADrgula" id="w">ponto&shy;e&shy;v&iacute;rgula</a> s&atilde;o terminadas por um ponto&shy;e&shy;v&iacute;rgula impl&iacute;cito, se fizer sentido. Os procedimentos s&atilde;o as constru&ccedil;&otilde;es de blocos b&aacute;sicas na linguagem Icon, e apesar de utilizarem a sintaxe do <a href="http://en.wikipedia.org/wiki/Pascal_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">Pascal</a> funcionam mais como fun&ccedil;&otilde;es de <a href="http://en.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)" id="w">C</a> e podem retornar valores. Em Icon n&atilde;o h&aacute; a palavra&shy;chave <code>function</code>.</p>&#10;<p>Uma caracter&iacute;stica interessante de Icon &eacute; que a linguagem reconhe&ccedil;e que em muitas computa&ccedil;&otilde;es existe mais de um valor a ser retornado. Um exemplo t&iacute;pico &eacute; das ra&iacute;zes reais de uma equa&ccedil;&atilde;o de 2&deg; grau, que, nos casos onde o valor de delta &eacute; positivo, retorna duas respostas. Uma das opera&ccedil;&otilde;es de manipula&ccedil;&atilde;o de cadeias de caracteres de Icon &eacute; a fun&ccedil;&atilde;o <b>find</b>(l, s) que encontra as posi&ccedil;&otilde;es na sequ&ecirc;ncia s onde l ocorre.<sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup> A express&atilde;o:</p>&#10;<p />&#10;&#10;<p>ir&aacute; escrever 2. Mas a express&atilde;o:</p>&#10;<p />&#10;&#10;<p>ir&aacute; escrever 2, 4 e 6. O motivo para isto &eacute; que a fun&ccedil;&atilde;o <b>find</b> retorna uma sequ&ecirc;ncia de resultados (2|4|6).</p>&#10;<a id="Hist%C3%B3ria" name="Hist%C3%B3ria"></a><h2> Hist&oacute;ria </h2>&#10;<p>Icon &eacute; o &uacute;ltimo de uma s&eacute;rie de linguagens de alto n&iacute;vel da programa&ccedil;&atilde;o destinada a facilitar as tarefas de programa&ccedil;&atilde;o envolvendo strings e estruturas. A linguagem original, SNOBOL, foi desenvolvida no <a href="http://en.wikipedia.org/wiki/Bell_Labs" id="w">Bell Telephone Laboratories</a> no in&iacute;cio dos anos 1960. SNOBOL evoluiu para <a href="http://en.wikipedia.org/wiki/SNOBOL_4" id="w">SNOBOL4</a>, que ainda est&aacute; em uso. Linguagens subsequentes foram desenvolvidas na <a href="http://en.wikipedia.org/wiki/Universidade_do_Arizona" id="w">Universidade do Arizona</a>, com o apoio da <a href="http://en.wikipedia.org/wiki/Funda%C3%A7%C3%A3o_Nacional_da_Ci%C3%AAncia" id="w">National Science Foundation</a>. Embora tenha objetivos semelhantes e muitos recursos semelhantes, Icon tem pouca semelhan&ccedil;a superficial com <a href="http://en.wikipedia.org/wiki/SNOBOL_4" id="w">SNOBOL4</a>. </p>&#10;<p>Implementa&ccedil;&otilde;es Icon foram desenvolvidas por professores, funcion&aacute;rios e estudantes da <a href="http://en.wikipedia.org/wiki/Universidade_do_Arizona" id="w">Universidade do Arizona</a>, com contribui&ccedil;&atilde;o significativa de volunt&aacute;rios ao redor do mundo. O <i>Icon history</i> de Ralph e Madge Griswold aparecem nas pr&eacute;&shy;publica&ccedil;&otilde;es da segunda <i>History of Programming Languages Conference</i> (HOPL&shy;II), ACM SIGPLAN Notices, Mar&ccedil;o de 1993 (Vol. 28, n &ordm; 3).</p>&#10;<p>O nome Icon n&atilde;o &eacute; uma sigla, nem representam nada em particular, embora a palavra <i>iconoclastic</i> foi mencionado quando o nome foi escolhido. O nome precede ao uso comum de &iacute;cones para referir&shy;se a pequenas imagens usadas em interfaces gr&aacute;ficas de usu&aacute;rio de agora. Isso &agrave;s vezes induz as pessoas a pensar que Icon &eacute; projetado para criar ou manipular &iacute;cones, mas n&atilde;o h&aacute; nenhuma boa solu&ccedil;&atilde;o para esse problema.</p>&#10;<a id="Caracter%C3%ADsticas" name="Caracter%C3%ADsticas"></a><h2> Caracter&iacute;sticas </h2>&#10;<a id="Execu%C3%A7%C3%A3o_voltada_a_um_objetivo" name="Execu%C3%A7%C3%A3o_voltada_a_um_objetivo"></a><h3> Execu&ccedil;&atilde;o voltada a um objetivo </h3>&#10;<p>Um dos conceitos chaves do Icon &eacute; que as estruturas de controle s&atilde;o baseadas em express&otilde;es de &#34&semi;sucesso&#34&semi; ou &#34&semi;falha&#34&semi;, ao inv&eacute;s de l&oacute;gica booleana, como na maioria das outras linguagens de programa&ccedil;&atilde;o. Sob este modelo, simples compara&ccedil;&otilde;es como if a <b a="" algo="" ao="" caso="" com="" como="" das="" direita="" disso,="" for="" inv&eacute;s="" linguagens&semi;="" maioria="" mais="" na="" nesse="" n&atilde;o="" o="" operador="" opera&ccedil;&atilde;o="" parecido="" seriam="" significa="" sucesso".="" um="" verdade"="">&#60&semi; sucede se a compara&ccedil;&atilde;o for verdadeira, ent&atilde;o no final o resultado &eacute; o mesmo. Al&eacute;m disso, o operador &#60&semi; retorna seu segundo argumento se for bem sucedido, permitindo coisas como a <b>&#60&semi;  c, um tipo comum de compara&ccedil;&atilde;o que n&atilde;o pode ser diretamente declarada na maioria das linguagens.&#10;A utilidade desse conceito se torna mais clara quando se considera exemplos pr&aacute;ticos. Como Icon usa sucesso ou falha para todo o controle de fluxo, este simples c&oacute;digo:</b></b></p>&#10;<p />&#10;&#10;<p>ir&aacute; copiar uma linha da sua entrada padr&atilde;o para sua sa&iacute;da padr&atilde;o. O que &eacute; interessante sobre este exemplo &eacute; que o c&oacute;digo ir&aacute; funcionar mesmo se o read() causar um erro, por exemplo, se o arquivo n&atilde;o existir. Neste caso a declara&ccedil;&atilde;o a := read() ir&aacute; falhar, e write(a) simplesmente n&atilde;o ser&aacute; chamado.</p>&#10;<p>Sucessos e falhas s&atilde;o passadas &#34&semi;para cima&#34&semi; atrav&eacute;s de fun&ccedil;&otilde;es, isso quer dizer que uma falha numa fun&ccedil;&atilde;o aninhada far&aacute; com que as fun&ccedil;&otilde;es que est&atilde;o chamando&shy;a ir&atilde;o falhar tamb&eacute;m. Por exemplo, n&atilde;o podemos escrever um programa para copiar um arquivo de entrada inteiro em apenas uma linha:</p>&#10;<p />&#10;&#10;<p>Quando o comando read() falhar, no final do arquivo por exemplo, a falha ser&aacute; transmitida at&eacute; a cadeia e write() tamb&eacute;m ir&aacute; falhar. O while, sendo a estrutura de controle, p&aacute;ra em caso de falha, o que significa que ir&aacute; parar quando o arquivo estiver vazio. Para efeito de compara&ccedil;&atilde;o, considere um exemplo semelhante escrito em pseudoc&oacute;digo baseado em Java:</p>&#10;<p />&#10;&#10;<p>Neste caso, h&aacute; duas compara&ccedil;&otilde;es necess&aacute;rias, uma para fim de arquivo (EOF) e outra para todos os outros erros. Como Java n&atilde;o permite que os erros sejam comparados como elementos l&oacute;gicos, conforme previsto na Icon, o longa sintaxe try / catch deve ser usada. Blocos try tamb&eacute;m imp&otilde;e uma penalidade de desempenho por simplesmente us&aacute;&shy;los, mesmo se nenhum erro ocorrer, um custo distribu&iacute;do que a Icon evita.</p>&#10;<p>Icon refere&shy;se a este conceito como execu&ccedil;&atilde;o voltada a um objetivo, referindo&shy;se &agrave; maneira que a execu&ccedil;&atilde;o continua at&eacute; que algum objetivo seja alcan&ccedil;ado. No exemplo acima, o objetivo &eacute; ler todo o arquivo, o comando read() continua a ter sucesso enquanto h&aacute; informa&ccedil;&otilde;es para ser lida, e falha quando n&atilde;o h&aacute;. O objetivo &eacute;, portanto, codificado diretamente na linguagem, em vez de usar declara&ccedil;&otilde;es para verificar c&oacute;digos de retorno ou constru&ccedil;&otilde;es semelhantes.</p>&#10;<a id="Geradores_(''Generators'')" name="Geradores_(''Generators'')"></a><h3> Geradores (&#39&semi;&#39&semi;Generators&#39&semi;&#39&semi;) </h3>&#10;<p>Express&otilde;es em Icon muitas vezes retornam um &uacute;nico valor, por exemplo, <b>x &#60&semi;5</b> ir&aacute; avaliar e ter sucesso com o valor 5 ou falhar. No entanto, v&aacute;rios dos exemplos abaixo dependem do fato de que muitas express&otilde;es n&atilde;o retornam imediatamente sucesso ou falha, retornando valores durante o mesmo. Isso leva os exemplos com <b>every</b> e <b>to</b>, <b>every</b> causa <b>to</b> a continuar a retornar os valores at&eacute; que ele falhar.</p>&#10;<p>Este &eacute; um conceito&shy;chave na Icon, conhecidos como <a href="http://en.wikipedia.org/wiki/Generator_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">generators(geradores)</a>. Generators conduzem muitas das funcionalidades de la&ccedil;o na linguagem, mas fazem mais diretamente, o programador n&atilde;o escreve um la&ccedil;o depois tira e comparar os valores, Icon ir&aacute; fazer de tudo isto para voc&ecirc;.</p>&#10;<p>Na linguagem de Icon, a avalia&ccedil;&atilde;o de uma express&atilde;o ou fun&ccedil;&atilde;o resulta em uma sequ&ecirc;ncia de resultados. Uma sequ&ecirc;ncia de resultados cont&eacute;m todos os valores poss&iacute;veis que podem ser gerados pela express&atilde;o ou fun&ccedil;&atilde;o. Quando a sequ&ecirc;ncia de resultados est&aacute; esgotada (por exemplo, n&atilde;o existem mais valores na sequ&ecirc;ncia de resultados), a express&atilde;o ou fun&ccedil;&atilde;o falha. Itera&ccedil;&atilde;o sobre a sequ&ecirc;ncia de resultado &eacute; obtida de forma expl&iacute;cita atrav&eacute;s da avalia&ccedil;&atilde;o voltada a um objetivo do Icon ou explicitamente, por meio da cl&aacute;usula <b>every</b>.</p>&#10;<p>Icon inclui v&aacute;rios geradores&shy;construtores. A sintaxe <i>alternadora</i> permite uma s&eacute;rie de itens serem gerados em sequ&ecirc;ncia at&eacute; que um falha:</p>&#10;<p />&#10;&#10;<p>pode gerar &#34&semi;1&#34&semi;, &#34&semi;hello&#34&semi; e &#34&semi;5&#34&semi; se x for menor que 5. Alternadores pode ser lido como &#34&semi;ou&#34&semi; em muitos casos, por exemplo:</p>&#10;<p />&#10;&#10;<p>ir&aacute; escrever o valor de y, se for menor do que x ou 5. Internamente Icon verifica todos os valores da esquerda para a direita at&eacute; uma ser bem sucedida ou acabar a lista e ele retorna uma falha. Lembre&shy;se que as fun&ccedil;&otilde;es n&atilde;o ser&atilde;o chamadas a menos que a chamada de dentro n&atilde;o falhar, de modo que este exemplo pode ser reduzido para:</p>&#10;<p />&#10;&#10;<p>Outro gerador simples &eacute; o <b>to</b>, que gera listas de inteiros, every write (1 to 10) ir&aacute; fazer exatamente o que parece. A <i>sintaxe&shy;bang</i> gera todos item de uma lista, every write (!aString) ir&aacute; ter como saida cada caractere de aString em uma nova linha. Para demonstrar o poder deste conceito, considere opera&ccedil;&otilde;es com strings. A maioria das linguagens incluem uma fun&ccedil;&atilde;o conhecida como find ou indexOf que retorna a localiza&ccedil;&atilde;o de uma string de outra. Considere:</p>&#10;<p />&#10;&#10;<p>Este c&oacute;digo ir&aacute; retornar 4, a posi&ccedil;&atilde;o da primeira ocorr&ecirc;ncia da palavra &#34&semi;the&#34&semi;. Para obter a pr&oacute;xima inst&acirc;ncia &#34&semi;the&#34&semi; uma forma alternativa deve ser utilizada, <code>i = indexOf(&#34&semi;the&#34&semi;, s, 5)</code> o 5 no final dizendo que ele deveria olhar a partir da posi&ccedil;&atilde;o 5 para frente. A fim de extrair todas as ocorr&ecirc;ncias de &#34&semi;the&#34&semi;, um la&ccedil;o deve ser usado:</p>&#10;<p />&#10;&#10;<p>Em Icon a fun&ccedil;&atilde;o <b>find</b> &eacute; um gerador, e ir&aacute; retornar a pr&oacute;xima ocorr&ecirc;ncia da string cada vez que for reiniciada antes de finalmente falhar depois que ela passar no final da string. O mesmo c&oacute;digo em Icon pode ser escrito:</p>&#10;<p />&#10;&#10;<p>find ir&aacute; retornar o &iacute;ndice da pr&oacute;xima inst&acirc;ncia &#34&semi;the&#34&semi; cada vez que ele &eacute; reiniciado por <b>every</b>, finalmente passando pelo final da string e falhar. Como no exemplo anterior, isso far&aacute; com que write falhe, e saia do la&ccedil;o every. Claro que h&aacute; momentos em que voc&ecirc; deliberadamente quer encontrar uma string ap&oacute;s algum ponto de entrada, por exemplo, voc&ecirc; pode estar varrendo um arquivo texto contendo os dados em v&aacute;rias colunas. Execu&ccedil;&atilde;o voltada a um objetivo funciona aqui tamb&eacute;m, e pode ser utilizado da seguinte maneira:</p>&#10;<p />&#10;&#10;<p>A posi&ccedil;&atilde;o s&oacute; ser&aacute; retornada se &#34&semi;the&#34&semi; aparecer depois de posi&ccedil;&atilde;o 5, a compara&ccedil;&atilde;o falhar&aacute; caso contr&aacute;rio, passando a falha para write() como antes. Icon adiciona v&aacute;rias estruturas de controle para fazer loops dentro de geradores. O operador <b>every</b> &eacute; semelhante ao <b>while</b>, fazendo loops em cada item devolvido por um gerador e saindo em caso de falha:</p>&#10;<p />&#10;&#10;<p>Por que usar <b>every</b> ao inv&eacute;s de um la&ccedil;o <b>while</b> neste caso? Porque <b>while</b> reavalia o primeiro resultado, mas <b>every</b> produz todos os resultados. A sintaxe every na verdade injeta valores na fun&ccedil;&atilde;o de forma semelhante aos blocos em Smalltalk. Por exemplo, o la&ccedil;o acima pode ser reescrito da seguinte maneira:</p>&#10;<p />&#10;&#10;<p>Os usu&aacute;rios podem construir novos geradores facilmente usando a palavra&shy;chave <b>suspend</b>:</p>&#10;<p />&#10;&#10;<p>Este exemplo faz um loop sobre theString usando find para procurar padr&otilde;es. Quando um &eacute; encontrado, e a posi&ccedil;&atilde;o &eacute; par, a localiza&ccedil;&atilde;o &eacute; retornada da fun&ccedil;&atilde;o com <b>suspend</b>. Ao contr&aacute;rio do <b>return</b>, <b>suspend</b> escreve onde est&aacute; nos geradores internos, bem como, permitindo que ele continue onde parou na pr&oacute;xima itera&ccedil;&atilde;o.</p>&#10;<a id="Strings" name="Strings"></a><h3> Strings </h3>&#10;<p>De acordo com sua funcionalidade parecida com script, Icon adiciona uma s&eacute;rie de recursos para tornar o trabalho com strings mais f&aacute;cil. O mais not&aacute;vel &eacute; o sistema de <i>varredura</i>, que repetidamente chama fun&ccedil;&otilde;es em uma string:</p>&#10;<p />&#10;&#10;<p>Nesse caso o <i>sujeito</i>  da fun&ccedil;&atilde;o find &eacute; colocada fora dos par&acirc;metros, em frente ao ponto de interroga&ccedil;&atilde;o. Fun&ccedil;&otilde;es em Icon s&atilde;o deliberadamente (ao contr&aacute;rio do autom&aacute;tico) escritas para identificar o sujeito em listas de par&acirc;metros e permitir&shy;lhes ser retirado desta forma. Substrings podem ser extra&iacute;das de uma string usando uma especifica&ccedil;&atilde;o de intervalo entre colchetes. A especifica&ccedil;&atilde;o de intervalo pode retornar um ponto para um &uacute;nico caractere, ou um peda&ccedil;o da string. Strings podem ser indexadas tanto da direita quanto da esquerda. &Eacute; importante observar que as posi&ccedil;&otilde;es dentro de uma sequ&ecirc;ncia est&atilde;o entre os caracteres <sub>1</sub>A<sub>2</sub>B<sub>3</sub>C<sub>4</sub> e podem ser especificados a partir da direita <sub>&shy;3</sub>A<sub>&shy;2</sub>B<sub>&shy;1</sub>C<sub>0</sub>.</p>&#10;<p>Por exemplo:&#10;</p>&#10;&#10;<p>Onde o &uacute;ltimo exemplo mostra o uso de um comprimento, em vez de uma posi&ccedil;&atilde;o final.</p>&#10;<p>A especifica&ccedil;&atilde;o de subscripting pode ser usado como um Lvalue dentro de uma express&atilde;o. Isso pode ser usado para inserir uma string em outra string ou apagar partes de uma string. Por exemplo:</p>&#10;<p />&#10;&#10;<a id="Outras_estruturas" name="Outras_estruturas"></a><h3> Outras estruturas </h3>&#10;<p>Icon tamb&eacute;m permite ao usu&aacute;rio facilmente construir suas pr&oacute;prias listas (ou arrays):</p>&#10;<p />&#10;&#10;<p>Os itens de uma lista podem ser de qualquer tipo, incluindo outras estruturas. Para criar rapidamente listas maiores, o Icon inclui o gerador de lista&semi; i := list (10, &#34&semi;palavra&#34&semi;) gera uma lista contendo 10 c&oacute;pias de &#34&semi;palavra&#34&semi;. Como arrays em outras linguagens, Icon permite que itens sejam pesquisados por posi&ccedil;&atilde;o, por exemplo, peso: = aCat [4]. A <i>sintaxe&shy;bang</i>, por exemplo, every write (!aCat), ir&aacute; imprimir quatro linhas, cada uma com um elemento. Icon inclui fun&ccedil;&otilde;es como pilha, push e pop que lhes permitam formar a base de pilhas e filas. Icon tamb&eacute;m inclui uma funcionalidade para os conjuntos e tabelas (conhecido como <i>hashes</i>, <i>arrays associativos</i>, <i>dicion&aacute;rios</i>, etc.):</p>&#10;<p />&#10;&#10;<p>Esse c&oacute;digo cria uma tabela que vai usar zero como o valor padr&atilde;o de uma chave desconhecida. Em seguida, adiciona dois itens nela, com as chaves &#34&semi;ali&#34&semi; e &#34&semi;aqui&#34&semi;, e os valores 1 e 2.</p>&#10;<a id="Exemplos_de_c%C3%B3digos" name="Exemplos_de_c%C3%B3digos"></a><h2> Exemplos de c&oacute;digos </h2>&#10;<a id="Programa_Ol%C3%A1_Mundo" name="Programa_Ol%C3%A1_Mundo"></a><h3> Programa Ol&aacute; Mundo </h3>&#10;<p> </p>&#10;<p />&#10;&#10;<a id="N&shy;primeiros_n%C3%BAmeros_perfeitos" name="N&shy;primeiros_n%C3%BAmeros_perfeitos"></a><h3> N&shy;primeiros n&uacute;meros perfeitos </h3>&#10;<p>Um exemplo de c&oacute;digo que encontra os n primeiros <a href="http://en.wikipedia.org/wiki/N%C3%BAmero_perfeito" id="w">n&uacute;meros perfeitos</a>:</p>&#10;<p />&#10;&#10;<p> </p>&#10;<a id="Bibliografia" name="Bibliografia"></a><h2> Bibliografia </h2>&#10;&#10;<ul>&#10;<li><i>The Icon Programming Language</i> (terceira edi&ccedil;&atilde;o) por <i>Ralph E. Griswold and Madge T. Griswold</i>, <a class="external text" href="http://www.amazon.com/exec/obidos/ASIN/1573980013" rel="nofollow" title="http://www.amazon.com/exec/obidos/ASIN/1573980013">ISBN 1&shy;57398&shy;001&shy;3</a>.</li></ul>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">Linguagem de programa&ccedil;&atilde;o</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Anexo:Lista_de_linguagens_de_programa%C3%A7%C3%A3o" id="w">Lista de linguagens de programa&ccedil;&atilde;o</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Unicon" id="w">Unicon</a></li></ul>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li> </li>&#10;<li> </li>&#10;<li> </li></ul>&#10;<p> &#10; </p>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Dom%C3%ADnio_p%C3%BAblico" id="w">Categoria:Dom&iacute;nio p&uacute;blico</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Linguagens_de_programa%C3%A7%C3%A3o" id="w">Categoria:Linguagens de programa&ccedil;&atilde;o</a></p></body></html>