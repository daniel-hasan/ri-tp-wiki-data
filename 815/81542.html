<html><title>M&eacute;todo de Monte Carlo</title><body>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:Montecarlo.svg%7Cthumb%7C300px" id="w">Aplica&ccedil;&atilde;o do m&eacute;todo de Monte Carlo para determinar a &aacute;rea de um lago.</a></p>&#10;<p>Designa&shy;se por <b>m&eacute;todo de Monte Carlo</b> (MMC) qualquer m&eacute;todo de uma classe de <a href="http://en.wikipedia.org/wiki/Estat%C3%ADstica" id="w">m&eacute;todos estat&iacute;sticos</a> que se baseiam em amostragens aleat&oacute;rias massivas para obter resultados num&eacute;ricos, isto &eacute;, repetindo sucessivas simula&ccedil;&otilde;es um elevado numero de vezes, para calcular probabilidades heuristicamente, tal como se, de facto, se registassem os resultados reais em jogos de casino (da&iacute; o nome).&#10;Este tipo de m&eacute;todo &eacute; utilizado em simula&ccedil;&otilde;es estoc&aacute;sticas com diversas aplica&ccedil;&otilde;es em &aacute;reas como a <a href="http://en.wikipedia.org/wiki/F%C3%ADsica" id="w">f&iacute;sica</a>, <a href="http://en.wikipedia.org/wiki/Matem%C3%A1tica" id="w">matem&aacute;tica</a> e <a href="http://en.wikipedia.org/wiki/Biologia" id="w">biologia</a><sup id="_ref&shy;1" class="reference"><a href="#_note&shy;1" title="">[1]</a></sup>. O m&eacute;todo de Monte Carlo tem sido utilizado h&aacute; bastante tempo como forma de obter aproxima&ccedil;&otilde;es num&eacute;ricas de fun&ccedil;&otilde;es complexas em que n&atilde;o &eacute; vi&aacute;vel, ou &eacute; mesmo imposs&iacute;vel, obter uma <a href="http://en.wikipedia.org/wiki/Solu%C3%A7%C3%A3o_anal%C3%ADtica" id="w">solu&ccedil;&atilde;o anal&iacute;tica</a> ou, pelo menos, determin&iacute;stica.</p>&#10;<p>De acordo com (HAMMERSELEY,1964) o nome &#34&semi;Monte Carlo&#34&semi; surgiu durante o <a href="http://en.wikipedia.org/wiki/Projeto_Manhattan" id="w">projeto Manhattan</a> na <a href="http://en.wikipedia.org/wiki/Segunda_Guerra_Mundial" id="w">Segunda Guerra Mundial</a>. No projeto de constru&ccedil;&atilde;o da <a href="http://en.wikipedia.org/wiki/Bomba_at%C3%B3mica" id="w">bomba at&oacute;mica</a>, <a href="http://en.wikipedia.org/wiki/Stanislaw_Ulam" id="w">Ulam</a>, <a href="http://en.wikipedia.org/wiki/Von_Neumann" id="w">von Neumann</a> e <a href="http://en.wikipedia.org/wiki/Fermi" id="w">Fermi</a> consideraram a possibilidade de utilizar o m&eacute;todo, que envolvia a simula&ccedil;&atilde;o direta de problemas de natureza probabil&iacute;stica relacionados com o coeficiente de difus&atilde;o do neutron em certos materiais. Apesar de ter despertado a aten&ccedil;&atilde;o desses cientistas em 1948, a l&oacute;gica do m&eacute;todo j&aacute; era conhecida h&aacute; bastante tempo. Por exemplo, existe um registro de um artigo escrito por <a href="http://en.wikipedia.org/wiki/Lord_Kelvin" id="w">Lord Kelvin</a> dezenas de anos antes, que j&aacute; utilizava t&eacute;cnicas de Monte Carlo em uma discuss&atilde;o das <a href="http://en.wikipedia.org/wiki/Equa%C3%A7%C3%B5es_de_Boltzmann" id="w">equa&ccedil;&otilde;es de Boltzmann</a>. (Fonte Mundo PM)</p>&#10;<p>Existem tr&ecirc;s classes de algoritmos Monte Carlo: Erro&shy;Unilateral,&#10;Erro&shy;Bilateral e Erro&shy;N&atilde;o&shy;Limitado.</p>&#10;<a id="Monte_Carlo_de_Erro&shy;Unilateral" name="Monte_Carlo_de_Erro&shy;Unilateral"></a><h2> Monte Carlo de Erro&shy;Unilateral </h2>&#10;<p>Seja P um problema e A um algoritmo aleat&oacute;rio, A &eacute; um algoritmo Monte Carlo de Erro&shy;Unilateral que resolve P se</p>&#10;<p>i) para toda configura&ccedil;&atilde;o x que &eacute; solu&ccedil;&atilde;o de P, <span class="math">prob(A(x = SIM)) \geq \frac{1}{2}</span>, e</p>&#10;<p>ii) para toda configura&ccedil;&atilde;o x que n&atilde;o &eacute; solu&ccedil;&atilde;o de P, <i>prob(A(x = N&Atilde;O)) = 1</i>.</p>&#10;<p>Ou seja, sempre que a resposta &eacute; N&Atilde;O, o algoritmo garante a certeza da resposta.</p>&#10;<p>Contudo, se a resposta for SIM, o algoritmo n&atilde;o garante que a resposta est&aacute; correta.</p>&#10;<a id="Monte_Carlo_de_Erro&shy;Bilateral" name="Monte_Carlo_de_Erro&shy;Bilateral"></a><h2> Monte Carlo de Erro&shy;Bilateral </h2>&#10;<p>Um algoritmo aleat&oacute;rio A &eacute; um algoritmo de Monte Carlo de Erro&shy;Bilateral que computa o problema F se existe um n&uacute;mero real positivo  <span class="math">\epsilon</span>, tal que para toda inst&acirc;ncia x de F</p>&#10;<p><span class="math">prob(A(x) = F(x)) \geq \frac{1}{2} + \epsilon</span></p>&#10;<a id="Monte_Carlo_de_Erro&shy;N%C3%A3o&shy;Limitado" name="Monte_Carlo_de_Erro&shy;N%C3%A3o&shy;Limitado"></a><h2> Monte Carlo de Erro&shy;N&atilde;o&shy;Limitado </h2>&#10;<p>Os algoritmos Monte Carlo de Erro&shy;N&atilde;o&shy;Limitado s&atilde;o comumente chamados de Algoritmos Monte Carlo.</p>&#10;<p>Um algoritmo aleat&oacute;rio A &eacute; um algoritmo de Monte Carlo se&#10;para qualquer entrada x do problema F</p>&#10;<p><span class="math">prob(A(x) = F(x)) &gt&semi; \frac{1}{2}</span></p>&#10;<a id="Algoritmo_de_Metropolis" name="Algoritmo_de_Metropolis"></a><h2> Algoritmo de Metropolis </h2>&#10;<p>O algoritmo de Metropolis, tamb&eacute;m conhecido por Algoritmo de Metropolis&shy;Hastings, apresentado inicialmente em 1953 num artigo <sup id="_ref&shy;2" class="reference"><a href="#_note&shy;2" title="">[2]</a></sup>&#10;de <a href="http://en.wikipedia.org/wiki/Nicholas_Metropolis" id="w">Nicholas Metropolis</a>, <a href="http://en.wikipedia.org/wiki/Arianna_Rosenbluth" id="w">Arianna Rosenbluth</a>, <a href="http://en.wikipedia.org/wiki/Marshall_Rosenbluth" id="w">Marshall Rosenbluth</a>, <a href="http://en.wikipedia.org/wiki/Augusta_Teller" id="w">Augusta Teller</a> e <a href="http://en.wikipedia.org/wiki/Edward_Teller" id="w">Edward Teller</a>, e generalizado em 1970 por <a href="http://en.wikipedia.org/wiki/W._K._Hastings" id="w">W. K. Hastings</a>&#10;<sup id="_ref&shy;3" class="reference"><a href="#_note&shy;3" title="">[3]</a></sup>, &eacute; provavelmente o m&eacute;todo Monte Carlo mais utilizado na F&iacute;sica, e tem como objetivo determinar valores esperados de propriedades do sistema simulado, atrav&eacute;s de uma m&eacute;dia sobre uma amostra. O algoritmo &eacute; concebido de modo a se obter uma amostra que siga a <a href="http://en.wikipedia.org/wiki/Distribui%C3%A7%C3%A3o_de_Boltzmann" id="w">distribui&ccedil;&atilde;o de Boltzmann</a>.</p>&#10;<p>Para se determinar a probabilidade de uma dada configura&ccedil;&atilde;o, seria necess&aacute;rio conhecer a chance de ocorr&ecirc;ncia de todas as outras configura&ccedil;&otilde;es. No caso de vari&aacute;veis cont&iacute;nuas, seria necess&aacute;rio uma integra&ccedil;&atilde;o da densidade de probabilidade sobre todo o espa&ccedil;o de configura&ccedil;&otilde;es, mas esse procedimento fica muito custoso quando se utiliza um n&uacute;mero de vari&aacute;veis da ordem de centenas.</p>&#10;<p>A efici&ecirc;ncia do algoritmo de Metropolis est&aacute; diretamente ligada ao fato de n&atilde;o levar em conta a probabilidade das configura&ccedil;&otilde;es em si, mas sim a raz&atilde;o entre elas, pois a raz&atilde;o entre as probabilidades de duas dadas configura&ccedil;&otilde;es pode ser determinada independentemente das outras. Dadas duas configura&ccedil;&otilde;es <i>m</i> e <i>n</i> quaisquer, a raz&atilde;o entre a probabilidade da configura&ccedil;&atilde;o <i>m</i>, <i>P_m</i>, e a probabilidade da configura&ccedil;&atilde;o <i>n</i>, <i>P_n</i>, pode ser escrita como</p>&#10;<p><span class="math">&#10;  \frac{P_m}{P_n}      =     \frac{      exp\left(&shy;\frac{U_m}{k_bT}\right)     }{&#10;  exp\left(&shy;\frac{U_n}{k_bT}\right) } = exp\left(&shy;\frac{U_m&shy;U_n}{k_bT}\right)&#10;</span></p>&#10;<p>A partir dessa igualdade, o algoritmo de Metropolis pode ser implementado atrav&eacute;s do seguinte conjunto de regras:</p>&#10;<p>(a) Gera&ccedil;&atilde;o de uma configura&ccedil;&atilde;o inicial aleat&oacute;ria, ou seja, com valores aleat&oacute;rios para todos os graus de liberdade do sistema, respeitando as suas restri&ccedil;&otilde;es. Vamos atribuir o &iacute;ndice <i>m</i> a essa configura&ccedil;&atilde;o, que &eacute; aceita para a amostra.</p>&#10;<p>(b) Gera&ccedil;&atilde;o de uma nova configura&ccedil;&atilde;o&shy;tentativa de&#10;&iacute;ndice <i>n</i>, resultado de pequenas altera&ccedil;&otilde;es nas&#10;coordenadas da configura&ccedil;&atilde;o <i>m</i>.</p>&#10;<p>(c) Se a energia da configura&ccedil;&atilde;o <i>n</i> for menor que a da configura&ccedil;&atilde;o <i>m</i>, inclui&shy;se a configura&ccedil;&atilde;o <i>n</i> na nossa amostra, e se atribui a ela o &iacute;ndice <i>m</i> a partir desse momento. Caso contr&aacute;rio, realizam&shy;se os passos descritos nos subitems (c1) e (c2) abaixo:</p>&#10;<p>(c1) Gera&shy;se um n&uacute;mero aleat&oacute;rio entre 0 e 1&semi;</p>&#10;<p>(c2) Se esse n&uacute;mero aleat&oacute;rio for menor que <span class="math">\frac{P_n}{P_m}</span>, aceita&shy;se na amostra a configura&ccedil;&atilde;o <i>n</i>, e se atribui a ela o &iacute;ndice <i>m</i>. Caso contr&aacute;rio, o &iacute;ndice <i>m</i> permanece designando a configura&ccedil;&atilde;o original.</p>&#10;<p>(d) Repete&shy;se os passos (b) e (c) at&eacute; que algum crit&eacute;rio de parada seja satisfeito. Cada uma dessas repeti&ccedil;&otilde;es &eacute; dita um passo Monte Carlo (MC).</p>&#10;<p><a href="http://en.wikipedia.org/wiki/Ficheiro:FMFluxogramaMetropolis.jpg%7Ccenter%7Cthumb%7C500px" id="w">Fluxograma para o algoritmo de Metropolis. Fonte: Wikimedia, criador: Leonardo Castro.</a></p>&#10;<a id="Refer%C3%AAncias" name="Refer%C3%AAncias"></a><h2> Refer&ecirc;ncias </h2>&#10;&#10;&#10;<p /><ol class="references">&#10;<li id="_note&shy;1"><b><a href="#_ref&shy;1" title="">&uarr&semi;</a></b> J. Hromkovic, <i>Algorithms for hard problems</i>: introduction to combinatorial optimization, randomization, approximation, and heuristics. [S.l.]: Springer&shy;Verlag, London &shy; Berlin &shy; Heidelberg &shy; New York, <a href="http://en.wikipedia.org/wiki/2001" id="w">2001</a>.</li><li id="_note&shy;2"><b><a href="#_ref&shy;2" title="">&uarr&semi;</a></b> N. Metropolis, A. Rosenbluth, M. Rosenbluth, A. Teller, E. Teller, Equation of State Calculations by Fast Computing Machines, Journal of Chemical Physics 21, 1087 (1953).</li><li id="_note&shy;3"><b><a href="#_ref&shy;3" title="">&uarr&semi;</a></b> W. K. Hastings, Monte Carlo Sampling Methods Using Markov Chains and Their Applications, Biometrika 57 (1), 97 (1970).</li></ol></body></html>