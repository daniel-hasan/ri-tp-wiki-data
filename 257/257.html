<html><title>Algoritmo</title><body>&#10;<p> &#10;<a href="http://en.wikipedia.org/wiki/Imagem:Sorting_quicksort_anim.gif%7Cthumb%7C250px%7Cright" id="w">Uma anima&ccedil;&atilde;o do algoritmo de ordena&ccedil;&atilde;o quicksort de uma matriz de valores ao acaso. As barras vermelhas marcam o elemento piv&ocirc;. No in&iacute;cio da anima&ccedil;&atilde;o, estando o elemento para o lado direito, &eacute; escolhido como o piv&ocirc;.Um</a> <b>algoritmo</b> &eacute; uma sequ&ecirc;ncia finita de <a href="http://en.wikipedia.org/wiki/Instru%C3%A7%C3%A3o" id="w">instru&ccedil;&otilde;es</a> bem definidas e n&atilde;o amb&iacute;guas, cada uma das quais pode ser executada mecanicamente num per&iacute;odo de tempo finito e com uma quantidade de esfor&ccedil;o finita.<sup id="_ref&shy;NCEUFRJ_a" class="reference"><a href="#_note&shy;NCEUFRJ" title="">[1]</a></sup><sup id="_ref&shy;UNIVASF_a" class="reference"><a href="#_note&shy;UNIVASF" title="">[2]</a></sup></p>&#10;<p>O conceito de algoritmo &eacute; frequentemente ilustrado pelo exemplo de uma receita culin&aacute;ria, embora muitos algoritmos sejam mais complexos. Eles podem repetir passos (fazer <a href="http://en.wikipedia.org/wiki/Itera%C3%A7%C3%A3o" id="w">itera&ccedil;&otilde;es</a>) ou necessitar de decis&otilde;es (tais como compara&ccedil;&otilde;es ou <a href="http://en.wikipedia.org/wiki/L%C3%B3gica" id="w">l&oacute;gica</a>) at&eacute; que a tarefa seja completada. Um algoritmo corretamente executado n&atilde;o ir&aacute; resolver um problema se estiver implementado incorretamente ou se n&atilde;o for apropriado ao problema.</p>&#10;<p>Um algoritmo n&atilde;o representa, necessariamente, um <a href="http://en.wikipedia.org/wiki/Programa_de_computador" id="w">programa de computador</a><sup id="_ref&shy;DEMOTUSAI_a" class="reference"><a href="#_note&shy;DEMOTUSAI" title="">[3]</a></sup>, e sim os passos necess&aacute;rios para realizar uma tarefa. Sua implementa&ccedil;&atilde;o pode ser feita por um <a href="http://en.wikipedia.org/wiki/Computador" id="w">computador</a>, por outro tipo de <a href="http://en.wikipedia.org/wiki/Aut%C3%B4mato" id="w">aut&ocirc;mato</a> ou mesmo por um ser humano. Diferentes algoritmos podem realizar a mesma tarefa usando um conjunto diferenciado de instru&ccedil;&otilde;es em mais ou menos tempo, espa&ccedil;o ou esfor&ccedil;o do que outros. Tal diferen&ccedil;a pode ser reflexo da <a href="http://en.wikipedia.org/wiki/Complexidade_computacional" id="w">complexidade computacional</a> aplicada, que depende de <a href="http://en.wikipedia.org/wiki/Estruturas_de_dados" id="w">estruturas de dados</a> adequadas ao algoritmo. Por exemplo, um algoritmo para se vestir pode especificar que voc&ecirc; vista primeiro as meias e os sapatos antes de vestir a cal&ccedil;a enquanto outro algoritmo especifica que voc&ecirc; deve primeiro vestir a cal&ccedil;a e depois as meias e os sapatos. Fica claro que o primeiro algoritmo &eacute; mais dif&iacute;cil de executar que o segundo apesar de ambos levarem ao mesmo resultado.</p>&#10;<p>O conceito de um algoritmo foi formalizado em <a href="http://en.wikipedia.org/wiki/1936" id="w">1936</a> pela <a href="http://en.wikipedia.org/wiki/M%C3%A1quina_de_Turing" id="w">M&aacute;quina de Turing</a> de <a href="http://en.wikipedia.org/wiki/Alan_Turing" id="w">Alan Turing</a> e pelo <a href="http://en.wikipedia.org/wiki/C%C3%A1lculo_lambda" id="w">c&aacute;lculo lambda</a> de <a href="http://en.wikipedia.org/wiki/Alonzo_Church" id="w">Alonzo Church</a>, que formaram as primeiras funda&ccedil;&otilde;es da <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">Ci&ecirc;ncia da computa&ccedil;&atilde;o</a>.</p>&#10;<a id="Etimologia" name="Etimologia"></a><h2> Etimologia </h2>&#10;<p>Os historiadores da palavra <i>algoritmo</i> encontraram a <a href="http://en.wikipedia.org/wiki/Etimologia" id="w">origem</a> no sobrenome, <a href="http://en.wikipedia.org/wiki/Al&shy;Khwarizmi" id="w">Al&shy;Khwarizmi</a>, do matem&aacute;tico <a href="http://en.wikipedia.org/wiki/P%C3%A9rsia" id="w">persa</a> do <a href="http://en.wikipedia.org/wiki/S%C3%A9culo_IX" id="w">s&eacute;culo IX</a> Mohamed ben Musa<sup id="_ref&shy;DECOMUFOP_a" class="reference"><a href="#_note&shy;DECOMUFOP" title="">[4]</a></sup>, cujas obras foram traduzidas no ocidente crist&atilde;o no <a href="http://en.wikipedia.org/wiki/S%C3%A9culo_XII" id="w">s&eacute;culo XII</a>, tendo uma delas recebido o nome <i>Algorithmi de numero indorum</i>, sobre os algoritmos usando o sistema de <a href="http://en.wikipedia.org/wiki/Sistema_decimal" id="w">numera&ccedil;&atilde;o decimal</a> (indiano). Outros autores, entretanto, defendem a origem da palavra em <i>Al&shy;goreten</i> (raiz &shy; conceito que se pode aplicar aos c&aacute;lculos).<sup id="_ref&shy;5" class="reference"><a href="#_note&shy;5" title="">[5]</a></sup> <a href="http://en.wikipedia.org/wiki/&Aacute;lgebra" id="w">&Aacute;lgebra</a> e algorismo tamb&eacute;m formam formas corrompidas da palavra, pois as pessoas esqueciam as deriva&ccedil;&otilde;es originais. O dicion&aacute;rio Vollst&auml;ndiges Mathematisches Lexicon (Leipzig, 1747) refere a palavra &#34&semi;Algorithmus&#34&semi;&semi; nesta designa&ccedil;&atilde;o est&aacute; combinado as no&ccedil;&otilde;es de quatro c&aacute;lculos aritm&eacute;ticos, nomeadamente a <a href="http://en.wikipedia.org/wiki/Adi%C3%A7%C3%A3o" id="w">adi&ccedil;&atilde;o</a>, <a href="http://en.wikipedia.org/wiki/Multiplica%C3%A7%C3%A3o" id="w">multiplica&ccedil;&atilde;o</a>, <a href="http://en.wikipedia.org/wiki/Subtra%C3%A7%C3%A3o" id="w">subtra&ccedil;&atilde;o</a> e <a href="http://en.wikipedia.org/wiki/Divis%C3%A3o" id="w">divis&atilde;o</a>. A frase &#34&semi;algorithmus infinitesimalis&#34&semi; foi na altura utilizado para significar&semi; &#34&semi;maneiras de calcular com quantidades infinit&eacute;simas&#34&semi; (pequenas), uma inven&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/Leibnitz" id="w">Leibnitz</a>. Tamb&eacute;m &eacute; conhecido no meio financeiro, como &#34&semi;algos&#34&semi;.<sup id="_ref&shy;6" class="reference"><a href="#_note&shy;6" title="">[6]</a></sup></p>&#10;<a id="Formalismo" name="Formalismo"></a><h2> Formalismo </h2>&#10;<p><a href="http://en.wikipedia.org/wiki/Imagem:Fluxogranma02.gif%7Cthumb%7C365px" id="w">[[Fluxograma]], um exemplo de algoritmo imperativo. O estado em vermelho indica a entrada do algoritmo enquanto os estados em verde indicam as poss&iacute;veis sa&iacute;das.</a></p>&#10;<p>Um <a href="http://en.wikipedia.org/wiki/Programa_de_computador" id="w">programa de computador</a> &eacute; essencialmente um algoritmo que diz ao <a href="http://en.wikipedia.org/wiki/Computador" id="w">computador</a> os passos espec&iacute;ficos e em que ordem eles devem ser executados, como por exemplo, os passos a serem tomados para calcular as notas que ser&atilde;o impressas nos boletins dos alunos de uma escola. Logo, o algoritmo pode ser considerado uma sequ&ecirc;ncia de opera&ccedil;&otilde;es que podem ser simuladas por uma <a href="http://en.wikipedia.org/wiki/M%C3%A1quina_de_Turing" id="w">m&aacute;quina de Turing</a> completa.</p>&#10;<p>Quando os procedimentos de um algoritmo envolvem o <a href="http://en.wikipedia.org/wiki/Processamento_de_dados" id="w">processamento de dados</a>, a informa&ccedil;&atilde;o &eacute; lida de uma fonte de entrada, processada e retornada sob novo valor ap&oacute;s processamento, o que geralmente &eacute; realizado com o aux&iacute;lio de uma ou mais <a href="http://en.wikipedia.org/wiki/Estrutura_de_dados" id="w">estrutura de dados</a>.</p>&#10;<p>Para qualquer processo computacional, o algoritmo precisa estar rigorosamente definido, especificando a maneira que ele se comportar&aacute; em todas as circunst&acirc;ncias. A corretividade do algoritmo pode ser provada matematicamente, bem como a quantidade assint&oacute;tica de tempo e espa&ccedil;o (complexidade) necess&aacute;rios para a sua execu&ccedil;&atilde;o. Estes aspectos dos algoritmos s&atilde;o alvo da <a href="http://en.wikipedia.org/wiki/An%C3%A1lise_de_algoritmos" id="w">an&aacute;lise de algoritmos</a>.</p>&#10;<p>A maneira mais simples de se pensar um algoritmo &eacute; por uma <a href="http://en.wikipedia.org/wiki/Lista" id="w">lista</a> de procedimentos bem definida, na qual as instru&ccedil;&otilde;es s&atilde;o executadas passo a passo a partir do come&ccedil;o da lista, uma ideia que pode ser facilmente visualizada atrav&eacute;s de um <a href="http://en.wikipedia.org/wiki/Fluxograma" id="w">fluxograma</a>. Tal formaliza&ccedil;&atilde;o adota as premissas da <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_imperativa" id="w">programa&ccedil;&atilde;o imperativa</a>, que &eacute; uma forma mec&acirc;nica para visualizar e desenvolver um algoritmo. Concep&ccedil;&otilde;es alternativas para algoritmos variam em <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_funcional" id="w">programa&ccedil;&atilde;o funcional</a> e <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_l%C3%B3gica" id="w">programa&ccedil;&atilde;o l&oacute;gica</a>.</p>&#10;<a id="T%C3%A9rmino_do_algoritmo" name="T%C3%A9rmino_do_algoritmo"></a><h3> T&eacute;rmino do algoritmo </h3>&#10;<p>Alguns autores restringem a defini&ccedil;&atilde;o de algoritmo para procedimentos que eventualmente terminam. <a href="http://en.wikipedia.org/wiki/Marvin_Minsky" id="w">Marvin Minsky</a> constatou que se o tamanho de um procedimento n&atilde;o &eacute; conhecido de antem&atilde;o, tentar descobri&shy;lo &eacute; um problema indecid&iacute;vel, j&aacute; que o procedimento pode ser executado infinitamente, de forma que nunca se ter&aacute; a resposta. Alan Turing provou em <a href="http://en.wikipedia.org/wiki/1936" id="w">1936</a> que n&atilde;o existe m&aacute;quina de Turing para realizar tal an&aacute;lise para todos os casos, logo n&atilde;o h&aacute; algoritmo para realizar tal tarefa para todos os casos. Tal condi&ccedil;&atilde;o &eacute; conhecida atualmente como <a href="http://en.wikipedia.org/wiki/Problema_da_parada" id="w">problema da parada</a>.</p>&#10;<p>Para algoritmos intermin&aacute;veis o sucesso n&atilde;o pode ser determinado pela interpreta&ccedil;&atilde;o da resposta e sim por condi&ccedil;&otilde;es impostas pelo pr&oacute;prio desenvolvedor do algoritmo durante sua execu&ccedil;&atilde;o.</p>&#10;<a id="Implementa%C3%A7%C3%A3o" name="Implementa%C3%A7%C3%A3o"></a><h2> Implementa&ccedil;&atilde;o </h2>&#10;<p>A maioria dos algoritmos &eacute; desenvolvida para ser implementada em um <a href="http://en.wikipedia.org/wiki/Programa_de_computador" id="w">programa de computador</a>. Apesar disso eles tamb&eacute;m podem ser implementados por outros modos tais como uma <a href="http://en.wikipedia.org/wiki/Rede_neural" id="w">rede neural</a> biol&oacute;gica (tal como no <a href="http://en.wikipedia.org/wiki/C%C3%A9rebro" id="w">c&eacute;rebro</a> quando efetuamos opera&ccedil;&otilde;es aritm&eacute;ticas) em <a href="http://en.wikipedia.org/wiki/Circuito_el%C3%A9trico" id="w">circuitos el&eacute;tricos</a> ou at&eacute; mesmo em dispositivos mec&acirc;nicos.</p>&#10;<p>Para programas de computador existe uma grande variedade de <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagens de programa&ccedil;&atilde;o</a>, cada uma com caracter&iacute;sticas espec&iacute;ficas que podem facilitar a implementa&ccedil;&atilde;o de determinados algoritmos ou atender a prop&oacute;sitos mais gerais.</p>&#10;<a id="An%C3%A1lise_de_algoritmos" name="An%C3%A1lise_de_algoritmos"></a><h2> An&aacute;lise de algoritmos </h2>&#10;<p> &#10;A an&aacute;lise de algoritmos &eacute; um ramo da <a href="http://en.wikipedia.org/wiki/Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">ci&ecirc;ncia da computa&ccedil;&atilde;o</a> que estuda as <a href="http://en.wikipedia.org/wiki/T%C3%A9cnicas_de_Projeto_de_Algoritmos" id="w">t&eacute;cnicas de projeto de algoritmos</a> e os algoritmos de forma abstrata, sem estarem implementados em uma <a href="http://en.wikipedia.org/wiki/Linguagem_de_programa%C3%A7%C3%A3o" id="w">linguagem de programa&ccedil;&atilde;o</a> em particular ou implementadas de algum outro modo. Ela preocupa&shy;se com os recursos necess&aacute;rios para a execu&ccedil;&atilde;o do algoritmo tais como o tempo de execu&ccedil;&atilde;o e o espa&ccedil;o de armazenamento de dados. Deve&shy;se perceber que para um dado algoritmo pode&shy;se ter diferentes quantidades de recursos alocados de acordo com os par&acirc;metros passados na entrada. Por exemplo, se definirmos que o fatorial de um n&uacute;mero natural &eacute; igual ao fatorial de seu antecessor multiplicado pelo pr&oacute;prio n&uacute;mero, fica claro que a execu&ccedil;&atilde;o de <code>fatorial(10)</code> consome mais tempo que a execu&ccedil;&atilde;o de <code>fatorial(5)</code>.</p>&#10;<p>Um meio de exibir um algoritmo a fim de analis&aacute;&shy;lo &eacute; atrav&eacute;s da implementa&ccedil;&atilde;o por <a href="http://en.wikipedia.org/wiki/Pseudoc%C3%B3digo" id="w">pseudoc&oacute;digo</a> em <a href="http://en.wikipedia.org/wiki/Pseudoc%C3%B3digo" id="w">portugu&ecirc;s estruturado</a>. O exemplo a seguir &eacute; um algoritmo em portugu&ecirc;s estruturado que retorna (valor de sa&iacute;da) a soma de dois valores (tamb&eacute;m conhecidos como <a href="http://en.wikipedia.org/wiki/Par%C3%A2metro" id="w">par&acirc;metros</a> ou argumentos, valores de entrada) que s&atilde;o introduzidos na chamada da <a href="http://en.wikipedia.org/wiki/Sub&shy;rotina" id="w">fun&ccedil;&atilde;o</a>:</p>&#10;<p><code>&#10;</code></p><dl><dd>Algoritmo &#34&semi;SomaDeDoisValores&#34&semi;&semi;</dd></dl><dl><dd>vari&aacute;vel:</dd></dl><dl><dd><dl><dd><dl><dd>SOMA,A,B: inteiro&semi;</dd></dl></dd></dl></dd></dl><dl><dd>inicio</dd></dl><dl><dd><dl><dd><dl><dd>Escreva(&#34&semi;Digite um numero: &#34&semi;)&semi;</dd></dl></dd></dl></dd></dl><dl><dd><dl><dd><dl><dd>Leia(A)&semi;</dd></dl></dd></dl></dd></dl><dl><dd><dl><dd><dl><dd>escreva(&#34&semi;Digite outro numero: &#34&semi;)&semi;</dd></dl></dd></dl></dd></dl><dl><dd><dl><dd><dl><dd>leia(B)&semi;</dd></dl></dd></dl></dd></dl><dl><dd><dl><dd><dl><dd>SOMA &larr; A + B&semi;</dd></dl></dd></dl></dd></dl><dl><dd><dl><dd><dl><dd>escreva(SOMA)&semi;</dd></dl></dd></dl></dd></dl><dl><dd>fim.</dd></dl>&#10;<p />&#10;<a id="Classifica%C3%A7%C3%A3o" name="Classifica%C3%A7%C3%A3o"></a><h2> Classifica&ccedil;&atilde;o </h2>&#10;<a id="Classifica%C3%A7%C3%A3o_por_implementa%C3%A7%C3%A3o" name="Classifica%C3%A7%C3%A3o_por_implementa%C3%A7%C3%A3o"></a><h3> Classifica&ccedil;&atilde;o por implementa&ccedil;&atilde;o </h3>&#10;<p>Pode&shy;se classificar algoritmos pela maneira pelo qual foram implementados.</p>&#10;&#10;<ul>&#10;<li><b>Recursivo</b> ou <b>iterativo</b> &shy; um <a href="http://en.wikipedia.org/wiki/Recursividade_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)" id="w">algoritmo recursivo</a> possui a caracter&iacute;stica de invocar a si mesmo repetidamente at&eacute; que certa condi&ccedil;&atilde;o seja satisfeita e ele &eacute; terminado, que &eacute; um m&eacute;todo comum em <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_funcional" id="w">programa&ccedil;&atilde;o funcional</a>. Algoritmos iterativos usam estruturas de repeti&ccedil;&atilde;o tais como la&ccedil;os, ou ainda estruturas de dados adicionais tais como <a href="http://en.wikipedia.org/wiki/LIFO" id="w">pilhas</a>, para resolver problemas. Cada algoritmo recursivo possui um algoritmo iterativo equivalente e vice&shy;versa, mas que pode ter mais ou menos complexidade em sua constru&ccedil;&atilde;o.</li>&#10;<li><b>L&oacute;gico</b> &shy; um algoritmo pode ser visto como uma dedu&ccedil;&atilde;o l&oacute;gica controlada. O componente l&oacute;gico expressa os axiomas usados na computa&ccedil;&atilde;o e o componente de controle determina a maneira como a dedu&ccedil;&atilde;o &eacute; aplicada aos axiomas. Tal conceito &eacute; base para a <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_l%C3%B3gica" id="w">programa&ccedil;&atilde;o l&oacute;gica</a>.</li>&#10;<li><b>Serial</b> ou <b>paralelo</b> &shy; algoritmos s&atilde;o geralmente assumidos por serem executados instru&ccedil;&atilde;o a instru&ccedil;&atilde;o individualmente, como uma lista de execu&ccedil;&atilde;o, o que constitui um algoritmo serial. Tal conceito &eacute; base para a <a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_imperativa" id="w">programa&ccedil;&atilde;o imperativa</a>. Por outro lado existem algoritmos executados paralelamente, que levam em conta as <a href="http://en.wikipedia.org/wiki/Arquitetura_de_computadores" id="w">arquiteturas de computadores</a> com mais de um <a href="http://en.wikipedia.org/wiki/Processador" id="w">processador</a> para executar mais de uma instru&ccedil;&atilde;o ao mesmo tempo. Tais algoritmos dividem os problemas em subproblemas e o delegam a quantos processadores estiverem dispon&iacute;veis, agrupando no final o resultado dos subproblemas em um resultado final ao algoritmo. Tal conceito &eacute; base para a <a href="http://en.wikipedia.org/wiki/Computa%C3%A7%C3%A3o_paralela" id="w">programa&ccedil;&atilde;o paralela</a>. De forma geral, algoritmos iterativos s&atilde;o paraleliz&aacute;veis&semi; por outro lado existem algoritmos que n&atilde;o s&atilde;o paraleliz&aacute;veis, chamados ent&atilde;o problemas inerentemente seriais.</li>&#10;<li><b>Determin&iacute;stico</b> ou <b>n&atilde;o&shy;determin&iacute;stico</b> &shy; algoritmos determin&iacute;sticos resolvem o problema com uma decis&atilde;o exata a cada passo enquanto algoritmos n&atilde;o&shy;determin&iacute;sticos resolvem o problema ao deduzir os melhores passos atrav&eacute;s de estimativas sob forma de <a href="http://en.wikipedia.org/wiki/Heur%C3%ADstica" id="w">heur&iacute;sticas</a>.</li>&#10;<li><b>Exato</b> ou <b>aproximado</b> &shy; enquanto alguns algoritmos encontram uma resposta exata, algoritmos de aproxima&ccedil;&atilde;o procuram uma resposta pr&oacute;xima a verdadeira solu&ccedil;&atilde;o, seja atrav&eacute;s de estrat&eacute;gia determin&iacute;stica ou aleat&oacute;ria. Possuem aplica&ccedil;&otilde;es pr&aacute;ticas sobretudo para problemas muito complexos, do qual uma resposta correta &eacute; invi&aacute;vel devido &agrave; sua <a href="http://en.wikipedia.org/wiki/Complexidade_computacional" id="w">complexidade computacional</a>.</li></ul>&#10;<a id="Classifica%C3%A7%C3%A3o_por_paradigma" name="Classifica%C3%A7%C3%A3o_por_paradigma"></a><h3> Classifica&ccedil;&atilde;o por paradigma </h3>&#10;<p>Pode&shy;se classificar algoritmos pela metodologia ou paradigma de seu desenvolvimento, tais como:</p>&#10;&#10;<ul>&#10;<li><b><a href="http://en.wikipedia.org/wiki/Divis%C3%A3o_e_conquista" id="w">Divis&atilde;o e conquista</a></b> &shy; algoritmos de divis&atilde;o e conquista reduzem repetidamente o problema em sub&shy;problemas, geralmente de forma recursiva, at&eacute; que o sub&shy;problema &eacute; pequeno o suficiente para ser resolvido. Um exemplo pr&aacute;tico &eacute; o algoritmo de ordena&ccedil;&atilde;o <i><a href="http://en.wikipedia.org/wiki/Merge_sort" id="w">merge sort</a></i>. Uma variante dessa metodologia &eacute; o <i>decremento e conquista</i>, que resolve um sub&shy;problema e utiliza a solu&ccedil;&atilde;o para resolver um problema maior. Um exemplo pr&aacute;tico &eacute; o algoritmo para <a href="http://en.wikipedia.org/wiki/Pesquisa_bin%C3%A1ria" id="w">pesquisa bin&aacute;ria</a>.</li>&#10;<li><b><a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_din%C3%A2mica" id="w">Programa&ccedil;&atilde;o din&acirc;mica</a></b> &shy; pode&shy;se utilizar a programa&ccedil;&atilde;o din&acirc;mica para evitar o re&shy;c&aacute;lculo de solu&ccedil;&atilde;o j&aacute; resolvidas anteriormente.</li>&#10;<li><b><a href="http://en.wikipedia.org/wiki/Algoritmo_ganancioso" id="w">Algoritmo ganancioso</a></b> &shy; um algoritmo ganancioso &eacute; similar &agrave; programa&ccedil;&atilde;o din&acirc;mica, mas difere na medida em que as solu&ccedil;&otilde;es dos sub&shy;problemas n&atilde;o precisam ser conhecidas a cada passo, uma escolha gananciosa pode ser feita a cada momento com o que at&eacute; ent&atilde;o parece ser mais adequado.</li>&#10;<li><b><a href="http://en.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_linear" id="w">Programa&ccedil;&atilde;o linear</a></b></li>&#10;<li><b>Redu&ccedil;&atilde;o</b> &shy; a redu&ccedil;&atilde;o resolve o problema ao transform&aacute;&shy;lo em outro problema. &Eacute; chamado tamb&eacute;m <i>transforma&ccedil;&atilde;o e conquista</i>.</li>&#10;<li><b>Busca e enumera&ccedil;&atilde;o</b> &shy; v&aacute;rios problemas podem ser modelados atrav&eacute;s de <a href="http://en.wikipedia.org/wiki/Grafo" id="w">grafos</a>. Um algoritmo de explora&ccedil;&atilde;o de grafo pode ser usado para caminhar pela estrutura e retornam informa&ccedil;&otilde;es &uacute;teis para a resolu&ccedil;&atilde;o do problema. Esta categoria inclui <a href="http://en.wikipedia.org/wiki/Algoritmo_de_busca" id="w">algoritmos de busca</a> e <a href="http://en.wikipedia.org/wiki/Backtracking" id="w">backtracking</a>.</li>&#10;<li><b>Paradigma heur&iacute;stico e probabil&iacute;stico</b> &shy; algoritmos probabil&iacute;sticos realizam escolhas aleatoriamente. <a href="http://en.wikipedia.org/wiki/Algoritmo_gen%C3%A9tico" id="w">Algoritmos gen&eacute;ticos</a> tentam encontrar a solu&ccedil;&atilde;o atrav&eacute;s de ciclos de muta&ccedil;&otilde;es evolucion&aacute;rias entre gera&ccedil;&otilde;es de passos, tendendo para a solu&ccedil;&atilde;o exata do problema. Algoritmos heur&iacute;sticos encontram uma solu&ccedil;&atilde;o aproximada para o problema.</li></ul>&#10;<a id="Classifica%C3%A7%C3%A3o_por_campo_de_estudo" name="Classifica%C3%A7%C3%A3o_por_campo_de_estudo"></a><h3> Classifica&ccedil;&atilde;o por campo de estudo </h3>&#10;<p>Cada campo da ci&ecirc;ncia possui seus pr&oacute;prios problemas e respectivos algoritmos adequados para resolv&ecirc;&shy;los. Exemplos cl&aacute;ssicos s&atilde;o algoritmos de <a href="http://en.wikipedia.org/wiki/Algoritmo_de_busca" id="w">busca</a>, de <a href="http://en.wikipedia.org/wiki/Algoritmo_de_ordena%C3%A7%C3%A3o" id="w">ordena&ccedil;&atilde;o</a>, de <a href="http://en.wikipedia.org/wiki/An%C3%A1lise_num%C3%A9rica" id="w">an&aacute;lise num&eacute;rica</a>, de <a href="http://en.wikipedia.org/wiki/Teoria_de_grafos" id="w">teoria de grafos</a>, de manipula&ccedil;&atilde;o de <a href="http://en.wikipedia.org/wiki/String" id="w">cadeias de texto</a>, de <a href="http://en.wikipedia.org/wiki/Geometria" id="w">geometria</a> computacional, de <a href="http://en.wikipedia.org/wiki/An%C3%A1lise_combinat%C3%B3ria" id="w">an&aacute;lise combinat&oacute;ria</a>, de <a href="http://en.wikipedia.org/wiki/Aprendizagem_de_m%C3%A1quina" id="w">aprendizagem de m&aacute;quina</a>, de <a href="http://en.wikipedia.org/wiki/Criptografia" id="w">criptografia</a>, de <a href="http://en.wikipedia.org/wiki/Compress%C3%A3o_de_dados" id="w">compress&atilde;o de dados</a> e de <a href="http://en.wikipedia.org/wiki/Parser" id="w">interpreta&ccedil;&atilde;o de texto</a>.</p>&#10;<a id="Classifica%C3%A7%C3%A3o_por_complexidade" name="Classifica%C3%A7%C3%A3o_por_complexidade"></a><h3> Classifica&ccedil;&atilde;o por complexidade </h3>&#10;<p> &#10;Alguns algoritmos s&atilde;o executados em tempo linear, de acordo com a entrada, enquanto outros s&atilde;o executados em tempo exponencial ou at&eacute; mesmo nunca terminam de serem executados. Alguns problemas tem m&uacute;ltiplos algoritmos enquanto outros n&atilde;o possuem algoritmos para resolu&ccedil;&atilde;o.</p>&#10;<p> </p>&#10;<a id="Bibliografia" name="Bibliografia"></a><h2> Bibliografia </h2>&#10;&#10;<ul>&#10;<li><a class="externallink" href="http://www.novateceditora.com.br/livros/algoritmos/" rel="nofollow" title="http://www.novateceditora.com.br/livros/algoritmos/">Algoritmos e Programa&ccedil;&atilde;o &shy; Teoria e Pr&aacute;tica: para universit&aacute;rios e profissionais de inform&aacute;tica</a>: Novatec Editora. <a class="external text" href="http://www.amazon.com/exec/obidos/ASIN/857522073" rel="nofollow" title="http://www.amazon.com/exec/obidos/ASIN/857522073">ISBN 85&shy;7522&shy;073&shy;</a>X</li></ul>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Donald_E._Knuth" id="w">Donald E. Knuth</a> (1973) <i><a href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming" id="w">The Art of Computer Programming</a>, Volume 1: Fundamental Algorithms (2&ordf; edi&ccedil;&atilde;o)</i>. Addison&shy;Wesley, <a class="external text" href="http://www.amazon.com/exec/obidos/ASIN/0201038099" rel="nofollow" title="http://www.amazon.com/exec/obidos/ASIN/0201038099">ISBN 0&shy;201&shy;03809&shy;9</a>  </li></ul>&#10;<a id="Ver_tamb%C3%A9m" name="Ver_tamb%C3%A9m"></a><h2> Ver tamb&eacute;m </h2>&#10;&#10;<ul>&#10;<li><a href="http://en.wikipedia.org/wiki/Estrutura_de_dados" id="w">Estrutura de dados</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Aut%C3%B4mato" id="w">Aut&ocirc;mato</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Teoria_da_computa%C3%A7%C3%A3o" id="w">Teoria da computa&ccedil;&atilde;o</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Algoritmo_probabil%C3%ADstico" id="w">Algoritmo probabil&iacute;stico</a></li>&#10;<li><a href="http://en.wikipedia.org/wiki/Algoritmo_de_Euclides" id="w">Algoritmo de Euclides</a></li></ul>&#10;<a id="Liga%C3%A7%C3%B5es_externas" name="Liga%C3%A7%C3%B5es_externas"></a><h2> Liga&ccedil;&otilde;es externas </h2>&#10;&#10;<ul>&#10;<li>  &shy; Revista Nova Escola</li>&#10;<li><a class="externallink" href="http://www.nist.gov/dads/" rel="nofollow" title="http://www.nist.gov/dads/">Dictionary of Algorithms and Data Structures</a></li>&#10;<li><a class="externallink" href="http://algoritmizando.com/desenvolvimento/aprender&shy;algoritmos/" rel="nofollow" title="http://algoritmizando.com/desenvolvimento/aprender&shy;algoritmos/">Aprenda a Programar</a>: S&eacute;rie de artigos did&aacute;ticos ensinando Portugu&ecirc;s Estruturado</li>&#10;<li><a class="externallink" href="http://algoritmizando.com/desenvolvimento/40&shy;exercicios&shy;de&shy;algoritmos&shy;resolvidos&shy;para&shy;estudo/" rel="nofollow" title="http://algoritmizando.com/desenvolvimento/40&shy;exercicios&shy;de&shy;algoritmos&shy;resolvidos&shy;para&shy;estudo/">Exerc&iacute;cios resolvidos de algoritmos para estudo</a></li></ul>&#10;<p> </p>&#10;<p><a href="http://en.wikipedia.org/wiki/Categoria:Algoritmos" id="w"> </a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Terminologia_inform%C3%A1tica" id="w">Categoria:Terminologia inform&aacute;tica</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Computa%C3%A7%C3%A3o" id="w">Categoria:Computa&ccedil;&atilde;o</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Ci%C3%AAncia_da_computa%C3%A7%C3%A3o" id="w">Categoria:Ci&ecirc;ncia da computa&ccedil;&atilde;o</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Programa%C3%A7%C3%A3o" id="w">Categoria:Programa&ccedil;&atilde;o</a>&#10;<a href="http://en.wikipedia.org/wiki/Categoria:Programas_de_computador" id="w">Categoria:Programas de computador</a></p>&#10;<p> &#10; </p></body></html>